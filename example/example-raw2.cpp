
namespace std {
inline namespace __1 {

using ::ptrdiff_t;
using ::size_t;

using ::max_align_t;

} // namespace __1
} // namespace std

namespace std {
inline namespace __1 {

template <class _T1, class _T2>
struct __attribute__((__type_visibility__("default"))) pair;
template <class _Tp>
class __attribute__((__type_visibility__("default"))) reference_wrapper;
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) hash;

template <class _Tp, _Tp __v>
struct __attribute__((__type_visibility__("default"))) integral_constant {
  static constexpr const _Tp value = __v;
  typedef _Tp value_type;
  typedef integral_constant type;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr
  operator value_type() const noexcept {
    return value;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr value_type
  operator()() const noexcept {
    return value;
  }
};

template <class _Tp, _Tp __v>
constexpr const _Tp integral_constant<_Tp, __v>::value;
# 455 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
typedef integral_constant<bool, (true)> true_type;
typedef integral_constant<bool, (false)> false_type;

template <bool _Val> using _BoolConstant = integral_constant<bool, _Val>;

template <bool> struct _MetaBase;
template <> struct _MetaBase<true> {
  template <class _Tp, class _Up> using _SelectImpl = _Tp;
  template <template <class...> class _FirstFn, template <class...> class,
            class... _Args>
  using _SelectApplyImpl = _FirstFn<_Args...>;
  template <class _First, class...> using _FirstImpl = _First;
  template <class, class _Second, class...> using _SecondImpl = _Second;
  template <class _Tp = void> using _EnableIfImpl = _Tp;
  template <class _Result, class _First, class... _Rest>
  using _OrImpl =
      typename _MetaBase<_First::value != true && sizeof...(_Rest) != 0>::
          template _OrImpl<_First, _Rest...>;
  template <class _Result, class _First, class... _Rest>
  using _AndImpl =
      typename _MetaBase<_First::value == true && sizeof...(_Rest) != 0>::
          template _AndImpl<_First, _Rest...>;
};

template <> struct _MetaBase<false> {
  template <class _Tp, class _Up> using _SelectImpl = _Up;
  template <template <class...> class, template <class...> class _SecondFn,
            class... _Args>
  using _SelectApplyImpl = _SecondFn<_Args...>;
  template <class _Result, class...> using _OrImpl = _Result;
  template <class _Result, class...> using _AndImpl = _Result;
};
template <bool _Cond, class _Ret = void>
using _EnableIf = typename _MetaBase<_Cond>::template _EnableIfImpl<_Ret>;
template <bool _Cond, class _IfRes, class _ElseRes>
using _If = typename _MetaBase<_Cond>::template _SelectImpl<_IfRes, _ElseRes>;
template <class... _Rest>
using _Or = typename _MetaBase<sizeof...(_Rest) !=
                               0>::template _OrImpl<false_type, _Rest...>;
template <class... _Rest>
using _And = typename _MetaBase<sizeof...(_Rest) !=
                                0>::template _AndImpl<true_type, _Rest...>;
template <class _Pred> struct _Not : _BoolConstant<!_Pred::value> {};
template <class... _Args>
using _FirstType =
    typename _MetaBase<(sizeof...(_Args) >= 1)>::template _FirstImpl<_Args...>;
template <class... _Args>
using _SecondType =
    typename _MetaBase<(sizeof...(_Args) >= 2)>::template _SecondImpl<_Args...>;

template <template <class...> class _Func, class... _Args>
struct _Lazy : _Func<_Args...> {};

template <template <class...> class _Templ, class... _Args,
          class = _Templ<_Args...>>
true_type __sfinae_test_impl(int);
template <template <class...> class, class...>
false_type __sfinae_test_impl(...);

template <template <class...> class _Templ, class... _Args>
using _IsValidExpansion =
    decltype(std::__sfinae_test_impl<_Templ, _Args...>(0));

template <class> struct __void_t { typedef void type; };

template <class _Tp> struct __identity { typedef _Tp type; };

template <class _Tp, bool>
struct __attribute__((__type_visibility__("default"))) __dependent_type
    : public _Tp {};

template <bool _Bp, class _If, class _Then>
struct __attribute__((__type_visibility__("default"))) conditional {
  typedef _If type;
};
template <class _If, class _Then>
struct __attribute__((__type_visibility__("default")))
conditional<false, _If, _Then> {
  typedef _Then type;
};

template <bool _Bp, class _If, class _Then>
using conditional_t = typename conditional<_Bp, _If, _Then>::type;

template <bool, class _Tp = void>
struct __attribute__((__type_visibility__("default"))) enable_if {};
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) enable_if<true, _Tp> {
  typedef _Tp type;
};

template <bool _Bp, class _Tp = void>
using enable_if_t = typename enable_if<_Bp, _Tp>::type;

template <class _Tp, class _Up>
struct __attribute__((__type_visibility__("default"))) is_same
    : public false_type {};
template <class _Tp>
struct __attribute__((__type_visibility__("default")))
is_same<_Tp, _Tp> : public true_type {};

template <class _Tp, class _Up>
using _IsSame = _BoolConstant<

    __is_same(_Tp, _Up)

    >;

template <class _Tp, class _Up>
using _IsNotSame = _BoolConstant<

    !__is_same(_Tp, _Up)

    >;

template <class _Tp>
using __test_for_primary_template =
    _EnableIf<_IsSame<_Tp, typename _Tp::__primary_template>::value>;
template <class _Tp>
using __is_primary_template =
    _IsValidExpansion<__test_for_primary_template, _Tp>;

template <class _Tp>
inline __attribute__((__no_sanitize__("cfi")))
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _Tp *
addressof(_Tp &__x) noexcept {
  return __builtin_addressof(__x);
}
# 650 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> _Tp *addressof(const _Tp &&) noexcept = delete;

struct __two {
  char __lx[2];
};

template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_const
    : public false_type {};
template <class _Tp>
struct __attribute__((__type_visibility__("default")))
is_const<_Tp const> : public true_type {};
# 670 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_volatile
    : public false_type {};
template <class _Tp>
struct __attribute__((__type_visibility__("default")))
is_volatile<_Tp volatile> : public true_type {};
# 681 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) remove_const {
  typedef _Tp type;
};
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) remove_const<const _Tp> {
  typedef _Tp type;
};

template <class _Tp> using remove_const_t = typename remove_const<_Tp>::type;

template <class _Tp>
struct __attribute__((__type_visibility__("default"))) remove_volatile {
  typedef _Tp type;
};
template <class _Tp>
struct __attribute__((__type_visibility__("default")))
remove_volatile<volatile _Tp> {
  typedef _Tp type;
};

template <class _Tp>
using remove_volatile_t = typename remove_volatile<_Tp>::type;

template <class _Tp>
struct __attribute__((__type_visibility__("default"))) remove_cv {
  typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;
};

template <class _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;

template <class _Tp> struct __libcpp_is_void : public false_type {};
template <> struct __libcpp_is_void<void> : public true_type {};

template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_void
    : public __libcpp_is_void<typename remove_cv<_Tp>::type> {};
# 719 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __is_nullptr_t_impl : public false_type {};
template <> struct __is_nullptr_t_impl<nullptr_t> : public true_type {};

template <class _Tp>
struct __attribute__((__type_visibility__("default"))) __is_nullptr_t
    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};

template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_null_pointer
    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};
# 738 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __libcpp_is_integral : public false_type {};
template <> struct __libcpp_is_integral<bool> : public true_type {};
template <> struct __libcpp_is_integral<char> : public true_type {};
template <> struct __libcpp_is_integral<signed char> : public true_type {};
template <> struct __libcpp_is_integral<unsigned char> : public true_type {};
template <> struct __libcpp_is_integral<wchar_t> : public true_type {};

template <> struct __libcpp_is_integral<char16_t> : public true_type {};
template <> struct __libcpp_is_integral<char32_t> : public true_type {};

template <> struct __libcpp_is_integral<short> : public true_type {};
template <> struct __libcpp_is_integral<unsigned short> : public true_type {};
template <> struct __libcpp_is_integral<int> : public true_type {};
template <> struct __libcpp_is_integral<unsigned int> : public true_type {};
template <> struct __libcpp_is_integral<long> : public true_type {};
template <> struct __libcpp_is_integral<unsigned long> : public true_type {};
template <> struct __libcpp_is_integral<long long> : public true_type {};
template <>
struct __libcpp_is_integral<unsigned long long> : public true_type {};

template <> struct __libcpp_is_integral<__int128_t> : public true_type {};
template <> struct __libcpp_is_integral<__uint128_t> : public true_type {};

template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_integral
    : public __libcpp_is_integral<typename remove_cv<_Tp>::type> {};
# 775 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __libcpp_is_floating_point : public false_type {};
template <> struct __libcpp_is_floating_point<float> : public true_type {};
template <> struct __libcpp_is_floating_point<double> : public true_type {};
template <>
struct __libcpp_is_floating_point<long double> : public true_type {};

template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_floating_point
    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};
# 791 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_array
    : public false_type {};
template <class _Tp>
struct __attribute__((__type_visibility__("default")))
is_array<_Tp[]> : public true_type {};
template <class _Tp, size_t _Np>
struct __attribute__((__type_visibility__("default")))
is_array<_Tp[_Np]> : public true_type {};
# 806 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __libcpp_is_pointer : public false_type {};
template <class _Tp> struct __libcpp_is_pointer<_Tp *> : public true_type {};

template <class _Tp> struct __libcpp_remove_objc_qualifiers {
  typedef _Tp type;
};

template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_pointer
    : public __libcpp_is_pointer<typename __libcpp_remove_objc_qualifiers<
          typename remove_cv<_Tp>::type>::type> {};
# 828 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_lvalue_reference
    : public false_type {};
template <class _Tp>
struct __attribute__((__type_visibility__("default")))
is_lvalue_reference<_Tp &> : public true_type {};

template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_rvalue_reference
    : public false_type {};
template <class _Tp>
struct __attribute__((__type_visibility__("default")))
is_rvalue_reference<_Tp &&> : public true_type {};

template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_reference
    : public false_type {};
template <class _Tp>
struct __attribute__((__type_visibility__("default")))
is_reference<_Tp &> : public true_type {};
template <class _Tp>
struct __attribute__((__type_visibility__("default")))
is_reference<_Tp &&> : public true_type {};
# 855 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_union
    : public integral_constant<bool, __is_union(_Tp)> {};
# 876 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_class
    : public integral_constant<bool, __is_class(_Tp)> {};
# 900 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_function
    : public _BoolConstant<

          __is_function(_Tp)

          > {};
# 916 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __libcpp_is_member_pointer {
  enum { __is_member = false, __is_func = false, __is_obj = false };
};
template <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> {
  enum {
    __is_member = true,
    __is_func = is_function<_Tp>::value,
    __is_obj = !__is_func,
  };
};

template <class _Tp>
struct __attribute__((__type_visibility__("default")))
is_member_function_pointer : public _BoolConstant<__libcpp_is_member_pointer<
                                 typename remove_cv<_Tp>::type>::__is_func> {};
# 943 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_member_pointer
    : public _BoolConstant<__libcpp_is_member_pointer<
          typename remove_cv<_Tp>::type>::__is_member> {};
# 954 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_member_object_pointer
    : public _BoolConstant<
          __libcpp_is_member_pointer<typename remove_cv<_Tp>::type>::__is_obj> {
};
# 967 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_enum
    : public integral_constant<bool, __is_enum(_Tp)> {};
# 994 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_arithmetic
    : public integral_constant<bool, is_integral<_Tp>::value ||
                                         is_floating_point<_Tp>::value> {};
# 1006 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_fundamental
    : public integral_constant<bool, is_void<_Tp>::value ||
                                         __is_nullptr_t<_Tp>::value ||
                                         is_arithmetic<_Tp>::value> {};
# 1019 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __is_block : false_type {};

template <class _Rp, class... _Args>
struct __is_block<_Rp (^)(_Args...)> : true_type {};

template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_scalar
    : public integral_constant<
          bool, is_arithmetic<_Tp>::value || is_member_pointer<_Tp>::value ||
                    is_pointer<_Tp>::value || __is_nullptr_t<_Tp>::value ||
                    __is_block<_Tp>::value || is_enum<_Tp>::value> {};

template <>
struct __attribute__((__type_visibility__("default")))
is_scalar<nullptr_t> : public true_type {};
# 1042 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_object
    : public integral_constant<
          bool, is_scalar<_Tp>::value || is_array<_Tp>::value ||
                    is_union<_Tp>::value || is_class<_Tp>::value> {};
# 1056 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_compound
    : public integral_constant<bool, !is_fundamental<_Tp>::value> {};
# 1068 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
struct __is_referenceable_impl {
  template <class _Tp> static _Tp &__test(int);
  template <class _Tp> static __two __test(...);
};

template <class _Tp>
struct __is_referenceable
    : integral_constant<
          bool, _IsNotSame<decltype(__is_referenceable_impl::__test<_Tp>(0)),
                           __two>::value> {};

template <class _Tp>
struct __attribute__((__type_visibility__("default"))) add_const {
  typedef const _Tp type;
};

template <class _Tp> using add_const_t = typename add_const<_Tp>::type;

template <class _Tp>
struct __attribute__((__type_visibility__("default"))) add_volatile {
  typedef volatile _Tp type;
};

template <class _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;

template <class _Tp>
struct __attribute__((__type_visibility__("default"))) add_cv {
  typedef const volatile _Tp type;
};

template <class _Tp> using add_cv_t = typename add_cv<_Tp>::type;

template <class _Tp>
struct __attribute__((__type_visibility__("default"))) remove_reference {
  typedef _Tp type;
};
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) remove_reference<_Tp &> {
  typedef _Tp type;
};
template <class _Tp>
struct __attribute__((__type_visibility__("default")))
remove_reference<_Tp &&> {
  typedef _Tp type;
};

template <class _Tp>
using remove_reference_t = typename remove_reference<_Tp>::type;

template <class _Tp, bool = __is_referenceable<_Tp>::value>
struct __add_lvalue_reference_impl {
  typedef _Tp type;
};
template <class _Tp> struct __add_lvalue_reference_impl<_Tp, true> {
  typedef _Tp &type;
};

template <class _Tp>
struct __attribute__((__type_visibility__("default"))) add_lvalue_reference {
  typedef typename __add_lvalue_reference_impl<_Tp>::type type;
};

template <class _Tp>
using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;

template <class _Tp, bool = __is_referenceable<_Tp>::value>
struct __add_rvalue_reference_impl {
  typedef _Tp type;
};
template <class _Tp> struct __add_rvalue_reference_impl<_Tp, true> {
  typedef _Tp &&type;
};

template <class _Tp>
struct __attribute__((__type_visibility__("default"))) add_rvalue_reference {
  typedef typename __add_rvalue_reference_impl<_Tp>::type type;
};

template <class _Tp>
using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;

#pragma GCC diagnostic push
# 1141 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
template <class _Tp> _Tp &&__declval(int);
template <class _Tp> _Tp __declval(long);
#pragma GCC diagnostic pop

template <class _Tp> decltype(std::__1::__declval<_Tp>(0)) declval() noexcept;

template <class _Tp> struct __uncvref {
  typedef typename remove_cv<typename remove_reference<_Tp>::type>::type type;
};

template <class _Tp> struct __unconstref {
  typedef
      typename remove_const<typename remove_reference<_Tp>::type>::type type;
};

template <class _Tp> using __uncvref_t = typename __uncvref<_Tp>::type;

template <class _Tp, class _Up>
struct __is_same_uncvref
    : _IsSame<typename __uncvref<_Tp>::type, typename __uncvref<_Up>::type> {};
# 1182 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
struct __any {
  __any(...);
};

template <class _Tp>
struct __attribute__((__type_visibility__("default"))) remove_pointer {
  typedef _Tp type;
};
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) remove_pointer<_Tp *> {
  typedef _Tp type;
};
template <class _Tp>
struct __attribute__((__type_visibility__("default")))
remove_pointer<_Tp *const> {
  typedef _Tp type;
};
template <class _Tp>
struct __attribute__((__type_visibility__("default")))
remove_pointer<_Tp *volatile> {
  typedef _Tp type;
};
template <class _Tp>
struct __attribute__((__type_visibility__("default")))
remove_pointer<_Tp *const volatile> {
  typedef _Tp type;
};

template <class _Tp>
using remove_pointer_t = typename remove_pointer<_Tp>::type;

template <class _Tp, bool = __is_referenceable<_Tp>::value ||
                            _IsSame<typename remove_cv<_Tp>::type, void>::value>
struct __add_pointer_impl {
  typedef typename remove_reference<_Tp>::type *type;
};
template <class _Tp> struct __add_pointer_impl<_Tp, false> {
  typedef _Tp type;
};

template <class _Tp>
struct __attribute__((__type_visibility__("default"))) add_pointer {
  typedef typename __add_pointer_impl<_Tp>::type type;
};

template <class _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;
# 1224 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp, bool = is_integral<_Tp>::value>
struct __libcpp_is_signed_impl
    : public integral_constant<bool, (_Tp(-1) < _Tp(0))> {};

template <class _Tp>
struct __libcpp_is_signed_impl<_Tp, false> : public true_type {};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
struct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {};

template <class _Tp>
struct __libcpp_is_signed<_Tp, false> : public false_type {};

template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_signed
    : public __libcpp_is_signed<_Tp> {};
# 1245 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp, bool = is_integral<_Tp>::value>
struct __libcpp_is_unsigned_impl
    : public integral_constant<bool, (_Tp(0) < _Tp(-1))> {};

template <class _Tp>
struct __libcpp_is_unsigned_impl<_Tp, false> : public false_type {};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
struct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {};

template <class _Tp>
struct __libcpp_is_unsigned<_Tp, false> : public false_type {};

template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_unsigned
    : public __libcpp_is_unsigned<_Tp> {};
# 1266 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) rank
    : public integral_constant<size_t, 0> {};
template <class _Tp>
struct __attribute__((__type_visibility__("default")))
rank<_Tp[]> : public integral_constant<size_t, rank<_Tp>::value + 1> {};
template <class _Tp, size_t _Np>
struct __attribute__((__type_visibility__("default")))
rank<_Tp[_Np]> : public integral_constant<size_t, rank<_Tp>::value + 1> {};
# 1281 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp, unsigned _Ip = 0>
struct __attribute__((__type_visibility__("default"))) extent
    : public integral_constant<size_t, 0> {};
template <class _Tp>
struct __attribute__((__type_visibility__("default")))
extent<_Tp[], 0> : public integral_constant<size_t, 0> {};
template <class _Tp, unsigned _Ip>
struct __attribute__((__type_visibility__("default"))) extent<_Tp[], _Ip>
    : public integral_constant<size_t, extent<_Tp, _Ip - 1>::value> {};
template <class _Tp, size_t _Np>
struct __attribute__((__type_visibility__("default")))
extent<_Tp[_Np], 0> : public integral_constant<size_t, _Np> {};
template <class _Tp, size_t _Np, unsigned _Ip>
struct __attribute__((__type_visibility__("default"))) extent<_Tp[_Np], _Ip>
    : public integral_constant<size_t, extent<_Tp, _Ip - 1>::value> {};
# 1300 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) remove_extent {
  typedef _Tp type;
};
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) remove_extent<_Tp[]> {
  typedef _Tp type;
};
template <class _Tp, size_t _Np>
struct __attribute__((__type_visibility__("default"))) remove_extent<_Tp[_Np]> {
  typedef _Tp type;
};

template <class _Tp> using remove_extent_t = typename remove_extent<_Tp>::type;

template <class _Tp>
struct __attribute__((__type_visibility__("default"))) remove_all_extents {
  typedef _Tp type;
};
template <class _Tp>
struct __attribute__((__type_visibility__("default")))
remove_all_extents<_Tp[]> {
  typedef typename remove_all_extents<_Tp>::type type;
};
template <class _Tp, size_t _Np>
struct __attribute__((__type_visibility__("default")))
remove_all_extents<_Tp[_Np]> {
  typedef typename remove_all_extents<_Tp>::type type;
};

template <class _Tp>
using remove_all_extents_t = typename remove_all_extents<_Tp>::type;
# 1346 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Up, bool> struct __decay {
  typedef typename remove_cv<_Up>::type type;
};

template <class _Up> struct __decay<_Up, true> {
public:
  typedef typename conditional<
      is_array<_Up>::value, typename remove_extent<_Up>::type *,
      typename conditional<is_function<_Up>::value,
                           typename add_pointer<_Up>::type,
                           typename remove_cv<_Up>::type>::type>::type type;
};

template <class _Tp>
struct __attribute__((__type_visibility__("default"))) decay {
private:
  typedef typename remove_reference<_Tp>::type _Up;

public:
  typedef typename __decay<_Up, __is_referenceable<_Up>::value>::type type;
};

template <class _Tp> using decay_t = typename decay<_Tp>::type;

template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)> {};
# 1393 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) __libcpp_is_final
    : public integral_constant<bool, __is_final(_Tp)> {};

template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_final
    : public integral_constant<bool, __is_final(_Tp)> {};
# 1423 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Bp, class _Dp>
struct __attribute__((__type_visibility__("default"))) is_base_of
    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};
# 1437 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _T1, class _T2>
struct __attribute__((__type_visibility__("default"))) is_convertible
    : public integral_constant<bool, __is_convertible_to(_T1, _T2)> {};
# 1545 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_empty
    : public integral_constant<bool, __is_empty(_Tp)> {};
# 1582 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)> {};
# 1608 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};
# 1642 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) alignment_of
    : public integral_constant<size_t, alignof(_Tp)> {};
# 1653 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Hp, class _Tp> struct __type_list {
  typedef _Hp _Head;
  typedef _Tp _Tail;
};

struct __nat {

  __nat() = delete;
  __nat(const __nat &) = delete;
  __nat &operator=(const __nat &) = delete;
  ~__nat() = delete;
};

template <class _Tp> struct __align_type {
  static const size_t value = __alignof(_Tp);
  typedef _Tp type;
};

struct __struct_double {
  long double __lx;
};
struct __struct_double4 {
  double __lx[4];
};

typedef __type_list<
    __align_type<unsigned char>,
    __type_list<
        __align_type<unsigned short>,
        __type_list<
            __align_type<unsigned int>,
            __type_list<
                __align_type<unsigned long>,
                __type_list<
                    __align_type<unsigned long long>,
                    __type_list<
                        __align_type<double>,
                        __type_list<
                            __align_type<long double>,
                            __type_list<
                                __align_type<__struct_double>,
                                __type_list<__align_type<__struct_double4>,
                                            __type_list<__align_type<int *>,
                                                        __nat>>>>>>>>>>
    __all_types;

template <size_t _Align> struct alignas(_Align) __fallback_overaligned {};

template <class _TL, size_t _Align> struct __find_pod;

template <class _Hp, size_t _Align>
struct __find_pod<__type_list<_Hp, __nat>, _Align> {
  typedef typename conditional<_Align == _Hp::value, typename _Hp::type,
                               __fallback_overaligned<_Align>>::type type;
};

template <class _Hp, class _Tp, size_t _Align>
struct __find_pod<__type_list<_Hp, _Tp>, _Align> {
  typedef
      typename conditional<_Align == _Hp::value, typename _Hp::type,
                           typename __find_pod<_Tp, _Align>::type>::type type;
};

template <class _TL, size_t _Len> struct __find_max_align;

template <class _Hp, size_t _Len>
struct __find_max_align<__type_list<_Hp, __nat>, _Len>
    : public integral_constant<size_t, _Hp::value> {};

template <size_t _Len, size_t _A1, size_t _A2> struct __select_align {
private:
  static const size_t __min = _A2 < _A1 ? _A2 : _A1;
  static const size_t __max = _A1 < _A2 ? _A2 : _A1;

public:
  static const size_t value = _Len < __max ? __min : __max;
};

template <class _Hp, class _Tp, size_t _Len>
struct __find_max_align<__type_list<_Hp, _Tp>, _Len>
    : public integral_constant<
          size_t, __select_align<_Len, _Hp::value,
                                 __find_max_align<_Tp, _Len>::value>::value> {};

template <size_t _Len,
          size_t _Align = __find_max_align<__all_types, _Len>::value>
struct __attribute__((__type_visibility__("default"))) aligned_storage {
  typedef typename __find_pod<__all_types, _Align>::type _Aligner;
  union type {
    _Aligner __align;
    unsigned char __data[(_Len + _Align - 1) / _Align * _Align];
  };
};

template <size_t _Len,
          size_t _Align = __find_max_align<__all_types, _Len>::value>
using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;
# 1764 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <size_t _Len>
struct __attribute__((__type_visibility__("default")))
aligned_storage<_Len, 0x1> {
  struct alignas(0x1) type {
    unsigned char __lx[(_Len + 0x1 - 1) / 0x1 * 0x1];
  };
};
template <size_t _Len>
struct __attribute__((__type_visibility__("default")))
aligned_storage<_Len, 0x2> {
  struct alignas(0x2) type {
    unsigned char __lx[(_Len + 0x2 - 1) / 0x2 * 0x2];
  };
};
template <size_t _Len>
struct __attribute__((__type_visibility__("default")))
aligned_storage<_Len, 0x4> {
  struct alignas(0x4) type {
    unsigned char __lx[(_Len + 0x4 - 1) / 0x4 * 0x4];
  };
};
template <size_t _Len>
struct __attribute__((__type_visibility__("default")))
aligned_storage<_Len, 0x8> {
  struct alignas(0x8) type {
    unsigned char __lx[(_Len + 0x8 - 1) / 0x8 * 0x8];
  };
};
template <size_t _Len>
struct __attribute__((__type_visibility__("default")))
aligned_storage<_Len, 0x10> {
  struct alignas(0x10) type {
    unsigned char __lx[(_Len + 0x10 - 1) / 0x10 * 0x10];
  };
};
template <size_t _Len>
struct __attribute__((__type_visibility__("default")))
aligned_storage<_Len, 0x20> {
  struct alignas(0x20) type {
    unsigned char __lx[(_Len + 0x20 - 1) / 0x20 * 0x20];
  };
};
template <size_t _Len>
struct __attribute__((__type_visibility__("default")))
aligned_storage<_Len, 0x40> {
  struct alignas(0x40) type {
    unsigned char __lx[(_Len + 0x40 - 1) / 0x40 * 0x40];
  };
};
template <size_t _Len>
struct __attribute__((__type_visibility__("default")))
aligned_storage<_Len, 0x80> {
  struct alignas(0x80) type {
    unsigned char __lx[(_Len + 0x80 - 1) / 0x80 * 0x80];
  };
};
template <size_t _Len>
struct __attribute__((__type_visibility__("default")))
aligned_storage<_Len, 0x100> {
  struct alignas(0x100) type {
    unsigned char __lx[(_Len + 0x100 - 1) / 0x100 * 0x100];
  };
};
template <size_t _Len>
struct __attribute__((__type_visibility__("default")))
aligned_storage<_Len, 0x200> {
  struct alignas(0x200) type {
    unsigned char __lx[(_Len + 0x200 - 1) / 0x200 * 0x200];
  };
};
template <size_t _Len>
struct __attribute__((__type_visibility__("default")))
aligned_storage<_Len, 0x400> {
  struct alignas(0x400) type {
    unsigned char __lx[(_Len + 0x400 - 1) / 0x400 * 0x400];
  };
};
template <size_t _Len>
struct __attribute__((__type_visibility__("default")))
aligned_storage<_Len, 0x800> {
  struct alignas(0x800) type {
    unsigned char __lx[(_Len + 0x800 - 1) / 0x800 * 0x800];
  };
};
template <size_t _Len>
struct __attribute__((__type_visibility__("default")))
aligned_storage<_Len, 0x1000> {
  struct alignas(0x1000) type {
    unsigned char __lx[(_Len + 0x1000 - 1) / 0x1000 * 0x1000];
  };
};
template <size_t _Len>
struct __attribute__((__type_visibility__("default")))
aligned_storage<_Len, 0x2000> {
  struct alignas(0x2000) type {
    unsigned char __lx[(_Len + 0x2000 - 1) / 0x2000 * 0x2000];
  };
};

template <size_t _Len>
struct __attribute__((__type_visibility__("default")))
aligned_storage<_Len, 0x4000> {
  struct alignas(0x4000) type {
    unsigned char __lx[(_Len + 0x4000 - 1) / 0x4000 * 0x4000];
  };
};

template <size_t _I0, size_t... _In> struct __static_max;

template <size_t _I0> struct __static_max<_I0> {
  static const size_t value = _I0;
};

template <size_t _I0, size_t _I1, size_t... _In>
struct __static_max<_I0, _I1, _In...> {
  static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value
                                         : __static_max<_I1, _In...>::value;
};

template <size_t _Len, class _Type0, class... _Types> struct aligned_union {
  static const size_t alignment_value =
      __static_max<__alignof(_Type0), __alignof(_Types)...>::value;
  static const size_t __len =
      __static_max<_Len, sizeof(_Type0), sizeof(_Types)...>::value;
  typedef typename aligned_storage<__len, alignment_value>::type type;
};

template <size_t _Len, class... _Types>
using aligned_union_t = typename aligned_union<_Len, _Types...>::type;

template <class _Tp> struct __numeric_type {
  static void __test(...);
  static float __test(float);
  static double __test(char);
  static double __test(int);
  static double __test(unsigned);
  static double __test(long);
  static double __test(unsigned long);
  static double __test(long long);
  static double __test(unsigned long long);
  static double __test(double);
  static long double __test(long double);

  typedef decltype(__test(declval<_Tp>())) type;
  static const bool value = _IsNotSame<type, void>::value;
};

template <> struct __numeric_type<void> { static const bool value = true; };

template <class _A1, class _A2 = void, class _A3 = void,
          bool = __numeric_type<_A1>::value &&__numeric_type<_A2>::value
              &&__numeric_type<_A3>::value>
class __promote_imp {
public:
  static const bool value = false;
};

template <class _A1, class _A2, class _A3>
class __promote_imp<_A1, _A2, _A3, true> {
private:
  typedef typename __promote_imp<_A1>::type __type1;
  typedef typename __promote_imp<_A2>::type __type2;
  typedef typename __promote_imp<_A3>::type __type3;

public:
  typedef decltype(__type1() + __type2() + __type3()) type;
  static const bool value = true;
};

template <class _A1, class _A2> class __promote_imp<_A1, _A2, void, true> {
private:
  typedef typename __promote_imp<_A1>::type __type1;
  typedef typename __promote_imp<_A2>::type __type2;

public:
  typedef decltype(__type1() + __type2()) type;
  static const bool value = true;
};

template <class _A1> class __promote_imp<_A1, void, void, true> {
public:
  typedef typename __numeric_type<_A1>::type type;
  static const bool value = true;
};

template <class _A1, class _A2 = void, class _A3 = void>
class __promote : public __promote_imp<_A1, _A2, _A3> {};

typedef __type_list<
    signed char,
    __type_list<
        signed short,
        __type_list<signed int,
                    __type_list<signed long, __type_list<signed long long,

                                                         __type_list<__int128_t,

                                                                     __nat

                                                                     >

                                                         >>>>>
    __signed_types;

typedef __type_list<
    unsigned char,
    __type_list<unsigned short,
                __type_list<unsigned int,
                            __type_list<unsigned long,
                                        __type_list<unsigned long long,

                                                    __type_list<__uint128_t,

                                                                __nat

                                                                >

                                                    >>>>>
    __unsigned_types;

template <class _TypeList, size_t _Size,
          bool = _Size <= sizeof(typename _TypeList::_Head)>
struct __find_first;

template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, true> {
  typedef _Hp type;
};

template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, false> {
  typedef typename __find_first<_Tp, _Size>::type type;
};

template <class _Tp, class _Up,
          bool = is_const<typename remove_reference<_Tp>::type>::value,
          bool = is_volatile<typename remove_reference<_Tp>::type>::value>
struct __apply_cv {
  typedef _Up type;
};

template <class _Tp, class _Up> struct __apply_cv<_Tp, _Up, true, false> {
  typedef const _Up type;
};

template <class _Tp, class _Up> struct __apply_cv<_Tp, _Up, false, true> {
  typedef volatile _Up type;
};

template <class _Tp, class _Up> struct __apply_cv<_Tp, _Up, true, true> {
  typedef const volatile _Up type;
};

template <class _Tp, class _Up> struct __apply_cv<_Tp &, _Up, false, false> {
  typedef _Up &type;
};

template <class _Tp, class _Up> struct __apply_cv<_Tp &, _Up, true, false> {
  typedef const _Up &type;
};

template <class _Tp, class _Up> struct __apply_cv<_Tp &, _Up, false, true> {
  typedef volatile _Up &type;
};

template <class _Tp, class _Up> struct __apply_cv<_Tp &, _Up, true, true> {
  typedef const volatile _Up &type;
};

template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
struct __make_signed {};

template <class _Tp> struct __make_signed<_Tp, true> {
  typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;
};

template <> struct __make_signed<bool, true> {};
template <> struct __make_signed<signed short, true> { typedef short type; };
template <> struct __make_signed<unsigned short, true> { typedef short type; };
template <> struct __make_signed<signed int, true> { typedef int type; };
template <> struct __make_signed<unsigned int, true> { typedef int type; };
template <> struct __make_signed<signed long, true> { typedef long type; };
template <> struct __make_signed<unsigned long, true> { typedef long type; };
template <> struct __make_signed<signed long long, true> {
  typedef long long type;
};
template <> struct __make_signed<unsigned long long, true> {
  typedef long long type;
};

template <> struct __make_signed<__int128_t, true> { typedef __int128_t type; };
template <> struct __make_signed<__uint128_t, true> {
  typedef __int128_t type;
};

template <class _Tp>
struct __attribute__((__type_visibility__("default"))) make_signed {
  typedef typename __apply_cv<
      _Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type
      type;
};

template <class _Tp> using make_signed_t = typename make_signed<_Tp>::type;

template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
struct __make_unsigned {};

template <class _Tp> struct __make_unsigned<_Tp, true> {
  typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;
};

template <> struct __make_unsigned<bool, true> {};
template <> struct __make_unsigned<signed short, true> {
  typedef unsigned short type;
};
template <> struct __make_unsigned<unsigned short, true> {
  typedef unsigned short type;
};
template <> struct __make_unsigned<signed int, true> {
  typedef unsigned int type;
};
template <> struct __make_unsigned<unsigned int, true> {
  typedef unsigned int type;
};
template <> struct __make_unsigned<signed long, true> {
  typedef unsigned long type;
};
template <> struct __make_unsigned<unsigned long, true> {
  typedef unsigned long type;
};
template <> struct __make_unsigned<signed long long, true> {
  typedef unsigned long long type;
};
template <> struct __make_unsigned<unsigned long long, true> {
  typedef unsigned long long type;
};

template <> struct __make_unsigned<__int128_t, true> {
  typedef __uint128_t type;
};
template <> struct __make_unsigned<__uint128_t, true> {
  typedef __uint128_t type;
};

template <class _Tp>
struct __attribute__((__type_visibility__("default"))) make_unsigned {
  typedef typename __apply_cv<
      _Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type
      type;
};

template <class _Tp> using make_unsigned_t = typename make_unsigned<_Tp>::type;

template <class _Tp, class _Up, class = void> struct __common_type2_imp {};

template <class _Tp, class _Up>
struct __common_type2_imp<
    _Tp, _Up,
    typename __void_t<decltype(true ? std::__1::declval<_Tp>()
                                    : std::__1::declval<_Up>())>::type> {
  typedef typename decay<decltype(true ? std::__1::declval<_Tp>()
                                       : std::__1::declval<_Up>())>::type type;
};

template <class, class = void> struct __common_type_impl {};

template <class... Tp> struct __common_types;
template <class... _Tp>
struct __attribute__((__type_visibility__("default"))) common_type;
# 2087 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp, class _Up>
struct __common_type_impl<
    __common_types<_Tp, _Up>,
    typename __void_t<typename common_type<_Tp, _Up>::type>::type> {
  typedef typename common_type<_Tp, _Up>::type type;
};

template <class _Tp, class _Up, class _Vp, class... _Rest>
struct __common_type_impl<
    __common_types<_Tp, _Up, _Vp, _Rest...>,
    typename __void_t<typename common_type<_Tp, _Up>::type>::type>
    : __common_type_impl<
          __common_types<typename common_type<_Tp, _Up>::type, _Vp, _Rest...>> {
};

template <>
struct __attribute__((__type_visibility__("default"))) common_type<> {};

template <class _Tp>
struct __attribute__((__type_visibility__("default")))
common_type<_Tp> : public common_type<_Tp, _Tp> {};

template <class _Tp, class _Up>
struct __attribute__((__type_visibility__("default"))) common_type<_Tp, _Up>
    : conditional<_IsSame<_Tp, typename decay<_Tp>::type>::value &&
                      _IsSame<_Up, typename decay<_Up>::type>::value,
                  __common_type2_imp<_Tp, _Up>,
                  common_type<typename decay<_Tp>::type,
                              typename decay<_Up>::type>>::type {};

template <class _Tp, class _Up, class _Vp, class... _Rest>
struct __attribute__((__type_visibility__("default")))
common_type<_Tp, _Up, _Vp, _Rest...>
    : __common_type_impl<__common_types<_Tp, _Up, _Vp, _Rest...>> {};

template <class... _Tp>
using common_type_t = typename common_type<_Tp...>::type;

template <typename, typename _Tp> struct __select_2nd { typedef _Tp type; };

template <class _Tp, class _Arg>
typename __select_2nd<
    decltype((std::__1::declval<_Tp>() = std::__1::declval<_Arg>())),
    true_type>::type
__is_assignable_test(int);

template <class, class> false_type __is_assignable_test(...);

template <class _Tp, class _Arg,
          bool = is_void<_Tp>::value || is_void<_Arg>::value>
struct __is_assignable_imp
    : public decltype((std::__1::__is_assignable_test<_Tp, _Arg>(0))) {};

template <class _Tp, class _Arg>
struct __is_assignable_imp<_Tp, _Arg, true> : public false_type {};

template <class _Tp, class _Arg>
struct is_assignable : public __is_assignable_imp<_Tp, _Arg> {};
# 2173 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_copy_assignable
    : public is_assignable<
          typename add_lvalue_reference<_Tp>::type,
          typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {
};
# 2185 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_move_assignable
    : public is_assignable<typename add_lvalue_reference<_Tp>::type,
                           typename add_rvalue_reference<_Tp>::type> {};
# 2204 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class> struct __is_destructible_apply { typedef int type; };

template <typename _Tp> struct __is_destructor_wellformed {
  template <typename _Tp1>
  static char __test(typename __is_destructible_apply<
                     decltype(std::__1::declval<_Tp1 &>().~_Tp1())>::type);

  template <typename _Tp1> static __two __test(...);

  static const bool value = sizeof(__test<_Tp>(12)) == sizeof(char);
};

template <class _Tp, bool> struct __destructible_imp;

template <class _Tp>
struct __destructible_imp<_Tp, false>
    : public std::__1::integral_constant<
          bool, __is_destructor_wellformed<
                    typename std::__1::remove_all_extents<_Tp>::type>::value> {
};

template <class _Tp>
struct __destructible_imp<_Tp, true> : public std::__1::true_type {};

template <class _Tp, bool> struct __destructible_false;

template <class _Tp>
struct __destructible_false<_Tp, false>
    : public __destructible_imp<_Tp, std::__1::is_reference<_Tp>::value> {};

template <class _Tp>
struct __destructible_false<_Tp, true> : public std::__1::false_type {};

template <class _Tp>
struct is_destructible
    : public __destructible_false<_Tp, std::__1::is_function<_Tp>::value> {};

template <class _Tp>
struct is_destructible<_Tp[]> : public std::__1::false_type {};

template <> struct is_destructible<void> : public std::__1::false_type {};
# 2261 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr
    typename remove_reference<_Tp>::type &&
    move(_Tp &&__t) noexcept {
  typedef typename remove_reference<_Tp>::type _Up;
  return static_cast<_Up &&>(__t);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr _Tp &&
forward(typename remove_reference<_Tp>::type &__t) noexcept {
  return static_cast<_Tp &&>(__t);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr _Tp &&
forward(typename remove_reference<_Tp>::type &&__t) noexcept {
  static_assert(!is_lvalue_reference<_Tp>::value,
                "can not forward an rvalue as an lvalue");
  return static_cast<_Tp &&>(__t);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) typename decay<_Tp>::type
__decay_copy(_Tp &&__t) {
  return std::__1::forward<_Tp>(__t);
}

template <class _MP, bool _IsMemberFunctionPtr, bool _IsMemberObjectPtr>
struct __member_pointer_traits_imp {};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false> {
  typedef _Class _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...), true,
                                   false> {
  typedef _Class _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true,
                                   false> {
  typedef _Class const _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const, true,
                                   false> {
  typedef _Class const _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true,
                                   false> {
  typedef _Class volatile _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile,
                                   true, false> {
  typedef _Class volatile _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile,
                                   true, false> {
  typedef _Class const volatile _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<
    _Rp (_Class::*)(_Param..., ...) const volatile, true, false> {
  typedef _Class const volatile _ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &, true, false> {
  typedef _Class &_ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &, true,
                                   false> {
  typedef _Class &_ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const &, true,
                                   false> {
  typedef _Class const &_ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const &,
                                   true, false> {
  typedef _Class const &_ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile &, true,
                                   false> {
  typedef _Class volatile &_ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile &,
                                   true, false> {
  typedef _Class volatile &_ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile &,
                                   true, false> {
  typedef _Class const volatile &_ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<
    _Rp (_Class::*)(_Param..., ...) const volatile &, true, false> {
  typedef _Class const volatile &_ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &&, true, false> {
  typedef _Class &&_ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &&, true,
                                   false> {
  typedef _Class &&_ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const &&, true,
                                   false> {
  typedef _Class const &&_ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const &&,
                                   true, false> {
  typedef _Class const &&_ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile &&, true,
                                   false> {
  typedef _Class volatile &&_ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile &&,
                                   true, false> {
  typedef _Class volatile &&_ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile &&,
                                   true, false> {
  typedef _Class const volatile &&_ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param...);
};

template <class _Rp, class _Class, class... _Param>
struct __member_pointer_traits_imp<
    _Rp (_Class::*)(_Param..., ...) const volatile &&, true, false> {
  typedef _Class const volatile &&_ClassType;
  typedef _Rp _ReturnType;
  typedef _Rp(_FnType)(_Param..., ...);
};

template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp _Class::*, false, true> {
  typedef _Class _ClassType;
  typedef _Rp _ReturnType;
};

template <class _MP>
struct __member_pointer_traits
    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,
                                         is_member_function_pointer<_MP>::value,
                                         is_member_object_pointer<_MP>::value> {

};

template <class _DecayedFp> struct __member_pointer_class_type {};

template <class _Ret, class _ClassType>
struct __member_pointer_class_type<_Ret _ClassType::*> {
  typedef _ClassType type;
};

template <class _Callable> class result_of;
# 2679 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
namespace __is_construct {
struct __nat {};
} // namespace __is_construct
# 2801 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp, class... _Args>
struct __attribute__((__type_visibility__("default"))) is_constructible
    : public integral_constant<bool, __is_constructible(_Tp, _Args...)> {};
# 2819 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_default_constructible
    : public is_constructible<_Tp> {};
# 2835 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> void __test_implicit_default_constructible(_Tp);

template <class _Tp, class = void, bool = is_default_constructible<_Tp>::value>
struct __is_implicitly_default_constructible : false_type {};

template <class _Tp>
struct __is_implicitly_default_constructible<
    _Tp, decltype(__test_implicit_default_constructible<_Tp const &>({})), true>
    : true_type {};

template <class _Tp>
struct __is_implicitly_default_constructible<
    _Tp, decltype(__test_implicit_default_constructible<_Tp const &>({})),
    false> : false_type {};

template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_copy_constructible
    : public is_constructible<_Tp, typename add_lvalue_reference<
                                       typename add_const<_Tp>::type>::type> {};
# 2869 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_move_constructible
    : public is_constructible<_Tp, typename add_rvalue_reference<_Tp>::type> {};
# 2884 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp, class... _Args>
struct __attribute__((__type_visibility__("default")))
is_trivially_constructible
    : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)> {};
# 2937 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default")))
is_trivially_default_constructible : public is_trivially_constructible<_Tp> {};
# 2949 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default")))
is_trivially_copy_constructible
    : public is_trivially_constructible<
          _Tp, typename add_lvalue_reference<const _Tp>::type> {};
# 2961 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default")))
is_trivially_move_constructible
    : public is_trivially_constructible<
          _Tp, typename add_rvalue_reference<_Tp>::type> {};
# 2975 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp, class _Arg>
struct is_trivially_assignable
    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)> {};
# 3013 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default")))
is_trivially_copy_assignable
    : public is_trivially_assignable<
          typename add_lvalue_reference<_Tp>::type,
          typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {
};
# 3025 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default")))
is_trivially_move_assignable
    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,
                                     typename add_rvalue_reference<_Tp>::type> {
};
# 3040 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_trivially_destructible
    : public integral_constant<bool, __is_trivially_destructible(_Tp)> {};
# 3072 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp, class... _Args>
struct __attribute__((__type_visibility__("default"))) is_nothrow_constructible
    : public integral_constant<bool,
                               __is_nothrow_constructible(_Tp, _Args...)> {};
# 3124 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default")))
is_nothrow_default_constructible : public is_nothrow_constructible<_Tp> {};
# 3136 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default")))
is_nothrow_copy_constructible
    : public is_nothrow_constructible<
          _Tp,
          typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {
};
# 3148 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default")))
is_nothrow_move_constructible
    : public is_nothrow_constructible<
          _Tp, typename add_rvalue_reference<_Tp>::type> {};
# 3162 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp, class _Arg>
struct __attribute__((__type_visibility__("default"))) is_nothrow_assignable
    : public integral_constant<bool, __is_nothrow_assignable(_Tp, _Arg)> {};
# 3198 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default")))
is_nothrow_copy_assignable
    : public is_nothrow_assignable<
          typename add_lvalue_reference<_Tp>::type,
          typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {
};
# 3210 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default")))
is_nothrow_move_assignable
    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,
                                   typename add_rvalue_reference<_Tp>::type> {};
# 3225 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <bool, class _Tp> struct __libcpp_is_nothrow_destructible;

template <class _Tp>
struct __libcpp_is_nothrow_destructible<false, _Tp> : public false_type {};

template <class _Tp>
struct __libcpp_is_nothrow_destructible<true, _Tp>
    : public integral_constant<bool,
                               noexcept(std::__1::declval<_Tp>().~_Tp())> {};

template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_nothrow_destructible
    : public __libcpp_is_nothrow_destructible<is_destructible<_Tp>::value,
                                              _Tp> {};

template <class _Tp, size_t _Ns>
struct __attribute__((__type_visibility__("default")))
is_nothrow_destructible<_Tp[_Ns]> : public is_nothrow_destructible<_Tp> {};

template <class _Tp>
struct __attribute__((__type_visibility__("default")))
is_nothrow_destructible<_Tp &> : public true_type {};

template <class _Tp>
struct __attribute__((__type_visibility__("default")))
is_nothrow_destructible<_Tp &&> : public true_type {};
# 3288 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_pod
    : public integral_constant<bool, __is_pod(_Tp)> {};
# 3309 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)> {};
# 3321 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_standard_layout

    : public integral_constant<bool, __is_standard_layout(_Tp)>

{};
# 3337 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_trivially_copyable

    : public integral_constant<bool, __is_trivially_copyable(_Tp)>

{};
# 3355 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_trivial

    : public integral_constant<bool, __is_trivial(_Tp)>

{};

template <class _Tp> struct __is_reference_wrapper_impl : public false_type {};
template <class _Tp>
struct __is_reference_wrapper_impl<reference_wrapper<_Tp>> : public true_type {
};
template <class _Tp>
struct __is_reference_wrapper
    : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {};

template <class _Fp, class _A0, class _DecayFp = typename decay<_Fp>::type,
          class _DecayA0 = typename decay<_A0>::type,
          class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet1 =
    typename enable_if<is_member_function_pointer<_DecayFp>::value &&
                       is_base_of<_ClassT, _DecayA0>::value>::type;

template <class _Fp, class _A0, class _DecayFp = typename decay<_Fp>::type,
          class _DecayA0 = typename decay<_A0>::type>
using __enable_if_bullet2 =
    typename enable_if<is_member_function_pointer<_DecayFp>::value &&
                       __is_reference_wrapper<_DecayA0>::value>::type;

template <class _Fp, class _A0, class _DecayFp = typename decay<_Fp>::type,
          class _DecayA0 = typename decay<_A0>::type,
          class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet3 =
    typename enable_if<is_member_function_pointer<_DecayFp>::value &&
                       !is_base_of<_ClassT, _DecayA0>::value &&
                       !__is_reference_wrapper<_DecayA0>::value>::type;

template <class _Fp, class _A0, class _DecayFp = typename decay<_Fp>::type,
          class _DecayA0 = typename decay<_A0>::type,
          class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet4 =
    typename enable_if<is_member_object_pointer<_DecayFp>::value &&
                       is_base_of<_ClassT, _DecayA0>::value>::type;

template <class _Fp, class _A0, class _DecayFp = typename decay<_Fp>::type,
          class _DecayA0 = typename decay<_A0>::type>
using __enable_if_bullet5 =
    typename enable_if<is_member_object_pointer<_DecayFp>::value &&
                       __is_reference_wrapper<_DecayA0>::value>::type;

template <class _Fp, class _A0, class _DecayFp = typename decay<_Fp>::type,
          class _DecayA0 = typename decay<_A0>::type,
          class _ClassT = typename __member_pointer_class_type<_DecayFp>::type>
using __enable_if_bullet6 =
    typename enable_if<is_member_object_pointer<_DecayFp>::value &&
                       !is_base_of<_ClassT, _DecayA0>::value &&
                       !__is_reference_wrapper<_DecayA0>::value>::type;
# 3445 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class... _Args> auto __invoke(__any, _Args &&...__args) -> __nat;

template <class... _Args>
auto __invoke_constexpr(__any, _Args &&...__args) -> __nat;

template <class _Fp, class _A0, class... _Args,
          class = __enable_if_bullet1<_Fp, _A0>>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) auto
__invoke(_Fp &&__f, _A0 &&__a0, _Args &&...__args) noexcept(noexcept(
    (std::__1::forward<_A0>(__a0).*__f)(std::__1::forward<_Args>(__args)...)))
    -> decltype((std::__1::forward<_A0>(__a0).*
                 __f)(std::__1::forward<_Args>(__args)...)) {
  return (std::__1::forward<_A0>(__a0).*
          __f)(std::__1::forward<_Args>(__args)...);
}

template <class _Fp, class _A0, class... _Args,
          class = __enable_if_bullet1<_Fp, _A0>>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr auto
__invoke_constexpr(_Fp &&__f, _A0 &&__a0, _Args &&...__args) noexcept(noexcept(
    (std::__1::forward<_A0>(__a0).*__f)(std::__1::forward<_Args>(__args)...)))
    -> decltype((std::__1::forward<_A0>(__a0).*
                 __f)(std::__1::forward<_Args>(__args)...)) {
  return (std::__1::forward<_A0>(__a0).*
          __f)(std::__1::forward<_Args>(__args)...);
}

template <class _Fp, class _A0, class... _Args,
          class = __enable_if_bullet2<_Fp, _A0>>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) auto
__invoke(_Fp &&__f, _A0 &&__a0, _Args &&...__args) noexcept(
    noexcept((__a0.get().*__f)(std::__1::forward<_Args>(__args)...)))
    -> decltype((__a0.get().*__f)(std::__1::forward<_Args>(__args)...)) {
  return (__a0.get().*__f)(std::__1::forward<_Args>(__args)...);
}

template <class _Fp, class _A0, class... _Args,
          class = __enable_if_bullet2<_Fp, _A0>>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr auto
__invoke_constexpr(_Fp &&__f, _A0 &&__a0, _Args &&...__args) noexcept(
    noexcept((__a0.get().*__f)(std::__1::forward<_Args>(__args)...)))
    -> decltype((__a0.get().*__f)(std::__1::forward<_Args>(__args)...)) {
  return (__a0.get().*__f)(std::__1::forward<_Args>(__args)...);
}

template <class _Fp, class _A0, class... _Args,
          class = __enable_if_bullet3<_Fp, _A0>>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) auto
__invoke(_Fp &&__f, _A0 &&__a0, _Args &&...__args) noexcept(noexcept((
    (*std::__1::forward<_A0>(__a0)).*__f)(std::__1::forward<_Args>(__args)...)))
    -> decltype(((*std::__1::forward<_A0>(__a0)).*
                 __f)(std::__1::forward<_Args>(__args)...)) {
  return ((*std::__1::forward<_A0>(__a0)).*
          __f)(std::__1::forward<_Args>(__args)...);
}

template <class _Fp, class _A0, class... _Args,
          class = __enable_if_bullet3<_Fp, _A0>>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr auto
__invoke_constexpr(_Fp &&__f, _A0 &&__a0, _Args &&...__args) noexcept(noexcept((
    (*std::__1::forward<_A0>(__a0)).*__f)(std::__1::forward<_Args>(__args)...)))
    -> decltype(((*std::__1::forward<_A0>(__a0)).*
                 __f)(std::__1::forward<_Args>(__args)...)) {
  return ((*std::__1::forward<_A0>(__a0)).*
          __f)(std::__1::forward<_Args>(__args)...);
}

template <class _Fp, class _A0, class = __enable_if_bullet4<_Fp, _A0>>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) auto
__invoke(_Fp &&__f,
         _A0 &&__a0) noexcept(noexcept(std::__1::forward<_A0>(__a0).*__f))
    -> decltype(std::__1::forward<_A0>(__a0).*__f) {
  return std::__1::forward<_A0>(__a0).*__f;
}

template <class _Fp, class _A0, class = __enable_if_bullet4<_Fp, _A0>>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr auto
__invoke_constexpr(_Fp &&__f,
                   _A0 &&__a0) noexcept(noexcept(std::__1::forward<_A0>(__a0).*
                                                 __f))
    -> decltype(std::__1::forward<_A0>(__a0).*__f) {
  return std::__1::forward<_A0>(__a0).*__f;
}

template <class _Fp, class _A0, class = __enable_if_bullet5<_Fp, _A0>>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) auto
__invoke(_Fp &&__f, _A0 &&__a0) noexcept(noexcept(__a0.get().*__f))
    -> decltype(__a0.get().*__f) {
  return __a0.get().*__f;
}

template <class _Fp, class _A0, class = __enable_if_bullet5<_Fp, _A0>>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr auto
__invoke_constexpr(_Fp &&__f, _A0 &&__a0) noexcept(noexcept(__a0.get().*__f))
    -> decltype(__a0.get().*__f) {
  return __a0.get().*__f;
}

template <class _Fp, class _A0, class = __enable_if_bullet6<_Fp, _A0>>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) auto
__invoke(_Fp &&__f,
         _A0 &&__a0) noexcept(noexcept((*std::__1::forward<_A0>(__a0)).*__f))
    -> decltype((*std::__1::forward<_A0>(__a0)).*__f) {
  return (*std::__1::forward<_A0>(__a0)).*__f;
}

template <class _Fp, class _A0, class = __enable_if_bullet6<_Fp, _A0>>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr auto
__invoke_constexpr(_Fp &&__f, _A0 &&__a0) noexcept(
    noexcept((*std::__1::forward<_A0>(__a0)).*__f))
    -> decltype((*std::__1::forward<_A0>(__a0)).*__f) {
  return (*std::__1::forward<_A0>(__a0)).*__f;
}

template <class _Fp, class... _Args>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) auto
__invoke(_Fp &&__f, _Args &&...__args) noexcept(
    noexcept(std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...)))
    -> decltype(
        std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...)) {
  return std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...);
}

template <class _Fp, class... _Args>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr auto
__invoke_constexpr(_Fp &&__f, _Args &&...__args) noexcept(
    noexcept(std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...)))
    -> decltype(
        std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...)) {
  return std::__1::forward<_Fp>(__f)(std::__1::forward<_Args>(__args)...);
}

template <class _Ret, class _Fp, class... _Args> struct __invokable_r {
  template <class _XFp, class... _XArgs>
  static auto __try_call(int)
      -> decltype(std::__1::__invoke(std::__1::declval<_XFp>(),
                                     std::__1::declval<_XArgs>()...));
  template <class _XFp, class... _XArgs> static __nat __try_call(...);

  using _Result = decltype(__try_call<_Fp, _Args...>(0));

  using type = typename conditional<
      _IsNotSame<_Result, __nat>::value,
      typename conditional<is_void<_Ret>::value, true_type,
                           is_convertible<_Result, _Ret>>::type,
      false_type>::type;
  static const bool value = type::value;
};
template <class _Fp, class... _Args>
using __invokable = __invokable_r<void, _Fp, _Args...>;

template <bool _IsInvokable, bool _IsCVVoid, class _Ret, class _Fp,
          class... _Args>
struct __nothrow_invokable_r_imp {
  static const bool value = false;
};

template <class _Ret, class _Fp, class... _Args>
struct __nothrow_invokable_r_imp<true, false, _Ret, _Fp, _Args...> {
  typedef __nothrow_invokable_r_imp _ThisT;

  template <class _Tp> static void __test_noexcept(_Tp) noexcept;

  static const bool value =
      noexcept(_ThisT::__test_noexcept<_Ret>(std::__1::__invoke(
          std::__1::declval<_Fp>(), std::__1::declval<_Args>()...)));
};

template <class _Ret, class _Fp, class... _Args>
struct __nothrow_invokable_r_imp<true, true, _Ret, _Fp, _Args...> {
  static const bool value = noexcept(std::__1::__invoke(
      std::__1::declval<_Fp>(), std::__1::declval<_Args>()...));
};

template <class _Ret, class _Fp, class... _Args>
using __nothrow_invokable_r =
    __nothrow_invokable_r_imp<__invokable_r<_Ret, _Fp, _Args...>::value,
                              is_void<_Ret>::value, _Ret, _Fp, _Args...>;

template <class _Fp, class... _Args>
using __nothrow_invokable =
    __nothrow_invokable_r_imp<__invokable<_Fp, _Args...>::value, true, void,
                              _Fp, _Args...>;

template <class _Fp, class... _Args>
struct __invoke_of
    : public enable_if<__invokable<_Fp, _Args...>::value,
                       typename __invokable_r<void, _Fp, _Args...>::_Result> {};

template <class _Fp, class... _Args>
class __attribute__((__type_visibility__("default")))
result_of<_Fp(_Args...)> : public __invoke_of<_Fp, _Args...> {};

template <class _Tp> using result_of_t = typename result_of<_Tp>::type;
# 3696 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __is_swappable;
template <class _Tp> struct __is_nothrow_swappable;

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _ForwardIterator2
swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
            _ForwardIterator2 __first2);

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))

typename enable_if<is_move_constructible<_Tp>::value &&
                   is_move_assignable<_Tp>::value>::type

swap(_Tp &__x, _Tp &__y) noexcept(is_nothrow_move_constructible<_Tp>::value
                                      &&is_nothrow_move_assignable<_Tp>::value)

{
  _Tp __t(std::__1::move(__x));
  __x = std::__1::move(__y);
  __y = std::__1::move(__t);
}

template <class _Tp, size_t _Np>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename enable_if<__is_swappable<_Tp>::value>::type
swap(_Tp (&__a)[_Np],
     _Tp (&__b)[_Np]) noexcept(__is_nothrow_swappable<_Tp>::value) {
  std::__1::swap_ranges(__a, __a + _Np, __b);
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _ForwardIterator2
swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
            _ForwardIterator2 __first2) {
  for (; __first1 != __last1; ++__first1, (void)++__first2)
    swap(*__first1, *__first2);
  return __first2;
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)

    noexcept(noexcept(swap(*std::__1::declval<_ForwardIterator1>(),
                           *std::__1::declval<_ForwardIterator2>())))

{
  swap(*__a, *__b);
}

namespace __detail {

template <class _Tp, class _Up = _Tp,
          bool _NotVoid = !is_void<_Tp>::value && !is_void<_Up>::value>
struct __swappable_with {
  template <class _LHS, class _RHS>
  static decltype(swap(std::__1::declval<_LHS>(), std::__1::declval<_RHS>()))
  __test_swap(int);
  template <class, class> static __nat __test_swap(long);

  typedef decltype((__test_swap<_Tp, _Up>(0))) __swap1;
  typedef decltype((__test_swap<_Up, _Tp>(0))) __swap2;

  static const bool value =
      _IsNotSame<__swap1, __nat>::value && _IsNotSame<__swap2, __nat>::value;
};

template <class _Tp, class _Up>
struct __swappable_with<_Tp, _Up, false> : false_type {};

template <class _Tp, class _Up = _Tp,
          bool _Swappable = __swappable_with<_Tp, _Up>::value>
struct __nothrow_swappable_with {
  static const bool value =

      noexcept(swap(std::__1::declval<_Tp>(), std::__1::declval<_Up>()))
          &&noexcept(swap(std::__1::declval<_Up>(), std::__1::declval<_Tp>()));
};

template <class _Tp, class _Up>
struct __nothrow_swappable_with<_Tp, _Up, false> : false_type {};

} // namespace __detail

template <class _Tp>
struct __is_swappable
    : public integral_constant<bool, __detail::__swappable_with<_Tp &>::value> {
};

template <class _Tp>
struct __is_nothrow_swappable
    : public integral_constant<
          bool, __detail::__nothrow_swappable_with<_Tp &>::value> {};
# 3870 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp, bool = is_enum<_Tp>::value> struct __underlying_type_impl;

template <class _Tp> struct __underlying_type_impl<_Tp, false> {};

template <class _Tp> struct __underlying_type_impl<_Tp, true> {
  typedef __underlying_type(_Tp) type;
};

template <class _Tp>
struct underlying_type : __underlying_type_impl<_Tp, is_enum<_Tp>::value> {};

template <class _Tp>
using underlying_type_t = typename underlying_type<_Tp>::type;

template <class _Tp, bool = is_enum<_Tp>::value>
struct __sfinae_underlying_type {
  typedef typename underlying_type<_Tp>::type type;
  typedef decltype(((type)1) + 0) __promoted_type;
};

template <class _Tp> struct __sfinae_underlying_type<_Tp, false> {};

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr int
__convert_to_integral(int __val) {
  return __val;
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr unsigned
__convert_to_integral(unsigned __val) {
  return __val;
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr long
__convert_to_integral(long __val) {
  return __val;
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr unsigned long
__convert_to_integral(unsigned long __val) {
  return __val;
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr long long
__convert_to_integral(long long __val) {
  return __val;
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr unsigned long long
__convert_to_integral(unsigned long long __val) {
  return __val;
}

template <typename _Fp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr
    typename enable_if<is_floating_point<_Fp>::value, long long>::type
    __convert_to_integral(_Fp __val) {
  return __val;
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr __int128_t
__convert_to_integral(__int128_t __val) {
  return __val;
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr __uint128_t
__convert_to_integral(__uint128_t __val) {
  return __val;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr
    typename __sfinae_underlying_type<_Tp>::__promoted_type
    __convert_to_integral(_Tp __val) {
  return __val;
}

template <class _Tp> struct __has_operator_addressof_member_imp {
  template <class _Up>
  static auto __test(int) ->
      typename __select_2nd<decltype(std::__1::declval<_Up>().operator&()),
                            true_type>::type;
  template <class> static auto __test(long) -> false_type;

  static const bool value = decltype(__test<_Tp>(0))::value;
};

template <class _Tp> struct __has_operator_addressof_free_imp {
  template <class _Up>
  static auto __test(int) ->
      typename __select_2nd<decltype(operator&(std::__1::declval<_Up>())),
                            true_type>::type;
  template <class> static auto __test(long) -> false_type;

  static const bool value = decltype(__test<_Tp>(0))::value;
};

template <class _Tp>
struct __has_operator_addressof
    : public integral_constant<
          bool, __has_operator_addressof_member_imp<_Tp>::value ||
                    __has_operator_addressof_free_imp<_Tp>::value> {};
# 3994 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
struct __extract_key_fail_tag {};
struct __extract_key_self_tag {};
struct __extract_key_first_tag {};

template <class _ValTy, class _Key,
          class _RawValTy = typename __unconstref<_ValTy>::type>
struct __can_extract_key
    : conditional<_IsSame<_RawValTy, _Key>::value, __extract_key_self_tag,
                  __extract_key_fail_tag>::type {};

template <class _Pair, class _Key, class _First, class _Second>
struct __can_extract_key<_Pair, _Key, pair<_First, _Second>>
    : conditional<_IsSame<typename remove_const<_First>::type, _Key>::value,
                  __extract_key_first_tag, __extract_key_fail_tag>::type {};

template <class _ValTy, class _Key, class _ContainerValueTy,
          class _RawValTy = typename __unconstref<_ValTy>::type>
struct __can_extract_map_key
    : integral_constant<bool, _IsSame<_RawValTy, _Key>::value> {};

template <class _ValTy, class _Key, class _RawValTy>
struct __can_extract_map_key<_ValTy, _Key, _Key, _RawValTy> : false_type {};
# 4033 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
inline constexpr bool __libcpp_is_constant_evaluated() noexcept {
  return __builtin_is_constant_evaluated();
}

template <class _CharT>
using _IsCharLikeType = _And<is_standard_layout<_CharT>, is_trivial<_CharT>>;

} // namespace __1
} // namespace std
# 46 "/usr/local/include/QtCore/qglobal.h" 2

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 1 3
# 198 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 199 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 2 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__tuple" 1 3
# 13 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__tuple" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 14 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__tuple" 2 3
# 19 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__tuple" 3

namespace std {
inline namespace __1 {

template <class _Tp>
struct __attribute__((__type_visibility__("default"))) tuple_size;

template <class _Tp, class...> using __enable_if_tuple_size_imp = _Tp;

template <class _Tp>
struct __attribute__((__type_visibility__("default")))
tuple_size<__enable_if_tuple_size_imp<
    const _Tp, typename enable_if<!is_volatile<_Tp>::value>::type,
    integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>
    : public integral_constant<size_t, tuple_size<_Tp>::value> {};

template <class _Tp>
struct __attribute__((__type_visibility__("default")))
tuple_size<__enable_if_tuple_size_imp<
    volatile _Tp, typename enable_if<!is_const<_Tp>::value>::type,
    integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>
    : public integral_constant<size_t, tuple_size<_Tp>::value> {};

template <class _Tp>
struct __attribute__((__type_visibility__("default")))
tuple_size<__enable_if_tuple_size_imp<
    const volatile _Tp, integral_constant<size_t, sizeof(tuple_size<_Tp>)>>>
    : public integral_constant<size_t, tuple_size<_Tp>::value> {};

template <size_t _Ip, class _Tp>
struct __attribute__((__type_visibility__("default"))) tuple_element;

template <size_t _Ip, class _Tp>
struct __attribute__((__type_visibility__("default")))
tuple_element<_Ip, const _Tp> {
  typedef typename add_const<typename tuple_element<_Ip, _Tp>::type>::type type;
};

template <size_t _Ip, class _Tp>
struct __attribute__((__type_visibility__("default")))
tuple_element<_Ip, volatile _Tp> {
  typedef
      typename add_volatile<typename tuple_element<_Ip, _Tp>::type>::type type;
};

template <size_t _Ip, class _Tp>
struct __attribute__((__type_visibility__("default")))
tuple_element<_Ip, const volatile _Tp> {
  typedef typename add_cv<typename tuple_element<_Ip, _Tp>::type>::type type;
};

template <class _Tp> struct __tuple_like : false_type {};

template <class _Tp>
struct __tuple_like<const _Tp> : public __tuple_like<_Tp> {};
template <class _Tp>
struct __tuple_like<volatile _Tp> : public __tuple_like<_Tp> {};
template <class _Tp>
struct __tuple_like<const volatile _Tp> : public __tuple_like<_Tp> {};

template <size_t...> struct __tuple_indices {};

template <class _IdxType, _IdxType... _Values> struct __integer_sequence {
  template <template <class _OIdxType, _OIdxType...> class _ToIndexSeq,
            class _ToIndexType>
  using __convert = _ToIndexSeq<_ToIndexType, _Values...>;

  template <size_t _Sp>
  using __to_tuple_indices = __tuple_indices<(_Values + _Sp)...>;
};
# 140 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__tuple" 3
template <size_t _Ep, size_t _Sp>
using __make_indices_imp =
    typename __make_integer_seq<__integer_sequence, size_t,
                                _Ep - _Sp>::template __to_tuple_indices<_Sp>;

template <size_t _Ep, size_t _Sp = 0> struct __make_tuple_indices {
  static_assert(_Sp <= _Ep, "__make_tuple_indices input error");
  typedef __make_indices_imp<_Ep, _Sp> type;
};

template <class... _Tp>
class __attribute__((__type_visibility__("default"))) tuple;

template <class... _Tp> struct __tuple_like<tuple<_Tp...>> : true_type {};

template <class... _Tp>
struct __attribute__((__type_visibility__("default")))
tuple_size<tuple<_Tp...>> : public integral_constant<size_t, sizeof...(_Tp)> {};

template <size_t _Ip, class... _Tp>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr
    typename tuple_element<_Ip, tuple<_Tp...>>::type &
    get(tuple<_Tp...> &) noexcept;

template <size_t _Ip, class... _Tp>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr const typename tuple_element<
    _Ip, tuple<_Tp...>>::type &
get(const tuple<_Tp...> &) noexcept;

template <size_t _Ip, class... _Tp>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr
    typename tuple_element<_Ip, tuple<_Tp...>>::type &&
    get(tuple<_Tp...> &&) noexcept;

template <size_t _Ip, class... _Tp>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr const typename tuple_element<
    _Ip, tuple<_Tp...>>::type &&
get(const tuple<_Tp...> &&) noexcept;

template <class _T1, class _T2>
struct __tuple_like<pair<_T1, _T2>> : true_type {};

template <size_t _Ip, class _T1, class _T2>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr
    typename tuple_element<_Ip, pair<_T1, _T2>>::type &
    get(pair<_T1, _T2> &) noexcept;

template <size_t _Ip, class _T1, class _T2>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr const typename tuple_element<
    _Ip, pair<_T1, _T2>>::type &
get(const pair<_T1, _T2> &) noexcept;

template <size_t _Ip, class _T1, class _T2>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr
    typename tuple_element<_Ip, pair<_T1, _T2>>::type &&
    get(pair<_T1, _T2> &&) noexcept;

template <size_t _Ip, class _T1, class _T2>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr const typename tuple_element<
    _Ip, pair<_T1, _T2>>::type &&
get(const pair<_T1, _T2> &&) noexcept;

template <class _Tp, size_t _Size>
struct __attribute__((__type_visibility__("default"))) array;

template <class _Tp, size_t _Size>
struct __tuple_like<array<_Tp, _Size>> : true_type {};

template <size_t _Ip, class _Tp, size_t _Size>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr _Tp &
get(array<_Tp, _Size> &) noexcept;

template <size_t _Ip, class _Tp, size_t _Size>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr const _Tp &
get(const array<_Tp, _Size> &) noexcept;

template <size_t _Ip, class _Tp, size_t _Size>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr _Tp &&
get(array<_Tp, _Size> &&) noexcept;

template <size_t _Ip, class _Tp, size_t _Size>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr const _Tp &&
get(const array<_Tp, _Size> &&) noexcept;

template <class... _Tp> struct __tuple_types {};
# 280 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__tuple" 3
template <size_t _Ip, class... _Types>
struct __attribute__((__type_visibility__("default")))
tuple_element<_Ip, __tuple_types<_Types...>> {
  static_assert(_Ip < sizeof...(_Types), "tuple_element index out of range");
  typedef __type_pack_element<_Ip, _Types...> type;
};

template <class... _Tp>
struct __attribute__((__type_visibility__("default")))
tuple_size<__tuple_types<_Tp...>>
    : public integral_constant<size_t, sizeof...(_Tp)> {};

template <class... _Tp>
struct __tuple_like<__tuple_types<_Tp...>> : true_type {};

template <bool _ApplyLV, bool _ApplyConst, bool _ApplyVolatile>
struct __apply_cv_mf;
template <> struct __apply_cv_mf<false, false, false> {
  template <class _Tp> using __apply = _Tp;
};
template <> struct __apply_cv_mf<false, true, false> {
  template <class _Tp> using __apply = const _Tp;
};
template <> struct __apply_cv_mf<false, false, true> {
  template <class _Tp> using __apply = volatile _Tp;
};
template <> struct __apply_cv_mf<false, true, true> {
  template <class _Tp> using __apply = const volatile _Tp;
};
template <> struct __apply_cv_mf<true, false, false> {
  template <class _Tp> using __apply = _Tp &;
};
template <> struct __apply_cv_mf<true, true, false> {
  template <class _Tp> using __apply = const _Tp &;
};
template <> struct __apply_cv_mf<true, false, true> {
  template <class _Tp> using __apply = volatile _Tp &;
};
template <> struct __apply_cv_mf<true, true, true> {
  template <class _Tp> using __apply = const volatile _Tp &;
};
template <class _Tp, class _RawTp = typename remove_reference<_Tp>::type>
using __apply_cv_t =
    __apply_cv_mf<is_lvalue_reference<_Tp>::value, is_const<_RawTp>::value,
                  is_volatile<_RawTp>::value>;
# 343 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__tuple" 3
template <class _TupleTypes, class _TupleIndices>
struct __make_tuple_types_flat;

template <template <class...> class _Tuple, class... _Types, size_t... _Idx>
struct __make_tuple_types_flat<_Tuple<_Types...>, __tuple_indices<_Idx...>> {

  template <class _Tp, class _ApplyFn = __apply_cv_t<_Tp>>
  using __apply_quals = __tuple_types<typename _ApplyFn::template __apply<
      __type_pack_element<_Idx, _Types...>>...>;
};

template <class _Vt, size_t _Np, size_t... _Idx>
struct __make_tuple_types_flat<array<_Vt, _Np>, __tuple_indices<_Idx...>> {
  template <size_t> using __value_type = _Vt;
  template <class _Tp, class _ApplyFn = __apply_cv_t<_Tp>>
  using __apply_quals =
      __tuple_types<typename _ApplyFn::template __apply<__value_type<_Idx>>...>;
};

template <class _Tp,
          size_t _Ep = tuple_size<typename remove_reference<_Tp>::type>::value,
          size_t _Sp = 0,
          bool _SameSize =
              (_Ep == tuple_size<typename remove_reference<_Tp>::type>::value)>
struct __make_tuple_types {
  static_assert(_Sp <= _Ep, "__make_tuple_types input error");
  using _RawTp = typename remove_cv<typename remove_reference<_Tp>::type>::type;
  using _Maker =
      __make_tuple_types_flat<_RawTp,
                              typename __make_tuple_indices<_Ep, _Sp>::type>;
  using type = typename _Maker::template __apply_quals<_Tp>;
};

template <class... _Types, size_t _Ep>
struct __make_tuple_types<tuple<_Types...>, _Ep, 0, true> {
  typedef __tuple_types<_Types...> type;
};

template <class... _Types, size_t _Ep>
struct __make_tuple_types<__tuple_types<_Types...>, _Ep, 0, true> {
  typedef __tuple_types<_Types...> type;
};

template <bool... _Preds> struct __all_dummy;

template <bool... _Pred>
using __all =
    _IsSame<__all_dummy<_Pred...>, __all_dummy<((void)_Pred, true)...>>;

struct __tuple_sfinae_base {
  template <template <class, class...> class _Trait, class... _LArgs,
            class... _RArgs>
  static auto __do_test(__tuple_types<_LArgs...>, __tuple_types<_RArgs...>)
      -> __all<typename enable_if<_Trait<_LArgs, _RArgs>::value, bool>::type{
          true}...>;
  template <template <class...> class> static auto __do_test(...) -> false_type;

  template <class _FromArgs, class _ToArgs>
  using __constructible =
      decltype(__do_test<is_constructible>(_ToArgs{}, _FromArgs{}));
  template <class _FromArgs, class _ToArgs>
  using __convertible =
      decltype(__do_test<is_convertible>(_FromArgs{}, _ToArgs{}));
  template <class _FromArgs, class _ToArgs>
  using __assignable =
      decltype(__do_test<is_assignable>(_ToArgs{}, _FromArgs{}));
};

template <class _Tp, class _Up,
          bool = __tuple_like<typename remove_reference<_Tp>::type>::value,
          bool = __tuple_like<_Up>::value>
struct __tuple_convertible : public false_type {};

template <class _Tp, class _Up>
struct __tuple_convertible<_Tp, _Up, true, true>
    : public __tuple_sfinae_base::__convertible<
          typename __make_tuple_types<_Tp>::type,
          typename __make_tuple_types<_Up>::type> {};

template <class _Tp, class _Up,
          bool = __tuple_like<typename remove_reference<_Tp>::type>::value,
          bool = __tuple_like<_Up>::value>
struct __tuple_constructible : public false_type {};

template <class _Tp, class _Up>
struct __tuple_constructible<_Tp, _Up, true, true>
    : public __tuple_sfinae_base::__constructible<
          typename __make_tuple_types<_Tp>::type,
          typename __make_tuple_types<_Up>::type> {};

template <class _Tp, class _Up,
          bool = __tuple_like<typename remove_reference<_Tp>::type>::value,
          bool = __tuple_like<_Up>::value>
struct __tuple_assignable : public false_type {};

template <class _Tp, class _Up>
struct __tuple_assignable<_Tp, _Up, true, true>
    : public __tuple_sfinae_base::__assignable<
          typename __make_tuple_types<_Tp>::type,
          typename __make_tuple_types<_Up &>::type> {};

template <size_t _Ip, class... _Tp>
struct __attribute__((__type_visibility__("default")))
tuple_element<_Ip, tuple<_Tp...>> {
  typedef typename tuple_element<_Ip, __tuple_types<_Tp...>>::type type;
};

template <size_t _Ip, class... _Tp>
using tuple_element_t = typename tuple_element<_Ip, _Tp...>::type;

template <bool _IsTuple, class _SizeTrait, size_t _Expected>
struct __tuple_like_with_size_imp : false_type {};

template <class _SizeTrait, size_t _Expected>
struct __tuple_like_with_size_imp<true, _SizeTrait, _Expected>
    : integral_constant<bool, _SizeTrait::value == _Expected> {};

template <class _Tuple, size_t _ExpectedSize,
          class _RawTuple = typename __uncvref<_Tuple>::type>
using __tuple_like_with_size =
    __tuple_like_with_size_imp<__tuple_like<_RawTuple>::value,
                               tuple_size<_RawTuple>, _ExpectedSize>;

struct __attribute__((__visibility__("default")))
__check_tuple_constructor_fail {

  static constexpr bool __enable_explicit_default() { return false; }
  static constexpr bool __enable_implicit_default() { return false; }
  template <class...> static constexpr bool __enable_explicit() {
    return false;
  }
  template <class...> static constexpr bool __enable_implicit() {
    return false;
  }
  template <class...> static constexpr bool __enable_assign() { return false; }
};
# 549 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__tuple" 3
} // namespace __1
} // namespace std
# 200 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 2 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/initializer_list" 1 3
# 45 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/initializer_list" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 46 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/initializer_list" 2 3
# 50 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/initializer_list" 3

namespace std {

template <class _Ep>
class __attribute__((__type_visibility__("default"))) initializer_list {
  const _Ep *__begin_;
  size_t __size_;

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr initializer_list(
      const _Ep *__b, size_t __s) noexcept
      : __begin_(__b), __size_(__s) {}

public:
  typedef _Ep value_type;
  typedef const _Ep &reference;
  typedef const _Ep &const_reference;
  typedef size_t size_type;

  typedef const _Ep *iterator;
  typedef const _Ep *const_iterator;

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr initializer_list() noexcept
      : __begin_(nullptr), __size_(0) {}

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr size_t
  size() const noexcept {
    return __size_;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr const _Ep *
  begin() const noexcept {
    return __begin_;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr const _Ep *
  end() const noexcept {
    return __begin_ + __size_;
  }
};

template <class _Ep>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr const _Ep *
begin(initializer_list<_Ep> __il) noexcept {
  return __il.begin();
}

template <class _Ep>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr const _Ep *
end(initializer_list<_Ep> __il) noexcept {
  return __il.end();
}

} // namespace std
# 202 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 2 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstring" 1 3
# 59 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstring" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 60 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstring" 2 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string.h" 1 3
# 54 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string.h" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 55 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string.h" 2 3
# 58 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string.h" 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/string.h" 1 3 4
# 61 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/string.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_types.h" 1 3 4
# 27 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_types.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types.h" 1 3 4
# 32 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 1 3 4
# 630 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_symbol_aliasing.h" 1 3 4
# 631 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 2 3 4
# 696 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_posix_availability.h" 1 3 4
# 697 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/cdefs.h" 2 3 4
# 33 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/machine/_types.h" 1 3 4
# 32 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/machine/_types.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/_types.h" 1 3 4
# 37 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/_types.h" 3 4
typedef signed char __int8_t;

typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long long __int64_t;
typedef unsigned long long __uint64_t;

typedef long __darwin_intptr_t;
typedef unsigned int __darwin_natural_t;
# 70 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/_types.h" 3 4
typedef int __darwin_ct_rune_t;

typedef union {
  char __mbstate8[128];
  long long _mbstateL;
} __mbstate_t;

typedef __mbstate_t __darwin_mbstate_t;

typedef long int __darwin_ptrdiff_t;

typedef long unsigned int __darwin_size_t;

typedef __builtin_va_list __darwin_va_list;

typedef int __darwin_wchar_t;

typedef __darwin_wchar_t __darwin_rune_t;

typedef int __darwin_wint_t;

typedef unsigned long __darwin_clock_t;
typedef __uint32_t __darwin_socklen_t;
typedef long __darwin_ssize_t;
typedef long __darwin_time_t;
# 33 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/machine/_types.h" 2 3 4
# 34 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types.h" 2 3 4
# 55 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types.h" 3 4
typedef __int64_t __darwin_blkcnt_t;
typedef __int32_t __darwin_blksize_t;
typedef __int32_t __darwin_dev_t;
typedef unsigned int __darwin_fsblkcnt_t;
typedef unsigned int __darwin_fsfilcnt_t;
typedef __uint32_t __darwin_gid_t;
typedef __uint32_t __darwin_id_t;
typedef __uint64_t __darwin_ino64_t;

typedef __darwin_ino64_t __darwin_ino_t;

typedef __darwin_natural_t __darwin_mach_port_name_t;
typedef __darwin_mach_port_name_t __darwin_mach_port_t;
typedef __uint16_t __darwin_mode_t;
typedef __int64_t __darwin_off_t;
typedef __int32_t __darwin_pid_t;
typedef __uint32_t __darwin_sigset_t;
typedef __int32_t __darwin_suseconds_t;
typedef __uint32_t __darwin_uid_t;
typedef __uint32_t __darwin_useconds_t;
typedef unsigned char __darwin_uuid_t[16];
typedef char __darwin_uuid_string_t[37];

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_types.h" 1 3 4
# 57 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_types.h" 3 4
struct __darwin_pthread_handler_rec {
  void (*__routine)(void *);
  void *__arg;
  struct __darwin_pthread_handler_rec *__next;
};

struct _opaque_pthread_attr_t {
  long __sig;
  char __opaque[56];
};

struct _opaque_pthread_cond_t {
  long __sig;
  char __opaque[40];
};

struct _opaque_pthread_condattr_t {
  long __sig;
  char __opaque[8];
};

struct _opaque_pthread_mutex_t {
  long __sig;
  char __opaque[56];
};

struct _opaque_pthread_mutexattr_t {
  long __sig;
  char __opaque[8];
};

struct _opaque_pthread_once_t {
  long __sig;
  char __opaque[8];
};

struct _opaque_pthread_rwlock_t {
  long __sig;
  char __opaque[192];
};

struct _opaque_pthread_rwlockattr_t {
  long __sig;
  char __opaque[16];
};

struct _opaque_pthread_t {
  long __sig;
  struct __darwin_pthread_handler_rec *__cleanup_stack;
  char __opaque[8176];
};

typedef struct _opaque_pthread_attr_t __darwin_pthread_attr_t;
typedef struct _opaque_pthread_cond_t __darwin_pthread_cond_t;
typedef struct _opaque_pthread_condattr_t __darwin_pthread_condattr_t;
typedef unsigned long __darwin_pthread_key_t;
typedef struct _opaque_pthread_mutex_t __darwin_pthread_mutex_t;
typedef struct _opaque_pthread_mutexattr_t __darwin_pthread_mutexattr_t;
typedef struct _opaque_pthread_once_t __darwin_pthread_once_t;
typedef struct _opaque_pthread_rwlock_t __darwin_pthread_rwlock_t;
typedef struct _opaque_pthread_rwlockattr_t __darwin_pthread_rwlockattr_t;
typedef struct _opaque_pthread_t *__darwin_pthread_t;
# 81 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types.h" 2 3 4
# 28 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_types.h" 2 3 4
# 40 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_types.h" 3 4
typedef int __darwin_nl_item;
typedef int __darwin_wctrans_t;

typedef __uint32_t __darwin_wctype_t;
# 62 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/string.h" 2 3 4

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/Availability.h" 1 3 4
# 259 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/Availability.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/AvailabilityInternal.h" 1 3 4
# 260 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/Availability.h" 2 3 4
# 64 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/string.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_size_t.h" 1 3 4
# 65 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/string.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_null.h" 1 3 4
# 66 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/string.h" 2 3 4

extern "C" {
void *memchr(const void *__s, int __c, size_t __n);
int memcmp(const void *__s1, const void *__s2, size_t __n);
void *memcpy(void *__dst, const void *__src, size_t __n);
void *memmove(void *__dst, const void *__src, size_t __len);
void *memset(void *__b, int __c, size_t __len);
char *strcat(char *__s1, const char *__s2);
char *strchr(const char *__s, int __c);
int strcmp(const char *__s1, const char *__s2);
int strcoll(const char *__s1, const char *__s2);
char *strcpy(char *__dst, const char *__src);
size_t strcspn(const char *__s, const char *__charset);
char *strerror(int __errnum) __asm("_"
                                   "strerror");
size_t strlen(const char *__s);
char *strncat(char *__s1, const char *__s2, size_t __n);
int strncmp(const char *__s1, const char *__s2, size_t __n);
char *strncpy(char *__dst, const char *__src, size_t __n);
char *strpbrk(const char *__s, const char *__charset);
char *strrchr(const char *__s, int __c);
size_t strspn(const char *__s, const char *__charset);
char *strstr(const char *__big, const char *__little);
char *strtok(char *__str, const char *__sep);
size_t strxfrm(char *__s1, const char *__s2, size_t __n);
}
# 103 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/string.h" 3 4
extern "C" {
char *strtok_r(char *__str, const char *__sep, char **__lasts);
}
# 115 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/string.h" 3 4
extern "C" {
int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen);
char *strdup(const char *__s1);
void *memccpy(void *__dst, const void *__src, int __c, size_t __n);
}
# 129 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/string.h" 3 4
extern "C" {
char *stpcpy(char *__dst, const char *__src);
char *stpncpy(char *__dst, const char *__src, size_t __n)
    __attribute__((availability(macosx, introduced = 10.7)));
char *strndup(const char *__s1, size_t __n)
    __attribute__((availability(macosx, introduced = 10.7)));
size_t strnlen(const char *__s1, size_t __n)
    __attribute__((availability(macosx, introduced = 10.7)));
char *strsignal(int __sig);
}
# 152 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/string.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_ssize_t.h" 1 3 4
# 30 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_ssize_t.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/machine/types.h" 1 3 4
# 35 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/machine/types.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/types.h" 1 3 4
# 76 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/types.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_int8_t.h" 1 3 4
# 30 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_int8_t.h" 3 4
typedef signed char int8_t;
# 77 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/types.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_int16_t.h" 1 3 4
# 30 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_int16_t.h" 3 4
typedef short int16_t;
# 78 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/types.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_int32_t.h" 1 3 4
# 30 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_int32_t.h" 3 4
typedef int int32_t;
# 79 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/types.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_int64_t.h" 1 3 4
# 30 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_int64_t.h" 3 4
typedef long long int64_t;
# 80 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/types.h" 2 3 4

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int8_t.h" 1 3 4
# 30 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int8_t.h" 3 4
typedef unsigned char u_int8_t;
# 82 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/types.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int16_t.h" 1 3 4
# 30 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int16_t.h" 3 4
typedef unsigned short u_int16_t;
# 83 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/types.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int32_t.h" 1 3 4
# 30 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int32_t.h" 3 4
typedef unsigned int u_int32_t;
# 84 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/types.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int64_t.h" 1 3 4
# 30 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int64_t.h" 3 4
typedef unsigned long long u_int64_t;
# 85 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/types.h" 2 3 4

typedef int64_t register_t;

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_intptr_t.h" 1 3 4
# 30 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_intptr_t.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/machine/types.h" 1 3 4
# 31 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_intptr_t.h" 2 3 4

typedef __darwin_intptr_t intptr_t;
# 93 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/types.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_uintptr_t.h" 1 3 4
# 30 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_uintptr_t.h" 3 4
typedef unsigned long uintptr_t;
# 94 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/types.h" 2 3 4

typedef u_int64_t user_addr_t;
typedef u_int64_t user_size_t;
typedef int64_t user_ssize_t;
typedef int64_t user_long_t;
typedef u_int64_t user_ulong_t;
typedef int64_t user_time_t;
typedef int64_t user_off_t;

typedef u_int64_t syscall_arg_t;
# 36 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/machine/types.h" 2 3 4
# 31 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_ssize_t.h" 2 3 4
typedef __darwin_ssize_t ssize_t;
# 153 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/string.h" 2 3 4

extern "C" {
void *memmem(const void *__big, size_t __big_len, const void *__little,
             size_t __little_len)
    __attribute__((availability(macosx, introduced = 10.7)));
void memset_pattern4(void *__b, const void *__pattern4, size_t __len)
    __attribute__((availability(macosx, introduced = 10.5)));
void memset_pattern8(void *__b, const void *__pattern8, size_t __len)
    __attribute__((availability(macosx, introduced = 10.5)));
void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
    __attribute__((availability(macosx, introduced = 10.5)));

char *strcasestr(const char *__big, const char *__little);
char *strnstr(const char *__big, const char *__little, size_t __len);
size_t strlcat(char *__dst, const char *__source, size_t __size);
size_t strlcpy(char *__dst, const char *__source, size_t __size);
void strmode(int __mode, char *__bp);
char *strsep(char **__stringp, const char *__delim);

void swab(const void *, void *, ssize_t);

__attribute__((availability(macosx, introduced = 10.12.1)))
__attribute__((availability(ios, introduced = 10.1)))
__attribute__((availability(tvos, introduced = 10.0.1)))
__attribute__((availability(watchos, introduced = 3.1))) int
timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len);
}

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/strings.h" 1 3 4
# 65 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/strings.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_size_t.h" 1 3 4
# 66 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/strings.h" 2 3 4

extern "C" {

int bcmp(const void *, const void *, size_t);
void bcopy(const void *, void *, size_t);
void bzero(void *, size_t);
char *index(const char *, int);
char *rindex(const char *, int);

int ffs(int);
int strcasecmp(const char *, const char *);
int strncasecmp(const char *, const char *, size_t);
}

extern "C" {
int ffsl(long) __attribute__((availability(macosx, introduced = 10.5)));
int ffsll(long long) __attribute__((availability(macosx, introduced = 10.9)));
int fls(int) __attribute__((availability(macosx, introduced = 10.5)));
int flsl(long) __attribute__((availability(macosx, introduced = 10.5)));
int flsll(long long) __attribute__((availability(macosx, introduced = 10.9)));
}

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string.h" 1 3 4
# 93 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/strings.h" 2 3 4
# 181 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/string.h" 2 3 4
# 61 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string.h" 2 3
# 71 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string.h" 3
extern "C++" {
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) char *
__libcpp_strchr(const char *__s, int __c) {
  return (char *)strchr(__s, __c);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) __attribute__((__enable_if__(true, "")))
const char *
strchr(const char *__s, int __c) {
  return __libcpp_strchr(__s, __c);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
__attribute__((__enable_if__(true, ""))) char *
strchr(char *__s, int __c) {
  return __libcpp_strchr(__s, __c);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) char *
__libcpp_strpbrk(const char *__s1, const char *__s2) {
  return (char *)strpbrk(__s1, __s2);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) __attribute__((__enable_if__(true, "")))
const char *
strpbrk(const char *__s1, const char *__s2) {
  return __libcpp_strpbrk(__s1, __s2);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
__attribute__((__enable_if__(true, ""))) char *
strpbrk(char *__s1, const char *__s2) {
  return __libcpp_strpbrk(__s1, __s2);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) char *
__libcpp_strrchr(const char *__s, int __c) {
  return (char *)strrchr(__s, __c);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) __attribute__((__enable_if__(true, "")))
const char *
strrchr(const char *__s, int __c) {
  return __libcpp_strrchr(__s, __c);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
__attribute__((__enable_if__(true, ""))) char *
strrchr(char *__s, int __c) {
  return __libcpp_strrchr(__s, __c);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void *
__libcpp_memchr(const void *__s, int __c, size_t __n) {
  return (void *)memchr(__s, __c, __n);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) __attribute__((__enable_if__(true, "")))
const void *
memchr(const void *__s, int __c, size_t __n) {
  return __libcpp_memchr(__s, __c, __n);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
__attribute__((__enable_if__(true, ""))) void *
memchr(void *__s, int __c, size_t __n) {
  return __libcpp_memchr(__s, __c, __n);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) char *
__libcpp_strstr(const char *__s1, const char *__s2) {
  return (char *)strstr(__s1, __s2);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) __attribute__((__enable_if__(true, "")))
const char *
strstr(const char *__s1, const char *__s2) {
  return __libcpp_strstr(__s1, __s2);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
__attribute__((__enable_if__(true, ""))) char *
strstr(char *__s1, const char *__s2) {
  return __libcpp_strstr(__s1, __s2);
}
}
# 61 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstring" 2 3
# 64 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstring" 3

namespace std {
inline namespace __1 {

using ::memchr;
using ::memcmp;
using ::memcpy;
using ::memmove;
using ::size_t;
using ::strcat;
using ::strchr;
using ::strcmp;
using ::strcoll;
using ::strcpy;
using ::strcspn;
using ::strncat;
using ::strncmp;
using ::strncpy;
using ::strpbrk;
using ::strrchr;
using ::strspn;
using ::strstr;
using ::strxfrm;

using ::strtok;

using ::memset;
using ::strerror;
using ::strlen;

} // namespace __1
} // namespace std
# 204 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 2 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdint" 1 3
# 143 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdint" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 144 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdint" 2 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/stdint.h" 1 3
# 106 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/stdint.h" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 107 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/stdint.h" 2 3
# 110 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/stdint.h" 3
# 123 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/stdint.h" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/12.0.0/include/stdint.h" 1 3
# 52 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/12.0.0/include/stdint.h" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/stdint.h" 1 3 4
# 23 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/stdint.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_types/_uint8_t.h" 1 3 4
# 31 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_types/_uint8_t.h" 3 4
typedef unsigned char uint8_t;
# 24 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/stdint.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_types/_uint16_t.h" 1 3 4
# 31 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_types/_uint16_t.h" 3 4
typedef unsigned short uint16_t;
# 25 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/stdint.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_types/_uint32_t.h" 1 3 4
# 31 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_types/_uint32_t.h" 3 4
typedef unsigned int uint32_t;
# 26 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/stdint.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_types/_uint64_t.h" 1 3 4
# 31 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_types/_uint64_t.h" 3 4
typedef unsigned long long uint64_t;
# 27 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/stdint.h" 2 3 4

typedef int8_t int_least8_t;
typedef int16_t int_least16_t;
typedef int32_t int_least32_t;
typedef int64_t int_least64_t;
typedef uint8_t uint_least8_t;
typedef uint16_t uint_least16_t;
typedef uint32_t uint_least32_t;
typedef uint64_t uint_least64_t;

typedef int8_t int_fast8_t;
typedef int16_t int_fast16_t;
typedef int32_t int_fast32_t;
typedef int64_t int_fast64_t;
typedef uint8_t uint_fast8_t;
typedef uint16_t uint_fast16_t;
typedef uint32_t uint_fast32_t;
typedef uint64_t uint_fast64_t;
# 58 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/stdint.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_types/_intmax_t.h" 1 3 4
# 32 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_types/_intmax_t.h" 3 4
typedef long int intmax_t;
# 59 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/stdint.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_types/_uintmax_t.h" 1 3 4
# 32 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_types/_uintmax_t.h" 3 4
typedef long unsigned int uintmax_t;
# 60 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/stdint.h" 2 3 4
# 53 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/12.0.0/include/stdint.h" 2 3
# 124 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/stdint.h" 2 3
# 145 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdint" 2 3
# 148 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdint" 3

namespace std {
inline namespace __1 {

using ::int16_t;
using ::int32_t;
using ::int64_t;
using ::int8_t;

using ::uint16_t;
using ::uint32_t;
using ::uint64_t;
using ::uint8_t;

using ::int_least16_t;
using ::int_least32_t;
using ::int_least64_t;
using ::int_least8_t;

using ::uint_least16_t;
using ::uint_least32_t;
using ::uint_least64_t;
using ::uint_least8_t;

using ::int_fast16_t;
using ::int_fast32_t;
using ::int_fast64_t;
using ::int_fast8_t;

using ::uint_fast16_t;
using ::uint_fast32_t;
using ::uint_fast64_t;
using ::uint_fast8_t;

using ::intptr_t;
using ::uintptr_t;

using ::intmax_t;
using ::uintmax_t;

} // namespace __1
} // namespace std
# 205 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 2 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__debug" 1 3
# 13 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__debug" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 14 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__debug" 2 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iosfwd" 1 3
# 94 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iosfwd" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 95 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iosfwd" 2 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/wchar.h" 1 3
# 108 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/wchar.h" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 109 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/wchar.h" 2 3
# 112 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/wchar.h" 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/wchar.h" 1 3 4
# 74 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/wchar.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_null.h" 1 3 4
# 75 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/wchar.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_size_t.h" 1 3 4
# 76 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/wchar.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_mbstate_t.h" 1 3 4
# 32 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_mbstate_t.h" 3 4
typedef __darwin_mbstate_t mbstate_t;
# 77 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/wchar.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_ct_rune_t.h" 1 3 4
# 32 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_ct_rune_t.h" 3 4
typedef __darwin_ct_rune_t ct_rune_t;
# 78 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/wchar.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_rune_t.h" 1 3 4
# 31 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_rune_t.h" 3 4
typedef __darwin_rune_t rune_t;
# 79 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/wchar.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_wchar_t.h" 1 3 4
# 80 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/wchar.h" 2 3 4
# 89 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/wchar.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/12.0.0/include/stdarg.h" 1 3 4
# 14 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/12.0.0/include/stdarg.h" 3 4
typedef __builtin_va_list va_list;
# 32 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/12.0.0/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 90 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/wchar.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/stdio.h" 1 3 4
# 101 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/stdio.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3 4
# 102 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/stdio.h" 2 3 4
# 105 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/stdio.h" 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/stdio.h" 1 3 4
# 64 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/stdio.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_stdio.h" 1 3 4
# 75 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_stdio.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_va_list.h" 1 3 4
# 32 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_va_list.h" 3 4
typedef __darwin_va_list va_list;
# 76 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_stdio.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_size_t.h" 1 3 4
# 77 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_stdio.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_null.h" 1 3 4
# 78 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_stdio.h" 2 3 4

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/stdio.h" 1 3 4
# 37 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/stdio.h" 3 4
extern "C" {

int renameat(int, const char *, int, const char *)
    __attribute__((availability(macosx, introduced = 10.10)));

int renamex_np(const char *, const char *, unsigned int)
    __attribute__((availability(macosx, introduced = 10.12)))
    __attribute__((availability(ios, introduced = 10.0)))
    __attribute__((availability(tvos, introduced = 10.0)))
    __attribute__((availability(watchos, introduced = 3.0)));
int renameatx_np(int, const char *, int, const char *, unsigned int)
    __attribute__((availability(macosx, introduced = 10.12)))
    __attribute__((availability(ios, introduced = 10.0)))
    __attribute__((availability(tvos, introduced = 10.0)))
    __attribute__((availability(watchos, introduced = 3.0)));
}
# 80 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_stdio.h" 2 3 4

typedef __darwin_off_t fpos_t;
# 92 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_stdio.h" 3 4
struct __sbuf {
  unsigned char *_base;
  int _size;
};

struct __sFILEX;
# 126 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_stdio.h" 3 4
typedef struct __sFILE {
  unsigned char *_p;
  int _r;
  int _w;
  short _flags;
  short _file;
  struct __sbuf _bf;
  int _lbfsize;

  void *_cookie;
  int (*_Nullable _close)(void *);
  int (*_Nullable _read)(void *, char *, int);
  fpos_t (*_Nullable _seek)(void *, fpos_t, int);
  int (*_Nullable _write)(void *, const char *, int);

  struct __sbuf _ub;
  struct __sFILEX *_extra;
  int _ur;

  unsigned char _ubuf[3];
  unsigned char _nbuf[1];

  struct __sbuf _lb;

  int _blksize;
  fpos_t _offset;
} FILE;
# 65 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/stdio.h" 2 3 4

extern "C" {
extern FILE *__stdinp;
extern FILE *__stdoutp;
extern FILE *__stderrp;
}
# 141 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/stdio.h" 3 4
extern "C" {
void clearerr(FILE *);
int fclose(FILE *);
int feof(FILE *);
int ferror(FILE *);
int fflush(FILE *);
int fgetc(FILE *);
int fgetpos(FILE *, fpos_t *);
char *fgets(char *, int, FILE *);

FILE *fopen(const char *__filename, const char *__mode) __asm("_"
                                                              "fopen");

int fprintf(FILE *, const char *, ...)
    __attribute__((__format__(__printf__, 2, 3)));
int fputc(int, FILE *);
int fputs(const char *, FILE *) __asm("_"
                                      "fputs");
size_t fread(void *__ptr, size_t __size, size_t __nitems, FILE *__stream);
FILE *freopen(const char *, const char *, FILE *) __asm("_"
                                                        "freopen");
int fscanf(FILE *, const char *, ...)
    __attribute__((__format__(__scanf__, 2, 3)));
int fseek(FILE *, long, int);
int fsetpos(FILE *, const fpos_t *);
long ftell(FILE *);
size_t fwrite(const void *__ptr, size_t __size, size_t __nitems,
              FILE *__stream) __asm("_"
                                    "fwrite");
int getc(FILE *);
int getchar(void);
char *gets(char *);
void perror(const char *) __attribute__((__cold__));
int printf(const char *, ...) __attribute__((__format__(__printf__, 1, 2)));
int putc(int, FILE *);
int putchar(int);
int puts(const char *);
int remove(const char *);
int rename(const char *__old, const char *__new);
void rewind(FILE *);
int scanf(const char *, ...) __attribute__((__format__(__scanf__, 1, 2)));
void setbuf(FILE *, char *);
int setvbuf(FILE *, char *, int, size_t);
int sprintf(char *, const char *, ...)
    __attribute__((__format__(__printf__, 2, 3)))
    __attribute__((__availability__(swift, unavailable,
                                    message = "Use snprintf instead.")));
int sscanf(const char *, const char *, ...)
    __attribute__((__format__(__scanf__, 2, 3)));
FILE *tmpfile(void);

__attribute__((__availability__(swift, unavailable,
                                message = "Use mkstemp(3) instead.")))

__attribute__((__deprecated__(
    "This function is provided for compatibility reasons only.  Due to "
    "security concerns inherent in the design of tmpnam(3), it is highly "
    "recommended that you use mkstemp(3) instead.")))

char *
tmpnam(char *);
int ungetc(int, FILE *);
int vfprintf(FILE *, const char *, va_list)
    __attribute__((__format__(__printf__, 2, 0)));
int vprintf(const char *, va_list)
    __attribute__((__format__(__printf__, 1, 0)));
int vsprintf(char *, const char *, va_list)
    __attribute__((__format__(__printf__, 2, 0)))
    __attribute__((__availability__(swift, unavailable,
                                    message = "Use vsnprintf instead.")));
}
# 204 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/stdio.h" 3 4
extern "C" {

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_ctermid.h" 1 3 4
# 26 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_ctermid.h" 3 4
char *ctermid(char *);
# 206 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/stdio.h" 2 3 4

FILE *fdopen(int, const char *) __asm("_"
                                      "fdopen");

int fileno(FILE *);
}
# 227 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/stdio.h" 3 4
extern "C" {
int pclose(FILE *) __attribute__((__availability__(
    swift, unavailable, message = "Use posix_spawn APIs or NSTask instead.")));

FILE *popen(const char *, const char *) __asm("_"
                                              "popen")
    __attribute__((
        __availability__(swift, unavailable,
                         message = "Use posix_spawn APIs or NSTask instead.")));
}
# 248 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/stdio.h" 3 4
extern "C" {
int __srget(FILE *);
int __svfscanf(FILE *, const char *, va_list)
    __attribute__((__format__(__scanf__, 2, 0)));
int __swbuf(int, FILE *);
}

inline __attribute__((__always_inline__)) int __sputc(int _c, FILE *_p) {
  if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
    return (*_p->_p++ = _c);
  else
    return (__swbuf(_c, _p));
}
# 285 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/stdio.h" 3 4
extern "C" {
void flockfile(FILE *);
int ftrylockfile(FILE *);
void funlockfile(FILE *);
int getc_unlocked(FILE *);
int getchar_unlocked(void);
int putc_unlocked(int, FILE *);
int putchar_unlocked(int);

int getw(FILE *);
int putw(int, FILE *);

__attribute__((__availability__(swift, unavailable,
                                message = "Use mkstemp(3) instead.")))

__attribute__((__deprecated__(
    "This function is provided for compatibility reasons only.  Due to "
    "security concerns inherent in the design of tempnam(3), it is highly "
    "recommended that you use mkstemp(3) instead.")))

char *
tempnam(const char *__dir, const char *__prefix) __asm("_"
                                                       "tempnam");
}
# 324 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/stdio.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_off_t.h" 1 3 4
# 31 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_off_t.h" 3 4
typedef __darwin_off_t off_t;
# 325 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/stdio.h" 2 3 4

extern "C" {
int fseeko(FILE *__stream, off_t __offset, int __whence);
off_t ftello(FILE *__stream);
}

extern "C" {
int snprintf(char *__str, size_t __size, const char *__format, ...)
    __attribute__((__format__(__printf__, 3, 4)));
int vfscanf(FILE *__stream, const char *__format, va_list)
    __attribute__((__format__(__scanf__, 2, 0)));
int vscanf(const char *__format, va_list)
    __attribute__((__format__(__scanf__, 1, 0)));
int vsnprintf(char *__str, size_t __size, const char *__format, va_list)
    __attribute__((__format__(__printf__, 3, 0)));
int vsscanf(const char *__str, const char *__format, va_list)
    __attribute__((__format__(__scanf__, 2, 0)));
}
# 351 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/stdio.h" 3 4
extern "C" {
int dprintf(int, const char *, ...)
    __attribute__((__format__(__printf__, 2, 3)))
    __attribute__((availability(macosx, introduced = 10.7)));
int vdprintf(int, const char *, va_list)
    __attribute__((__format__(__printf__, 2, 0)))
    __attribute__((availability(macosx, introduced = 10.7)));
ssize_t getdelim(char **__linep, size_t *__linecapp, int __delimiter,
                 FILE *__stream)
    __attribute__((availability(macosx, introduced = 10.7)));
ssize_t getline(char **__linep, size_t *__linecapp, FILE *__stream)
    __attribute__((availability(macosx, introduced = 10.7)));
FILE *fmemopen(void *__buf, size_t __size, const char *__mode)
    __attribute__((availability(macos, introduced = 10.13)))
    __attribute__((availability(ios, introduced = 11.0)))
    __attribute__((availability(tvos, introduced = 11.0)))
    __attribute__((availability(watchos, introduced = 4.0)));
FILE *open_memstream(char **__bufp, size_t *__sizep)
    __attribute__((availability(macos, introduced = 10.13)))
    __attribute__((availability(ios, introduced = 11.0)))
    __attribute__((availability(tvos, introduced = 11.0)))
    __attribute__((availability(watchos, introduced = 4.0)));
}

extern "C" {
extern const int sys_nerr;
extern const char *const sys_errlist[];

int asprintf(char **, const char *, ...)
    __attribute__((__format__(__printf__, 2, 3)));
char *ctermid_r(char *);
char *fgetln(FILE *, size_t *);
const char *fmtcheck(const char *, const char *);
int fpurge(FILE *);
void setbuffer(FILE *, char *, int);
int setlinebuf(FILE *);
int vasprintf(char **, const char *, va_list)
    __attribute__((__format__(__printf__, 2, 0)));
FILE *zopen(const char *, const char *, int);

FILE *funopen(const void *, int (*_Nullable)(void *, char *, int),
              int (*_Nullable)(void *, const char *, int),
              fpos_t (*_Nullable)(void *, fpos_t, int),
              int (*_Nullable)(void *));
}
# 108 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/stdio.h" 2 3
# 91 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/wchar.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/time.h" 1 3 4
# 69 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/time.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_clock_t.h" 1 3 4
# 31 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_clock_t.h" 3 4
typedef __darwin_clock_t clock_t;
# 70 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/time.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_null.h" 1 3 4
# 71 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/time.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_size_t.h" 1 3 4
# 72 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/time.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_time_t.h" 1 3 4
# 31 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_time_t.h" 3 4
typedef __darwin_time_t time_t;
# 73 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/time.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_timespec.h" 1 3 4
# 33 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_timespec.h" 3 4
struct timespec {
  __darwin_time_t tv_sec;
  long tv_nsec;
};
# 74 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/time.h" 2 3 4

struct tm {
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;
  long tm_gmtoff;
  char *tm_zone;
};
# 98 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/time.h" 3 4
extern char *tzname[];

extern int getdate_err;

extern long timezone __asm("_"
                           "timezone");

extern int daylight;

extern "C" {
char *asctime(const struct tm *);
clock_t clock(void) __asm("_"
                          "clock");
char *ctime(const time_t *);
double difftime(time_t, time_t);
struct tm *getdate(const char *);
struct tm *gmtime(const time_t *);
struct tm *localtime(const time_t *);
time_t mktime(struct tm *) __asm("_"
                                 "mktime");
size_t strftime(char *, size_t, const char *,
                const struct tm *) __asm("_"
                                         "strftime");
char *strptime(const char *, const char *, struct tm *) __asm("_"
                                                              "strptime");
time_t time(time_t *);

void tzset(void);

char *asctime_r(const struct tm *, char *);
char *ctime_r(const time_t *, char *);
struct tm *gmtime_r(const time_t *, struct tm *);
struct tm *localtime_r(const time_t *, struct tm *);

time_t posix2time(time_t);

void tzsetwall(void);
time_t time2posix(time_t);
time_t timelocal(struct tm *const);
time_t timegm(struct tm *const);

int nanosleep(const struct timespec *__rqtp,
              struct timespec *__rmtp) __asm("_"
                                             "nanosleep");
# 153 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/time.h" 3 4
typedef enum {
  _CLOCK_REALTIME __attribute__((availability(macosx, introduced = 10.12)))
  __attribute__((availability(ios, introduced = 10.0)))
  __attribute__((availability(tvos, introduced = 10.0)))
  __attribute__((availability(watchos, introduced = 3.0))) = 0,

  _CLOCK_MONOTONIC __attribute__((availability(macosx, introduced = 10.12)))
  __attribute__((availability(ios, introduced = 10.0)))
  __attribute__((availability(tvos, introduced = 10.0)))
  __attribute__((availability(watchos, introduced = 3.0))) = 6,

  _CLOCK_MONOTONIC_RAW __attribute__((availability(macosx, introduced = 10.12)))
  __attribute__((availability(ios, introduced = 10.0)))
  __attribute__((availability(tvos, introduced = 10.0)))
  __attribute__((availability(watchos, introduced = 3.0))) = 4,

  _CLOCK_MONOTONIC_RAW_APPROX
  __attribute__((availability(macosx, introduced = 10.12)))
  __attribute__((availability(ios, introduced = 10.0)))
  __attribute__((availability(tvos, introduced = 10.0)))
  __attribute__((availability(watchos, introduced = 3.0))) = 5,

  _CLOCK_UPTIME_RAW __attribute__((availability(macosx, introduced = 10.12)))
  __attribute__((availability(ios, introduced = 10.0)))
  __attribute__((availability(tvos, introduced = 10.0)))
  __attribute__((availability(watchos, introduced = 3.0))) = 8,

  _CLOCK_UPTIME_RAW_APPROX
  __attribute__((availability(macosx, introduced = 10.12)))
  __attribute__((availability(ios, introduced = 10.0)))
  __attribute__((availability(tvos, introduced = 10.0)))
  __attribute__((availability(watchos, introduced = 3.0))) = 9,

  _CLOCK_PROCESS_CPUTIME_ID
  __attribute__((availability(macosx, introduced = 10.12)))
  __attribute__((availability(ios, introduced = 10.0)))
  __attribute__((availability(tvos, introduced = 10.0)))
  __attribute__((availability(watchos, introduced = 3.0))) = 12,

  _CLOCK_THREAD_CPUTIME_ID
  __attribute__((availability(macosx, introduced = 10.12)))
  __attribute__((availability(ios, introduced = 10.0)))
  __attribute__((availability(tvos, introduced = 10.0)))
  __attribute__((availability(watchos, introduced = 3.0))) = 16

} clockid_t;

__attribute__((availability(macosx, introduced = 10.12)))
__attribute__((availability(ios, introduced = 10.0)))
__attribute__((availability(tvos, introduced = 10.0)))
__attribute__((availability(watchos, introduced = 3.0))) int
clock_getres(clockid_t __clock_id, struct timespec *__res);

__attribute__((availability(macosx, introduced = 10.12)))
__attribute__((availability(ios, introduced = 10.0)))
__attribute__((availability(tvos, introduced = 10.0)))
__attribute__((availability(watchos, introduced = 3.0))) int
clock_gettime(clockid_t __clock_id, struct timespec *__tp);

__attribute__((availability(macosx, introduced = 10.12)))
__attribute__((availability(ios, introduced = 10.0)))
__attribute__((availability(tvos, introduced = 10.0)))
__attribute__((availability(watchos, introduced = 3.0))) __uint64_t
clock_gettime_nsec_np(clockid_t __clock_id);

__attribute__((availability(macosx, introduced = 10.12)))
__attribute__((availability(ios, unavailable)))
__attribute__((availability(tvos, unavailable)))
__attribute__((availability(watchos, unavailable))) int
clock_settime(clockid_t __clock_id, const struct timespec *__tp);
# 202 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/time.h" 3 4
}
# 92 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/wchar.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_wctype.h" 1 3 4
# 42 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_wctype.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/__wctype.h" 1 3 4
# 60 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/__wctype.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_wint_t.h" 1 3 4
# 32 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_wint_t.h" 3 4
typedef __darwin_wint_t wint_t;
# 61 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/__wctype.h" 2 3 4

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_types/_wctype_t.h" 1 3 4
# 32 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_types/_wctype_t.h" 3 4
typedef __darwin_wctype_t wctype_t;
# 63 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/__wctype.h" 2 3 4
# 72 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/__wctype.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ctype.h" 1 3 4
# 32 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ctype.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3 4
# 33 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ctype.h" 2 3 4
# 36 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ctype.h" 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/ctype.h" 1 3 4
# 69 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/ctype.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_ctype.h" 1 3 4
# 70 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_ctype.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/runetype.h" 1 3 4
# 46 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/runetype.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_size_t.h" 1 3 4
# 47 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/runetype.h" 2 3 4

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_wchar_t.h" 1 3 4
# 50 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/runetype.h" 2 3 4
# 60 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/runetype.h" 3 4
typedef struct {
  __darwin_rune_t __min;
  __darwin_rune_t __max;
  __darwin_rune_t __map;
  __uint32_t *__types;
} _RuneEntry;

typedef struct {
  int __nranges;
  _RuneEntry *__ranges;
} _RuneRange;

typedef struct {
  char __name[14];
  __uint32_t __mask;
} _RuneCharClass;

typedef struct {
  char __magic[8];
  char __encoding[32];

  __darwin_rune_t (*__sgetrune)(const char *, __darwin_size_t, char const **);
  int (*__sputrune)(__darwin_rune_t, char *, __darwin_size_t, char **);
  __darwin_rune_t __invalid_rune;

  __uint32_t __runetype[(1 << 8)];
  __darwin_rune_t __maplower[(1 << 8)];
  __darwin_rune_t __mapupper[(1 << 8)];

  _RuneRange __runetype_ext;
  _RuneRange __maplower_ext;
  _RuneRange __mapupper_ext;

  void *__variable;
  int __variable_len;

  int __ncharclasses;
  _RuneCharClass *__charclasses;
} _RuneLocale;

extern "C" {
extern _RuneLocale _DefaultRuneLocale;
extern _RuneLocale *_CurrentRuneLocale;
}
# 71 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_ctype.h" 2 3 4
# 128 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_ctype.h" 3 4
extern "C" {
unsigned long ___runetype(__darwin_ct_rune_t);
__darwin_ct_rune_t ___tolower(__darwin_ct_rune_t);
__darwin_ct_rune_t ___toupper(__darwin_ct_rune_t);
}

inline int isascii(int _c) { return ((_c & ~0x7F) == 0); }
# 147 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_ctype.h" 3 4
extern "C" {
int __maskrune(__darwin_ct_rune_t, unsigned long);
}

inline int __istype(__darwin_ct_rune_t _c, unsigned long _f) {

  return (isascii(_c) ? !!(_DefaultRuneLocale.__runetype[_c] & _f)
                      : !!__maskrune(_c, _f));
}

inline __darwin_ct_rune_t __isctype(__darwin_ct_rune_t _c, unsigned long _f) {

  return (_c < 0 || _c >= (1 << 8))
             ? 0
             : !!(_DefaultRuneLocale.__runetype[_c] & _f);
}
# 187 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_ctype.h" 3 4
extern "C" {
__darwin_ct_rune_t __toupper(__darwin_ct_rune_t);
__darwin_ct_rune_t __tolower(__darwin_ct_rune_t);
}

inline int __wcwidth(__darwin_ct_rune_t _c) {
  unsigned int _x;

  if (_c == 0)
    return (0);
  _x = (unsigned int)__maskrune(_c, 0xe0000000L | 0x00040000L);
  if ((_x & 0xe0000000L) != 0)
    return ((_x & 0xe0000000L) >> 30);
  return ((_x & 0x00040000L) != 0 ? 1 : -1);
}

inline int isalnum(int _c) { return (__istype(_c, 0x00000100L | 0x00000400L)); }

inline int isalpha(int _c) { return (__istype(_c, 0x00000100L)); }

inline int isblank(int _c) { return (__istype(_c, 0x00020000L)); }

inline int iscntrl(int _c) { return (__istype(_c, 0x00000200L)); }

inline int isdigit(int _c) { return (__isctype(_c, 0x00000400L)); }

inline int isgraph(int _c) { return (__istype(_c, 0x00000800L)); }

inline int islower(int _c) { return (__istype(_c, 0x00001000L)); }

inline int isprint(int _c) { return (__istype(_c, 0x00040000L)); }

inline int ispunct(int _c) { return (__istype(_c, 0x00002000L)); }

inline int isspace(int _c) { return (__istype(_c, 0x00004000L)); }

inline int isupper(int _c) { return (__istype(_c, 0x00008000L)); }

inline int isxdigit(int _c) { return (__isctype(_c, 0x00010000L)); }

inline int toascii(int _c) { return (_c & 0x7F); }

inline int tolower(int _c) { return (__tolower(_c)); }

inline int toupper(int _c) { return (__toupper(_c)); }

inline int digittoint(int _c) { return (__maskrune(_c, 0x0F)); }

inline int ishexnumber(int _c) { return (__istype(_c, 0x00010000L)); }

inline int isideogram(int _c) { return (__istype(_c, 0x00080000L)); }

inline int isnumber(int _c) { return (__istype(_c, 0x00000400L)); }

inline int isphonogram(int _c) { return (__istype(_c, 0x00200000L)); }

inline int isrune(int _c) { return (__istype(_c, 0xFFFFFFF0L)); }

inline int isspecial(int _c) { return (__istype(_c, 0x00100000L)); }
# 70 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/ctype.h" 2 3 4
# 39 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ctype.h" 2 3
# 73 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/__wctype.h" 2 3 4
# 43 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_wctype.h" 2 3 4

inline int iswalnum(wint_t _wc) {
  return (__istype(_wc, 0x00000100L | 0x00000400L));
}

inline int iswalpha(wint_t _wc) { return (__istype(_wc, 0x00000100L)); }

inline int iswcntrl(wint_t _wc) { return (__istype(_wc, 0x00000200L)); }

inline int iswctype(wint_t _wc, wctype_t _charclass) {
  return (__istype(_wc, _charclass));
}

inline int iswdigit(wint_t _wc) { return (__isctype(_wc, 0x00000400L)); }

inline int iswgraph(wint_t _wc) { return (__istype(_wc, 0x00000800L)); }

inline int iswlower(wint_t _wc) { return (__istype(_wc, 0x00001000L)); }

inline int iswprint(wint_t _wc) { return (__istype(_wc, 0x00040000L)); }

inline int iswpunct(wint_t _wc) { return (__istype(_wc, 0x00002000L)); }

inline int iswspace(wint_t _wc) { return (__istype(_wc, 0x00004000L)); }

inline int iswupper(wint_t _wc) { return (__istype(_wc, 0x00008000L)); }

inline int iswxdigit(wint_t _wc) { return (__isctype(_wc, 0x00010000L)); }

inline wint_t towlower(wint_t _wc) { return (__tolower(_wc)); }

inline wint_t towupper(wint_t _wc) { return (__toupper(_wc)); }
# 155 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_wctype.h" 3 4
extern "C" {
wctype_t wctype(const char *);
}
# 93 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/wchar.h" 2 3 4

extern "C" {
wint_t btowc(int);
wint_t fgetwc(FILE *);
wchar_t *fgetws(wchar_t *, int, FILE *);
wint_t fputwc(wchar_t, FILE *);
int fputws(const wchar_t *, FILE *);
int fwide(FILE *, int);
int fwprintf(FILE *, const wchar_t *, ...);
int fwscanf(FILE *, const wchar_t *, ...);
wint_t getwc(FILE *);
wint_t getwchar(void);
size_t mbrlen(const char *, size_t, mbstate_t *);
size_t mbrtowc(wchar_t *, const char *, size_t, mbstate_t *);
int mbsinit(const mbstate_t *);
size_t mbsrtowcs(wchar_t *, const char **, size_t, mbstate_t *);
wint_t putwc(wchar_t, FILE *);
wint_t putwchar(wchar_t);
int swprintf(wchar_t *, size_t, const wchar_t *, ...);
int swscanf(const wchar_t *, const wchar_t *, ...);
wint_t ungetwc(wint_t, FILE *);
int vfwprintf(FILE *, const wchar_t *, __darwin_va_list);
int vswprintf(wchar_t *, size_t, const wchar_t *, __darwin_va_list);
int vwprintf(const wchar_t *, __darwin_va_list);
size_t wcrtomb(char *, wchar_t, mbstate_t *);
wchar_t *wcscat(wchar_t *, const wchar_t *);
wchar_t *wcschr(const wchar_t *, wchar_t);
int wcscmp(const wchar_t *, const wchar_t *);
int wcscoll(const wchar_t *, const wchar_t *);
wchar_t *wcscpy(wchar_t *, const wchar_t *);
size_t wcscspn(const wchar_t *, const wchar_t *);
size_t wcsftime(wchar_t *, size_t, const wchar_t *,
                const struct tm *) __asm("_"
                                         "wcsftime");
size_t wcslen(const wchar_t *);
wchar_t *wcsncat(wchar_t *, const wchar_t *, size_t);
int wcsncmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wcsncpy(wchar_t *, const wchar_t *, size_t);
wchar_t *wcspbrk(const wchar_t *, const wchar_t *);
wchar_t *wcsrchr(const wchar_t *, wchar_t);
size_t wcsrtombs(char *, const wchar_t **, size_t, mbstate_t *);
size_t wcsspn(const wchar_t *, const wchar_t *);
wchar_t *wcsstr(const wchar_t *, const wchar_t *);
size_t wcsxfrm(wchar_t *, const wchar_t *, size_t);
int wctob(wint_t);
double wcstod(const wchar_t *, wchar_t **);
wchar_t *wcstok(wchar_t *, const wchar_t *, wchar_t **);
long wcstol(const wchar_t *, wchar_t **, int);
unsigned long wcstoul(const wchar_t *, wchar_t **, int);
wchar_t *wmemchr(const wchar_t *, wchar_t, size_t);
int wmemcmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wmemcpy(wchar_t *, const wchar_t *, size_t);
wchar_t *wmemmove(wchar_t *, const wchar_t *, size_t);
wchar_t *wmemset(wchar_t *, wchar_t, size_t);
int wprintf(const wchar_t *, ...);
int wscanf(const wchar_t *, ...);
int wcswidth(const wchar_t *, size_t);
int wcwidth(wchar_t);
}
# 169 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/wchar.h" 3 4
extern "C" {
int vfwscanf(FILE *, const wchar_t *, __darwin_va_list);
int vswscanf(const wchar_t *, const wchar_t *, __darwin_va_list);
int vwscanf(const wchar_t *, __darwin_va_list);
float wcstof(const wchar_t *, wchar_t **);
long double wcstold(const wchar_t *, wchar_t **);

long long wcstoll(const wchar_t *, wchar_t **, int);
unsigned long long wcstoull(const wchar_t *, wchar_t **, int);
}
# 194 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/wchar.h" 3 4
extern "C" {
size_t mbsnrtowcs(wchar_t *, const char **, size_t, size_t, mbstate_t *);
wchar_t *wcpcpy(wchar_t *, const wchar_t *)
    __attribute__((availability(macosx, introduced = 10.7)));
wchar_t *wcpncpy(wchar_t *, const wchar_t *, size_t)
    __attribute__((availability(macosx, introduced = 10.7)));
wchar_t *wcsdup(const wchar_t *)
    __attribute__((availability(macosx, introduced = 10.7)));
int wcscasecmp(const wchar_t *, const wchar_t *)
    __attribute__((availability(macosx, introduced = 10.7)));
int wcsncasecmp(const wchar_t *, const wchar_t *, size_t n)
    __attribute__((availability(macosx, introduced = 10.7)));
size_t wcsnlen(const wchar_t *, size_t)
    __attribute__((availability(macosx, introduced = 10.7)));
size_t wcsnrtombs(char *, const wchar_t **, size_t, size_t, mbstate_t *);
FILE *open_wmemstream(wchar_t **__bufp, size_t *__sizep)
    __attribute__((availability(macos, introduced = 10.13)))
    __attribute__((availability(ios, introduced = 11.0)))
    __attribute__((availability(tvos, introduced = 11.0)))
    __attribute__((availability(watchos, introduced = 4.0)));
}

extern "C" {
wchar_t *fgetwln(FILE *, size_t *)
    __attribute__((availability(macosx, introduced = 10.7)));
size_t wcslcat(wchar_t *, const wchar_t *, size_t);
size_t wcslcpy(wchar_t *, const wchar_t *, size_t);
}
# 119 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/wchar.h" 2 3
# 134 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/wchar.h" 3
extern "C++" {
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) wchar_t *
__libcpp_wcschr(const wchar_t *__s, wchar_t __c) {
  return (wchar_t *)wcschr(__s, __c);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) __attribute__((__enable_if__(true, "")))
const wchar_t *
wcschr(const wchar_t *__s, wchar_t __c) {
  return __libcpp_wcschr(__s, __c);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) __attribute__((__enable_if__(true, "")))
wchar_t *
wcschr(wchar_t *__s, wchar_t __c) {
  return __libcpp_wcschr(__s, __c);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) wchar_t *
__libcpp_wcspbrk(const wchar_t *__s1, const wchar_t *__s2) {
  return (wchar_t *)wcspbrk(__s1, __s2);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) __attribute__((__enable_if__(true, "")))
const wchar_t *
wcspbrk(const wchar_t *__s1, const wchar_t *__s2) {
  return __libcpp_wcspbrk(__s1, __s2);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) __attribute__((__enable_if__(true, "")))
wchar_t *
wcspbrk(wchar_t *__s1, const wchar_t *__s2) {
  return __libcpp_wcspbrk(__s1, __s2);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) wchar_t *
__libcpp_wcsrchr(const wchar_t *__s, wchar_t __c) {
  return (wchar_t *)wcsrchr(__s, __c);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) __attribute__((__enable_if__(true, "")))
const wchar_t *
wcsrchr(const wchar_t *__s, wchar_t __c) {
  return __libcpp_wcsrchr(__s, __c);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) __attribute__((__enable_if__(true, "")))
wchar_t *
wcsrchr(wchar_t *__s, wchar_t __c) {
  return __libcpp_wcsrchr(__s, __c);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) wchar_t *
__libcpp_wcsstr(const wchar_t *__s1, const wchar_t *__s2) {
  return (wchar_t *)wcsstr(__s1, __s2);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) __attribute__((__enable_if__(true, "")))
const wchar_t *
wcsstr(const wchar_t *__s1, const wchar_t *__s2) {
  return __libcpp_wcsstr(__s1, __s2);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) __attribute__((__enable_if__(true, "")))
wchar_t *
wcsstr(wchar_t *__s1, const wchar_t *__s2) {
  return __libcpp_wcsstr(__s1, __s2);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) wchar_t *
__libcpp_wmemchr(const wchar_t *__s, wchar_t __c, size_t __n) {
  return (wchar_t *)wmemchr(__s, __c, __n);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) __attribute__((__enable_if__(true, "")))
const wchar_t *
wmemchr(const wchar_t *__s, wchar_t __c, size_t __n) {
  return __libcpp_wmemchr(__s, __c, __n);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) __attribute__((__enable_if__(true, "")))
wchar_t *
wmemchr(wchar_t *__s, wchar_t __c, size_t __n) {
  return __libcpp_wmemchr(__s, __c, __n);
}
}
# 96 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iosfwd" 2 3
# 99 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iosfwd" 3

namespace std {
inline namespace __1 {

class __attribute__((__visibility__("default"))) ios_base;

template <class _CharT>
struct __attribute__((__type_visibility__("default"))) char_traits;
template <> struct char_traits<char>;

template <> struct char_traits<char16_t>;
template <> struct char_traits<char32_t>;
template <> struct char_traits<wchar_t>;

template <class _Tp>
class __attribute__((__type_visibility__("default"))) allocator;

template <class _CharT, class _Traits = char_traits<_CharT>>
class __attribute__((__type_visibility__("default"))) basic_ios;

template <class _CharT, class _Traits = char_traits<_CharT>>
class __attribute__((__type_visibility__("default"))) basic_streambuf;
template <class _CharT, class _Traits = char_traits<_CharT>>
class __attribute__((__type_visibility__("default"))) basic_istream;
template <class _CharT, class _Traits = char_traits<_CharT>>
class __attribute__((__type_visibility__("default"))) basic_ostream;
template <class _CharT, class _Traits = char_traits<_CharT>>
class __attribute__((__type_visibility__("default"))) basic_iostream;

template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT>>
class __attribute__((__type_visibility__("default"))) basic_stringbuf;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT>>
class __attribute__((__type_visibility__("default"))) basic_istringstream;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT>>
class __attribute__((__type_visibility__("default"))) basic_ostringstream;
template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT>>
class __attribute__((__type_visibility__("default"))) basic_stringstream;

template <class _CharT, class _Traits = char_traits<_CharT>>
class __attribute__((__type_visibility__("default"))) basic_filebuf;
template <class _CharT, class _Traits = char_traits<_CharT>>
class __attribute__((__type_visibility__("default"))) basic_ifstream;
template <class _CharT, class _Traits = char_traits<_CharT>>
class __attribute__((__type_visibility__("default"))) basic_ofstream;
template <class _CharT, class _Traits = char_traits<_CharT>>
class __attribute__((__type_visibility__("default"))) basic_fstream;

template <class _CharT, class _Traits = char_traits<_CharT>>
class __attribute__((__type_visibility__("default"))) istreambuf_iterator;
template <class _CharT, class _Traits = char_traits<_CharT>>
class __attribute__((__type_visibility__("default"))) ostreambuf_iterator;

typedef basic_ios<char> ios;
typedef basic_ios<wchar_t> wios;

typedef basic_streambuf<char> streambuf;
typedef basic_istream<char> istream;
typedef basic_ostream<char> ostream;
typedef basic_iostream<char> iostream;

typedef basic_stringbuf<char> stringbuf;
typedef basic_istringstream<char> istringstream;
typedef basic_ostringstream<char> ostringstream;
typedef basic_stringstream<char> stringstream;

typedef basic_filebuf<char> filebuf;
typedef basic_ifstream<char> ifstream;
typedef basic_ofstream<char> ofstream;
typedef basic_fstream<char> fstream;

typedef basic_streambuf<wchar_t> wstreambuf;
typedef basic_istream<wchar_t> wistream;
typedef basic_ostream<wchar_t> wostream;
typedef basic_iostream<wchar_t> wiostream;

typedef basic_stringbuf<wchar_t> wstringbuf;
typedef basic_istringstream<wchar_t> wistringstream;
typedef basic_ostringstream<wchar_t> wostringstream;
typedef basic_stringstream<wchar_t> wstringstream;

typedef basic_filebuf<wchar_t> wfilebuf;
typedef basic_ifstream<wchar_t> wifstream;
typedef basic_ofstream<wchar_t> wofstream;
typedef basic_fstream<wchar_t> wfstream;

template <class _State>
class __attribute__((__type_visibility__("default"))) fpos;
typedef fpos<mbstate_t> streampos;
typedef fpos<mbstate_t> wstreampos;

typedef fpos<mbstate_t> u16streampos;
typedef fpos<mbstate_t> u32streampos;

typedef long long streamoff;

template <class _CharT, class _Traits = char_traits<_CharT>,
          class _Allocator = allocator<_CharT>>
class __attribute__((__type_visibility__("default"))) basic_string;
typedef basic_string<char, char_traits<char>, allocator<char>> string;
typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>> wstring;

template <class _Tp, class _Alloc = allocator<_Tp>>
class __attribute__((__type_visibility__("default"))) vector;

} // namespace __1
} // namespace std
# 15 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__debug" 2 3
# 18 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__debug" 3
# 52 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__debug" 3
namespace std {
inline namespace __1 {

struct __attribute__((__type_visibility__("default"))) __libcpp_debug_info {
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr __libcpp_debug_info()
      : __file_(nullptr), __line_(-1), __pred_(nullptr), __msg_(nullptr) {}
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr __libcpp_debug_info(
      const char *__f, int __l, const char *__p, const char *__m)
      : __file_(__f), __line_(__l), __pred_(__p), __msg_(__m) {}

  __attribute__((__visibility__("default"))) std::string what() const;

  const char *__file_;
  int __line_;
  const char *__pred_;
  const char *__msg_;
};

typedef void (*__libcpp_debug_function_type)(__libcpp_debug_info const &);

extern __attribute__((__visibility__("default")))
__libcpp_debug_function_type __libcpp_debug_function;

[[noreturn]] __attribute__((__visibility__("default"))) void
__libcpp_abort_debug_function(__libcpp_debug_info const &);

__attribute__((__visibility__("default"))) bool
__libcpp_set_debug_function(__libcpp_debug_function_type __func);
# 276 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__debug" 3
} // namespace __1
} // namespace std
# 207 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 2 3
# 210 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 3

namespace std {
inline namespace __1 {

namespace rel_ops {

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator!=(const _Tp &__x, const _Tp &__y) {
  return !(__x == __y);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator>(const _Tp &__x, const _Tp &__y) {
  return __y < __x;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator<=(const _Tp &__x, const _Tp &__y) {
  return !(__y < __x);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator>=(const _Tp &__x, const _Tp &__y) {
  return !(__x < __y);
}

} // namespace rel_ops

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr

    typename conditional<!is_nothrow_move_constructible<_Tp>::value &&
                             is_copy_constructible<_Tp>::value,
                         const _Tp &, _Tp &&>::type

    move_if_noexcept(_Tp &__x) noexcept {
  return std::__1::move(__x);
}

struct __attribute__((__type_visibility__("default"))) piecewise_construct_t {
  explicit piecewise_construct_t() = default;
};

constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();
# 296 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 3
template <class _T1, class _T2>
struct __attribute__((__type_visibility__("default"))) pair

{
  typedef _T1 first_type;
  typedef _T2 second_type;

  _T1 first;
  _T2 second;

  pair(pair const &) = default;
  pair(pair &&) = default;
# 333 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 3
  template <bool _Val> using _EnableB = typename enable_if<_Val, bool>::type;

  struct _CheckArgs {
    template <int &...> static constexpr bool __enable_explicit_default() {
      return is_default_constructible<_T1>::value &&
             is_default_constructible<_T2>::value &&
             !__enable_implicit_default<>();
    }

    template <int &...> static constexpr bool __enable_implicit_default() {
      return __is_implicitly_default_constructible<_T1>::value &&
             __is_implicitly_default_constructible<_T2>::value;
    }

    template <class _U1, class _U2> static constexpr bool __enable_explicit() {
      return is_constructible<first_type, _U1>::value &&
             is_constructible<second_type, _U2>::value &&
             (!is_convertible<_U1, first_type>::value ||
              !is_convertible<_U2, second_type>::value);
    }

    template <class _U1, class _U2> static constexpr bool __enable_implicit() {
      return is_constructible<first_type, _U1>::value &&
             is_constructible<second_type, _U2>::value &&
             is_convertible<_U1, first_type>::value &&
             is_convertible<_U2, second_type>::value;
    }
  };

  template <bool _MaybeEnable>
  using _CheckArgsDep =
      typename conditional<_MaybeEnable, _CheckArgs,
                           __check_tuple_constructor_fail>::type;

  struct _CheckTupleLikeConstructor {
    template <class _Tuple> static constexpr bool __enable_implicit() {
      return __tuple_convertible<_Tuple, pair>::value;
    }

    template <class _Tuple> static constexpr bool __enable_explicit() {
      return __tuple_constructible<_Tuple, pair>::value &&
             !__tuple_convertible<_Tuple, pair>::value;
    }

    template <class _Tuple> static constexpr bool __enable_assign() {
      return __tuple_assignable<_Tuple, pair>::value;
    }
  };

  template <class _Tuple>
  using _CheckTLC = typename conditional<
      __tuple_like_with_size<_Tuple, 2>::value &&
          !is_same<typename decay<_Tuple>::type, pair>::value,
      _CheckTupleLikeConstructor, __check_tuple_constructor_fail>::type;

  template <
      bool _Dummy = true,
      _EnableB<_CheckArgsDep<_Dummy>::__enable_explicit_default()> = false>
  explicit __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr pair() noexcept(
      is_nothrow_default_constructible<first_type>::value
          &&is_nothrow_default_constructible<second_type>::value)

      : first(), second() {}

  template <
      bool _Dummy = true,
      _EnableB<_CheckArgsDep<_Dummy>::__enable_implicit_default()> = false>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr pair() noexcept(
      is_nothrow_default_constructible<first_type>::value
          &&is_nothrow_default_constructible<second_type>::value)

      : first(), second() {}

  template <bool _Dummy = true,
            _EnableB<_CheckArgsDep<_Dummy>::template __enable_explicit<
                _T1 const &, _T2 const &>()> = false>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr explicit pair(
      _T1 const &__t1,
      _T2 const
          &__t2) noexcept(is_nothrow_copy_constructible<first_type>::value &&
                              is_nothrow_copy_constructible<second_type>::value)

      : first(__t1), second(__t2) {}

  template <bool _Dummy = true,
            _EnableB<_CheckArgsDep<_Dummy>::template __enable_implicit<
                _T1 const &, _T2 const &>()> = false>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr pair(
      _T1 const &__t1,
      _T2 const
          &__t2) noexcept(is_nothrow_copy_constructible<first_type>::value &&
                              is_nothrow_copy_constructible<second_type>::value)

      : first(__t1), second(__t2) {}

  template <
      class _U1, class _U2,
      _EnableB<_CheckArgs::template __enable_explicit<_U1, _U2>()> = false>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr explicit pair(
      _U1 &&__u1,
      _U2 &&__u2) noexcept((is_nothrow_constructible<first_type, _U1>::value &&
                            is_nothrow_constructible<second_type, _U2>::value))

      : first(std::__1::forward<_U1>(__u1)),
        second(std::__1::forward<_U2>(__u2)) {}

  template <
      class _U1, class _U2,
      _EnableB<_CheckArgs::template __enable_implicit<_U1, _U2>()> = false>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr pair(
      _U1 &&__u1,
      _U2 &&__u2) noexcept((is_nothrow_constructible<first_type, _U1>::value &&
                            is_nothrow_constructible<second_type, _U2>::value))

      : first(std::__1::forward<_U1>(__u1)),
        second(std::__1::forward<_U2>(__u2)) {}

  template <class _U1, class _U2,
            _EnableB<_CheckArgs::template __enable_explicit<
                _U1 const &, _U2 const &>()> = false>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr explicit pair(
      pair<_U1, _U2> const
          &__p) noexcept((is_nothrow_constructible<first_type,
                                                   _U1 const &>::value &&
                          is_nothrow_constructible<second_type,
                                                   _U2 const &>::value))

      : first(__p.first), second(__p.second) {}

  template <class _U1, class _U2,
            _EnableB<_CheckArgs::template __enable_implicit<
                _U1 const &, _U2 const &>()> = false>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr pair(
      pair<_U1, _U2> const
          &__p) noexcept((is_nothrow_constructible<first_type,
                                                   _U1 const &>::value &&
                          is_nothrow_constructible<second_type,
                                                   _U2 const &>::value))

      : first(__p.first), second(__p.second) {}

  template <
      class _U1, class _U2,
      _EnableB<_CheckArgs::template __enable_explicit<_U1, _U2>()> = false>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr explicit pair(
      pair<_U1, _U2> &&
          __p) noexcept((is_nothrow_constructible<first_type, _U1 &&>::value &&
                         is_nothrow_constructible<second_type, _U2 &&>::value))

      : first(std::__1::forward<_U1>(__p.first)),
        second(std::__1::forward<_U2>(__p.second)) {}

  template <
      class _U1, class _U2,
      _EnableB<_CheckArgs::template __enable_implicit<_U1, _U2>()> = false>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr pair(
      pair<_U1, _U2> &&
          __p) noexcept((is_nothrow_constructible<first_type, _U1 &&>::value &&
                         is_nothrow_constructible<second_type, _U2 &&>::value))

      : first(std::__1::forward<_U1>(__p.first)),
        second(std::__1::forward<_U2>(__p.second)) {}

  template <
      class _Tuple,
      _EnableB<_CheckTLC<_Tuple>::template __enable_explicit<_Tuple>()> = false>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr explicit pair(_Tuple &&__p)
      : first(std::__1::get<0>(std::__1::forward<_Tuple>(__p))),
        second(std::__1::get<1>(std::__1::forward<_Tuple>(__p))) {}

  template <
      class _Tuple,
      _EnableB<_CheckTLC<_Tuple>::template __enable_implicit<_Tuple>()> = false>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr pair(_Tuple &&__p)
      : first(std::__1::get<0>(std::__1::forward<_Tuple>(__p))),
        second(std::__1::get<1>(std::__1::forward<_Tuple>(__p))) {}

  template <class... _Args1, class... _Args2>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pair(
      piecewise_construct_t __pc, tuple<_Args1...> __first_args,
      tuple<_Args2...>
          __second_args) noexcept((is_nothrow_constructible<first_type,
                                                            _Args1...>::value &&
                                   is_nothrow_constructible<second_type,
                                                            _Args2...>::value))

      : pair(__pc, __first_args, __second_args,
             typename __make_tuple_indices<sizeof...(_Args1)>::type(),
             typename __make_tuple_indices<sizeof...(_Args2)>::type()) {}

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pair &
  operator=(
      typename conditional<is_copy_assignable<first_type>::value &&
                               is_copy_assignable<second_type>::value,
                           pair, __nat>::type const
          &__p) noexcept(is_nothrow_copy_assignable<first_type>::value
                             &&is_nothrow_copy_assignable<second_type>::value)

  {
    first = __p.first;
    second = __p.second;
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pair &
  operator=(
      typename conditional<is_move_assignable<first_type>::value &&
                               is_move_assignable<second_type>::value,
                           pair, __nat>::type
          &&__p) noexcept(is_nothrow_move_assignable<first_type>::value
                              &&is_nothrow_move_assignable<second_type>::value)

  {
    first = std::__1::forward<first_type>(__p.first);
    second = std::__1::forward<second_type>(__p.second);
    return *this;
  }

  template <
      class _Tuple,
      _EnableB<_CheckTLC<_Tuple>::template __enable_assign<_Tuple>()> = false>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pair &
  operator=(_Tuple &&__p) {
    first = std::__1::get<0>(std::__1::forward<_Tuple>(__p));
    second = std::__1::get<1>(std::__1::forward<_Tuple>(__p));
    return *this;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  swap(pair &__p) noexcept(__is_nothrow_swappable<first_type>::value
                               &&__is_nothrow_swappable<second_type>::value)

  {
    using std::__1::swap;
    swap(first, __p.first);
    swap(second, __p.second);
  }

private:
  template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pair(piecewise_construct_t, tuple<_Args1...> &__first_args,
       tuple<_Args2...> &__second_args, __tuple_indices<_I1...>,
       __tuple_indices<_I2...>);
};

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr bool
operator==(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y) {
  return __x.first == __y.first && __x.second == __y.second;
}

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr bool
operator!=(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y) {
  return !(__x == __y);
}

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr bool
operator<(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y) {
  return __x.first < __y.first ||
         (!(__y.first < __x.first) && __x.second < __y.second);
}

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr bool
operator>(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y) {
  return __y < __x;
}

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr bool
operator>=(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y) {
  return !(__x < __y);
}

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr bool
operator<=(const pair<_T1, _T2> &__x, const pair<_T1, _T2> &__y) {
  return !(__y < __x);
}

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename enable_if<__is_swappable<_T1>::value && __is_swappable<_T2>::value,
                   void>::type
swap(pair<_T1, _T2> &__x,
     pair<_T1, _T2> &__y) noexcept((__is_nothrow_swappable<_T1>::value &&
                                    __is_nothrow_swappable<_T2>::value))

{
  __x.swap(__y);
}

template <class _Tp> struct __unwrap_reference { typedef _Tp type; };

template <class _Tp> struct __unwrap_reference<reference_wrapper<_Tp>> {
  typedef _Tp &type;
};
# 650 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 3
template <class _Tp>
struct __unwrap_ref_decay

    : __unwrap_reference<typename decay<_Tp>::type>

{};

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden"))) __attribute__((
    internal_linkage)) constexpr pair<typename __unwrap_ref_decay<_T1>::type,
                                      typename __unwrap_ref_decay<_T2>::type>
make_pair(_T1 &&__t1, _T2 &&__t2) {
  return pair<typename __unwrap_ref_decay<_T1>::type,
              typename __unwrap_ref_decay<_T2>::type>(
      std::__1::forward<_T1>(__t1), std::__1::forward<_T2>(__t2));
}
# 682 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 3
template <class _T1, class _T2>
struct __attribute__((__type_visibility__("default")))
tuple_size<pair<_T1, _T2>> : public integral_constant<size_t, 2> {};

template <size_t _Ip, class _T1, class _T2>
struct __attribute__((__type_visibility__("default")))
tuple_element<_Ip, pair<_T1, _T2>> {
  static_assert(_Ip < 2,
                "Index out of bounds in std::tuple_element<std::pair<T1, T2>>");
};

template <class _T1, class _T2>
struct __attribute__((__type_visibility__("default")))
tuple_element<0, pair<_T1, _T2>> {
  typedef _T1 type;
};

template <class _T1, class _T2>
struct __attribute__((__type_visibility__("default")))
tuple_element<1, pair<_T1, _T2>> {
  typedef _T2 type;
};

template <size_t _Ip> struct __get_pair;

template <> struct __get_pair<0> {
  template <class _T1, class _T2>
  static __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr _T1 &
  get(pair<_T1, _T2> &__p) noexcept {
    return __p.first;
  }

  template <class _T1, class _T2>
  static __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr const _T1 &
  get(const pair<_T1, _T2> &__p) noexcept {
    return __p.first;
  }

  template <class _T1, class _T2>
  static __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr _T1 &&
  get(pair<_T1, _T2> &&__p) noexcept {
    return std::__1::forward<_T1>(__p.first);
  }

  template <class _T1, class _T2>
  static __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr const _T1 &&
  get(const pair<_T1, _T2> &&__p) noexcept {
    return std::__1::forward<const _T1>(__p.first);
  }
};

template <> struct __get_pair<1> {
  template <class _T1, class _T2>
  static __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr _T2 &
  get(pair<_T1, _T2> &__p) noexcept {
    return __p.second;
  }

  template <class _T1, class _T2>
  static __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr const _T2 &
  get(const pair<_T1, _T2> &__p) noexcept {
    return __p.second;
  }

  template <class _T1, class _T2>
  static __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr _T2 &&
  get(pair<_T1, _T2> &&__p) noexcept {
    return std::__1::forward<_T2>(__p.second);
  }

  template <class _T1, class _T2>
  static __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr const _T2 &&
  get(const pair<_T1, _T2> &&__p) noexcept {
    return std::__1::forward<const _T2>(__p.second);
  }
};

template <size_t _Ip, class _T1, class _T2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr
    typename tuple_element<_Ip, pair<_T1, _T2>>::type &
    get(pair<_T1, _T2> &__p) noexcept {
  return __get_pair<_Ip>::get(__p);
}

template <size_t _Ip, class _T1, class _T2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr const typename tuple_element<
    _Ip, pair<_T1, _T2>>::type &
get(const pair<_T1, _T2> &__p) noexcept {
  return __get_pair<_Ip>::get(__p);
}

template <size_t _Ip, class _T1, class _T2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr
    typename tuple_element<_Ip, pair<_T1, _T2>>::type &&
    get(pair<_T1, _T2> &&__p) noexcept {
  return __get_pair<_Ip>::get(std::__1::move(__p));
}

template <size_t _Ip, class _T1, class _T2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr const typename tuple_element<
    _Ip, pair<_T1, _T2>>::type &&
get(const pair<_T1, _T2> &&__p) noexcept {
  return __get_pair<_Ip>::get(std::__1::move(__p));
}

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr _T1 &
get(pair<_T1, _T2> &__p) noexcept {
  return __get_pair<0>::get(__p);
}

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr _T1 const &
get(pair<_T1, _T2> const &__p) noexcept {
  return __get_pair<0>::get(__p);
}

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr _T1 &&
get(pair<_T1, _T2> &&__p) noexcept {
  return __get_pair<0>::get(std::__1::move(__p));
}

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr _T1 const &&
get(pair<_T1, _T2> const &&__p) noexcept {
  return __get_pair<0>::get(std::__1::move(__p));
}

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr _T1 &
get(pair<_T2, _T1> &__p) noexcept {
  return __get_pair<1>::get(__p);
}

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr _T1 const &
get(pair<_T2, _T1> const &__p) noexcept {
  return __get_pair<1>::get(__p);
}

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr _T1 &&
get(pair<_T2, _T1> &&__p) noexcept {
  return __get_pair<1>::get(std::__1::move(__p));
}

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr _T1 const &&
get(pair<_T2, _T1> const &&__p) noexcept {
  return __get_pair<1>::get(std::__1::move(__p));
}

template <class _Tp, _Tp... _Ip>
struct __attribute__((__type_visibility__("default"))) integer_sequence {
  typedef _Tp value_type;
  static_assert(
      is_integral<_Tp>::value,
      "std::integer_sequence can only be instantiated with an integral type");
  static __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr size_t
  size() noexcept {
    return sizeof...(_Ip);
  }
};

template <size_t... _Ip>
using index_sequence = integer_sequence<size_t, _Ip...>;

template <class _Tp, _Tp _Ep>
using __make_integer_sequence = __make_integer_seq<integer_sequence, _Tp, _Ep>;
# 903 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 3
template <class _Tp, _Tp _Np>
using make_integer_sequence = __make_integer_sequence<_Tp, _Np>;

template <size_t _Np>
using make_index_sequence = make_integer_sequence<size_t, _Np>;

template <class... _Tp>
using index_sequence_for = make_index_sequence<sizeof...(_Tp)>;

template <class _T1, class _T2 = _T1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _T1
exchange(_T1 &__obj, _T2 &&__new_value) {
  _T1 __old_value = std::__1::move(__obj);
  __obj = std::__1::forward<_T2>(__new_value);
  return __old_value;
}
# 960 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 3
template <class _Arg, class _Result>
struct __attribute__((__type_visibility__("default"))) unary_function {
  typedef _Arg argument_type;
  typedef _Result result_type;
};

template <class _Size>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _Size
__loadword(const void *__p) {
  _Size __r;
  std::memcpy(&__r, __p, sizeof(__r));
  return __r;
}

template <class _Size, size_t = sizeof(_Size) * 8> struct __murmur2_or_cityhash;

template <class _Size> struct __murmur2_or_cityhash<_Size, 32> {
  inline _Size operator()(const void *__key, _Size __len)
      __attribute__((__no_sanitize__("unsigned-integer-overflow")));
};

template <class _Size>
_Size __murmur2_or_cityhash<_Size, 32>::operator()(const void *__key,
                                                   _Size __len) {
  const _Size __m = 0x5bd1e995;
  const _Size __r = 24;
  _Size __h = __len;
  const unsigned char *__data = static_cast<const unsigned char *>(__key);
  for (; __len >= 4; __data += 4, __len -= 4) {
    _Size __k = __loadword<_Size>(__data);
    __k *= __m;
    __k ^= __k >> __r;
    __k *= __m;
    __h *= __m;
    __h ^= __k;
  }
  switch (__len) {
  case 3:
    __h ^= __data[2] << 16;
    [[clang::fallthrough]];
  case 2:
    __h ^= __data[1] << 8;
    [[clang::fallthrough]];
  case 1:
    __h ^= __data[0];
    __h *= __m;
  }
  __h ^= __h >> 13;
  __h *= __m;
  __h ^= __h >> 15;
  return __h;
}

template <class _Size> struct __murmur2_or_cityhash<_Size, 64> {
  inline _Size operator()(const void *__key, _Size __len)
      __attribute__((__no_sanitize__("unsigned-integer-overflow")));

private:
  static const _Size __k0 = 0xc3a5c85c97cb3127ULL;
  static const _Size __k1 = 0xb492b66fbe98f273ULL;
  static const _Size __k2 = 0x9ae16a3b2f90404fULL;
  static const _Size __k3 = 0xc949d7c7509e6557ULL;

  static _Size __rotate(_Size __val, int __shift) {
    return __shift == 0 ? __val
                        : ((__val >> __shift) | (__val << (64 - __shift)));
  }

  static _Size __rotate_by_at_least_1(_Size __val, int __shift) {
    return (__val >> __shift) | (__val << (64 - __shift));
  }

  static _Size __shift_mix(_Size __val) { return __val ^ (__val >> 47); }

  static _Size __hash_len_16(_Size __u, _Size __v)
      __attribute__((__no_sanitize__("unsigned-integer-overflow"))) {
    const _Size __mul = 0x9ddfea08eb382d69ULL;
    _Size __a = (__u ^ __v) * __mul;
    __a ^= (__a >> 47);
    _Size __b = (__v ^ __a) * __mul;
    __b ^= (__b >> 47);
    __b *= __mul;
    return __b;
  }

  static _Size __hash_len_0_to_16(const char *__s, _Size __len)
      __attribute__((__no_sanitize__("unsigned-integer-overflow"))) {
    if (__len > 8) {
      const _Size __a = __loadword<_Size>(__s);
      const _Size __b = __loadword<_Size>(__s + __len - 8);
      return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^
             __b;
    }
    if (__len >= 4) {
      const uint32_t __a = __loadword<uint32_t>(__s);
      const uint32_t __b = __loadword<uint32_t>(__s + __len - 4);
      return __hash_len_16(__len + (__a << 3), __b);
    }
    if (__len > 0) {
      const unsigned char __a = __s[0];
      const unsigned char __b = __s[__len >> 1];
      const unsigned char __c = __s[__len - 1];
      const uint32_t __y =
          static_cast<uint32_t>(__a) + (static_cast<uint32_t>(__b) << 8);
      const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);
      return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;
    }
    return __k2;
  }

  static _Size __hash_len_17_to_32(const char *__s, _Size __len)
      __attribute__((__no_sanitize__("unsigned-integer-overflow"))) {
    const _Size __a = __loadword<_Size>(__s) * __k1;
    const _Size __b = __loadword<_Size>(__s + 8);
    const _Size __c = __loadword<_Size>(__s + __len - 8) * __k2;
    const _Size __d = __loadword<_Size>(__s + __len - 16) * __k0;
    return __hash_len_16(__rotate(__a - __b, 43) + __rotate(__c, 30) + __d,
                         __a + __rotate(__b ^ __k3, 20) - __c + __len);
  }

  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(_Size __w, _Size __x,
                                                          _Size __y, _Size __z,
                                                          _Size __a, _Size __b)
      __attribute__((__no_sanitize__("unsigned-integer-overflow"))) {
    __a += __w;
    __b = __rotate(__b + __a + __z, 21);
    const _Size __c = __a;
    __a += __x;
    __a += __y;
    __b += __rotate(__a, 44);
    return pair<_Size, _Size>(__a + __z, __b + __c);
  }

  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(const char *__s,
                                                          _Size __a, _Size __b)
      __attribute__((__no_sanitize__("unsigned-integer-overflow"))) {
    return __weak_hash_len_32_with_seeds(
        __loadword<_Size>(__s), __loadword<_Size>(__s + 8),
        __loadword<_Size>(__s + 16), __loadword<_Size>(__s + 24), __a, __b);
  }

  static _Size __hash_len_33_to_64(const char *__s, size_t __len)
      __attribute__((__no_sanitize__("unsigned-integer-overflow"))) {
    _Size __z = __loadword<_Size>(__s + 24);
    _Size __a = __loadword<_Size>(__s) +
                (__len + __loadword<_Size>(__s + __len - 16)) * __k0;
    _Size __b = __rotate(__a + __z, 52);
    _Size __c = __rotate(__a, 37);
    __a += __loadword<_Size>(__s + 8);
    __c += __rotate(__a, 7);
    __a += __loadword<_Size>(__s + 16);
    _Size __vf = __a + __z;
    _Size __vs = __b + __rotate(__a, 31) + __c;
    __a = __loadword<_Size>(__s + 16) + __loadword<_Size>(__s + __len - 32);
    __z += __loadword<_Size>(__s + __len - 8);
    __b = __rotate(__a + __z, 52);
    __c = __rotate(__a, 37);
    __a += __loadword<_Size>(__s + __len - 24);
    __c += __rotate(__a, 7);
    __a += __loadword<_Size>(__s + __len - 16);
    _Size __wf = __a + __z;
    _Size __ws = __b + __rotate(__a, 31) + __c;
    _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);
    return __shift_mix(__r * __k0 + __vs) * __k2;
  }
};

template <class _Size>
_Size __murmur2_or_cityhash<_Size, 64>::operator()(const void *__key,
                                                   _Size __len) {
  const char *__s = static_cast<const char *>(__key);
  if (__len <= 32) {
    if (__len <= 16) {
      return __hash_len_0_to_16(__s, __len);
    } else {
      return __hash_len_17_to_32(__s, __len);
    }
  } else if (__len <= 64) {
    return __hash_len_33_to_64(__s, __len);
  }

  _Size __x = __loadword<_Size>(__s + __len - 40);
  _Size __y =
      __loadword<_Size>(__s + __len - 16) + __loadword<_Size>(__s + __len - 56);
  _Size __z = __hash_len_16(__loadword<_Size>(__s + __len - 48) + __len,
                            __loadword<_Size>(__s + __len - 24));
  pair<_Size, _Size> __v =
      __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);
  pair<_Size, _Size> __w =
      __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);
  __x = __x * __k1 + __loadword<_Size>(__s);

  __len = (__len - 1) & ~static_cast<_Size>(63);
  do {
    __x =
        __rotate(__x + __y + __v.first + __loadword<_Size>(__s + 8), 37) * __k1;
    __y = __rotate(__y + __v.second + __loadword<_Size>(__s + 48), 42) * __k1;
    __x ^= __w.second;
    __y += __v.first + __loadword<_Size>(__s + 40);
    __z = __rotate(__z + __w.first, 33) * __k1;
    __v =
        __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);
    __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second,
                                        __y + __loadword<_Size>(__s + 16));
    std::swap(__z, __x);
    __s += 64;
    __len -= 64;
  } while (__len != 0);
  return __hash_len_16(__hash_len_16(__v.first, __w.first) +
                           __shift_mix(__y) * __k1 + __z,
                       __hash_len_16(__v.second, __w.second) + __x);
}

template <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)>
struct __scalar_hash;

template <class _Tp>
struct __scalar_hash<_Tp, 0> : public unary_function<_Tp, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_t
  operator()(_Tp __v) const noexcept {
    union {
      _Tp __t;
      size_t __a;
    } __u;
    __u.__a = 0;
    __u.__t = __v;
    return __u.__a;
  }
};

template <class _Tp>
struct __scalar_hash<_Tp, 1> : public unary_function<_Tp, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_t
  operator()(_Tp __v) const noexcept {
    union {
      _Tp __t;
      size_t __a;
    } __u;
    __u.__t = __v;
    return __u.__a;
  }
};

template <class _Tp>
struct __scalar_hash<_Tp, 2> : public unary_function<_Tp, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_t
  operator()(_Tp __v) const noexcept {
    union {
      _Tp __t;
      struct {
        size_t __a;
        size_t __b;
      } __s;
    } __u;
    __u.__t = __v;
    return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
  }
};

template <class _Tp>
struct __scalar_hash<_Tp, 3> : public unary_function<_Tp, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_t
  operator()(_Tp __v) const noexcept {
    union {
      _Tp __t;
      struct {
        size_t __a;
        size_t __b;
        size_t __c;
      } __s;
    } __u;
    __u.__t = __v;
    return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
  }
};

template <class _Tp>
struct __scalar_hash<_Tp, 4> : public unary_function<_Tp, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_t
  operator()(_Tp __v) const noexcept {
    union {
      _Tp __t;
      struct {
        size_t __a;
        size_t __b;
        size_t __c;
        size_t __d;
      } __s;
    } __u;
    __u.__t = __v;
    return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
  }
};

struct _PairT {
  size_t first;
  size_t second;
};

__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) inline size_t
__hash_combine(size_t __lhs, size_t __rhs) noexcept {
  typedef __scalar_hash<_PairT> _HashT;
  const _PairT __p = {__lhs, __rhs};
  return _HashT()(__p);
}

template <class _Tp>
struct __attribute__((__type_visibility__("default")))
hash<_Tp *> : public unary_function<_Tp *, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_t
  operator()(_Tp *__v) const noexcept {
    union {
      _Tp *__t;
      size_t __a;
    } __u;
    __u.__t = __v;
    return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));
  }
};

template <>
struct __attribute__((__type_visibility__("default")))
hash<bool> : public unary_function<bool, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_t
  operator()(bool __v) const noexcept {
    return static_cast<size_t>(__v);
  }
};

template <>
struct __attribute__((__type_visibility__("default")))
hash<char> : public unary_function<char, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_t
  operator()(char __v) const noexcept {
    return static_cast<size_t>(__v);
  }
};

template <>
struct __attribute__((__type_visibility__("default")))
hash<signed char> : public unary_function<signed char, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_t
  operator()(signed char __v) const noexcept {
    return static_cast<size_t>(__v);
  }
};

template <>
struct __attribute__((__type_visibility__("default")))
hash<unsigned char> : public unary_function<unsigned char, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_t
  operator()(unsigned char __v) const noexcept {
    return static_cast<size_t>(__v);
  }
};

template <>
struct __attribute__((__type_visibility__("default")))
hash<char16_t> : public unary_function<char16_t, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_t
  operator()(char16_t __v) const noexcept {
    return static_cast<size_t>(__v);
  }
};

template <>
struct __attribute__((__type_visibility__("default")))
hash<char32_t> : public unary_function<char32_t, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_t
  operator()(char32_t __v) const noexcept {
    return static_cast<size_t>(__v);
  }
};

template <>
struct __attribute__((__type_visibility__("default")))
hash<wchar_t> : public unary_function<wchar_t, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_t
  operator()(wchar_t __v) const noexcept {
    return static_cast<size_t>(__v);
  }
};

template <>
struct __attribute__((__type_visibility__("default")))
hash<short> : public unary_function<short, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_t
  operator()(short __v) const noexcept {
    return static_cast<size_t>(__v);
  }
};

template <>
struct __attribute__((__type_visibility__("default")))
hash<unsigned short> : public unary_function<unsigned short, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_t
  operator()(unsigned short __v) const noexcept {
    return static_cast<size_t>(__v);
  }
};

template <>
struct __attribute__((__type_visibility__("default")))
hash<int> : public unary_function<int, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_t
  operator()(int __v) const noexcept {
    return static_cast<size_t>(__v);
  }
};

template <>
struct __attribute__((__type_visibility__("default")))
hash<unsigned int> : public unary_function<unsigned int, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_t
  operator()(unsigned int __v) const noexcept {
    return static_cast<size_t>(__v);
  }
};

template <>
struct __attribute__((__type_visibility__("default")))
hash<long> : public unary_function<long, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_t
  operator()(long __v) const noexcept {
    return static_cast<size_t>(__v);
  }
};

template <>
struct __attribute__((__type_visibility__("default")))
hash<unsigned long> : public unary_function<unsigned long, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_t
  operator()(unsigned long __v) const noexcept {
    return static_cast<size_t>(__v);
  }
};

template <>
struct __attribute__((__type_visibility__("default")))
hash<long long> : public __scalar_hash<long long> {};

template <>
struct __attribute__((__type_visibility__("default")))
hash<unsigned long long> : public __scalar_hash<unsigned long long> {};

template <>
struct __attribute__((__type_visibility__("default")))
hash<__int128_t> : public __scalar_hash<__int128_t> {};

template <>
struct __attribute__((__type_visibility__("default")))
hash<__uint128_t> : public __scalar_hash<__uint128_t> {};

template <>
struct __attribute__((__type_visibility__("default")))
hash<float> : public __scalar_hash<float> {
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_t
  operator()(float __v) const noexcept {

    if (__v == 0.0f)
      return 0;
    return __scalar_hash<float>::operator()(__v);
  }
};

template <>
struct __attribute__((__type_visibility__("default")))
hash<double> : public __scalar_hash<double> {
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_t
  operator()(double __v) const noexcept {

    if (__v == 0.0)
      return 0;
    return __scalar_hash<double>::operator()(__v);
  }
};

template <>
struct __attribute__((__type_visibility__("default")))
hash<long double> : public __scalar_hash<long double> {
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_t
  operator()(long double __v) const noexcept {

    if (__v == 0.0L)
      return 0;
# 1530 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 3
    union {
      long double __t;
      struct {
        size_t __a;
        size_t __b;
      } __s;
    } __u;
    __u.__s.__a = 0;
    __u.__s.__b = 0;
    __u.__t = __v;
    return __u.__s.__a ^ __u.__s.__b;
  }
};

template <class _Tp, bool = is_enum<_Tp>::value>
struct __attribute__((__type_visibility__("default"))) __enum_hash
    : public unary_function<_Tp, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_t
  operator()(_Tp __v) const noexcept {
    typedef typename underlying_type<_Tp>::type type;
    return hash<type>{}(static_cast<type>(__v));
  }
};
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) __enum_hash<_Tp, false> {
  __enum_hash() = delete;
  __enum_hash(__enum_hash const &) = delete;
  __enum_hash &operator=(__enum_hash const &) = delete;
};

template <class _Tp>
struct __attribute__((__type_visibility__("default"))) hash
    : public __enum_hash<_Tp> {};
# 1589 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 3
template <class _Key, class _Hash>
using __check_hash_requirements =
    integral_constant<bool,
                      is_copy_constructible<_Hash>::value &&
                          is_move_constructible<_Hash>::value &&
                          __invokable_r<size_t, _Hash, _Key const &>::value>;

template <class _Key, class _Hash = std::hash<_Key>>
using __has_enabled_hash =
    integral_constant<bool, __check_hash_requirements<_Key, _Hash>::value &&
                                is_default_constructible<_Hash>::value>;
# 1611 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/utility" 3
template <class _Type, class...> using __enable_hash_helper = _Type;

} // namespace __1
} // namespace std
# 48 "/usr/local/include/QtCore/qglobal.h" 2

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/stdlib.h" 1 3 4
# 91 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/stdlib.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3 4
# 92 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/stdlib.h" 2 3 4
# 95 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/stdlib.h" 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/stdlib.h" 1 3 4
# 66 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/stdlib.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/wait.h" 1 3 4
# 79 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/wait.h" 3 4
typedef enum { P_ALL, P_PID, P_PGID } idtype_t;

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_pid_t.h" 1 3 4
# 31 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_pid_t.h" 3 4
typedef __darwin_pid_t pid_t;
# 90 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/wait.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_id_t.h" 1 3 4
# 31 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_id_t.h" 3 4
typedef __darwin_id_t id_t;
# 91 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/wait.h" 2 3 4
# 109 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/wait.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 1 3 4
# 73 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/appleapiopts.h" 1 3 4
# 74 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 2 3 4

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/machine/signal.h" 1 3 4
# 32 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/machine/signal.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/signal.h" 1 3 4
# 39 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/signal.h" 3 4
typedef int sig_atomic_t;
# 33 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/machine/signal.h" 2 3 4
# 83 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 2 3 4
# 146 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/machine/_mcontext.h" 1 3 4
# 29 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/machine/_mcontext.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/_mcontext.h" 1 3 4
# 34 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/_mcontext.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/mach/machine/_structs.h" 1 3 4
# 33 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/mach/machine/_structs.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/mach/i386/_structs.h" 1 3 4
# 46 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_i386_thread_state {
  unsigned int __eax;
  unsigned int __ebx;
  unsigned int __ecx;
  unsigned int __edx;
  unsigned int __edi;
  unsigned int __esi;
  unsigned int __ebp;
  unsigned int __esp;
  unsigned int __ss;
  unsigned int __eflags;
  unsigned int __eip;
  unsigned int __cs;
  unsigned int __ds;
  unsigned int __es;
  unsigned int __fs;
  unsigned int __gs;
};
# 92 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_fp_control {
  unsigned short __invalid : 1, __denorm : 1, __zdiv : 1, __ovrfl : 1,
      __undfl : 1, __precis : 1, : 2, __pc : 2,

      __rc : 2,

      : 1, : 3;
};
typedef struct __darwin_fp_control __darwin_fp_control_t;
# 150 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_fp_status {
  unsigned short __invalid : 1, __denorm : 1, __zdiv : 1, __ovrfl : 1,
      __undfl : 1, __precis : 1, __stkflt : 1, __errsumm : 1, __c0 : 1,
      __c1 : 1, __c2 : 1, __tos : 3, __c3 : 1, __busy : 1;
};
typedef struct __darwin_fp_status __darwin_fp_status_t;
# 194 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_mmst_reg {
  char __mmst_reg[10];
  char __mmst_rsrv[6];
};
# 213 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_xmm_reg {
  char __xmm_reg[16];
};
# 229 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_ymm_reg {
  char __ymm_reg[32];
};
# 245 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_zmm_reg {
  char __zmm_reg[64];
};
# 259 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_opmask_reg {
  char __opmask_reg[8];
};
# 281 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_i386_float_state {
  int __fpu_reserved[2];
  struct __darwin_fp_control __fpu_fcw;
  struct __darwin_fp_status __fpu_fsw;
  __uint8_t __fpu_ftw;
  __uint8_t __fpu_rsrv1;
  __uint16_t __fpu_fop;
  __uint32_t __fpu_ip;
  __uint16_t __fpu_cs;
  __uint16_t __fpu_rsrv2;
  __uint32_t __fpu_dp;
  __uint16_t __fpu_ds;
  __uint16_t __fpu_rsrv3;
  __uint32_t __fpu_mxcsr;
  __uint32_t __fpu_mxcsrmask;
  struct __darwin_mmst_reg __fpu_stmm0;
  struct __darwin_mmst_reg __fpu_stmm1;
  struct __darwin_mmst_reg __fpu_stmm2;
  struct __darwin_mmst_reg __fpu_stmm3;
  struct __darwin_mmst_reg __fpu_stmm4;
  struct __darwin_mmst_reg __fpu_stmm5;
  struct __darwin_mmst_reg __fpu_stmm6;
  struct __darwin_mmst_reg __fpu_stmm7;
  struct __darwin_xmm_reg __fpu_xmm0;
  struct __darwin_xmm_reg __fpu_xmm1;
  struct __darwin_xmm_reg __fpu_xmm2;
  struct __darwin_xmm_reg __fpu_xmm3;
  struct __darwin_xmm_reg __fpu_xmm4;
  struct __darwin_xmm_reg __fpu_xmm5;
  struct __darwin_xmm_reg __fpu_xmm6;
  struct __darwin_xmm_reg __fpu_xmm7;
  char __fpu_rsrv4[14 * 16];
  int __fpu_reserved1;
};

struct __darwin_i386_avx_state {
  int __fpu_reserved[2];
  struct __darwin_fp_control __fpu_fcw;
  struct __darwin_fp_status __fpu_fsw;
  __uint8_t __fpu_ftw;
  __uint8_t __fpu_rsrv1;
  __uint16_t __fpu_fop;
  __uint32_t __fpu_ip;
  __uint16_t __fpu_cs;
  __uint16_t __fpu_rsrv2;
  __uint32_t __fpu_dp;
  __uint16_t __fpu_ds;
  __uint16_t __fpu_rsrv3;
  __uint32_t __fpu_mxcsr;
  __uint32_t __fpu_mxcsrmask;
  struct __darwin_mmst_reg __fpu_stmm0;
  struct __darwin_mmst_reg __fpu_stmm1;
  struct __darwin_mmst_reg __fpu_stmm2;
  struct __darwin_mmst_reg __fpu_stmm3;
  struct __darwin_mmst_reg __fpu_stmm4;
  struct __darwin_mmst_reg __fpu_stmm5;
  struct __darwin_mmst_reg __fpu_stmm6;
  struct __darwin_mmst_reg __fpu_stmm7;
  struct __darwin_xmm_reg __fpu_xmm0;
  struct __darwin_xmm_reg __fpu_xmm1;
  struct __darwin_xmm_reg __fpu_xmm2;
  struct __darwin_xmm_reg __fpu_xmm3;
  struct __darwin_xmm_reg __fpu_xmm4;
  struct __darwin_xmm_reg __fpu_xmm5;
  struct __darwin_xmm_reg __fpu_xmm6;
  struct __darwin_xmm_reg __fpu_xmm7;
  char __fpu_rsrv4[14 * 16];
  int __fpu_reserved1;
  char __avx_reserved1[64];
  struct __darwin_xmm_reg __fpu_ymmh0;
  struct __darwin_xmm_reg __fpu_ymmh1;
  struct __darwin_xmm_reg __fpu_ymmh2;
  struct __darwin_xmm_reg __fpu_ymmh3;
  struct __darwin_xmm_reg __fpu_ymmh4;
  struct __darwin_xmm_reg __fpu_ymmh5;
  struct __darwin_xmm_reg __fpu_ymmh6;
  struct __darwin_xmm_reg __fpu_ymmh7;
};

struct __darwin_i386_avx512_state {
  int __fpu_reserved[2];
  struct __darwin_fp_control __fpu_fcw;
  struct __darwin_fp_status __fpu_fsw;
  __uint8_t __fpu_ftw;
  __uint8_t __fpu_rsrv1;
  __uint16_t __fpu_fop;
  __uint32_t __fpu_ip;
  __uint16_t __fpu_cs;
  __uint16_t __fpu_rsrv2;
  __uint32_t __fpu_dp;
  __uint16_t __fpu_ds;
  __uint16_t __fpu_rsrv3;
  __uint32_t __fpu_mxcsr;
  __uint32_t __fpu_mxcsrmask;
  struct __darwin_mmst_reg __fpu_stmm0;
  struct __darwin_mmst_reg __fpu_stmm1;
  struct __darwin_mmst_reg __fpu_stmm2;
  struct __darwin_mmst_reg __fpu_stmm3;
  struct __darwin_mmst_reg __fpu_stmm4;
  struct __darwin_mmst_reg __fpu_stmm5;
  struct __darwin_mmst_reg __fpu_stmm6;
  struct __darwin_mmst_reg __fpu_stmm7;
  struct __darwin_xmm_reg __fpu_xmm0;
  struct __darwin_xmm_reg __fpu_xmm1;
  struct __darwin_xmm_reg __fpu_xmm2;
  struct __darwin_xmm_reg __fpu_xmm3;
  struct __darwin_xmm_reg __fpu_xmm4;
  struct __darwin_xmm_reg __fpu_xmm5;
  struct __darwin_xmm_reg __fpu_xmm6;
  struct __darwin_xmm_reg __fpu_xmm7;
  char __fpu_rsrv4[14 * 16];
  int __fpu_reserved1;
  char __avx_reserved1[64];
  struct __darwin_xmm_reg __fpu_ymmh0;
  struct __darwin_xmm_reg __fpu_ymmh1;
  struct __darwin_xmm_reg __fpu_ymmh2;
  struct __darwin_xmm_reg __fpu_ymmh3;
  struct __darwin_xmm_reg __fpu_ymmh4;
  struct __darwin_xmm_reg __fpu_ymmh5;
  struct __darwin_xmm_reg __fpu_ymmh6;
  struct __darwin_xmm_reg __fpu_ymmh7;
  struct __darwin_opmask_reg __fpu_k0;
  struct __darwin_opmask_reg __fpu_k1;
  struct __darwin_opmask_reg __fpu_k2;
  struct __darwin_opmask_reg __fpu_k3;
  struct __darwin_opmask_reg __fpu_k4;
  struct __darwin_opmask_reg __fpu_k5;
  struct __darwin_opmask_reg __fpu_k6;
  struct __darwin_opmask_reg __fpu_k7;
  struct __darwin_ymm_reg __fpu_zmmh0;
  struct __darwin_ymm_reg __fpu_zmmh1;
  struct __darwin_ymm_reg __fpu_zmmh2;
  struct __darwin_ymm_reg __fpu_zmmh3;
  struct __darwin_ymm_reg __fpu_zmmh4;
  struct __darwin_ymm_reg __fpu_zmmh5;
  struct __darwin_ymm_reg __fpu_zmmh6;
  struct __darwin_ymm_reg __fpu_zmmh7;
};
# 575 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_i386_exception_state {
  __uint16_t __trapno;
  __uint16_t __cpu;
  __uint32_t __err;
  __uint32_t __faultvaddr;
};
# 595 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_debug_state32 {
  unsigned int __dr0;
  unsigned int __dr1;
  unsigned int __dr2;
  unsigned int __dr3;
  unsigned int __dr4;
  unsigned int __dr5;
  unsigned int __dr6;
  unsigned int __dr7;
};
# 622 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __x86_pagein_state {
  int __pagein_error;
};

struct __darwin_x86_thread_state64 {
  __uint64_t __rax;
  __uint64_t __rbx;
  __uint64_t __rcx;
  __uint64_t __rdx;
  __uint64_t __rdi;
  __uint64_t __rsi;
  __uint64_t __rbp;
  __uint64_t __rsp;
  __uint64_t __r8;
  __uint64_t __r9;
  __uint64_t __r10;
  __uint64_t __r11;
  __uint64_t __r12;
  __uint64_t __r13;
  __uint64_t __r14;
  __uint64_t __r15;
  __uint64_t __rip;
  __uint64_t __rflags;
  __uint64_t __cs;
  __uint64_t __fs;
  __uint64_t __gs;
};
# 691 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_thread_full_state64 {
  struct __darwin_x86_thread_state64 __ss64;
  __uint64_t __ds;
  __uint64_t __es;
  __uint64_t __ss;
  __uint64_t __gsbase;
};
# 714 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_float_state64 {
  int __fpu_reserved[2];
  struct __darwin_fp_control __fpu_fcw;
  struct __darwin_fp_status __fpu_fsw;
  __uint8_t __fpu_ftw;
  __uint8_t __fpu_rsrv1;
  __uint16_t __fpu_fop;

  __uint32_t __fpu_ip;
  __uint16_t __fpu_cs;

  __uint16_t __fpu_rsrv2;

  __uint32_t __fpu_dp;
  __uint16_t __fpu_ds;

  __uint16_t __fpu_rsrv3;
  __uint32_t __fpu_mxcsr;
  __uint32_t __fpu_mxcsrmask;
  struct __darwin_mmst_reg __fpu_stmm0;
  struct __darwin_mmst_reg __fpu_stmm1;
  struct __darwin_mmst_reg __fpu_stmm2;
  struct __darwin_mmst_reg __fpu_stmm3;
  struct __darwin_mmst_reg __fpu_stmm4;
  struct __darwin_mmst_reg __fpu_stmm5;
  struct __darwin_mmst_reg __fpu_stmm6;
  struct __darwin_mmst_reg __fpu_stmm7;
  struct __darwin_xmm_reg __fpu_xmm0;
  struct __darwin_xmm_reg __fpu_xmm1;
  struct __darwin_xmm_reg __fpu_xmm2;
  struct __darwin_xmm_reg __fpu_xmm3;
  struct __darwin_xmm_reg __fpu_xmm4;
  struct __darwin_xmm_reg __fpu_xmm5;
  struct __darwin_xmm_reg __fpu_xmm6;
  struct __darwin_xmm_reg __fpu_xmm7;
  struct __darwin_xmm_reg __fpu_xmm8;
  struct __darwin_xmm_reg __fpu_xmm9;
  struct __darwin_xmm_reg __fpu_xmm10;
  struct __darwin_xmm_reg __fpu_xmm11;
  struct __darwin_xmm_reg __fpu_xmm12;
  struct __darwin_xmm_reg __fpu_xmm13;
  struct __darwin_xmm_reg __fpu_xmm14;
  struct __darwin_xmm_reg __fpu_xmm15;
  char __fpu_rsrv4[6 * 16];
  int __fpu_reserved1;
};

struct __darwin_x86_avx_state64 {
  int __fpu_reserved[2];
  struct __darwin_fp_control __fpu_fcw;
  struct __darwin_fp_status __fpu_fsw;
  __uint8_t __fpu_ftw;
  __uint8_t __fpu_rsrv1;
  __uint16_t __fpu_fop;

  __uint32_t __fpu_ip;
  __uint16_t __fpu_cs;

  __uint16_t __fpu_rsrv2;

  __uint32_t __fpu_dp;
  __uint16_t __fpu_ds;

  __uint16_t __fpu_rsrv3;
  __uint32_t __fpu_mxcsr;
  __uint32_t __fpu_mxcsrmask;
  struct __darwin_mmst_reg __fpu_stmm0;
  struct __darwin_mmst_reg __fpu_stmm1;
  struct __darwin_mmst_reg __fpu_stmm2;
  struct __darwin_mmst_reg __fpu_stmm3;
  struct __darwin_mmst_reg __fpu_stmm4;
  struct __darwin_mmst_reg __fpu_stmm5;
  struct __darwin_mmst_reg __fpu_stmm6;
  struct __darwin_mmst_reg __fpu_stmm7;
  struct __darwin_xmm_reg __fpu_xmm0;
  struct __darwin_xmm_reg __fpu_xmm1;
  struct __darwin_xmm_reg __fpu_xmm2;
  struct __darwin_xmm_reg __fpu_xmm3;
  struct __darwin_xmm_reg __fpu_xmm4;
  struct __darwin_xmm_reg __fpu_xmm5;
  struct __darwin_xmm_reg __fpu_xmm6;
  struct __darwin_xmm_reg __fpu_xmm7;
  struct __darwin_xmm_reg __fpu_xmm8;
  struct __darwin_xmm_reg __fpu_xmm9;
  struct __darwin_xmm_reg __fpu_xmm10;
  struct __darwin_xmm_reg __fpu_xmm11;
  struct __darwin_xmm_reg __fpu_xmm12;
  struct __darwin_xmm_reg __fpu_xmm13;
  struct __darwin_xmm_reg __fpu_xmm14;
  struct __darwin_xmm_reg __fpu_xmm15;
  char __fpu_rsrv4[6 * 16];
  int __fpu_reserved1;
  char __avx_reserved1[64];
  struct __darwin_xmm_reg __fpu_ymmh0;
  struct __darwin_xmm_reg __fpu_ymmh1;
  struct __darwin_xmm_reg __fpu_ymmh2;
  struct __darwin_xmm_reg __fpu_ymmh3;
  struct __darwin_xmm_reg __fpu_ymmh4;
  struct __darwin_xmm_reg __fpu_ymmh5;
  struct __darwin_xmm_reg __fpu_ymmh6;
  struct __darwin_xmm_reg __fpu_ymmh7;
  struct __darwin_xmm_reg __fpu_ymmh8;
  struct __darwin_xmm_reg __fpu_ymmh9;
  struct __darwin_xmm_reg __fpu_ymmh10;
  struct __darwin_xmm_reg __fpu_ymmh11;
  struct __darwin_xmm_reg __fpu_ymmh12;
  struct __darwin_xmm_reg __fpu_ymmh13;
  struct __darwin_xmm_reg __fpu_ymmh14;
  struct __darwin_xmm_reg __fpu_ymmh15;
};

struct __darwin_x86_avx512_state64 {
  int __fpu_reserved[2];
  struct __darwin_fp_control __fpu_fcw;
  struct __darwin_fp_status __fpu_fsw;
  __uint8_t __fpu_ftw;
  __uint8_t __fpu_rsrv1;
  __uint16_t __fpu_fop;

  __uint32_t __fpu_ip;
  __uint16_t __fpu_cs;

  __uint16_t __fpu_rsrv2;

  __uint32_t __fpu_dp;
  __uint16_t __fpu_ds;

  __uint16_t __fpu_rsrv3;
  __uint32_t __fpu_mxcsr;
  __uint32_t __fpu_mxcsrmask;
  struct __darwin_mmst_reg __fpu_stmm0;
  struct __darwin_mmst_reg __fpu_stmm1;
  struct __darwin_mmst_reg __fpu_stmm2;
  struct __darwin_mmst_reg __fpu_stmm3;
  struct __darwin_mmst_reg __fpu_stmm4;
  struct __darwin_mmst_reg __fpu_stmm5;
  struct __darwin_mmst_reg __fpu_stmm6;
  struct __darwin_mmst_reg __fpu_stmm7;
  struct __darwin_xmm_reg __fpu_xmm0;
  struct __darwin_xmm_reg __fpu_xmm1;
  struct __darwin_xmm_reg __fpu_xmm2;
  struct __darwin_xmm_reg __fpu_xmm3;
  struct __darwin_xmm_reg __fpu_xmm4;
  struct __darwin_xmm_reg __fpu_xmm5;
  struct __darwin_xmm_reg __fpu_xmm6;
  struct __darwin_xmm_reg __fpu_xmm7;
  struct __darwin_xmm_reg __fpu_xmm8;
  struct __darwin_xmm_reg __fpu_xmm9;
  struct __darwin_xmm_reg __fpu_xmm10;
  struct __darwin_xmm_reg __fpu_xmm11;
  struct __darwin_xmm_reg __fpu_xmm12;
  struct __darwin_xmm_reg __fpu_xmm13;
  struct __darwin_xmm_reg __fpu_xmm14;
  struct __darwin_xmm_reg __fpu_xmm15;
  char __fpu_rsrv4[6 * 16];
  int __fpu_reserved1;
  char __avx_reserved1[64];
  struct __darwin_xmm_reg __fpu_ymmh0;
  struct __darwin_xmm_reg __fpu_ymmh1;
  struct __darwin_xmm_reg __fpu_ymmh2;
  struct __darwin_xmm_reg __fpu_ymmh3;
  struct __darwin_xmm_reg __fpu_ymmh4;
  struct __darwin_xmm_reg __fpu_ymmh5;
  struct __darwin_xmm_reg __fpu_ymmh6;
  struct __darwin_xmm_reg __fpu_ymmh7;
  struct __darwin_xmm_reg __fpu_ymmh8;
  struct __darwin_xmm_reg __fpu_ymmh9;
  struct __darwin_xmm_reg __fpu_ymmh10;
  struct __darwin_xmm_reg __fpu_ymmh11;
  struct __darwin_xmm_reg __fpu_ymmh12;
  struct __darwin_xmm_reg __fpu_ymmh13;
  struct __darwin_xmm_reg __fpu_ymmh14;
  struct __darwin_xmm_reg __fpu_ymmh15;
  struct __darwin_opmask_reg __fpu_k0;
  struct __darwin_opmask_reg __fpu_k1;
  struct __darwin_opmask_reg __fpu_k2;
  struct __darwin_opmask_reg __fpu_k3;
  struct __darwin_opmask_reg __fpu_k4;
  struct __darwin_opmask_reg __fpu_k5;
  struct __darwin_opmask_reg __fpu_k6;
  struct __darwin_opmask_reg __fpu_k7;
  struct __darwin_ymm_reg __fpu_zmmh0;
  struct __darwin_ymm_reg __fpu_zmmh1;
  struct __darwin_ymm_reg __fpu_zmmh2;
  struct __darwin_ymm_reg __fpu_zmmh3;
  struct __darwin_ymm_reg __fpu_zmmh4;
  struct __darwin_ymm_reg __fpu_zmmh5;
  struct __darwin_ymm_reg __fpu_zmmh6;
  struct __darwin_ymm_reg __fpu_zmmh7;
  struct __darwin_ymm_reg __fpu_zmmh8;
  struct __darwin_ymm_reg __fpu_zmmh9;
  struct __darwin_ymm_reg __fpu_zmmh10;
  struct __darwin_ymm_reg __fpu_zmmh11;
  struct __darwin_ymm_reg __fpu_zmmh12;
  struct __darwin_ymm_reg __fpu_zmmh13;
  struct __darwin_ymm_reg __fpu_zmmh14;
  struct __darwin_ymm_reg __fpu_zmmh15;
  struct __darwin_zmm_reg __fpu_zmm16;
  struct __darwin_zmm_reg __fpu_zmm17;
  struct __darwin_zmm_reg __fpu_zmm18;
  struct __darwin_zmm_reg __fpu_zmm19;
  struct __darwin_zmm_reg __fpu_zmm20;
  struct __darwin_zmm_reg __fpu_zmm21;
  struct __darwin_zmm_reg __fpu_zmm22;
  struct __darwin_zmm_reg __fpu_zmm23;
  struct __darwin_zmm_reg __fpu_zmm24;
  struct __darwin_zmm_reg __fpu_zmm25;
  struct __darwin_zmm_reg __fpu_zmm26;
  struct __darwin_zmm_reg __fpu_zmm27;
  struct __darwin_zmm_reg __fpu_zmm28;
  struct __darwin_zmm_reg __fpu_zmm29;
  struct __darwin_zmm_reg __fpu_zmm30;
  struct __darwin_zmm_reg __fpu_zmm31;
};
# 1172 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_exception_state64 {
  __uint16_t __trapno;
  __uint16_t __cpu;
  __uint32_t __err;
  __uint64_t __faultvaddr;
};
# 1192 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_debug_state64 {
  __uint64_t __dr0;
  __uint64_t __dr1;
  __uint64_t __dr2;
  __uint64_t __dr3;
  __uint64_t __dr4;
  __uint64_t __dr5;
  __uint64_t __dr6;
  __uint64_t __dr7;
};
# 1220 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_cpmu_state64 {
  __uint64_t __ctrs[16];
};
# 34 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/mach/machine/_structs.h" 2 3 4
# 35 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/_mcontext.h" 2 3 4

struct __darwin_mcontext32 {
  struct __darwin_i386_exception_state __es;
  struct __darwin_i386_thread_state __ss;
  struct __darwin_i386_float_state __fs;
};

struct __darwin_mcontext_avx32 {
  struct __darwin_i386_exception_state __es;
  struct __darwin_i386_thread_state __ss;
  struct __darwin_i386_avx_state __fs;
};

struct __darwin_mcontext_avx512_32 {
  struct __darwin_i386_exception_state __es;
  struct __darwin_i386_thread_state __ss;
  struct __darwin_i386_avx512_state __fs;
};
# 97 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/_mcontext.h" 3 4
struct __darwin_mcontext64 {
  struct __darwin_x86_exception_state64 __es;
  struct __darwin_x86_thread_state64 __ss;
  struct __darwin_x86_float_state64 __fs;
};

struct __darwin_mcontext64_full {
  struct __darwin_x86_exception_state64 __es;
  struct __darwin_x86_thread_full_state64 __ss;
  struct __darwin_x86_float_state64 __fs;
};

struct __darwin_mcontext_avx64 {
  struct __darwin_x86_exception_state64 __es;
  struct __darwin_x86_thread_state64 __ss;
  struct __darwin_x86_avx_state64 __fs;
};

struct __darwin_mcontext_avx64_full {
  struct __darwin_x86_exception_state64 __es;
  struct __darwin_x86_thread_full_state64 __ss;
  struct __darwin_x86_avx_state64 __fs;
};

struct __darwin_mcontext_avx512_64 {
  struct __darwin_x86_exception_state64 __es;
  struct __darwin_x86_thread_state64 __ss;
  struct __darwin_x86_avx512_state64 __fs;
};

struct __darwin_mcontext_avx512_64_full {
  struct __darwin_x86_exception_state64 __es;
  struct __darwin_x86_thread_full_state64 __ss;
  struct __darwin_x86_avx512_state64 __fs;
};
# 204 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/_mcontext.h" 3 4
typedef struct __darwin_mcontext64 *mcontext_t;
# 30 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/machine/_mcontext.h" 2 3 4
# 147 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 2 3 4

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_attr_t.h" 1 3 4
# 31 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_attr_t.h" 3 4
typedef __darwin_pthread_attr_t pthread_attr_t;
# 149 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 2 3 4

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_sigaltstack.h" 1 3 4
# 42 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_sigaltstack.h" 3 4
struct __darwin_sigaltstack {
  void *ss_sp;
  __darwin_size_t ss_size;
  int ss_flags;
};
typedef struct __darwin_sigaltstack stack_t;
# 151 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_ucontext.h" 1 3 4
# 39 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_ucontext.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/machine/_mcontext.h" 1 3 4
# 40 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_ucontext.h" 2 3 4

struct __darwin_ucontext {
  int uc_onstack;
  __darwin_sigset_t uc_sigmask;
  struct __darwin_sigaltstack uc_stack;
  struct __darwin_ucontext *uc_link;
  __darwin_size_t uc_mcsize;
  struct __darwin_mcontext64 *uc_mcontext;
};

typedef struct __darwin_ucontext ucontext_t;
# 152 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 2 3 4

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_sigset_t.h" 1 3 4
# 31 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_sigset_t.h" 3 4
typedef __darwin_sigset_t sigset_t;
# 155 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_size_t.h" 1 3 4
# 156 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_uid_t.h" 1 3 4
# 31 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_uid_t.h" 3 4
typedef __darwin_uid_t uid_t;
# 157 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 2 3 4

union sigval {

  int sival_int;
  void *sival_ptr;
};

struct sigevent {
  int sigev_notify;
  int sigev_signo;
  union sigval sigev_value;
  void (*sigev_notify_function)(union sigval);
  pthread_attr_t *sigev_notify_attributes;
};

typedef struct __siginfo {
  int si_signo;
  int si_errno;
  int si_code;
  pid_t si_pid;
  uid_t si_uid;
  int si_status;
  void *si_addr;
  union sigval si_value;
  long si_band;
  unsigned long __pad[7];
} siginfo_t;
# 269 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 3 4
union __sigaction_u {
  void (*__sa_handler)(int);
  void (*__sa_sigaction)(int, struct __siginfo *, void *);
};

struct __sigaction {
  union __sigaction_u __sigaction_u;
  void (*sa_tramp)(void *, int, int, siginfo_t *, void *);
  sigset_t sa_mask;
  int sa_flags;
};

struct sigaction {
  union __sigaction_u __sigaction_u;
  sigset_t sa_mask;
  int sa_flags;
};
# 331 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 3 4
typedef void (*sig_t)(int);
# 348 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 3 4
struct sigvec {
  void (*sv_handler)(int);
  int sv_mask;
  int sv_flags;
};
# 367 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 3 4
struct sigstack {
  char *ss_sp;
  int ss_onstack;
};
# 389 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/signal.h" 3 4
extern "C" {
void (*signal(int, void (*)(int)))(int);
}
# 110 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/wait.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/resource.h" 1 3 4
# 80 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/resource.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_timeval.h" 1 3 4
# 34 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_timeval.h" 3 4
struct timeval {
  __darwin_time_t tv_sec;
  __darwin_suseconds_t tv_usec;
};
# 81 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/resource.h" 2 3 4

typedef __uint64_t rlim_t;
# 152 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/resource.h" 3 4
struct rusage {
  struct timeval ru_utime;
  struct timeval ru_stime;
# 163 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/resource.h" 3 4
  long ru_maxrss;

  long ru_ixrss;
  long ru_idrss;
  long ru_isrss;
  long ru_minflt;
  long ru_majflt;
  long ru_nswap;
  long ru_inblock;
  long ru_oublock;
  long ru_msgsnd;
  long ru_msgrcv;
  long ru_nsignals;
  long ru_nvcsw;
  long ru_nivcsw;
};
# 193 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/resource.h" 3 4
typedef void *rusage_info_t;

struct rusage_info_v0 {
  uint8_t ri_uuid[16];
  uint64_t ri_user_time;
  uint64_t ri_system_time;
  uint64_t ri_pkg_idle_wkups;
  uint64_t ri_interrupt_wkups;
  uint64_t ri_pageins;
  uint64_t ri_wired_size;
  uint64_t ri_resident_size;
  uint64_t ri_phys_footprint;
  uint64_t ri_proc_start_abstime;
  uint64_t ri_proc_exit_abstime;
};

struct rusage_info_v1 {
  uint8_t ri_uuid[16];
  uint64_t ri_user_time;
  uint64_t ri_system_time;
  uint64_t ri_pkg_idle_wkups;
  uint64_t ri_interrupt_wkups;
  uint64_t ri_pageins;
  uint64_t ri_wired_size;
  uint64_t ri_resident_size;
  uint64_t ri_phys_footprint;
  uint64_t ri_proc_start_abstime;
  uint64_t ri_proc_exit_abstime;
  uint64_t ri_child_user_time;
  uint64_t ri_child_system_time;
  uint64_t ri_child_pkg_idle_wkups;
  uint64_t ri_child_interrupt_wkups;
  uint64_t ri_child_pageins;
  uint64_t ri_child_elapsed_abstime;
};

struct rusage_info_v2 {
  uint8_t ri_uuid[16];
  uint64_t ri_user_time;
  uint64_t ri_system_time;
  uint64_t ri_pkg_idle_wkups;
  uint64_t ri_interrupt_wkups;
  uint64_t ri_pageins;
  uint64_t ri_wired_size;
  uint64_t ri_resident_size;
  uint64_t ri_phys_footprint;
  uint64_t ri_proc_start_abstime;
  uint64_t ri_proc_exit_abstime;
  uint64_t ri_child_user_time;
  uint64_t ri_child_system_time;
  uint64_t ri_child_pkg_idle_wkups;
  uint64_t ri_child_interrupt_wkups;
  uint64_t ri_child_pageins;
  uint64_t ri_child_elapsed_abstime;
  uint64_t ri_diskio_bytesread;
  uint64_t ri_diskio_byteswritten;
};

struct rusage_info_v3 {
  uint8_t ri_uuid[16];
  uint64_t ri_user_time;
  uint64_t ri_system_time;
  uint64_t ri_pkg_idle_wkups;
  uint64_t ri_interrupt_wkups;
  uint64_t ri_pageins;
  uint64_t ri_wired_size;
  uint64_t ri_resident_size;
  uint64_t ri_phys_footprint;
  uint64_t ri_proc_start_abstime;
  uint64_t ri_proc_exit_abstime;
  uint64_t ri_child_user_time;
  uint64_t ri_child_system_time;
  uint64_t ri_child_pkg_idle_wkups;
  uint64_t ri_child_interrupt_wkups;
  uint64_t ri_child_pageins;
  uint64_t ri_child_elapsed_abstime;
  uint64_t ri_diskio_bytesread;
  uint64_t ri_diskio_byteswritten;
  uint64_t ri_cpu_time_qos_default;
  uint64_t ri_cpu_time_qos_maintenance;
  uint64_t ri_cpu_time_qos_background;
  uint64_t ri_cpu_time_qos_utility;
  uint64_t ri_cpu_time_qos_legacy;
  uint64_t ri_cpu_time_qos_user_initiated;
  uint64_t ri_cpu_time_qos_user_interactive;
  uint64_t ri_billed_system_time;
  uint64_t ri_serviced_system_time;
};

struct rusage_info_v4 {
  uint8_t ri_uuid[16];
  uint64_t ri_user_time;
  uint64_t ri_system_time;
  uint64_t ri_pkg_idle_wkups;
  uint64_t ri_interrupt_wkups;
  uint64_t ri_pageins;
  uint64_t ri_wired_size;
  uint64_t ri_resident_size;
  uint64_t ri_phys_footprint;
  uint64_t ri_proc_start_abstime;
  uint64_t ri_proc_exit_abstime;
  uint64_t ri_child_user_time;
  uint64_t ri_child_system_time;
  uint64_t ri_child_pkg_idle_wkups;
  uint64_t ri_child_interrupt_wkups;
  uint64_t ri_child_pageins;
  uint64_t ri_child_elapsed_abstime;
  uint64_t ri_diskio_bytesread;
  uint64_t ri_diskio_byteswritten;
  uint64_t ri_cpu_time_qos_default;
  uint64_t ri_cpu_time_qos_maintenance;
  uint64_t ri_cpu_time_qos_background;
  uint64_t ri_cpu_time_qos_utility;
  uint64_t ri_cpu_time_qos_legacy;
  uint64_t ri_cpu_time_qos_user_initiated;
  uint64_t ri_cpu_time_qos_user_interactive;
  uint64_t ri_billed_system_time;
  uint64_t ri_serviced_system_time;
  uint64_t ri_logical_writes;
  uint64_t ri_lifetime_max_phys_footprint;
  uint64_t ri_instructions;
  uint64_t ri_cycles;
  uint64_t ri_billed_energy;
  uint64_t ri_serviced_energy;
  uint64_t ri_interval_max_phys_footprint;
  uint64_t ri_runnable_time;
};

typedef struct rusage_info_v4 rusage_info_current;
# 365 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/resource.h" 3 4
struct rlimit {
  rlim_t rlim_cur;
  rlim_t rlim_max;
};
# 400 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/resource.h" 3 4
struct proc_rlimit_control_wakeupmon {
  uint32_t wm_flags;
  int32_t wm_rate;
};
# 444 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/resource.h" 3 4
extern "C" {
int getpriority(int, id_t);

int getiopolicy_np(int, int)
    __attribute__((availability(macosx, introduced = 10.5)));

int getrlimit(int, struct rlimit *) __asm("_"
                                          "getrlimit");
int getrusage(int, struct rusage *);
int setpriority(int, id_t, int);

int setiopolicy_np(int, int, int)
    __attribute__((availability(macosx, introduced = 10.5)));

int setrlimit(int, const struct rlimit *) __asm("_"
                                                "setrlimit");
}
# 111 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/wait.h" 2 3 4
# 186 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/wait.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/machine/endian.h" 1 3 4
# 35 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/machine/endian.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/endian.h" 1 3 4
# 99 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/endian.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_endian.h" 1 3 4
# 130 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_endian.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/libkern/_OSByteOrder.h" 1 3 4
# 66 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/libkern/_OSByteOrder.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/libkern/i386/_OSByteOrder.h" 1 3 4
# 44 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/libkern/i386/_OSByteOrder.h" 3 4
static inline __uint16_t _OSSwapInt16(__uint16_t _data) {
  return (__uint16_t)((_data << 8) | (_data >> 8));
}

static inline __uint32_t _OSSwapInt32(__uint32_t _data) {

  return __builtin_bswap32(_data);
}

static inline __uint64_t _OSSwapInt64(__uint64_t _data) {
  return __builtin_bswap64(_data);
}
# 67 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/libkern/_OSByteOrder.h" 2 3 4
# 131 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_endian.h" 2 3 4
# 100 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/endian.h" 2 3 4
# 36 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/machine/endian.h" 2 3 4
# 187 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/wait.h" 2 3 4

union wait {
  int w_status;

  struct {

    unsigned int w_Termsig : 7, w_Coredump : 1, w_Retcode : 8, w_Filler : 16;

  } w_T;

  struct {

    unsigned int w_Stopval : 8, w_Stopsig : 8, w_Filler : 16;

  } w_S;
};
# 247 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/wait.h" 3 4
extern "C" {
pid_t wait(int *) __asm("_"
                        "wait");
pid_t waitpid(pid_t, int *, int) __asm("_"
                                       "waitpid");

int waitid(idtype_t, id_t, siginfo_t *, int) __asm("_"
                                                   "waitid");

pid_t wait3(int *, int, struct rusage *);
pid_t wait4(pid_t, int *, int, struct rusage *);
}
# 67 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/stdlib.h" 2 3 4

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/alloca.h" 1 3 4
# 29 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/alloca.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_size_t.h" 1 3 4
# 30 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/alloca.h" 2 3 4

extern "C" {
void *alloca(size_t);
}
# 69 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/stdlib.h" 2 3 4

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_size_t.h" 1 3 4
# 75 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/stdlib.h" 2 3 4

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_wchar_t.h" 1 3 4
# 82 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/stdlib.h" 2 3 4

typedef struct {
  int quot;
  int rem;
} div_t;

typedef struct {
  long quot;
  long rem;
} ldiv_t;

typedef struct {
  long long quot;
  long long rem;
} lldiv_t;

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_null.h" 1 3 4
# 101 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/stdlib.h" 2 3 4
# 118 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/stdlib.h" 3 4
extern int __mb_cur_max;
# 128 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/stdlib.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/malloc/_malloc.h" 1 3 4
# 36 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/malloc/_malloc.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_size_t.h" 1 3 4
# 37 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/malloc/_malloc.h" 2 3 4

extern "C" {

void *malloc(size_t __size) __attribute__((__warn_unused_result__))
__attribute__((alloc_size(1)));
void *calloc(size_t __count, size_t __size)
    __attribute__((__warn_unused_result__)) __attribute__((alloc_size(1, 2)));
void free(void *);
void *realloc(void *__ptr, size_t __size)
    __attribute__((__warn_unused_result__)) __attribute__((alloc_size(2)));

void *valloc(size_t) __attribute__((alloc_size(1)));

int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
    __attribute__((availability(macosx, introduced = 10.6)));
}
# 129 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/stdlib.h" 2 3 4

extern "C" {
void abort(void) __attribute__((__cold__)) __attribute__((__noreturn__));
int abs(int) __attribute__((__const__));
int atexit(void (*_Nonnull)(void));
double atof(const char *);
int atoi(const char *);
long atol(const char *);

long long atoll(const char *);

void *bsearch(const void *__key, const void *__base, size_t __nel,
              size_t __width,
              int (*_Nonnull __compar)(const void *, const void *));

div_t div(int, int) __attribute__((__const__));
void exit(int) __attribute__((__noreturn__));

char *getenv(const char *);
long labs(long) __attribute__((__const__));
ldiv_t ldiv(long, long) __attribute__((__const__));

long long llabs(long long);
lldiv_t lldiv(long long, long long);

int mblen(const char *__s, size_t __n);
size_t mbstowcs(wchar_t *, const char *, size_t);
int mbtowc(wchar_t *, const char *, size_t);

void qsort(void *__base, size_t __nel, size_t __width,
           int (*_Nonnull __compar)(const void *, const void *));
int rand(void)
    __attribute__((__availability__(swift, unavailable,
                                    message = "Use arc4random instead.")));

void srand(unsigned)
    __attribute__((__availability__(swift, unavailable,
                                    message = "Use arc4random instead.")));
double strtod(const char *, char **) __asm("_"
                                           "strtod");
float strtof(const char *, char **) __asm("_"
                                          "strtof");
long strtol(const char *__str, char **__endptr, int __base);
long double strtold(const char *, char **);

long long strtoll(const char *__str, char **__endptr, int __base);

unsigned long strtoul(const char *__str, char **__endptr, int __base);

unsigned long long strtoull(const char *__str, char **__endptr, int __base);
# 187 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/stdlib.h" 3 4
__attribute__((__availability__(
    swift, unavailable, message = "Use posix_spawn APIs or NSTask instead.")))
__attribute__((availability(macos, introduced = 10.0)))
__attribute__((availability(ios, unavailable)))
__attribute__((availability(watchos, unavailable)))
__attribute__((availability(tvos, unavailable))) int
system(const char *) __asm("_"
                           "system");

size_t wcstombs(char *, const wchar_t *, size_t);
int wctomb(char *, wchar_t);

void _Exit(int) __attribute__((__noreturn__));
long a64l(const char *);
double drand48(void);
char *ecvt(double, int, int *, int *);
double erand48(unsigned short[3]);
char *fcvt(double, int, int *, int *);
char *gcvt(double, int, char *);
int getsubopt(char **, char *const *, char **);
int grantpt(int);

char *initstate(unsigned, char *, size_t);

long jrand48(unsigned short[3])
    __attribute__((__availability__(swift, unavailable,
                                    message = "Use arc4random instead.")));
char *l64a(long);
void lcong48(unsigned short[7]);
long lrand48(void)
    __attribute__((__availability__(swift, unavailable,
                                    message = "Use arc4random instead.")));
char *mktemp(char *);
int mkstemp(char *);
long mrand48(void)
    __attribute__((__availability__(swift, unavailable,
                                    message = "Use arc4random instead.")));
long nrand48(unsigned short[3])
    __attribute__((__availability__(swift, unavailable,
                                    message = "Use arc4random instead.")));
int posix_openpt(int);
char *ptsname(int);

int ptsname_r(int fildes, char *buffer, size_t buflen)
    __attribute__((availability(macos, introduced = 10.13.4)))
    __attribute__((availability(ios, introduced = 11.3)))
    __attribute__((availability(tvos, introduced = 11.3)))
    __attribute__((availability(watchos, introduced = 4.3)));

int putenv(char *) __asm("_"
                         "putenv");
long random(void)
    __attribute__((__availability__(swift, unavailable,
                                    message = "Use arc4random instead.")));
int rand_r(unsigned *)
    __attribute__((__availability__(swift, unavailable,
                                    message = "Use arc4random instead.")));

char *realpath(const char *, char *) __asm("_"
                                           "realpath"
                                           "$DARWIN_EXTSN");

unsigned short *seed48(unsigned short[3]);
int setenv(const char *__name, const char *__value,
           int __overwrite) __asm("_"
                                  "setenv");

void setkey(const char *) __asm("_"
                                "setkey");

char *setstate(const char *);
void srand48(long);

void srandom(unsigned);

int unlockpt(int);

int unsetenv(const char *) __asm("_"
                                 "unsetenv");

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_dev_t.h" 1 3 4
# 31 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_dev_t.h" 3 4
typedef __darwin_dev_t dev_t;
# 261 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/stdlib.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_mode_t.h" 1 3 4
# 31 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_mode_t.h" 3 4
typedef __darwin_mode_t mode_t;
# 262 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/stdlib.h" 2 3 4

uint32_t arc4random(void);
void arc4random_addrandom(unsigned char *, int)
    __attribute__((availability(macosx, introduced = 10.0)))
    __attribute__((availability(macosx, deprecated = 10.12,
                                message = "use arc4random_stir")))
    __attribute__((availability(ios, introduced = 2.0)))
    __attribute__((availability(ios, deprecated = 10.0,
                                message = "use arc4random_stir")))
    __attribute__((availability(tvos, introduced = 2.0)))
    __attribute__((availability(tvos, deprecated = 10.0,
                                message = "use arc4random_stir")))
    __attribute__((availability(watchos, introduced = 1.0)))
    __attribute__((availability(watchos, deprecated = 3.0,
                                message = "use arc4random_stir")));
void arc4random_buf(void *__buf, size_t __nbytes)
    __attribute__((availability(macosx, introduced = 10.7)));
void arc4random_stir(void);
uint32_t arc4random_uniform(uint32_t __upper_bound)
    __attribute__((availability(macosx, introduced = 10.7)));

int atexit_b(void (^_Nonnull)(void))
    __attribute__((availability(macosx, introduced = 10.6)));
void *bsearch_b(const void *__key, const void *__base, size_t __nel,
                size_t __width,
                int (^_Nonnull __compar)(const void *, const void *))
    __attribute__((availability(macosx, introduced = 10.6)));

char *cgetcap(char *, const char *, int);
int cgetclose(void);
int cgetent(char **, char **, const char *);
int cgetfirst(char **, char **);
int cgetmatch(const char *, const char *);
int cgetnext(char **, char **);
int cgetnum(char *, const char *, long *);
int cgetset(const char *);
int cgetstr(char *, const char *, char **);
int cgetustr(char *, const char *, char **);

int daemon(int, int) __asm("_"
                           "daemon"
                           "$1050")
    __attribute__((availability(macosx, introduced = 10.0, deprecated = 10.5,
                                message = "Use posix_spawn APIs instead.")))
    __attribute__((availability(watchos, unavailable)))
    __attribute__((availability(tvos, unavailable)));
char *devname(dev_t, mode_t);
char *devname_r(dev_t, mode_t, char *buf, int len);
char *getbsize(int *, long *);
int getloadavg(double[], int);
const char *getprogname(void);
void setprogname(const char *);
# 309 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/stdlib.h" 3 4
int heapsort(void *__base, size_t __nel, size_t __width,
             int (*_Nonnull __compar)(const void *, const void *));

int heapsort_b(void *__base, size_t __nel, size_t __width,
               int (^_Nonnull __compar)(const void *, const void *)
                   __attribute__((__noescape__)))
    __attribute__((availability(macosx, introduced = 10.6)));

int mergesort(void *__base, size_t __nel, size_t __width,
              int (*_Nonnull __compar)(const void *, const void *));

int mergesort_b(void *__base, size_t __nel, size_t __width,
                int (^_Nonnull __compar)(const void *, const void *)
                    __attribute__((__noescape__)))
    __attribute__((availability(macosx, introduced = 10.6)));

void psort(void *__base, size_t __nel, size_t __width,
           int (*_Nonnull __compar)(const void *, const void *))
    __attribute__((availability(macosx, introduced = 10.6)));

void psort_b(void *__base, size_t __nel, size_t __width,
             int (^_Nonnull __compar)(const void *, const void *)
                 __attribute__((__noescape__)))
    __attribute__((availability(macosx, introduced = 10.6)));

void psort_r(void *__base, size_t __nel, size_t __width, void *,
             int (*_Nonnull __compar)(void *, const void *, const void *))
    __attribute__((availability(macosx, introduced = 10.6)));

void qsort_b(void *__base, size_t __nel, size_t __width,
             int (^_Nonnull __compar)(const void *, const void *)
                 __attribute__((__noescape__)))
    __attribute__((availability(macosx, introduced = 10.6)));

void qsort_r(void *__base, size_t __nel, size_t __width, void *,
             int (*_Nonnull __compar)(void *, const void *, const void *));
int radixsort(const unsigned char **__base, int __nel,
              const unsigned char *__table, unsigned __endbyte);
int rpmatch(const char *)
    __attribute__((availability(macos, introduced = 10.15)))
    __attribute__((availability(ios, introduced = 13.0)))
    __attribute__((availability(tvos, introduced = 13.0)))
    __attribute__((availability(watchos, introduced = 6.0)));
int sradixsort(const unsigned char **__base, int __nel,
               const unsigned char *__table, unsigned __endbyte);
void sranddev(void);
void srandomdev(void);
void *reallocf(void *__ptr, size_t __size) __attribute__((alloc_size(2)));

long long strtoq(const char *__str, char **__endptr, int __base);
unsigned long long strtouq(const char *__str, char **__endptr, int __base);

extern char *suboptarg;
}
# 98 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/stdlib.h" 2 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/math.h" 1 3
# 294 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/math.h" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 295 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/math.h" 2 3
# 298 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/math.h" 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/stdlib.h" 1 3
# 14 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/stdlib.h" 3
# 302 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/math.h" 2 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/math.h" 1 3 4
# 33 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
extern "C" {
# 44 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
typedef float float_t;
typedef double double_t;
# 111 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
extern int __math_errhandling(void);
# 131 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
extern int __fpclassifyf(float);
extern int __fpclassifyd(double);
extern int __fpclassifyl(long double);
# 174 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
inline __attribute__((__always_inline__)) int __inline_isfinitef(float);
inline __attribute__((__always_inline__)) int __inline_isfinited(double);
inline __attribute__((__always_inline__)) int __inline_isfinitel(long double);
inline __attribute__((__always_inline__)) int __inline_isinff(float);
inline __attribute__((__always_inline__)) int __inline_isinfd(double);
inline __attribute__((__always_inline__)) int __inline_isinfl(long double);
inline __attribute__((__always_inline__)) int __inline_isnanf(float);
inline __attribute__((__always_inline__)) int __inline_isnand(double);
inline __attribute__((__always_inline__)) int __inline_isnanl(long double);
inline __attribute__((__always_inline__)) int __inline_isnormalf(float);
inline __attribute__((__always_inline__)) int __inline_isnormald(double);
inline __attribute__((__always_inline__)) int __inline_isnormall(long double);
inline __attribute__((__always_inline__)) int __inline_signbitf(float);
inline __attribute__((__always_inline__)) int __inline_signbitd(double);
inline __attribute__((__always_inline__)) int __inline_signbitl(long double);

inline __attribute__((__always_inline__)) int __inline_isfinitef(float __x) {
  return __x == __x && __builtin_fabsf(__x) != __builtin_inff();
}
inline __attribute__((__always_inline__)) int __inline_isfinited(double __x) {
  return __x == __x && __builtin_fabs(__x) != __builtin_inf();
}
inline __attribute__((__always_inline__)) int
__inline_isfinitel(long double __x) {
  return __x == __x && __builtin_fabsl(__x) != __builtin_infl();
}
inline __attribute__((__always_inline__)) int __inline_isinff(float __x) {
  return __builtin_fabsf(__x) == __builtin_inff();
}
inline __attribute__((__always_inline__)) int __inline_isinfd(double __x) {
  return __builtin_fabs(__x) == __builtin_inf();
}
inline __attribute__((__always_inline__)) int __inline_isinfl(long double __x) {
  return __builtin_fabsl(__x) == __builtin_infl();
}
inline __attribute__((__always_inline__)) int __inline_isnanf(float __x) {
  return __x != __x;
}
inline __attribute__((__always_inline__)) int __inline_isnand(double __x) {
  return __x != __x;
}
inline __attribute__((__always_inline__)) int __inline_isnanl(long double __x) {
  return __x != __x;
}
inline __attribute__((__always_inline__)) int __inline_signbitf(float __x) {
  union {
    float __f;
    unsigned int __u;
  } __u;
  __u.__f = __x;
  return (int)(__u.__u >> 31);
}
inline __attribute__((__always_inline__)) int __inline_signbitd(double __x) {
  union {
    double __f;
    unsigned long long __u;
  } __u;
  __u.__f = __x;
  return (int)(__u.__u >> 63);
}

inline __attribute__((__always_inline__)) int
__inline_signbitl(long double __x) {
  union {
    long double __ld;
    struct {
      unsigned long long __m;
      unsigned short __sexp;
    } __p;
  } __u;
  __u.__ld = __x;
  return (int)(__u.__p.__sexp >> 15);
}

inline __attribute__((__always_inline__)) int __inline_isnormalf(float __x) {
  return __inline_isfinitef(__x) && __builtin_fabsf(__x) >= 1.17549435e-38F;
}
inline __attribute__((__always_inline__)) int __inline_isnormald(double __x) {
  return __inline_isfinited(__x) &&
         __builtin_fabs(__x) >= 2.2250738585072014e-308;
}
inline __attribute__((__always_inline__)) int
__inline_isnormall(long double __x) {
  return __inline_isfinitel(__x) &&
         __builtin_fabsl(__x) >= 3.36210314311209350626e-4932L;
}
# 308 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
extern float acosf(float);
extern double acos(double);
extern long double acosl(long double);

extern float asinf(float);
extern double asin(double);
extern long double asinl(long double);

extern float atanf(float);
extern double atan(double);
extern long double atanl(long double);

extern float atan2f(float, float);
extern double atan2(double, double);
extern long double atan2l(long double, long double);

extern float cosf(float);
extern double cos(double);
extern long double cosl(long double);

extern float sinf(float);
extern double sin(double);
extern long double sinl(long double);

extern float tanf(float);
extern double tan(double);
extern long double tanl(long double);

extern float acoshf(float);
extern double acosh(double);
extern long double acoshl(long double);

extern float asinhf(float);
extern double asinh(double);
extern long double asinhl(long double);

extern float atanhf(float);
extern double atanh(double);
extern long double atanhl(long double);

extern float coshf(float);
extern double cosh(double);
extern long double coshl(long double);

extern float sinhf(float);
extern double sinh(double);
extern long double sinhl(long double);

extern float tanhf(float);
extern double tanh(double);
extern long double tanhl(long double);

extern float expf(float);
extern double exp(double);
extern long double expl(long double);

extern float exp2f(float);
extern double exp2(double);
extern long double exp2l(long double);

extern float expm1f(float);
extern double expm1(double);
extern long double expm1l(long double);

extern float logf(float);
extern double log(double);
extern long double logl(long double);

extern float log10f(float);
extern double log10(double);
extern long double log10l(long double);

extern float log2f(float);
extern double log2(double);
extern long double log2l(long double);

extern float log1pf(float);
extern double log1p(double);
extern long double log1pl(long double);

extern float logbf(float);
extern double logb(double);
extern long double logbl(long double);

extern float modff(float, float *);
extern double modf(double, double *);
extern long double modfl(long double, long double *);

extern float ldexpf(float, int);
extern double ldexp(double, int);
extern long double ldexpl(long double, int);

extern float frexpf(float, int *);
extern double frexp(double, int *);
extern long double frexpl(long double, int *);

extern int ilogbf(float);
extern int ilogb(double);
extern int ilogbl(long double);

extern float scalbnf(float, int);
extern double scalbn(double, int);
extern long double scalbnl(long double, int);

extern float scalblnf(float, long int);
extern double scalbln(double, long int);
extern long double scalblnl(long double, long int);

extern float fabsf(float);
extern double fabs(double);
extern long double fabsl(long double);

extern float cbrtf(float);
extern double cbrt(double);
extern long double cbrtl(long double);

extern float hypotf(float, float);
extern double hypot(double, double);
extern long double hypotl(long double, long double);

extern float powf(float, float);
extern double pow(double, double);
extern long double powl(long double, long double);

extern float sqrtf(float);
extern double sqrt(double);
extern long double sqrtl(long double);

extern float erff(float);
extern double erf(double);
extern long double erfl(long double);

extern float erfcf(float);
extern double erfc(double);
extern long double erfcl(long double);

extern float lgammaf(float);
extern double lgamma(double);
extern long double lgammal(long double);

extern float tgammaf(float);
extern double tgamma(double);
extern long double tgammal(long double);

extern float ceilf(float);
extern double ceil(double);
extern long double ceill(long double);

extern float floorf(float);
extern double floor(double);
extern long double floorl(long double);

extern float nearbyintf(float);
extern double nearbyint(double);
extern long double nearbyintl(long double);

extern float rintf(float);
extern double rint(double);
extern long double rintl(long double);

extern long int lrintf(float);
extern long int lrint(double);
extern long int lrintl(long double);

extern float roundf(float);
extern double round(double);
extern long double roundl(long double);

extern long int lroundf(float);
extern long int lround(double);
extern long int lroundl(long double);

extern long long int llrintf(float);
extern long long int llrint(double);
extern long long int llrintl(long double);

extern long long int llroundf(float);
extern long long int llround(double);
extern long long int llroundl(long double);

extern float truncf(float);
extern double trunc(double);
extern long double truncl(long double);

extern float fmodf(float, float);
extern double fmod(double, double);
extern long double fmodl(long double, long double);

extern float remainderf(float, float);
extern double remainder(double, double);
extern long double remainderl(long double, long double);

extern float remquof(float, float, int *);
extern double remquo(double, double, int *);
extern long double remquol(long double, long double, int *);

extern float copysignf(float, float);
extern double copysign(double, double);
extern long double copysignl(long double, long double);

extern float nanf(const char *);
extern double nan(const char *);
extern long double nanl(const char *);

extern float nextafterf(float, float);
extern double nextafter(double, double);
extern long double nextafterl(long double, long double);

extern double nexttoward(double, long double);
extern float nexttowardf(float, long double);
extern long double nexttowardl(long double, long double);

extern float fdimf(float, float);
extern double fdim(double, double);
extern long double fdiml(long double, long double);

extern float fmaxf(float, float);
extern double fmax(double, double);
extern long double fmaxl(long double, long double);

extern float fminf(float, float);
extern double fmin(double, double);
extern long double fminl(long double, long double);

extern float fmaf(float, float, float);
extern double fma(double, double, double);
extern long double fmal(long double, long double, long double);
# 551 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
extern float __inff(void)
    __attribute__((availability(macos, introduced = 10.0, deprecated = 10.9,
                                message = "use `(float)INFINITY` instead")))
    __attribute__((availability(ios, unavailable)))
    __attribute__((availability(watchos, unavailable)))
    __attribute__((availability(tvos, unavailable)));
extern double __inf(void)
    __attribute__((availability(macos, introduced = 10.0, deprecated = 10.9,
                                message = "use `INFINITY` instead")))
    __attribute__((availability(ios, unavailable)))
    __attribute__((availability(watchos, unavailable)))
    __attribute__((availability(tvos, unavailable)));
extern long double __infl(void) __attribute__((
    availability(macos, introduced = 10.0, deprecated = 10.9,
                 message = "use `(long double)INFINITY` instead")))
__attribute__((availability(ios, unavailable)))
__attribute__((availability(watchos, unavailable)))
__attribute__((availability(tvos, unavailable)));
extern float __nan(void)
    __attribute__((availability(macos, introduced = 10.0, deprecated = 10.14,
                                message = "use `NAN` instead")))
    __attribute__((availability(ios, unavailable)))
    __attribute__((availability(watchos, unavailable)))
    __attribute__((availability(tvos, unavailable)));

extern float lgammaf_r(float, int *)
    __attribute__((availability(macos, introduced = 10.6)))
    __attribute__((availability(ios, introduced = 3.1)));
extern double lgamma_r(double, int *)
    __attribute__((availability(macos, introduced = 10.6)))
    __attribute__((availability(ios, introduced = 3.1)));
extern long double lgammal_r(long double, int *)
    __attribute__((availability(macos, introduced = 10.6)))
    __attribute__((availability(ios, introduced = 3.1)));
# 586 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
extern float __exp10f(float)
    __attribute__((availability(macos, introduced = 10.9)))
    __attribute__((availability(ios, introduced = 7.0)));
extern double __exp10(double)
    __attribute__((availability(macos, introduced = 10.9)))
    __attribute__((availability(ios, introduced = 7.0)));

inline __attribute__((__always_inline__)) void
__sincosf(float __x, float *__sinp, float *__cosp);
inline __attribute__((__always_inline__)) void
__sincos(double __x, double *__sinp, double *__cosp);
# 603 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
extern float __cospif(float)
    __attribute__((availability(macos, introduced = 10.9)))
    __attribute__((availability(ios, introduced = 7.0)));
extern double __cospi(double)
    __attribute__((availability(macos, introduced = 10.9)))
    __attribute__((availability(ios, introduced = 7.0)));
extern float __sinpif(float)
    __attribute__((availability(macos, introduced = 10.9)))
    __attribute__((availability(ios, introduced = 7.0)));
extern double __sinpi(double)
    __attribute__((availability(macos, introduced = 10.9)))
    __attribute__((availability(ios, introduced = 7.0)));
extern float __tanpif(float)
    __attribute__((availability(macos, introduced = 10.9)))
    __attribute__((availability(ios, introduced = 7.0)));
extern double __tanpi(double)
    __attribute__((availability(macos, introduced = 10.9)))
    __attribute__((availability(ios, introduced = 7.0)));
# 634 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
inline __attribute__((__always_inline__)) void
__sincospif(float __x, float *__sinp, float *__cosp);
inline __attribute__((__always_inline__)) void
__sincospi(double __x, double *__sinp, double *__cosp);

struct __float2 {
  float __sinval;
  float __cosval;
};
struct __double2 {
  double __sinval;
  double __cosval;
};

extern struct __float2 __sincosf_stret(float);
extern struct __double2 __sincos_stret(double);
extern struct __float2 __sincospif_stret(float);
extern struct __double2 __sincospi_stret(double);

inline __attribute__((__always_inline__)) void
__sincosf(float __x, float *__sinp, float *__cosp) {
  const struct __float2 __stret = __sincosf_stret(__x);
  *__sinp = __stret.__sinval;
  *__cosp = __stret.__cosval;
}

inline __attribute__((__always_inline__)) void
__sincos(double __x, double *__sinp, double *__cosp) {
  const struct __double2 __stret = __sincos_stret(__x);
  *__sinp = __stret.__sinval;
  *__cosp = __stret.__cosval;
}

inline __attribute__((__always_inline__)) void
__sincospif(float __x, float *__sinp, float *__cosp) {
  const struct __float2 __stret = __sincospif_stret(__x);
  *__sinp = __stret.__sinval;
  *__cosp = __stret.__cosval;
}

inline __attribute__((__always_inline__)) void
__sincospi(double __x, double *__sinp, double *__cosp) {
  const struct __double2 __stret = __sincospi_stret(__x);
  *__sinp = __stret.__sinval;
  *__cosp = __stret.__cosval;
}

extern double j0(double) __attribute__((availability(macos, introduced = 10.0)))
__attribute__((availability(ios, introduced = 3.2)));
extern double j1(double) __attribute__((availability(macos, introduced = 10.0)))
__attribute__((availability(ios, introduced = 3.2)));
extern double jn(int, double)
    __attribute__((availability(macos, introduced = 10.0)))
    __attribute__((availability(ios, introduced = 3.2)));
extern double y0(double) __attribute__((availability(macos, introduced = 10.0)))
__attribute__((availability(ios, introduced = 3.2)));
extern double y1(double) __attribute__((availability(macos, introduced = 10.0)))
__attribute__((availability(ios, introduced = 3.2)));
extern double yn(int, double)
    __attribute__((availability(macos, introduced = 10.0)))
    __attribute__((availability(ios, introduced = 3.2)));
extern double scalb(double, double);
extern int signgam;
# 740 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
extern long int rinttol(double)
    __attribute__((availability(macos, introduced = 10.0, deprecated = 10.9,
                                replacement = "lrint")))
    __attribute__((availability(ios, unavailable)))
    __attribute__((availability(watchos, unavailable)))
    __attribute__((availability(tvos, unavailable)));

extern long int roundtol(double)
    __attribute__((availability(macos, introduced = 10.0, deprecated = 10.9,
                                replacement = "lround")))
    __attribute__((availability(ios, unavailable)))
    __attribute__((availability(watchos, unavailable)))
    __attribute__((availability(tvos, unavailable)));

extern double drem(double, double)
    __attribute__((availability(macos, introduced = 10.0, deprecated = 10.9,
                                replacement = "remainder")))
    __attribute__((availability(ios, unavailable)))
    __attribute__((availability(watchos, unavailable)))
    __attribute__((availability(tvos, unavailable)));

extern int finite(double) __attribute__((
    availability(macos, introduced = 10.0, deprecated = 10.9,
                 message = "Use `isfinite((double)x)` instead.")))
__attribute__((availability(ios, unavailable)))
__attribute__((availability(watchos, unavailable)))
__attribute__((availability(tvos, unavailable)));

extern double gamma(double)
    __attribute__((availability(macos, introduced = 10.0, deprecated = 10.9,
                                replacement = "tgamma")))
    __attribute__((availability(ios, unavailable)))
    __attribute__((availability(watchos, unavailable)))
    __attribute__((availability(tvos, unavailable)));

extern double significand(double) __attribute__((availability(
    macos, introduced = 10.0, deprecated = 10.9,
    message = "Use `2*frexp( )` or `scalbn(x, -ilogb(x))` instead.")))
__attribute__((availability(ios, unavailable)))
__attribute__((availability(watchos, unavailable)))
__attribute__((availability(tvos, unavailable)));
# 770 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/math.h" 3 4
}
# 304 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/math.h" 2 3

extern "C++" {

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/limits" 1 3
# 104 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/limits" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 105 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/limits" 2 3
# 117 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/limits" 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_macros" 1 3
# 121 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/limits" 2 3

namespace std {
inline namespace __1 {

enum float_round_style {
  round_indeterminate = -1,
  round_toward_zero = 0,
  round_to_nearest = 1,
  round_toward_infinity = 2,
  round_toward_neg_infinity = 3
};

enum float_denorm_style {
  denorm_indeterminate = -1,
  denorm_absent = 0,
  denorm_present = 1
};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
class __libcpp_numeric_limits {
protected:
  typedef _Tp type;

  static constexpr const bool is_specialized = false;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  min() noexcept {
    return type();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  max() noexcept {
    return type();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  lowest() noexcept {
    return type();
  }

  static constexpr const int digits = 0;
  static constexpr const int digits10 = 0;
  static constexpr const int max_digits10 = 0;
  static constexpr const bool is_signed = false;
  static constexpr const bool is_integer = false;
  static constexpr const bool is_exact = false;
  static constexpr const int radix = 0;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  epsilon() noexcept {
    return type();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  round_error() noexcept {
    return type();
  }

  static constexpr const int min_exponent = 0;
  static constexpr const int min_exponent10 = 0;
  static constexpr const int max_exponent = 0;
  static constexpr const int max_exponent10 = 0;

  static constexpr const bool has_infinity = false;
  static constexpr const bool has_quiet_NaN = false;
  static constexpr const bool has_signaling_NaN = false;
  static constexpr const float_denorm_style has_denorm = denorm_absent;
  static constexpr const bool has_denorm_loss = false;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  infinity() noexcept {
    return type();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  quiet_NaN() noexcept {
    return type();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  signaling_NaN() noexcept {
    return type();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  denorm_min() noexcept {
    return type();
  }

  static constexpr const bool is_iec559 = false;
  static constexpr const bool is_bounded = false;
  static constexpr const bool is_modulo = false;

  static constexpr const bool traps = false;
  static constexpr const bool tinyness_before = false;
  static constexpr const float_round_style round_style = round_toward_zero;
};

template <class _Tp, int __digits, bool _IsSigned> struct __libcpp_compute_min {
  static constexpr const _Tp value = _Tp(_Tp(1) << __digits);
};

template <class _Tp, int __digits>
struct __libcpp_compute_min<_Tp, __digits, false> {
  static constexpr const _Tp value = _Tp(0);
};

template <class _Tp> class __libcpp_numeric_limits<_Tp, true> {
protected:
  typedef _Tp type;

  static constexpr const bool is_specialized = true;

  static constexpr const bool is_signed = type(-1) < type(0);
  static constexpr const int digits =
      static_cast<int>(sizeof(type) * 8 - is_signed);
  static constexpr const int digits10 = digits * 3 / 10;
  static constexpr const int max_digits10 = 0;
  static constexpr const type __min =
      __libcpp_compute_min<type, digits, is_signed>::value;
  static constexpr const type __max =
      is_signed ? type(type(~0) ^ __min) : type(~0);
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  min() noexcept {
    return __min;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  max() noexcept {
    return __max;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  lowest() noexcept {
    return min();
  }

  static constexpr const bool is_integer = true;
  static constexpr const bool is_exact = true;
  static constexpr const int radix = 2;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  epsilon() noexcept {
    return type(0);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  round_error() noexcept {
    return type(0);
  }

  static constexpr const int min_exponent = 0;
  static constexpr const int min_exponent10 = 0;
  static constexpr const int max_exponent = 0;
  static constexpr const int max_exponent10 = 0;

  static constexpr const bool has_infinity = false;
  static constexpr const bool has_quiet_NaN = false;
  static constexpr const bool has_signaling_NaN = false;
  static constexpr const float_denorm_style has_denorm = denorm_absent;
  static constexpr const bool has_denorm_loss = false;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  infinity() noexcept {
    return type(0);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  quiet_NaN() noexcept {
    return type(0);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  signaling_NaN() noexcept {
    return type(0);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  denorm_min() noexcept {
    return type(0);
  }

  static constexpr const bool is_iec559 = false;
  static constexpr const bool is_bounded = true;
  static constexpr const bool is_modulo = !std::__1::is_signed<_Tp>::value;

  static constexpr const bool traps = true;

  static constexpr const bool tinyness_before = false;
  static constexpr const float_round_style round_style = round_toward_zero;
};

template <> class __libcpp_numeric_limits<bool, true> {
protected:
  typedef bool type;

  static constexpr const bool is_specialized = true;

  static constexpr const bool is_signed = false;
  static constexpr const int digits = 1;
  static constexpr const int digits10 = 0;
  static constexpr const int max_digits10 = 0;
  static constexpr const type __min = false;
  static constexpr const type __max = true;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  min() noexcept {
    return __min;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  max() noexcept {
    return __max;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  lowest() noexcept {
    return min();
  }

  static constexpr const bool is_integer = true;
  static constexpr const bool is_exact = true;
  static constexpr const int radix = 2;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  epsilon() noexcept {
    return type(0);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  round_error() noexcept {
    return type(0);
  }

  static constexpr const int min_exponent = 0;
  static constexpr const int min_exponent10 = 0;
  static constexpr const int max_exponent = 0;
  static constexpr const int max_exponent10 = 0;

  static constexpr const bool has_infinity = false;
  static constexpr const bool has_quiet_NaN = false;
  static constexpr const bool has_signaling_NaN = false;
  static constexpr const float_denorm_style has_denorm = denorm_absent;
  static constexpr const bool has_denorm_loss = false;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  infinity() noexcept {
    return type(0);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  quiet_NaN() noexcept {
    return type(0);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  signaling_NaN() noexcept {
    return type(0);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  denorm_min() noexcept {
    return type(0);
  }

  static constexpr const bool is_iec559 = false;
  static constexpr const bool is_bounded = true;
  static constexpr const bool is_modulo = false;

  static constexpr const bool traps = false;
  static constexpr const bool tinyness_before = false;
  static constexpr const float_round_style round_style = round_toward_zero;
};

template <> class __libcpp_numeric_limits<float, true> {
protected:
  typedef float type;

  static constexpr const bool is_specialized = true;

  static constexpr const bool is_signed = true;
  static constexpr const int digits = 24;
  static constexpr const int digits10 = 6;
  static constexpr const int max_digits10 = 2 + (digits * 30103l) / 100000l;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  min() noexcept {
    return 1.17549435e-38F;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  max() noexcept {
    return 3.40282347e+38F;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  lowest() noexcept {
    return -max();
  }

  static constexpr const bool is_integer = false;
  static constexpr const bool is_exact = false;
  static constexpr const int radix = 2;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  epsilon() noexcept {
    return 1.19209290e-7F;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  round_error() noexcept {
    return 0.5F;
  }

  static constexpr const int min_exponent = (-125);
  static constexpr const int min_exponent10 = (-37);
  static constexpr const int max_exponent = 128;
  static constexpr const int max_exponent10 = 38;

  static constexpr const bool has_infinity = true;
  static constexpr const bool has_quiet_NaN = true;
  static constexpr const bool has_signaling_NaN = true;
  static constexpr const float_denorm_style has_denorm = denorm_present;
  static constexpr const bool has_denorm_loss = false;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  infinity() noexcept {
    return __builtin_huge_valf();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  quiet_NaN() noexcept {
    return __builtin_nanf("");
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  signaling_NaN() noexcept {
    return __builtin_nansf("");
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  denorm_min() noexcept {
    return 1.40129846e-45F;
  }

  static constexpr const bool is_iec559 = true;
  static constexpr const bool is_bounded = true;
  static constexpr const bool is_modulo = false;

  static constexpr const bool traps = false;
  static constexpr const bool tinyness_before = false;
  static constexpr const float_round_style round_style = round_to_nearest;
};

template <> class __libcpp_numeric_limits<double, true> {
protected:
  typedef double type;

  static constexpr const bool is_specialized = true;

  static constexpr const bool is_signed = true;
  static constexpr const int digits = 53;
  static constexpr const int digits10 = 15;
  static constexpr const int max_digits10 = 2 + (digits * 30103l) / 100000l;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  min() noexcept {
    return 2.2250738585072014e-308;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  max() noexcept {
    return 1.7976931348623157e+308;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  lowest() noexcept {
    return -max();
  }

  static constexpr const bool is_integer = false;
  static constexpr const bool is_exact = false;
  static constexpr const int radix = 2;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  epsilon() noexcept {
    return 2.2204460492503131e-16;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  round_error() noexcept {
    return 0.5;
  }

  static constexpr const int min_exponent = (-1021);
  static constexpr const int min_exponent10 = (-307);
  static constexpr const int max_exponent = 1024;
  static constexpr const int max_exponent10 = 308;

  static constexpr const bool has_infinity = true;
  static constexpr const bool has_quiet_NaN = true;
  static constexpr const bool has_signaling_NaN = true;
  static constexpr const float_denorm_style has_denorm = denorm_present;
  static constexpr const bool has_denorm_loss = false;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  infinity() noexcept {
    return __builtin_huge_val();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  quiet_NaN() noexcept {
    return __builtin_nan("");
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  signaling_NaN() noexcept {
    return __builtin_nans("");
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  denorm_min() noexcept {
    return 4.9406564584124654e-324;
  }

  static constexpr const bool is_iec559 = true;
  static constexpr const bool is_bounded = true;
  static constexpr const bool is_modulo = false;

  static constexpr const bool traps = false;
  static constexpr const bool tinyness_before = false;
  static constexpr const float_round_style round_style = round_to_nearest;
};

template <> class __libcpp_numeric_limits<long double, true> {
protected:
  typedef long double type;

  static constexpr const bool is_specialized = true;

  static constexpr const bool is_signed = true;
  static constexpr const int digits = 64;
  static constexpr const int digits10 = 18;
  static constexpr const int max_digits10 = 2 + (digits * 30103l) / 100000l;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  min() noexcept {
    return 3.36210314311209350626e-4932L;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  max() noexcept {
    return 1.18973149535723176502e+4932L;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  lowest() noexcept {
    return -max();
  }

  static constexpr const bool is_integer = false;
  static constexpr const bool is_exact = false;
  static constexpr const int radix = 2;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  epsilon() noexcept {
    return 1.08420217248550443401e-19L;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  round_error() noexcept {
    return 0.5L;
  }

  static constexpr const int min_exponent = (-16381);
  static constexpr const int min_exponent10 = (-4931);
  static constexpr const int max_exponent = 16384;
  static constexpr const int max_exponent10 = 4932;

  static constexpr const bool has_infinity = true;
  static constexpr const bool has_quiet_NaN = true;
  static constexpr const bool has_signaling_NaN = true;
  static constexpr const float_denorm_style has_denorm = denorm_present;
  static constexpr const bool has_denorm_loss = false;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  infinity() noexcept {
    return __builtin_huge_vall();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  quiet_NaN() noexcept {
    return __builtin_nanl("");
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  signaling_NaN() noexcept {
    return __builtin_nansl("");
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  denorm_min() noexcept {
    return 3.64519953188247460253e-4951L;
  }

  static constexpr const bool is_iec559 = true;

  static constexpr const bool is_bounded = true;
  static constexpr const bool is_modulo = false;

  static constexpr const bool traps = false;
  static constexpr const bool tinyness_before = false;
  static constexpr const float_round_style round_style = round_to_nearest;
};

template <class _Tp>
class __attribute__((__type_visibility__("default"))) numeric_limits
    : private __libcpp_numeric_limits<typename remove_cv<_Tp>::type> {
  typedef __libcpp_numeric_limits<typename remove_cv<_Tp>::type> __base;
  typedef typename __base::type type;

public:
  static constexpr const bool is_specialized = __base::is_specialized;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  min() noexcept {
    return __base::min();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  max() noexcept {
    return __base::max();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  lowest() noexcept {
    return __base::lowest();
  }

  static constexpr const int digits = __base::digits;
  static constexpr const int digits10 = __base::digits10;
  static constexpr const int max_digits10 = __base::max_digits10;
  static constexpr const bool is_signed = __base::is_signed;
  static constexpr const bool is_integer = __base::is_integer;
  static constexpr const bool is_exact = __base::is_exact;
  static constexpr const int radix = __base::radix;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  epsilon() noexcept {
    return __base::epsilon();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  round_error() noexcept {
    return __base::round_error();
  }

  static constexpr const int min_exponent = __base::min_exponent;
  static constexpr const int min_exponent10 = __base::min_exponent10;
  static constexpr const int max_exponent = __base::max_exponent;
  static constexpr const int max_exponent10 = __base::max_exponent10;

  static constexpr const bool has_infinity = __base::has_infinity;
  static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
  static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
  static constexpr const float_denorm_style has_denorm = __base::has_denorm;
  static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  infinity() noexcept {
    return __base::infinity();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  quiet_NaN() noexcept {
    return __base::quiet_NaN();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  signaling_NaN() noexcept {
    return __base::signaling_NaN();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  denorm_min() noexcept {
    return __base::denorm_min();
  }

  static constexpr const bool is_iec559 = __base::is_iec559;
  static constexpr const bool is_bounded = __base::is_bounded;
  static constexpr const bool is_modulo = __base::is_modulo;

  static constexpr const bool traps = __base::traps;
  static constexpr const bool tinyness_before = __base::tinyness_before;
  static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp> constexpr const bool numeric_limits<_Tp>::is_specialized;
template <class _Tp> constexpr const int numeric_limits<_Tp>::digits;
template <class _Tp> constexpr const int numeric_limits<_Tp>::digits10;
template <class _Tp> constexpr const int numeric_limits<_Tp>::max_digits10;
template <class _Tp> constexpr const bool numeric_limits<_Tp>::is_signed;
template <class _Tp> constexpr const bool numeric_limits<_Tp>::is_integer;
template <class _Tp> constexpr const bool numeric_limits<_Tp>::is_exact;
template <class _Tp> constexpr const int numeric_limits<_Tp>::radix;
template <class _Tp> constexpr const int numeric_limits<_Tp>::min_exponent;
template <class _Tp> constexpr const int numeric_limits<_Tp>::min_exponent10;
template <class _Tp> constexpr const int numeric_limits<_Tp>::max_exponent;
template <class _Tp> constexpr const int numeric_limits<_Tp>::max_exponent10;
template <class _Tp> constexpr const bool numeric_limits<_Tp>::has_infinity;
template <class _Tp> constexpr const bool numeric_limits<_Tp>::has_quiet_NaN;
template <class _Tp>
constexpr const bool numeric_limits<_Tp>::has_signaling_NaN;
template <class _Tp>
constexpr const float_denorm_style numeric_limits<_Tp>::has_denorm;
template <class _Tp> constexpr const bool numeric_limits<_Tp>::has_denorm_loss;
template <class _Tp> constexpr const bool numeric_limits<_Tp>::is_iec559;
template <class _Tp> constexpr const bool numeric_limits<_Tp>::is_bounded;
template <class _Tp> constexpr const bool numeric_limits<_Tp>::is_modulo;
template <class _Tp> constexpr const bool numeric_limits<_Tp>::traps;
template <class _Tp> constexpr const bool numeric_limits<_Tp>::tinyness_before;
template <class _Tp>
constexpr const float_round_style numeric_limits<_Tp>::round_style;

template <class _Tp>
class __attribute__((__type_visibility__("default")))
numeric_limits<const _Tp> : private numeric_limits<_Tp> {
  typedef numeric_limits<_Tp> __base;
  typedef _Tp type;

public:
  static constexpr const bool is_specialized = __base::is_specialized;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  min() noexcept {
    return __base::min();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  max() noexcept {
    return __base::max();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  lowest() noexcept {
    return __base::lowest();
  }

  static constexpr const int digits = __base::digits;
  static constexpr const int digits10 = __base::digits10;
  static constexpr const int max_digits10 = __base::max_digits10;
  static constexpr const bool is_signed = __base::is_signed;
  static constexpr const bool is_integer = __base::is_integer;
  static constexpr const bool is_exact = __base::is_exact;
  static constexpr const int radix = __base::radix;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  epsilon() noexcept {
    return __base::epsilon();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  round_error() noexcept {
    return __base::round_error();
  }

  static constexpr const int min_exponent = __base::min_exponent;
  static constexpr const int min_exponent10 = __base::min_exponent10;
  static constexpr const int max_exponent = __base::max_exponent;
  static constexpr const int max_exponent10 = __base::max_exponent10;

  static constexpr const bool has_infinity = __base::has_infinity;
  static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
  static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
  static constexpr const float_denorm_style has_denorm = __base::has_denorm;
  static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  infinity() noexcept {
    return __base::infinity();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  quiet_NaN() noexcept {
    return __base::quiet_NaN();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  signaling_NaN() noexcept {
    return __base::signaling_NaN();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  denorm_min() noexcept {
    return __base::denorm_min();
  }

  static constexpr const bool is_iec559 = __base::is_iec559;
  static constexpr const bool is_bounded = __base::is_bounded;
  static constexpr const bool is_modulo = __base::is_modulo;

  static constexpr const bool traps = __base::traps;
  static constexpr const bool tinyness_before = __base::tinyness_before;
  static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp>
constexpr const bool numeric_limits<const _Tp>::is_specialized;
template <class _Tp> constexpr const int numeric_limits<const _Tp>::digits;
template <class _Tp> constexpr const int numeric_limits<const _Tp>::digits10;
template <class _Tp>
constexpr const int numeric_limits<const _Tp>::max_digits10;
template <class _Tp> constexpr const bool numeric_limits<const _Tp>::is_signed;
template <class _Tp> constexpr const bool numeric_limits<const _Tp>::is_integer;
template <class _Tp> constexpr const bool numeric_limits<const _Tp>::is_exact;
template <class _Tp> constexpr const int numeric_limits<const _Tp>::radix;
template <class _Tp>
constexpr const int numeric_limits<const _Tp>::min_exponent;
template <class _Tp>
constexpr const int numeric_limits<const _Tp>::min_exponent10;
template <class _Tp>
constexpr const int numeric_limits<const _Tp>::max_exponent;
template <class _Tp>
constexpr const int numeric_limits<const _Tp>::max_exponent10;
template <class _Tp>
constexpr const bool numeric_limits<const _Tp>::has_infinity;
template <class _Tp>
constexpr const bool numeric_limits<const _Tp>::has_quiet_NaN;
template <class _Tp>
constexpr const bool numeric_limits<const _Tp>::has_signaling_NaN;
template <class _Tp>
constexpr const float_denorm_style numeric_limits<const _Tp>::has_denorm;
template <class _Tp>
constexpr const bool numeric_limits<const _Tp>::has_denorm_loss;
template <class _Tp> constexpr const bool numeric_limits<const _Tp>::is_iec559;
template <class _Tp> constexpr const bool numeric_limits<const _Tp>::is_bounded;
template <class _Tp> constexpr const bool numeric_limits<const _Tp>::is_modulo;
template <class _Tp> constexpr const bool numeric_limits<const _Tp>::traps;
template <class _Tp>
constexpr const bool numeric_limits<const _Tp>::tinyness_before;
template <class _Tp>
constexpr const float_round_style numeric_limits<const _Tp>::round_style;

template <class _Tp>
class __attribute__((__type_visibility__("default")))
numeric_limits<volatile _Tp> : private numeric_limits<_Tp> {
  typedef numeric_limits<_Tp> __base;
  typedef _Tp type;

public:
  static constexpr const bool is_specialized = __base::is_specialized;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  min() noexcept {
    return __base::min();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  max() noexcept {
    return __base::max();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  lowest() noexcept {
    return __base::lowest();
  }

  static constexpr const int digits = __base::digits;
  static constexpr const int digits10 = __base::digits10;
  static constexpr const int max_digits10 = __base::max_digits10;
  static constexpr const bool is_signed = __base::is_signed;
  static constexpr const bool is_integer = __base::is_integer;
  static constexpr const bool is_exact = __base::is_exact;
  static constexpr const int radix = __base::radix;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  epsilon() noexcept {
    return __base::epsilon();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  round_error() noexcept {
    return __base::round_error();
  }

  static constexpr const int min_exponent = __base::min_exponent;
  static constexpr const int min_exponent10 = __base::min_exponent10;
  static constexpr const int max_exponent = __base::max_exponent;
  static constexpr const int max_exponent10 = __base::max_exponent10;

  static constexpr const bool has_infinity = __base::has_infinity;
  static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
  static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
  static constexpr const float_denorm_style has_denorm = __base::has_denorm;
  static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  infinity() noexcept {
    return __base::infinity();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  quiet_NaN() noexcept {
    return __base::quiet_NaN();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  signaling_NaN() noexcept {
    return __base::signaling_NaN();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  denorm_min() noexcept {
    return __base::denorm_min();
  }

  static constexpr const bool is_iec559 = __base::is_iec559;
  static constexpr const bool is_bounded = __base::is_bounded;
  static constexpr const bool is_modulo = __base::is_modulo;

  static constexpr const bool traps = __base::traps;
  static constexpr const bool tinyness_before = __base::tinyness_before;
  static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp>
constexpr const bool numeric_limits<volatile _Tp>::is_specialized;
template <class _Tp> constexpr const int numeric_limits<volatile _Tp>::digits;
template <class _Tp> constexpr const int numeric_limits<volatile _Tp>::digits10;
template <class _Tp>
constexpr const int numeric_limits<volatile _Tp>::max_digits10;
template <class _Tp>
constexpr const bool numeric_limits<volatile _Tp>::is_signed;
template <class _Tp>
constexpr const bool numeric_limits<volatile _Tp>::is_integer;
template <class _Tp>
constexpr const bool numeric_limits<volatile _Tp>::is_exact;
template <class _Tp> constexpr const int numeric_limits<volatile _Tp>::radix;
template <class _Tp>
constexpr const int numeric_limits<volatile _Tp>::min_exponent;
template <class _Tp>
constexpr const int numeric_limits<volatile _Tp>::min_exponent10;
template <class _Tp>
constexpr const int numeric_limits<volatile _Tp>::max_exponent;
template <class _Tp>
constexpr const int numeric_limits<volatile _Tp>::max_exponent10;
template <class _Tp>
constexpr const bool numeric_limits<volatile _Tp>::has_infinity;
template <class _Tp>
constexpr const bool numeric_limits<volatile _Tp>::has_quiet_NaN;
template <class _Tp>
constexpr const bool numeric_limits<volatile _Tp>::has_signaling_NaN;
template <class _Tp>
constexpr const float_denorm_style numeric_limits<volatile _Tp>::has_denorm;
template <class _Tp>
constexpr const bool numeric_limits<volatile _Tp>::has_denorm_loss;
template <class _Tp>
constexpr const bool numeric_limits<volatile _Tp>::is_iec559;
template <class _Tp>
constexpr const bool numeric_limits<volatile _Tp>::is_bounded;
template <class _Tp>
constexpr const bool numeric_limits<volatile _Tp>::is_modulo;
template <class _Tp> constexpr const bool numeric_limits<volatile _Tp>::traps;
template <class _Tp>
constexpr const bool numeric_limits<volatile _Tp>::tinyness_before;
template <class _Tp>
constexpr const float_round_style numeric_limits<volatile _Tp>::round_style;

template <class _Tp>
class __attribute__((__type_visibility__("default")))
numeric_limits<const volatile _Tp> : private numeric_limits<_Tp> {
  typedef numeric_limits<_Tp> __base;
  typedef _Tp type;

public:
  static constexpr const bool is_specialized = __base::is_specialized;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  min() noexcept {
    return __base::min();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  max() noexcept {
    return __base::max();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  lowest() noexcept {
    return __base::lowest();
  }

  static constexpr const int digits = __base::digits;
  static constexpr const int digits10 = __base::digits10;
  static constexpr const int max_digits10 = __base::max_digits10;
  static constexpr const bool is_signed = __base::is_signed;
  static constexpr const bool is_integer = __base::is_integer;
  static constexpr const bool is_exact = __base::is_exact;
  static constexpr const int radix = __base::radix;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  epsilon() noexcept {
    return __base::epsilon();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  round_error() noexcept {
    return __base::round_error();
  }

  static constexpr const int min_exponent = __base::min_exponent;
  static constexpr const int min_exponent10 = __base::min_exponent10;
  static constexpr const int max_exponent = __base::max_exponent;
  static constexpr const int max_exponent10 = __base::max_exponent10;

  static constexpr const bool has_infinity = __base::has_infinity;
  static constexpr const bool has_quiet_NaN = __base::has_quiet_NaN;
  static constexpr const bool has_signaling_NaN = __base::has_signaling_NaN;
  static constexpr const float_denorm_style has_denorm = __base::has_denorm;
  static constexpr const bool has_denorm_loss = __base::has_denorm_loss;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  infinity() noexcept {
    return __base::infinity();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  quiet_NaN() noexcept {
    return __base::quiet_NaN();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  signaling_NaN() noexcept {
    return __base::signaling_NaN();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr type
  denorm_min() noexcept {
    return __base::denorm_min();
  }

  static constexpr const bool is_iec559 = __base::is_iec559;
  static constexpr const bool is_bounded = __base::is_bounded;
  static constexpr const bool is_modulo = __base::is_modulo;

  static constexpr const bool traps = __base::traps;
  static constexpr const bool tinyness_before = __base::tinyness_before;
  static constexpr const float_round_style round_style = __base::round_style;
};

template <class _Tp>
constexpr const bool numeric_limits<const volatile _Tp>::is_specialized;
template <class _Tp>
constexpr const int numeric_limits<const volatile _Tp>::digits;
template <class _Tp>
constexpr const int numeric_limits<const volatile _Tp>::digits10;
template <class _Tp>
constexpr const int numeric_limits<const volatile _Tp>::max_digits10;
template <class _Tp>
constexpr const bool numeric_limits<const volatile _Tp>::is_signed;
template <class _Tp>
constexpr const bool numeric_limits<const volatile _Tp>::is_integer;
template <class _Tp>
constexpr const bool numeric_limits<const volatile _Tp>::is_exact;
template <class _Tp>
constexpr const int numeric_limits<const volatile _Tp>::radix;
template <class _Tp>
constexpr const int numeric_limits<const volatile _Tp>::min_exponent;
template <class _Tp>
constexpr const int numeric_limits<const volatile _Tp>::min_exponent10;
template <class _Tp>
constexpr const int numeric_limits<const volatile _Tp>::max_exponent;
template <class _Tp>
constexpr const int numeric_limits<const volatile _Tp>::max_exponent10;
template <class _Tp>
constexpr const bool numeric_limits<const volatile _Tp>::has_infinity;
template <class _Tp>
constexpr const bool numeric_limits<const volatile _Tp>::has_quiet_NaN;
template <class _Tp>
constexpr const bool numeric_limits<const volatile _Tp>::has_signaling_NaN;
template <class _Tp>
constexpr const float_denorm_style
    numeric_limits<const volatile _Tp>::has_denorm;
template <class _Tp>
constexpr const bool numeric_limits<const volatile _Tp>::has_denorm_loss;
template <class _Tp>
constexpr const bool numeric_limits<const volatile _Tp>::is_iec559;
template <class _Tp>
constexpr const bool numeric_limits<const volatile _Tp>::is_bounded;
template <class _Tp>
constexpr const bool numeric_limits<const volatile _Tp>::is_modulo;
template <class _Tp>
constexpr const bool numeric_limits<const volatile _Tp>::traps;
template <class _Tp>
constexpr const bool numeric_limits<const volatile _Tp>::tinyness_before;
template <class _Tp>
constexpr const float_round_style
    numeric_limits<const volatile _Tp>::round_style;

} // namespace __1
} // namespace std
# 313 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/math.h" 2 3

template <class _A1>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) bool
__libcpp_signbit(_A1 __lcpp_x) noexcept {
  return (sizeof(__lcpp_x) == sizeof(float)
              ? __inline_signbitf((float)(__lcpp_x))
          : sizeof(__lcpp_x) == sizeof(double)
              ? __inline_signbitd((double)(__lcpp_x))
              : __inline_signbitl((long double)(__lcpp_x)));
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_floating_point<_A1>::value, bool>::type
signbit(_A1 __lcpp_x) noexcept {
  return __libcpp_signbit((typename std::__promote<_A1>::type)__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) typename std::enable_if<
    std::is_integral<_A1>::value && std::is_signed<_A1>::value, bool>::type
signbit(_A1 __lcpp_x) noexcept {
  return __lcpp_x < 0;
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) typename std::enable_if<
    std::is_integral<_A1>::value && !std::is_signed<_A1>::value, bool>::type
signbit(_A1) noexcept {
  return false;
}
# 380 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/math.h" 3
template <class _A1>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) int
__libcpp_fpclassify(_A1 __lcpp_x) noexcept {
  return (sizeof(__lcpp_x) == sizeof(float) ? __fpclassifyf((float)(__lcpp_x))
          : sizeof(__lcpp_x) == sizeof(double)
              ? __fpclassifyd((double)(__lcpp_x))
              : __fpclassifyl((long double)(__lcpp_x)));
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_floating_point<_A1>::value, int>::type
fpclassify(_A1 __lcpp_x) noexcept {
  return __libcpp_fpclassify((typename std::__promote<_A1>::type)__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, int>::type
fpclassify(_A1 __lcpp_x) noexcept {
  return __lcpp_x == 0 ? 3 : 4;
}
# 426 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/math.h" 3
template <class _A1>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) bool
__libcpp_isfinite(_A1 __lcpp_x) noexcept {
  return (sizeof(__lcpp_x) == sizeof(float)
              ? __inline_isfinitef((float)(__lcpp_x))
          : sizeof(__lcpp_x) == sizeof(double)
              ? __inline_isfinited((double)(__lcpp_x))
              : __inline_isfinitel((long double)(__lcpp_x)));
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_arithmetic<_A1>::value &&
                            std::numeric_limits<_A1>::has_infinity,
                        bool>::type
isfinite(_A1 __lcpp_x) noexcept {
  return __libcpp_isfinite((typename std::__promote<_A1>::type)__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_arithmetic<_A1>::value &&
                            !std::numeric_limits<_A1>::has_infinity,
                        bool>::type
isfinite(_A1) noexcept {
  return true;
}

template <class _A1>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) bool
__libcpp_isinf(_A1 __lcpp_x) noexcept {
  return (sizeof(__lcpp_x) == sizeof(float) ? __inline_isinff((float)(__lcpp_x))
          : sizeof(__lcpp_x) == sizeof(double)
              ? __inline_isinfd((double)(__lcpp_x))
              : __inline_isinfl((long double)(__lcpp_x)));
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_arithmetic<_A1>::value &&
                            std::numeric_limits<_A1>::has_infinity,
                        bool>::type
isinf(_A1 __lcpp_x) noexcept {
  return __libcpp_isinf((typename std::__promote<_A1>::type)__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_arithmetic<_A1>::value &&
                            !std::numeric_limits<_A1>::has_infinity,
                        bool>::type
isinf(_A1) noexcept {
  return false;
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
isinf(float __lcpp_x) noexcept {
  return __libcpp_isinf(__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) __attribute__((__enable_if__(true, ""))) bool
isinf(double __lcpp_x) noexcept {
  return __libcpp_isinf(__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
isinf(long double __lcpp_x) noexcept {
  return __libcpp_isinf(__lcpp_x);
}
# 508 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/math.h" 3
template <class _A1>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) bool
__libcpp_isnan(_A1 __lcpp_x) noexcept {
  return (sizeof(__lcpp_x) == sizeof(float) ? __inline_isnanf((float)(__lcpp_x))
          : sizeof(__lcpp_x) == sizeof(double)
              ? __inline_isnand((double)(__lcpp_x))
              : __inline_isnanl((long double)(__lcpp_x)));
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_floating_point<_A1>::value, bool>::type
isnan(_A1 __lcpp_x) noexcept {
  return __libcpp_isnan((typename std::__promote<_A1>::type)__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, bool>::type
isnan(_A1) noexcept {
  return false;
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
isnan(float __lcpp_x) noexcept {
  return __libcpp_isnan(__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) __attribute__((__enable_if__(true, ""))) bool
isnan(double __lcpp_x) noexcept {
  return __libcpp_isnan(__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
isnan(long double __lcpp_x) noexcept {
  return __libcpp_isnan(__lcpp_x);
}
# 552 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/math.h" 3
template <class _A1>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) bool
__libcpp_isnormal(_A1 __lcpp_x) noexcept {
  return (sizeof(__lcpp_x) == sizeof(float)
              ? __inline_isnormalf((float)(__lcpp_x))
          : sizeof(__lcpp_x) == sizeof(double)
              ? __inline_isnormald((double)(__lcpp_x))
              : __inline_isnormall((long double)(__lcpp_x)));
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_floating_point<_A1>::value, bool>::type
isnormal(_A1 __lcpp_x) noexcept {
  return __libcpp_isnormal((typename std::__promote<_A1>::type)__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, bool>::type
isnormal(_A1 __lcpp_x) noexcept {
  return __lcpp_x != 0;
}

template <class _A1, class _A2>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) bool
__libcpp_isgreater(_A1 __lcpp_x, _A2 __lcpp_y) noexcept {
  return __builtin_isgreater((__lcpp_x), (__lcpp_y));
}

template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_arithmetic<_A1>::value &&
                            std::is_arithmetic<_A2>::value,
                        bool>::type
isgreater(_A1 __lcpp_x, _A2 __lcpp_y) noexcept {
  typedef typename std::__promote<_A1, _A2>::type type;
  return __libcpp_isgreater((type)__lcpp_x, (type)__lcpp_y);
}

template <class _A1, class _A2>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) bool
__libcpp_isgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) noexcept {
  return __builtin_isgreaterequal((__lcpp_x), (__lcpp_y));
}

template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_arithmetic<_A1>::value &&
                            std::is_arithmetic<_A2>::value,
                        bool>::type
isgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) noexcept {
  typedef typename std::__promote<_A1, _A2>::type type;
  return __libcpp_isgreaterequal((type)__lcpp_x, (type)__lcpp_y);
}

template <class _A1, class _A2>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) bool
__libcpp_isless(_A1 __lcpp_x, _A2 __lcpp_y) noexcept {
  return __builtin_isless((__lcpp_x), (__lcpp_y));
}

template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_arithmetic<_A1>::value &&
                            std::is_arithmetic<_A2>::value,
                        bool>::type
isless(_A1 __lcpp_x, _A2 __lcpp_y) noexcept {
  typedef typename std::__promote<_A1, _A2>::type type;
  return __libcpp_isless((type)__lcpp_x, (type)__lcpp_y);
}

template <class _A1, class _A2>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) bool
__libcpp_islessequal(_A1 __lcpp_x, _A2 __lcpp_y) noexcept {
  return __builtin_islessequal((__lcpp_x), (__lcpp_y));
}

template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_arithmetic<_A1>::value &&
                            std::is_arithmetic<_A2>::value,
                        bool>::type
islessequal(_A1 __lcpp_x, _A2 __lcpp_y) noexcept {
  typedef typename std::__promote<_A1, _A2>::type type;
  return __libcpp_islessequal((type)__lcpp_x, (type)__lcpp_y);
}

template <class _A1, class _A2>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) bool
__libcpp_islessgreater(_A1 __lcpp_x, _A2 __lcpp_y) noexcept {
  return __builtin_islessgreater((__lcpp_x), (__lcpp_y));
}

template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_arithmetic<_A1>::value &&
                            std::is_arithmetic<_A2>::value,
                        bool>::type
islessgreater(_A1 __lcpp_x, _A2 __lcpp_y) noexcept {
  typedef typename std::__promote<_A1, _A2>::type type;
  return __libcpp_islessgreater((type)__lcpp_x, (type)__lcpp_y);
}

template <class _A1, class _A2>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) bool
__libcpp_isunordered(_A1 __lcpp_x, _A2 __lcpp_y) noexcept {
  return __builtin_isunordered((__lcpp_x), (__lcpp_y));
}

template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_arithmetic<_A1>::value &&
                            std::is_arithmetic<_A2>::value,
                        bool>::type
isunordered(_A1 __lcpp_x, _A2 __lcpp_y) noexcept {
  typedef typename std::__promote<_A1, _A2>::type type;
  return __libcpp_isunordered((type)__lcpp_x, (type)__lcpp_y);
}
# 768 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/math.h" 3
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long
abs(long __x) noexcept {
  return ::labs(__x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long long
abs(long long __x) noexcept {
  return ::llabs(__x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
abs(float __lcpp_x) noexcept {
  return ::fabsf(__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) double
abs(double __lcpp_x) noexcept {
  return ::fabs(__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
abs(long double __lcpp_x) noexcept {
  return ::fabsl(__lcpp_x);
}
# 804 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/math.h" 3
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) ldiv_t
div(long __x, long __y) noexcept {
  return ::ldiv(__x, __y);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) lldiv_t
div(long long __x, long long __y) noexcept {
  return ::lldiv(__x, __y);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
acos(float __lcpp_x) noexcept {
  return ::acosf(__lcpp_x);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
acos(long double __lcpp_x) noexcept {
  return ::acosl(__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
acos(_A1 __lcpp_x) noexcept {
  return ::acos((double)__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
asin(float __lcpp_x) noexcept {
  return ::asinf(__lcpp_x);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
asin(long double __lcpp_x) noexcept {
  return ::asinl(__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
asin(_A1 __lcpp_x) noexcept {
  return ::asin((double)__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
atan(float __lcpp_x) noexcept {
  return ::atanf(__lcpp_x);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
atan(long double __lcpp_x) noexcept {
  return ::atanl(__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
atan(_A1 __lcpp_x) noexcept {
  return ::atan((double)__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
atan2(float __lcpp_y, float __lcpp_x) noexcept {
  return ::atan2f(__lcpp_y, __lcpp_x);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
atan2(long double __lcpp_y, long double __lcpp_x) noexcept {
  return ::atan2l(__lcpp_y, __lcpp_x);
}

template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::_EnableIf<std::is_arithmetic<_A1>::value &&
                            std::is_arithmetic<_A2>::value,
                        std::__promote<_A1, _A2>>::type
atan2(_A1 __lcpp_y, _A2 __lcpp_x) noexcept {
  typedef typename std::__promote<_A1, _A2>::type __result_type;
  static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                   std::_IsSame<_A2, __result_type>::value)),
                "");
  return ::atan2((__result_type)__lcpp_y, (__result_type)__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
ceil(float __lcpp_x) noexcept {
  return ::ceilf(__lcpp_x);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
ceil(long double __lcpp_x) noexcept {
  return ::ceill(__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
ceil(_A1 __lcpp_x) noexcept {
  return ::ceil((double)__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
cos(float __lcpp_x) noexcept {
  return ::cosf(__lcpp_x);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
cos(long double __lcpp_x) noexcept {
  return ::cosl(__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
cos(_A1 __lcpp_x) noexcept {
  return ::cos((double)__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
cosh(float __lcpp_x) noexcept {
  return ::coshf(__lcpp_x);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
cosh(long double __lcpp_x) noexcept {
  return ::coshl(__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
cosh(_A1 __lcpp_x) noexcept {
  return ::cosh((double)__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
exp(float __lcpp_x) noexcept {
  return ::expf(__lcpp_x);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
exp(long double __lcpp_x) noexcept {
  return ::expl(__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
exp(_A1 __lcpp_x) noexcept {
  return ::exp((double)__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
fabs(float __lcpp_x) noexcept {
  return ::fabsf(__lcpp_x);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
fabs(long double __lcpp_x) noexcept {
  return ::fabsl(__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
fabs(_A1 __lcpp_x) noexcept {
  return ::fabs((double)__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
floor(float __lcpp_x) noexcept {
  return ::floorf(__lcpp_x);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
floor(long double __lcpp_x) noexcept {
  return ::floorl(__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
floor(_A1 __lcpp_x) noexcept {
  return ::floor((double)__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
fmod(float __lcpp_x, float __lcpp_y) noexcept {
  return ::fmodf(__lcpp_x, __lcpp_y);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
fmod(long double __lcpp_x, long double __lcpp_y) noexcept {
  return ::fmodl(__lcpp_x, __lcpp_y);
}

template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::_EnableIf<std::is_arithmetic<_A1>::value &&
                            std::is_arithmetic<_A2>::value,
                        std::__promote<_A1, _A2>>::type
fmod(_A1 __lcpp_x, _A2 __lcpp_y) noexcept {
  typedef typename std::__promote<_A1, _A2>::type __result_type;
  static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                   std::_IsSame<_A2, __result_type>::value)),
                "");
  return ::fmod((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
frexp(float __lcpp_x, int *__lcpp_e) noexcept {
  return ::frexpf(__lcpp_x, __lcpp_e);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
frexp(long double __lcpp_x, int *__lcpp_e) noexcept {
  return ::frexpl(__lcpp_x, __lcpp_e);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
frexp(_A1 __lcpp_x, int *__lcpp_e) noexcept {
  return ::frexp((double)__lcpp_x, __lcpp_e);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
ldexp(float __lcpp_x, int __lcpp_e) noexcept {
  return ::ldexpf(__lcpp_x, __lcpp_e);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
ldexp(long double __lcpp_x, int __lcpp_e) noexcept {
  return ::ldexpl(__lcpp_x, __lcpp_e);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
ldexp(_A1 __lcpp_x, int __lcpp_e) noexcept {
  return ::ldexp((double)__lcpp_x, __lcpp_e);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
log(float __lcpp_x) noexcept {
  return ::logf(__lcpp_x);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
log(long double __lcpp_x) noexcept {
  return ::logl(__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
log(_A1 __lcpp_x) noexcept {
  return ::log((double)__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
log10(float __lcpp_x) noexcept {
  return ::log10f(__lcpp_x);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
log10(long double __lcpp_x) noexcept {
  return ::log10l(__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
log10(_A1 __lcpp_x) noexcept {
  return ::log10((double)__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
modf(float __lcpp_x, float *__lcpp_y) noexcept {
  return ::modff(__lcpp_x, __lcpp_y);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
modf(long double __lcpp_x, long double *__lcpp_y) noexcept {
  return ::modfl(__lcpp_x, __lcpp_y);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
pow(float __lcpp_x, float __lcpp_y) noexcept {
  return ::powf(__lcpp_x, __lcpp_y);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
pow(long double __lcpp_x, long double __lcpp_y) noexcept {
  return ::powl(__lcpp_x, __lcpp_y);
}

template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::_EnableIf<std::is_arithmetic<_A1>::value &&
                            std::is_arithmetic<_A2>::value,
                        std::__promote<_A1, _A2>>::type
pow(_A1 __lcpp_x, _A2 __lcpp_y) noexcept {
  typedef typename std::__promote<_A1, _A2>::type __result_type;
  static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                   std::_IsSame<_A2, __result_type>::value)),
                "");
  return ::pow((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
sin(float __lcpp_x) noexcept {
  return ::sinf(__lcpp_x);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
sin(long double __lcpp_x) noexcept {
  return ::sinl(__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
sin(_A1 __lcpp_x) noexcept {
  return ::sin((double)__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
sinh(float __lcpp_x) noexcept {
  return ::sinhf(__lcpp_x);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
sinh(long double __lcpp_x) noexcept {
  return ::sinhl(__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
sinh(_A1 __lcpp_x) noexcept {
  return ::sinh((double)__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
sqrt(float __lcpp_x) noexcept {
  return ::sqrtf(__lcpp_x);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
sqrt(long double __lcpp_x) noexcept {
  return ::sqrtl(__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
sqrt(_A1 __lcpp_x) noexcept {
  return ::sqrt((double)__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
tan(float __lcpp_x) noexcept {
  return ::tanf(__lcpp_x);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
tan(long double __lcpp_x) noexcept {
  return ::tanl(__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
tan(_A1 __lcpp_x) noexcept {
  return ::tan((double)__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
tanh(float __lcpp_x) noexcept {
  return ::tanhf(__lcpp_x);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
tanh(long double __lcpp_x) noexcept {
  return ::tanhl(__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
tanh(_A1 __lcpp_x) noexcept {
  return ::tanh((double)__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
acosh(float __lcpp_x) noexcept {
  return ::acoshf(__lcpp_x);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
acosh(long double __lcpp_x) noexcept {
  return ::acoshl(__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
acosh(_A1 __lcpp_x) noexcept {
  return ::acosh((double)__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
asinh(float __lcpp_x) noexcept {
  return ::asinhf(__lcpp_x);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
asinh(long double __lcpp_x) noexcept {
  return ::asinhl(__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
asinh(_A1 __lcpp_x) noexcept {
  return ::asinh((double)__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
atanh(float __lcpp_x) noexcept {
  return ::atanhf(__lcpp_x);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
atanh(long double __lcpp_x) noexcept {
  return ::atanhl(__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
atanh(_A1 __lcpp_x) noexcept {
  return ::atanh((double)__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
cbrt(float __lcpp_x) noexcept {
  return ::cbrtf(__lcpp_x);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
cbrt(long double __lcpp_x) noexcept {
  return ::cbrtl(__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
cbrt(_A1 __lcpp_x) noexcept {
  return ::cbrt((double)__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
copysign(float __lcpp_x, float __lcpp_y) noexcept {
  return ::copysignf(__lcpp_x, __lcpp_y);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
copysign(long double __lcpp_x, long double __lcpp_y) noexcept {
  return ::copysignl(__lcpp_x, __lcpp_y);
}

template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::_EnableIf<std::is_arithmetic<_A1>::value &&
                            std::is_arithmetic<_A2>::value,
                        std::__promote<_A1, _A2>>::type
copysign(_A1 __lcpp_x, _A2 __lcpp_y) noexcept {
  typedef typename std::__promote<_A1, _A2>::type __result_type;
  static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                   std::_IsSame<_A2, __result_type>::value)),
                "");
  return ::copysign((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
erf(float __lcpp_x) noexcept {
  return ::erff(__lcpp_x);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
erf(long double __lcpp_x) noexcept {
  return ::erfl(__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
erf(_A1 __lcpp_x) noexcept {
  return ::erf((double)__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
erfc(float __lcpp_x) noexcept {
  return ::erfcf(__lcpp_x);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
erfc(long double __lcpp_x) noexcept {
  return ::erfcl(__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
erfc(_A1 __lcpp_x) noexcept {
  return ::erfc((double)__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
exp2(float __lcpp_x) noexcept {
  return ::exp2f(__lcpp_x);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
exp2(long double __lcpp_x) noexcept {
  return ::exp2l(__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
exp2(_A1 __lcpp_x) noexcept {
  return ::exp2((double)__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
expm1(float __lcpp_x) noexcept {
  return ::expm1f(__lcpp_x);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
expm1(long double __lcpp_x) noexcept {
  return ::expm1l(__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
expm1(_A1 __lcpp_x) noexcept {
  return ::expm1((double)__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
fdim(float __lcpp_x, float __lcpp_y) noexcept {
  return ::fdimf(__lcpp_x, __lcpp_y);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
fdim(long double __lcpp_x, long double __lcpp_y) noexcept {
  return ::fdiml(__lcpp_x, __lcpp_y);
}

template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::_EnableIf<std::is_arithmetic<_A1>::value &&
                            std::is_arithmetic<_A2>::value,
                        std::__promote<_A1, _A2>>::type
fdim(_A1 __lcpp_x, _A2 __lcpp_y) noexcept {
  typedef typename std::__promote<_A1, _A2>::type __result_type;
  static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                   std::_IsSame<_A2, __result_type>::value)),
                "");
  return ::fdim((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
fma(float __lcpp_x, float __lcpp_y, float __lcpp_z) noexcept {
  return ::fmaf(__lcpp_x, __lcpp_y, __lcpp_z);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
fma(long double __lcpp_x, long double __lcpp_y, long double __lcpp_z) noexcept {
  return ::fmal(__lcpp_x, __lcpp_y, __lcpp_z);
}

template <class _A1, class _A2, class _A3>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::_EnableIf<std::is_arithmetic<_A1>::value &&
                            std::is_arithmetic<_A2>::value &&
                            std::is_arithmetic<_A3>::value,
                        std::__promote<_A1, _A2, _A3>>::type
fma(_A1 __lcpp_x, _A2 __lcpp_y, _A3 __lcpp_z) noexcept {
  typedef typename std::__promote<_A1, _A2, _A3>::type __result_type;
  static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                   std::_IsSame<_A2, __result_type>::value &&
                   std::_IsSame<_A3, __result_type>::value)),
                "");
  return ::fma((__result_type)__lcpp_x, (__result_type)__lcpp_y,
               (__result_type)__lcpp_z);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
fmax(float __lcpp_x, float __lcpp_y) noexcept {
  return ::fmaxf(__lcpp_x, __lcpp_y);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
fmax(long double __lcpp_x, long double __lcpp_y) noexcept {
  return ::fmaxl(__lcpp_x, __lcpp_y);
}

template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::_EnableIf<std::is_arithmetic<_A1>::value &&
                            std::is_arithmetic<_A2>::value,
                        std::__promote<_A1, _A2>>::type
fmax(_A1 __lcpp_x, _A2 __lcpp_y) noexcept {
  typedef typename std::__promote<_A1, _A2>::type __result_type;
  static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                   std::_IsSame<_A2, __result_type>::value)),
                "");
  return ::fmax((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
fmin(float __lcpp_x, float __lcpp_y) noexcept {
  return ::fminf(__lcpp_x, __lcpp_y);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
fmin(long double __lcpp_x, long double __lcpp_y) noexcept {
  return ::fminl(__lcpp_x, __lcpp_y);
}

template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::_EnableIf<std::is_arithmetic<_A1>::value &&
                            std::is_arithmetic<_A2>::value,
                        std::__promote<_A1, _A2>>::type
fmin(_A1 __lcpp_x, _A2 __lcpp_y) noexcept {
  typedef typename std::__promote<_A1, _A2>::type __result_type;
  static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                   std::_IsSame<_A2, __result_type>::value)),
                "");
  return ::fmin((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
hypot(float __lcpp_x, float __lcpp_y) noexcept {
  return ::hypotf(__lcpp_x, __lcpp_y);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
hypot(long double __lcpp_x, long double __lcpp_y) noexcept {
  return ::hypotl(__lcpp_x, __lcpp_y);
}

template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::_EnableIf<std::is_arithmetic<_A1>::value &&
                            std::is_arithmetic<_A2>::value,
                        std::__promote<_A1, _A2>>::type
hypot(_A1 __lcpp_x, _A2 __lcpp_y) noexcept {
  typedef typename std::__promote<_A1, _A2>::type __result_type;
  static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                   std::_IsSame<_A2, __result_type>::value)),
                "");
  return ::hypot((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) int
ilogb(float __lcpp_x) noexcept {
  return ::ilogbf(__lcpp_x);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) int
ilogb(long double __lcpp_x) noexcept {
  return ::ilogbl(__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, int>::type
ilogb(_A1 __lcpp_x) noexcept {
  return ::ilogb((double)__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
lgamma(float __lcpp_x) noexcept {
  return ::lgammaf(__lcpp_x);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
lgamma(long double __lcpp_x) noexcept {
  return ::lgammal(__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
lgamma(_A1 __lcpp_x) noexcept {
  return ::lgamma((double)__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long long
llrint(float __lcpp_x) noexcept {
  return ::llrintf(__lcpp_x);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long long
llrint(long double __lcpp_x) noexcept {
  return ::llrintl(__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, long long>::type
llrint(_A1 __lcpp_x) noexcept {
  return ::llrint((double)__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long long
llround(float __lcpp_x) noexcept {
  return ::llroundf(__lcpp_x);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long long
llround(long double __lcpp_x) noexcept {
  return ::llroundl(__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, long long>::type
llround(_A1 __lcpp_x) noexcept {
  return ::llround((double)__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
log1p(float __lcpp_x) noexcept {
  return ::log1pf(__lcpp_x);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
log1p(long double __lcpp_x) noexcept {
  return ::log1pl(__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
log1p(_A1 __lcpp_x) noexcept {
  return ::log1p((double)__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
log2(float __lcpp_x) noexcept {
  return ::log2f(__lcpp_x);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
log2(long double __lcpp_x) noexcept {
  return ::log2l(__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
log2(_A1 __lcpp_x) noexcept {
  return ::log2((double)__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
logb(float __lcpp_x) noexcept {
  return ::logbf(__lcpp_x);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
logb(long double __lcpp_x) noexcept {
  return ::logbl(__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
logb(_A1 __lcpp_x) noexcept {
  return ::logb((double)__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long
lrint(float __lcpp_x) noexcept {
  return ::lrintf(__lcpp_x);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long
lrint(long double __lcpp_x) noexcept {
  return ::lrintl(__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, long>::type
lrint(_A1 __lcpp_x) noexcept {
  return ::lrint((double)__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long
lround(float __lcpp_x) noexcept {
  return ::lroundf(__lcpp_x);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long
lround(long double __lcpp_x) noexcept {
  return ::lroundl(__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, long>::type
lround(_A1 __lcpp_x) noexcept {
  return ::lround((double)__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
nearbyint(float __lcpp_x) noexcept {
  return ::nearbyintf(__lcpp_x);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
nearbyint(long double __lcpp_x) noexcept {
  return ::nearbyintl(__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
nearbyint(_A1 __lcpp_x) noexcept {
  return ::nearbyint((double)__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
nextafter(float __lcpp_x, float __lcpp_y) noexcept {
  return ::nextafterf(__lcpp_x, __lcpp_y);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
nextafter(long double __lcpp_x, long double __lcpp_y) noexcept {
  return ::nextafterl(__lcpp_x, __lcpp_y);
}

template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::_EnableIf<std::is_arithmetic<_A1>::value &&
                            std::is_arithmetic<_A2>::value,
                        std::__promote<_A1, _A2>>::type
nextafter(_A1 __lcpp_x, _A2 __lcpp_y) noexcept {
  typedef typename std::__promote<_A1, _A2>::type __result_type;
  static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                   std::_IsSame<_A2, __result_type>::value)),
                "");
  return ::nextafter((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
nexttoward(float __lcpp_x, long double __lcpp_y) noexcept {
  return ::nexttowardf(__lcpp_x, __lcpp_y);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
nexttoward(long double __lcpp_x, long double __lcpp_y) noexcept {
  return ::nexttowardl(__lcpp_x, __lcpp_y);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
nexttoward(_A1 __lcpp_x, long double __lcpp_y) noexcept {
  return ::nexttoward((double)__lcpp_x, __lcpp_y);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
remainder(float __lcpp_x, float __lcpp_y) noexcept {
  return ::remainderf(__lcpp_x, __lcpp_y);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
remainder(long double __lcpp_x, long double __lcpp_y) noexcept {
  return ::remainderl(__lcpp_x, __lcpp_y);
}

template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::_EnableIf<std::is_arithmetic<_A1>::value &&
                            std::is_arithmetic<_A2>::value,
                        std::__promote<_A1, _A2>>::type
remainder(_A1 __lcpp_x, _A2 __lcpp_y) noexcept {
  typedef typename std::__promote<_A1, _A2>::type __result_type;
  static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                   std::_IsSame<_A2, __result_type>::value)),
                "");
  return ::remainder((__result_type)__lcpp_x, (__result_type)__lcpp_y);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
remquo(float __lcpp_x, float __lcpp_y, int *__lcpp_z) noexcept {
  return ::remquof(__lcpp_x, __lcpp_y, __lcpp_z);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
remquo(long double __lcpp_x, long double __lcpp_y, int *__lcpp_z) noexcept {
  return ::remquol(__lcpp_x, __lcpp_y, __lcpp_z);
}

template <class _A1, class _A2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::_EnableIf<std::is_arithmetic<_A1>::value &&
                            std::is_arithmetic<_A2>::value,
                        std::__promote<_A1, _A2>>::type
remquo(_A1 __lcpp_x, _A2 __lcpp_y, int *__lcpp_z) noexcept {
  typedef typename std::__promote<_A1, _A2>::type __result_type;
  static_assert((!(std::_IsSame<_A1, __result_type>::value &&
                   std::_IsSame<_A2, __result_type>::value)),
                "");
  return ::remquo((__result_type)__lcpp_x, (__result_type)__lcpp_y, __lcpp_z);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
rint(float __lcpp_x) noexcept {
  return ::rintf(__lcpp_x);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
rint(long double __lcpp_x) noexcept {
  return ::rintl(__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
rint(_A1 __lcpp_x) noexcept {
  return ::rint((double)__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
round(float __lcpp_x) noexcept {
  return ::roundf(__lcpp_x);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
round(long double __lcpp_x) noexcept {
  return ::roundl(__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
round(_A1 __lcpp_x) noexcept {
  return ::round((double)__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
scalbln(float __lcpp_x, long __lcpp_y) noexcept {
  return ::scalblnf(__lcpp_x, __lcpp_y);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
scalbln(long double __lcpp_x, long __lcpp_y) noexcept {
  return ::scalblnl(__lcpp_x, __lcpp_y);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
scalbln(_A1 __lcpp_x, long __lcpp_y) noexcept {
  return ::scalbln((double)__lcpp_x, __lcpp_y);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
scalbn(float __lcpp_x, int __lcpp_y) noexcept {
  return ::scalbnf(__lcpp_x, __lcpp_y);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
scalbn(long double __lcpp_x, int __lcpp_y) noexcept {
  return ::scalbnl(__lcpp_x, __lcpp_y);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
scalbn(_A1 __lcpp_x, int __lcpp_y) noexcept {
  return ::scalbn((double)__lcpp_x, __lcpp_y);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
tgamma(float __lcpp_x) noexcept {
  return ::tgammaf(__lcpp_x);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
tgamma(long double __lcpp_x) noexcept {
  return ::tgammal(__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
tgamma(_A1 __lcpp_x) noexcept {
  return ::tgamma((double)__lcpp_x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) float
trunc(float __lcpp_x) noexcept {
  return ::truncf(__lcpp_x);
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) long double
trunc(long double __lcpp_x) noexcept {
  return ::truncl(__lcpp_x);
}

template <class _A1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename std::enable_if<std::is_integral<_A1>::value, double>::type
trunc(_A1 __lcpp_x) noexcept {
  return ::trunc((double)__lcpp_x);
}
}
# 101 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/stdlib.h" 2 3
# 45 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 75 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *)
    __attribute__((__noreturn__)) __attribute__((__cold__))
    __attribute__((__disable_tail_calls__));
}
# 51 "/usr/local/include/QtCore/qglobal.h" 2
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/stddef.h" 1 3
# 39 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/stddef.h" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 40 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/stddef.h" 2 3
# 43 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/stddef.h" 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/12.0.0/include/stddef.h" 1 3
# 46 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/stddef.h" 2 3

extern "C++" {

using std::nullptr_t;
}
# 52 "/usr/local/include/QtCore/qglobal.h" 2
# 66 "/usr/local/include/QtCore/qglobal.h"
# 1 "/usr/local/include/QtCore/qconfig.h" 1
# 67 "/usr/local/include/QtCore/qglobal.h" 2
# 1 "/usr/local/include/QtCore/qtcore-config.h" 1
# 68 "/usr/local/include/QtCore/qglobal.h" 2
# 103 "/usr/local/include/QtCore/qglobal.h"
# 1 "/usr/local/include/QtCore/qsystemdetection.h" 1
# 86 "/usr/local/include/QtCore/qsystemdetection.h"
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/TargetConditionals.h" 1 3 4
# 87 "/usr/local/include/QtCore/qsystemdetection.h" 2
# 217 "/usr/local/include/QtCore/qsystemdetection.h"
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/AvailabilityMacros.h" 1 3 4
# 218 "/usr/local/include/QtCore/qsystemdetection.h" 2
# 104 "/usr/local/include/QtCore/qglobal.h" 2
# 1 "/usr/local/include/QtCore/qprocessordetection.h" 1
# 105 "/usr/local/include/QtCore/qglobal.h" 2
# 1 "/usr/local/include/QtCore/qcompilerdetection.h" 1
# 106 "/usr/local/include/QtCore/qglobal.h" 2
# 142 "/usr/local/include/QtCore/qglobal.h"
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 1 3
# 638 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 639 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 2 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 1 3
# 651 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 652 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 2 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/typeinfo" 1 3
# 59 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/typeinfo" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 60 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/typeinfo" 2 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/exception" 1 3
# 79 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/exception" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 80 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/exception" 2 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdlib" 1 3
# 84 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdlib" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 85 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdlib" 2 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/stdlib.h" 1 3
# 86 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdlib" 2 3
# 89 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdlib" 3

namespace std {
inline namespace __1 {

using ::div_t;
using ::ldiv_t;
using ::size_t;

using ::lldiv_t;

using ::atof;
using ::atoi;
using ::atol;

using ::atoll;

using ::strtod;
using ::strtof;
using ::strtol;
using ::strtold;

using ::strtoll;

using ::strtoul;

using ::strtoull;

using ::calloc;
using ::free;
using ::malloc;
using ::rand;
using ::realloc;
using ::srand;

using ::abort;

using ::_Exit;
using ::atexit;
using ::exit;

using ::getenv;
using ::system;

using ::abs;
using ::bsearch;
using ::labs;
using ::qsort;

using ::llabs;

using ::div;
using ::ldiv;

using ::lldiv;

using ::mblen;
using ::mbstowcs;
using ::mbtowc;
using ::wcstombs;
using ::wctomb;
# 178 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdlib" 3
} // namespace __1
} // namespace std
# 82 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/exception" 2 3
# 91 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/exception" 3

namespace std {

class __attribute__((__visibility__("default"))) exception {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  exception() noexcept {}
  virtual ~exception() noexcept;
  virtual const char *what() const noexcept;
};

class __attribute__((__visibility__("default"))) bad_exception
    : public exception {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  bad_exception() noexcept {}
  virtual ~bad_exception() noexcept;
  virtual const char *what() const noexcept;
};

typedef void (*unexpected_handler)();
__attribute__((__visibility__("default")))
unexpected_handler set_unexpected(unexpected_handler) noexcept;
__attribute__((__visibility__("default"))) unexpected_handler
get_unexpected() noexcept;
[[noreturn]] __attribute__((__visibility__("default"))) void unexpected();

typedef void (*terminate_handler)();
__attribute__((__visibility__("default")))
terminate_handler set_terminate(terminate_handler) noexcept;
__attribute__((__visibility__("default"))) terminate_handler
get_terminate() noexcept;
[[noreturn]] __attribute__((__visibility__("default"))) void
terminate() noexcept;

__attribute__((__visibility__("default"))) bool uncaught_exception() noexcept;
__attribute__((__visibility__("default")))
__attribute__((availability(macosx, strict, introduced = 10.12)))
__attribute__((availability(ios, strict, introduced = 10.0)))
__attribute__((availability(tvos, strict, introduced = 10.0)))
__attribute__((availability(watchos, strict, introduced = 3.0))) int
uncaught_exceptions() noexcept;

class __attribute__((__visibility__("default"))) exception_ptr;

__attribute__((__visibility__("default"))) exception_ptr
current_exception() noexcept;
[[noreturn]] __attribute__((__visibility__("default"))) void
    rethrow_exception(exception_ptr);

class __attribute__((__visibility__("default"))) exception_ptr {
  void *__ptr_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  exception_ptr() noexcept
      : __ptr_() {}
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  exception_ptr(nullptr_t) noexcept
      : __ptr_() {}

  exception_ptr(const exception_ptr &) noexcept;
  exception_ptr &operator=(const exception_ptr &) noexcept;
  ~exception_ptr() noexcept;

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit
  operator bool() const noexcept {
    return __ptr_ != nullptr;
  }

  friend __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator==(const exception_ptr &__x, const exception_ptr &__y) noexcept {
    return __x.__ptr_ == __y.__ptr_;
  }

  friend __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator!=(const exception_ptr &__x, const exception_ptr &__y) noexcept {
    return !(__x == __y);
  }

  friend __attribute__((__visibility__("default"))) exception_ptr
  current_exception() noexcept;
  friend __attribute__((__visibility__("default"))) void
      rethrow_exception(exception_ptr);
};

template <class _Ep>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
exception_ptr
make_exception_ptr(_Ep __e) noexcept {

  try {
    throw __e;
  } catch (...) {
    return current_exception();
  }
}
# 234 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/exception" 3
class __attribute__((__visibility__("default"))) nested_exception {
  exception_ptr __ptr_;

public:
  nested_exception() noexcept;

  virtual ~nested_exception() noexcept;

  [[noreturn]] void rethrow_nested() const;
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  exception_ptr
  nested_ptr() const noexcept {
    return __ptr_;
  }
};

template <class _Tp> struct __nested : public _Tp, public nested_exception {
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit __nested(const _Tp &__t)
      : _Tp(__t) {}
};

template <class _Tp, class _Up, bool> struct __throw_with_nested;

template <class _Tp, class _Up> struct __throw_with_nested<_Tp, _Up, true> {
  [[noreturn]] static inline __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __do_throw(_Tp &&__t) {
    throw __nested<_Up>(std::__1::forward<_Tp>(__t));
  }
};

template <class _Tp, class _Up> struct __throw_with_nested<_Tp, _Up, false> {
  [[noreturn]] static inline __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void

  __do_throw(_Tp &&__t)

  {
    throw std::__1::forward<_Tp>(__t);
  }
};

template <class _Tp> [[noreturn]] void throw_with_nested(_Tp &&__t) {

  typedef typename decay<_Tp>::type _Up;
  static_assert(is_copy_constructible<_Up>::value,
                "type thrown must be CopyConstructible");
  __throw_with_nested<_Tp, _Up,
                      is_class<_Up>::value &&
                          !is_base_of<nested_exception, _Up>::value &&
                          !__libcpp_is_final<_Up>::value>::
      __do_throw(std::__1::forward<_Tp>(__t));
}

template <class _From, class _To>
struct __can_dynamic_cast
    : public integral_constant<
          bool, (is_polymorphic<_From>::value &&
                 (!is_base_of<_To, _From>::value ||
                  is_convertible<const _From *, const _To *>::value))> {};

template <class _Ep>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
rethrow_if_nested(
    const _Ep &__e,
    typename enable_if<__can_dynamic_cast<_Ep, nested_exception>::value>::type
        * = 0) {
  const nested_exception *__nep =
      dynamic_cast<const nested_exception *>(std::__1::addressof(__e));
  if (__nep)
    __nep->rethrow_nested();
}

template <class _Ep>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
rethrow_if_nested(
    const _Ep &,
    typename enable_if<!__can_dynamic_cast<_Ep, nested_exception>::value>::type
        * = 0) {}

} // namespace std
# 61 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/typeinfo" 2 3
# 69 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/typeinfo" 3

namespace std {
# 159 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/typeinfo" 3
struct __type_info_implementations {
  struct __string_impl_base {
    typedef const char *__type_name_t;
    __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
    __attribute__((__always_inline__)) constexpr static const char *
    __type_name_to_string(__type_name_t __v) noexcept {
      return __v;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
    __attribute__((__always_inline__)) constexpr static __type_name_t
    __string_to_type_name(const char *__v) noexcept {
      return __v;
    }
  };

  struct __unique_impl : __string_impl_base {
    __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
    __attribute__((__always_inline__)) static size_t
    __hash(__type_name_t __v) noexcept {
      return reinterpret_cast<size_t>(__v);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
    __attribute__((__always_inline__)) static bool
    __eq(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      return __lhs == __rhs;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
    __attribute__((__always_inline__)) static bool
    __lt(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      return __lhs < __rhs;
    }
  };

  struct __non_unique_impl : __string_impl_base {
    __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
    __attribute__((__always_inline__)) static size_t
    __hash(__type_name_t __ptr) noexcept {
      size_t __hash = 5381;
      while (unsigned char __c = static_cast<unsigned char>(*__ptr++))
        __hash = (__hash * 33) ^ __c;
      return __hash;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
    __attribute__((__always_inline__)) static bool
    __eq(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      return __lhs == __rhs || __builtin_strcmp(__lhs, __rhs) == 0;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
    __attribute__((__always_inline__)) static bool
    __lt(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      return __builtin_strcmp(__lhs, __rhs) < 0;
    }
  };

  struct __non_unique_arm_rtti_bit_impl {
    typedef uintptr_t __type_name_t;

    __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
    __attribute__((__always_inline__)) static const char *
    __type_name_to_string(__type_name_t __v) noexcept {
      return reinterpret_cast<const char *>(__v &
                                            ~__non_unique_rtti_bit::value);
    }
    __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
    __attribute__((__always_inline__)) static __type_name_t
    __string_to_type_name(const char *__v) noexcept {
      return reinterpret_cast<__type_name_t>(__v);
    }

    __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
    __attribute__((__always_inline__)) static size_t
    __hash(__type_name_t __v) noexcept {
      if (__is_type_name_unique(__v))
        return reinterpret_cast<size_t>(__v);
      return __non_unique_impl::__hash(__type_name_to_string(__v));
    }
    __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
    __attribute__((__always_inline__)) static bool
    __eq(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      if (__lhs == __rhs)
        return true;
      if (__is_type_name_unique(__lhs, __rhs))
        return false;
      return __builtin_strcmp(__type_name_to_string(__lhs),
                              __type_name_to_string(__rhs)) == 0;
    }
    __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
    __attribute__((__always_inline__)) static bool
    __lt(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      if (__is_type_name_unique(__lhs, __rhs))
        return __lhs < __rhs;
      return __builtin_strcmp(__type_name_to_string(__lhs),
                              __type_name_to_string(__rhs)) < 0;
    }

  private:
    typedef std::integral_constant<__type_name_t,
                                   (1ULL << ((8 * sizeof(__type_name_t)) - 1))>
        __non_unique_rtti_bit;

    __attribute__((__visibility__("hidden")))
    __attribute__((internal_linkage)) static bool
    __is_type_name_unique(__type_name_t __lhs) noexcept {
      return !(__lhs & __non_unique_rtti_bit::value);
    }
    __attribute__((__visibility__("hidden")))
    __attribute__((internal_linkage)) static bool
    __is_type_name_unique(__type_name_t __lhs, __type_name_t __rhs) noexcept {
      return !((__lhs & __rhs) & __non_unique_rtti_bit::value);
    }
  };

  typedef

      __non_unique_impl

          __impl;
};
# 276 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/typeinfo" 3
class __attribute__((__visibility__("default"))) type_info {
  type_info &operator=(const type_info &);
  type_info(const type_info &);

protected:
  typedef __type_info_implementations::__impl __impl;

  __impl::__type_name_t __type_name;

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit type_info(const char *__n)
      : __type_name(__impl::__string_to_type_name(__n)) {}

public:
  __attribute__((availability(macosx, strict, introduced = 10.9)))
  __attribute__((availability(ios, strict,
                              introduced = 7.0))) virtual ~type_info();

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const char *
  name() const noexcept {
    return __impl::__type_name_to_string(__type_name);
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  before(const type_info &__arg) const noexcept {
    return __impl::__lt(__type_name, __arg.__type_name);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_t
  hash_code() const noexcept {
    return __impl::__hash(__type_name);
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator==(const type_info &__arg) const noexcept {
    return __impl::__eq(__type_name, __arg.__type_name);
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator!=(const type_info &__arg) const noexcept {
    return !operator==(__arg);
  }
};

class __attribute__((__visibility__("default"))) bad_cast : public exception {
public:
  bad_cast() noexcept;
  virtual ~bad_cast() noexcept;
  virtual const char *what() const noexcept;
};

class __attribute__((__visibility__("default"))) bad_typeid : public exception {
public:
  bad_typeid() noexcept;
  virtual ~bad_typeid() noexcept;
  virtual const char *what() const noexcept;
};

} // namespace std

namespace std {
inline namespace __1 {
[[noreturn]] inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
__throw_bad_cast() {

  throw bad_cast();
}
} // namespace __1
} // namespace std
# 654 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 2 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/new" 1 3
# 89 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/new" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 90 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/new" 2 3
# 104 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/new" 3
# 125 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/new" 3
namespace std {

struct __attribute__((__visibility__("default"))) nothrow_t {
  explicit nothrow_t() = default;
};
extern __attribute__((__visibility__("default"))) const nothrow_t nothrow;

class __attribute__((__visibility__("default"))) bad_alloc : public exception {
public:
  bad_alloc() noexcept;
  virtual ~bad_alloc() noexcept;
  virtual const char *what() const noexcept;
};

class __attribute__((__visibility__("default"))) bad_array_new_length
    : public bad_alloc {
public:
  bad_array_new_length() noexcept;
  virtual ~bad_array_new_length() noexcept;
  virtual const char *what() const noexcept;
};

typedef void (*new_handler)();
__attribute__((__visibility__("default")))
new_handler set_new_handler(new_handler) noexcept;
__attribute__((__visibility__("default"))) new_handler
get_new_handler() noexcept;

[[noreturn]] __attribute__((__visibility__("default"))) void
__throw_bad_alloc();

enum class __attribute__((__type_visibility__("default")))
align_val_t : size_t {};
# 176 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/new" 3
} // namespace std
# 186 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/new" 3
__attribute__((__visibility__("default"))) void *operator new(std::size_t __sz);
__attribute__((__visibility__("default"))) void *
operator new(std::size_t __sz, const std::nothrow_t &) noexcept
    __attribute__((__malloc__));
__attribute__((__visibility__("default"))) void
operator delete(void *__p) noexcept;
__attribute__((__visibility__("default"))) void
operator delete(void *__p, const std::nothrow_t &) noexcept;

__attribute__((__visibility__("default")))
__attribute__((availability(macosx, strict, introduced = 10.12)))
__attribute__((availability(ios, strict, introduced = 10.0)))
__attribute__((availability(tvos, strict, introduced = 10.0)))
__attribute__((availability(watchos, strict, introduced = 3.0))) void
operator delete(void *__p, std::size_t __sz) noexcept;

__attribute__((__visibility__("default"))) void *
operator new[](std::size_t __sz);
__attribute__((__visibility__("default"))) void *
operator new[](std::size_t __sz, const std::nothrow_t &) noexcept
    __attribute__((__malloc__));
__attribute__((__visibility__("default"))) void
operator delete[](void *__p) noexcept;
__attribute__((__visibility__("default"))) void
operator delete[](void *__p, const std::nothrow_t &) noexcept;

__attribute__((__visibility__("default")))
__attribute__((availability(macosx, strict, introduced = 10.12)))
__attribute__((availability(ios, strict, introduced = 10.0)))
__attribute__((availability(tvos, strict, introduced = 10.0)))
__attribute__((availability(watchos, strict, introduced = 3.0))) void
operator delete[](void *__p, std::size_t __sz) noexcept;

__attribute__((__visibility__("default"))) void *operator new(std::size_t __sz,
                                                              std::align_val_t);
__attribute__((__visibility__("default"))) void *
operator new(std::size_t __sz, std::align_val_t,
             const std::nothrow_t &) noexcept __attribute__((__malloc__));
__attribute__((__visibility__("default"))) void
operator delete(void *__p, std::align_val_t) noexcept;
__attribute__((__visibility__("default"))) void
operator delete(void *__p, std::align_val_t, const std::nothrow_t &) noexcept;

__attribute__((__visibility__("default")))
__attribute__((availability(macosx, strict, introduced = 10.12)))
__attribute__((availability(ios, strict, introduced = 10.0)))
__attribute__((availability(tvos, strict, introduced = 10.0)))
__attribute__((availability(watchos, strict, introduced = 3.0))) void
operator delete(void *__p, std::size_t __sz, std::align_val_t) noexcept;

__attribute__((__visibility__("default"))) void *
operator new[](std::size_t __sz, std::align_val_t);
__attribute__((__visibility__("default"))) void *
operator new[](std::size_t __sz, std::align_val_t,
               const std::nothrow_t &) noexcept __attribute__((__malloc__));
__attribute__((__visibility__("default"))) void
operator delete[](void *__p, std::align_val_t) noexcept;
__attribute__((__visibility__("default"))) void
operator delete[](void *__p, std::align_val_t, const std::nothrow_t &) noexcept;

__attribute__((__visibility__("default")))
__attribute__((availability(macosx, strict, introduced = 10.12)))
__attribute__((availability(ios, strict, introduced = 10.0)))
__attribute__((availability(tvos, strict, introduced = 10.0)))
__attribute__((availability(watchos, strict, introduced = 3.0))) void
operator delete[](void *__p, std::size_t __sz, std::align_val_t) noexcept;

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void *
operator new(std::size_t, void *__p) noexcept {
  return __p;
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void *
operator new[](std::size_t, void *__p) noexcept {
  return __p;
}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
operator delete(void *, void *) noexcept {}
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
operator delete[](void *, void *) noexcept {}

namespace std {
inline namespace __1 {

constexpr inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
__is_overaligned_for_new(size_t __align) noexcept {

  return __align > 16UL;
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void *
__libcpp_allocate(size_t __size, size_t __align) {
# 248 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/new" 3
  ((void)__align);

  return __builtin_operator_new(__size);
}

struct _DeallocateCaller {
  static inline __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __do_deallocate_handle_size_align(void *__ptr, size_t __size,
                                    size_t __align) {

    ((void)__align);
    return __do_deallocate_handle_size(__ptr, __size);
# 271 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/new" 3
  }

  static inline __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __do_deallocate_handle_align(void *__ptr, size_t __align) {

    ((void)__align);
    return __do_call(__ptr);
# 286 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/new" 3
  }

private:
  static inline void __do_deallocate_handle_size(void *__ptr, size_t __size) {

    ((void)__size);
    return __do_call(__ptr);
  }
# 309 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/new" 3
private:
  template <class _A1, class _A2>
  static inline void __do_call(void *__ptr, _A1 __a1, _A2 __a2) {

    return __builtin_operator_delete(__ptr, __a1, __a2);
  }

  template <class _A1> static inline void __do_call(void *__ptr, _A1 __a1) {

    return __builtin_operator_delete(__ptr, __a1);
  }

  static inline void __do_call(void *__ptr) {

    return __builtin_operator_delete(__ptr);
  }
};

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
__libcpp_deallocate(void *__ptr, size_t __size, size_t __align) {
  _DeallocateCaller::__do_deallocate_handle_size_align(__ptr, __size, __align);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
__libcpp_deallocate_unsized(void *__ptr, size_t __align) {
  _DeallocateCaller::__do_deallocate_handle_align(__ptr, __align);
}

template <class _Tp> inline constexpr _Tp *__launder(_Tp *__p) noexcept {
  static_assert(!(is_function<_Tp>::value), "can't launder functions");
  static_assert(!(is_same<void, typename remove_cv<_Tp>::type>::value),
                "can't launder cv-void");

  return __builtin_launder(__p);
}
# 370 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/new" 3
} // namespace __1
} // namespace std
# 657 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 2 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iterator" 1 3
# 419 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iterator" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 420 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iterator" 2 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_base" 1 3
# 13 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_base" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 14 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_base" 2 3
# 22 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_base" 3

namespace std {
inline namespace __1 {

template <class _Arg1, class _Arg2, class _Result>
struct __attribute__((__type_visibility__("default"))) binary_function {
  typedef _Arg1 first_argument_type;
  typedef _Arg2 second_argument_type;
  typedef _Result result_type;
};

template <class _Tp> struct __has_result_type {
private:
  struct __two {
    char __lx;
    char __lxx;
  };
  template <class _Up> static __two __test(...);
  template <class _Up> static char __test(typename _Up::result_type * = 0);

public:
  static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp = void>

struct __attribute__((__type_visibility__("default"))) less
    : binary_function<_Tp, _Tp, bool> {
  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator()(const _Tp &__x, const _Tp &__y) const {
    return __x < __y;
  }
};

template <> struct __attribute__((__type_visibility__("default"))) less<void> {
  template <class _T1, class _T2>
  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) auto
  operator()(_T1 &&__t,
             _T2 &&__u) const noexcept(noexcept(std::__1::forward<_T1>(__t) <
                                                std::__1::forward<_T2>(__u)))
      -> decltype(std::__1::forward<_T1>(__t) < std::__1::forward<_T2>(__u)) {
    return std::__1::forward<_T1>(__t) < std::__1::forward<_T2>(__u);
  }
  typedef void is_transparent;
};

template <class _Tp> struct __derives_from_unary_function {
private:
  struct __two {
    char __lx;
    char __lxx;
  };
  static __two __test(...);
  template <class _Ap, class _Rp>
  static unary_function<_Ap, _Rp>
  __test(const volatile unary_function<_Ap, _Rp> *);

public:
  static const bool value = !is_same<decltype(__test((_Tp *)0)), __two>::value;
  typedef decltype(__test((_Tp *)0)) type;
};

template <class _Tp> struct __derives_from_binary_function {
private:
  struct __two {
    char __lx;
    char __lxx;
  };
  static __two __test(...);
  template <class _A1, class _A2, class _Rp>
  static binary_function<_A1, _A2, _Rp>
  __test(const volatile binary_function<_A1, _A2, _Rp> *);

public:
  static const bool value = !is_same<decltype(__test((_Tp *)0)), __two>::value;
  typedef decltype(__test((_Tp *)0)) type;
};

template <class _Tp, bool = __derives_from_unary_function<_Tp>::value>
struct __maybe_derive_from_unary_function
    : public __derives_from_unary_function<_Tp>::type {};

template <class _Tp> struct __maybe_derive_from_unary_function<_Tp, false> {};

template <class _Tp, bool = __derives_from_binary_function<_Tp>::value>
struct __maybe_derive_from_binary_function
    : public __derives_from_binary_function<_Tp>::type {};

template <class _Tp> struct __maybe_derive_from_binary_function<_Tp, false> {};

template <class _Tp, bool = __has_result_type<_Tp>::value>
struct __weak_result_type_imp
    : public __maybe_derive_from_unary_function<_Tp>,
      public __maybe_derive_from_binary_function<_Tp> {
  typedef typename _Tp::result_type result_type;
};

template <class _Tp>
struct __weak_result_type_imp<_Tp, false>
    : public __maybe_derive_from_unary_function<_Tp>,
      public __maybe_derive_from_binary_function<_Tp> {};

template <class _Tp>
struct __weak_result_type : public __weak_result_type_imp<_Tp> {};

template <class _Rp> struct __weak_result_type<_Rp()> {
  typedef _Rp result_type;
};

template <class _Rp> struct __weak_result_type<_Rp (&)()> {
  typedef _Rp result_type;
};

template <class _Rp> struct __weak_result_type<_Rp (*)()> {
  typedef _Rp result_type;
};

template <class _Rp, class _A1>
struct __weak_result_type<_Rp(_A1)> : public unary_function<_A1, _Rp> {};

template <class _Rp, class _A1>
struct __weak_result_type<_Rp (&)(_A1)> : public unary_function<_A1, _Rp> {};

template <class _Rp, class _A1>
struct __weak_result_type<_Rp (*)(_A1)> : public unary_function<_A1, _Rp> {};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)()> : public unary_function<_Cp *, _Rp> {
};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() const>
    : public unary_function<const _Cp *, _Rp> {};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() volatile>
    : public unary_function<volatile _Cp *, _Rp> {};

template <class _Rp, class _Cp>
struct __weak_result_type<_Rp (_Cp::*)() const volatile>
    : public unary_function<const volatile _Cp *, _Rp> {};

template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp> {};

template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (*)(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp> {};

template <class _Rp, class _A1, class _A2>
struct __weak_result_type<_Rp (&)(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp> {};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1)>
    : public binary_function<_Cp *, _A1, _Rp> {};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) const>
    : public binary_function<const _Cp *, _A1, _Rp> {};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) volatile>
    : public binary_function<volatile _Cp *, _A1, _Rp> {};

template <class _Rp, class _Cp, class _A1>
struct __weak_result_type<_Rp (_Cp::*)(_A1) const volatile>
    : public binary_function<const volatile _Cp *, _A1, _Rp> {};

template <class _Rp, class _A1, class _A2, class _A3, class... _A4>
struct __weak_result_type<_Rp(_A1, _A2, _A3, _A4...)> {
  typedef _Rp result_type;
};

template <class _Rp, class _A1, class _A2, class _A3, class... _A4>
struct __weak_result_type<_Rp (&)(_A1, _A2, _A3, _A4...)> {
  typedef _Rp result_type;
};

template <class _Rp, class _A1, class _A2, class _A3, class... _A4>
struct __weak_result_type<_Rp (*)(_A1, _A2, _A3, _A4...)> {
  typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2, class... _A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...)> {
  typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2, class... _A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const> {
  typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2, class... _A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) volatile> {
  typedef _Rp result_type;
};

template <class _Rp, class _Cp, class _A1, class _A2, class... _A3>
struct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const volatile> {
  typedef _Rp result_type;
};

template <class _Tp, class... _Args> struct __invoke_return {
  typedef decltype(
      __invoke(std::__1::declval<_Tp>(), std::__1::declval<_Args>()...)) type;
};
# 311 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_base" 3
template <class _Ret> struct __invoke_void_return_wrapper {

  template <class... _Args> static _Ret __call(_Args &&...__args) {
    return __invoke(std::__1::forward<_Args>(__args)...);
  }
# 340 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_base" 3
};

template <> struct __invoke_void_return_wrapper<void> {

  template <class... _Args> static void __call(_Args &&...__args) {
    __invoke(std::__1::forward<_Args>(__args)...);
  }
# 371 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_base" 3
};

template <class _Tp>
class __attribute__((__type_visibility__("default"))) reference_wrapper
    : public __weak_result_type<_Tp> {
public:
  typedef _Tp type;

private:
  type *__f_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reference_wrapper(type &__f) noexcept
      : __f_(std::__1::addressof(__f)) {}

private:
  reference_wrapper(type &&);
public:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  operator type &() const noexcept {
    return *__f_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  type &
  get() const noexcept {
    return *__f_;
  }

  template <class... _ArgTypes>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename __invoke_of<type &, _ArgTypes...>::type
  operator()(_ArgTypes &&...__args) const {
    return __invoke(get(), std::__1::forward<_ArgTypes>(__args)...);
  }
# 509 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_base" 3
};

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) reference_wrapper<_Tp>
ref(_Tp &__t) noexcept {
  return reference_wrapper<_Tp>(__t);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) reference_wrapper<_Tp>
ref(reference_wrapper<_Tp> __t) noexcept {
  return ref(__t.get());
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) reference_wrapper<const _Tp>
cref(const _Tp &__t) noexcept {
  return reference_wrapper<const _Tp>(__t);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) reference_wrapper<const _Tp>
cref(reference_wrapper<_Tp> __t) noexcept {
  return cref(__t.get());
}

template <class _Tp> void ref(const _Tp &&) = delete;
template <class _Tp> void cref(const _Tp &&) = delete;

template <class _Tp, class, class = void>
struct __is_transparent : false_type {};

template <class _Tp, class _Up>
struct __is_transparent<_Tp, _Up,
                        typename __void_t<typename _Tp::is_transparent>::type>
    : true_type {};

struct __attribute__((__type_visibility__("default"))) allocator_arg_t {
  explicit allocator_arg_t() = default;
};

constexpr allocator_arg_t allocator_arg = allocator_arg_t();

template <class _Tp> struct __has_allocator_type {
private:
  struct __two {
    char __lx;
    char __lxx;
  };
  template <class _Up> static __two __test(...);
  template <class _Up> static char __test(typename _Up::allocator_type * = 0);

public:
  static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Alloc, bool = __has_allocator_type<_Tp>::value>
struct __uses_allocator
    : public integral_constant<
          bool, is_convertible<_Alloc, typename _Tp::allocator_type>::value> {};

template <class _Tp, class _Alloc>
struct __uses_allocator<_Tp, _Alloc, false> : public false_type {};

template <class _Tp, class _Alloc>
struct __attribute__((__type_visibility__("default"))) uses_allocator
    : public __uses_allocator<_Tp, _Alloc> {};
# 610 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__functional_base" 3
template <class _Tp, class _Alloc, class... _Args>
struct __uses_alloc_ctor_imp {
  typedef typename __uncvref<_Alloc>::type _RawAlloc;
  static const bool __ua = uses_allocator<_Tp, _RawAlloc>::value;
  static const bool __ic =
      is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value;
  static const int value = __ua ? 2 - __ic : 0;
};

template <class _Tp, class _Alloc, class... _Args>
struct __uses_alloc_ctor
    : integral_constant<int,
                        __uses_alloc_ctor_imp<_Tp, _Alloc, _Args...>::value> {};

template <class _Tp, class _Allocator, class... _Args>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
__user_alloc_construct_impl(integral_constant<int, 0>, _Tp *__storage,
                            const _Allocator &, _Args &&...__args) {
  new (__storage) _Tp(std::__1::forward<_Args>(__args)...);
}

template <class _Tp, class _Allocator, class... _Args>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
__user_alloc_construct_impl(integral_constant<int, 1>, _Tp *__storage,
                            const _Allocator &__a, _Args &&...__args) {
  new (__storage) _Tp(allocator_arg, __a, std::__1::forward<_Args>(__args)...);
}

template <class _Tp, class _Allocator, class... _Args>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
__user_alloc_construct_impl(integral_constant<int, 2>, _Tp *__storage,
                            const _Allocator &__a, _Args &&...__args) {
  new (__storage) _Tp(std::__1::forward<_Args>(__args)..., __a);
}

} // namespace __1
} // namespace std
# 422 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iterator" 2 3
# 434 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iterator" 3

namespace std {
inline namespace __1 {
template <class _Iter>
struct __attribute__((__type_visibility__("default"))) iterator_traits;

struct __attribute__((__type_visibility__("default"))) input_iterator_tag {};
struct __attribute__((__type_visibility__("default"))) output_iterator_tag {};
struct __attribute__((__type_visibility__("default"))) forward_iterator_tag
    : public input_iterator_tag {};
struct __attribute__((__type_visibility__("default")))
bidirectional_iterator_tag : public forward_iterator_tag {};
struct __attribute__((__type_visibility__("default")))
random_access_iterator_tag : public bidirectional_iterator_tag {};

template <class _Iter> struct __iter_traits_cache {
  using type = _If<__is_primary_template<iterator_traits<_Iter>>::value, _Iter,
                   iterator_traits<_Iter>>;
};
template <class _Iter>
using _ITER_TRAITS = typename __iter_traits_cache<_Iter>::type;

struct __iter_concept_concept_test {
  template <class _Iter>
  using _Apply = typename _ITER_TRAITS<_Iter>::iterator_concept;
};
struct __iter_concept_category_test {
  template <class _Iter>
  using _Apply = typename _ITER_TRAITS<_Iter>::iterator_category;
};
struct __iter_concept_random_fallback {
  template <class _Iter>
  using _Apply = _EnableIf<__is_primary_template<iterator_traits<_Iter>>::value,
                           random_access_iterator_tag>;
};

template <class _Iter, class _Tester>
struct __test_iter_concept : _IsValidExpansion<_Tester::template _Apply, _Iter>,
                             _Tester {};

template <class _Iter> struct __iter_concept_cache {
  using type = _Or<__test_iter_concept<_Iter, __iter_concept_concept_test>,
                   __test_iter_concept<_Iter, __iter_concept_category_test>,
                   __test_iter_concept<_Iter, __iter_concept_random_fallback>>;
};

template <class _Iter>
using _ITER_CONCEPT =
    typename __iter_concept_cache<_Iter>::type::template _Apply<_Iter>;

template <class _Tp> struct __has_iterator_typedefs {
private:
  struct __two {
    char __lx;
    char __lxx;
  };
  template <class _Up> static __two __test(...);
  template <class _Up>
  static char
  __test(typename std::__void_t<typename _Up::iterator_category>::type * = 0,
         typename std::__void_t<typename _Up::difference_type>::type * = 0,
         typename std::__void_t<typename _Up::value_type>::type * = 0,
         typename std::__void_t<typename _Up::reference>::type * = 0,
         typename std::__void_t<typename _Up::pointer>::type * = 0);

public:
  static const bool value = sizeof(__test<_Tp>(0, 0, 0, 0, 0)) == 1;
};

template <class _Tp> struct __has_iterator_category {
private:
  struct __two {
    char __lx;
    char __lxx;
  };
  template <class _Up> static __two __test(...);
  template <class _Up>
  static char __test(typename _Up::iterator_category * = 0);

public:
  static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Iter, bool> struct __iterator_traits_impl {};

template <class _Iter> struct __iterator_traits_impl<_Iter, true> {
  typedef typename _Iter::difference_type difference_type;
  typedef typename _Iter::value_type value_type;
  typedef typename _Iter::pointer pointer;
  typedef typename _Iter::reference reference;
  typedef typename _Iter::iterator_category iterator_category;
};

template <class _Iter, bool> struct __iterator_traits {};

template <class _Iter>
struct __iterator_traits<_Iter, true>
    : __iterator_traits_impl<
          _Iter, is_convertible<typename _Iter::iterator_category,
                                input_iterator_tag>::value ||
                     is_convertible<typename _Iter::iterator_category,
                                    output_iterator_tag>::value> {};

template <class _Iter>
struct __attribute__((__type_visibility__("default"))) iterator_traits
    : __iterator_traits<_Iter, __has_iterator_typedefs<_Iter>::value> {

  using __primary_template = iterator_traits;
};

template <class _Tp>
struct __attribute__((__type_visibility__("default"))) iterator_traits<_Tp *> {
  typedef ptrdiff_t difference_type;
  typedef typename remove_cv<_Tp>::type value_type;
  typedef _Tp *pointer;
  typedef _Tp &reference;
  typedef random_access_iterator_tag iterator_category;
};

template <class _Tp, class _Up,
          bool = __has_iterator_category<iterator_traits<_Tp>>::value>
struct __has_iterator_category_convertible_to
    : public integral_constant<
          bool, is_convertible<typename iterator_traits<_Tp>::iterator_category,
                               _Up>::value> {};

template <class _Tp, class _Up>
struct __has_iterator_category_convertible_to<_Tp, _Up, false>
    : public false_type {};

template <class _Tp>
struct __is_cpp17_input_iterator
    : public __has_iterator_category_convertible_to<_Tp, input_iterator_tag> {};

template <class _Tp>
struct __is_cpp17_forward_iterator
    : public __has_iterator_category_convertible_to<_Tp, forward_iterator_tag> {
};

template <class _Tp>
struct __is_cpp17_bidirectional_iterator
    : public __has_iterator_category_convertible_to<
          _Tp, bidirectional_iterator_tag> {};

template <class _Tp>
struct __is_cpp17_random_access_iterator
    : public __has_iterator_category_convertible_to<
          _Tp, random_access_iterator_tag> {};

template <class _Tp>
struct __is_cpp17_contiguous_iterator : public false_type {};

template <class _Tp>
struct __is_exactly_cpp17_input_iterator
    : public integral_constant<bool,
                               __has_iterator_category_convertible_to<
                                   _Tp, input_iterator_tag>::value &&
                                   !__has_iterator_category_convertible_to<
                                       _Tp, forward_iterator_tag>::value> {};
# 625 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iterator" 3
template <class _Category, class _Tp, class _Distance = ptrdiff_t,
          class _Pointer = _Tp *, class _Reference = _Tp &>
struct __attribute__((__type_visibility__("default"))) iterator {
  typedef _Tp value_type;
  typedef _Distance difference_type;
  typedef _Pointer pointer;
  typedef _Reference reference;
  typedef _Category iterator_category;
};

template <class _InputIter>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
__advance(_InputIter &__i,
          typename iterator_traits<_InputIter>::difference_type __n,
          input_iterator_tag) {
  for (; __n > 0; --__n)
    ++__i;
}

template <class _BiDirIter>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
__advance(_BiDirIter &__i,
          typename iterator_traits<_BiDirIter>::difference_type __n,
          bidirectional_iterator_tag) {
  if (__n >= 0)
    for (; __n > 0; --__n)
      ++__i;
  else
    for (; __n < 0; ++__n)
      --__i;
}

template <class _RandIter>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
__advance(_RandIter &__i,
          typename iterator_traits<_RandIter>::difference_type __n,
          random_access_iterator_tag) {
  __i += __n;
}

template <class _InputIter>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
advance(_InputIter &__i,
        typename iterator_traits<_InputIter>::difference_type __n) {
  ((void)0);

  __advance(__i, __n,
            typename iterator_traits<_InputIter>::iterator_category());
}

template <class _InputIter>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename iterator_traits<_InputIter>::difference_type
__distance(_InputIter __first, _InputIter __last, input_iterator_tag) {
  typename iterator_traits<_InputIter>::difference_type __r(0);
  for (; __first != __last; ++__first)
    ++__r;
  return __r;
}

template <class _RandIter>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename iterator_traits<_RandIter>::difference_type
__distance(_RandIter __first, _RandIter __last, random_access_iterator_tag) {
  return __last - __first;
}

template <class _InputIter>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename iterator_traits<_InputIter>::difference_type
distance(_InputIter __first, _InputIter __last) {
  return __distance(__first, __last,
                    typename iterator_traits<_InputIter>::iterator_category());
}

template <class _InputIter>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename enable_if<__is_cpp17_input_iterator<_InputIter>::value,
                   _InputIter>::type
next(_InputIter __x,
     typename iterator_traits<_InputIter>::difference_type __n = 1) {
  ((void)0);

  std::__1::advance(__x, __n);
  return __x;
}

template <class _InputIter>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename enable_if<__is_cpp17_input_iterator<_InputIter>::value,
                   _InputIter>::type
prev(_InputIter __x,
     typename iterator_traits<_InputIter>::difference_type __n = 1) {
  ((void)0);

  std::__1::advance(__x, -__n);
  return __x;
}

template <class _Tp, class = void>
struct __is_stashing_iterator : false_type {};

template <class _Tp>
struct __is_stashing_iterator<
    _Tp, typename __void_t<typename _Tp::__stashing_iterator_tag>::type>
    : true_type {};

template <class _Iter>
class __attribute__((__type_visibility__("default"))) reverse_iterator
    : public iterator<typename iterator_traits<_Iter>::iterator_category,
                      typename iterator_traits<_Iter>::value_type,
                      typename iterator_traits<_Iter>::difference_type,
                      typename iterator_traits<_Iter>::pointer,
                      typename iterator_traits<_Iter>::reference> {
private:
  _Iter __t;

  static_assert(
      !__is_stashing_iterator<_Iter>::value,
      "The specified iterator type cannot be used with reverse_iterator; "
      "Using stashing iterators with reverse_iterator causes undefined "
      "behavior");

protected:
  _Iter current;

public:
  typedef _Iter iterator_type;
  typedef typename iterator_traits<_Iter>::difference_type difference_type;
  typedef typename iterator_traits<_Iter>::reference reference;
  typedef typename iterator_traits<_Iter>::pointer pointer;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reverse_iterator()
      : __t(), current() {}
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit reverse_iterator(_Iter __x)
      : __t(__x), current(__x) {}
  template <class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reverse_iterator(const reverse_iterator<_Up> &__u)
      : __t(__u.base()), current(__u.base()) {}
  template <class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reverse_iterator &
  operator=(const reverse_iterator<_Up> &__u) {
    __t = current = __u.base();
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  _Iter
  base() const {
    return current;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reference
  operator*() const {
    _Iter __tmp = current;
    return *--__tmp;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pointer
  operator->() const {
    return std::__1::addressof(operator*());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reverse_iterator &
  operator++() {
    --current;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reverse_iterator
  operator++(int) {
    reverse_iterator __tmp(*this);
    --current;
    return __tmp;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reverse_iterator &
  operator--() {
    ++current;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reverse_iterator
  operator--(int) {
    reverse_iterator __tmp(*this);
    ++current;
    return __tmp;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reverse_iterator
  operator+(difference_type __n) const {
    return reverse_iterator(current - __n);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reverse_iterator &
  operator+=(difference_type __n) {
    current -= __n;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reverse_iterator
  operator-(difference_type __n) const {
    return reverse_iterator(current + __n);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reverse_iterator &
  operator-=(difference_type __n) {
    current += __n;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reference
  operator[](difference_type __n) const {
    return *(*this + __n);
  }
};

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator==(const reverse_iterator<_Iter1> &__x,
           const reverse_iterator<_Iter2> &__y) {
  return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator<(const reverse_iterator<_Iter1> &__x,
          const reverse_iterator<_Iter2> &__y) {
  return __x.base() > __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator!=(const reverse_iterator<_Iter1> &__x,
           const reverse_iterator<_Iter2> &__y) {
  return __x.base() != __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator>(const reverse_iterator<_Iter1> &__x,
          const reverse_iterator<_Iter2> &__y) {
  return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator>=(const reverse_iterator<_Iter1> &__x,
           const reverse_iterator<_Iter2> &__y) {
  return __x.base() <= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator<=(const reverse_iterator<_Iter1> &__x,
           const reverse_iterator<_Iter2> &__y) {
  return __x.base() >= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) auto
operator-(const reverse_iterator<_Iter1> &__x,
          const reverse_iterator<_Iter2> &__y)
    -> decltype(__y.base() - __x.base()) {
  return __y.base() - __x.base();
}
# 871 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iterator" 3
template <class _Iter>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) reverse_iterator<_Iter>
operator+(typename reverse_iterator<_Iter>::difference_type __n,
          const reverse_iterator<_Iter> &__x) {
  return reverse_iterator<_Iter>(__x.base() - __n);
}

template <class _Iter>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) reverse_iterator<_Iter>
make_reverse_iterator(_Iter __i) {
  return reverse_iterator<_Iter>(__i);
}

template <class _Container>
class __attribute__((__type_visibility__("default"))) back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void> {
protected:
  _Container *container;

public:
  typedef _Container container_type;

  __attribute__((__visibility__("hidden"))) __attribute__((
      internal_linkage)) explicit back_insert_iterator(_Container &__x)
      : container(std::__1::addressof(__x)) {}
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  back_insert_iterator &
  operator=(const typename _Container::value_type &__value_) {
    container->push_back(__value_);
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  back_insert_iterator &
  operator=(typename _Container::value_type &&__value_) {
    container->push_back(std::__1::move(__value_));
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  back_insert_iterator &
  operator*() {
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  back_insert_iterator &
  operator++() {
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  back_insert_iterator
  operator++(int) {
    return *this;
  }
};

template <class _Container>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) back_insert_iterator<_Container>
back_inserter(_Container &__x) {
  return back_insert_iterator<_Container>(__x);
}

template <class _Container>
class __attribute__((__type_visibility__("default"))) front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void> {
protected:
  _Container *container;

public:
  typedef _Container container_type;

  __attribute__((__visibility__("hidden"))) __attribute__((
      internal_linkage)) explicit front_insert_iterator(_Container &__x)
      : container(std::__1::addressof(__x)) {}
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  front_insert_iterator &
  operator=(const typename _Container::value_type &__value_) {
    container->push_front(__value_);
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  front_insert_iterator &
  operator=(typename _Container::value_type &&__value_) {
    container->push_front(std::__1::move(__value_));
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  front_insert_iterator &
  operator*() {
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  front_insert_iterator &
  operator++() {
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  front_insert_iterator
  operator++(int) {
    return *this;
  }
};

template <class _Container>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) front_insert_iterator<_Container>
front_inserter(_Container &__x) {
  return front_insert_iterator<_Container>(__x);
}

template <class _Container>
class __attribute__((__type_visibility__("default"))) insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void> {
protected:
  _Container *container;
  typename _Container::iterator iter;

public:
  typedef _Container container_type;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  insert_iterator(_Container &__x, typename _Container::iterator __i)
      : container(std::__1::addressof(__x)), iter(__i) {}
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  insert_iterator &
  operator=(const typename _Container::value_type &__value_) {
    iter = container->insert(iter, __value_);
    ++iter;
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  insert_iterator &
  operator=(typename _Container::value_type &&__value_) {
    iter = container->insert(iter, std::__1::move(__value_));
    ++iter;
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  insert_iterator &
  operator*() {
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  insert_iterator &
  operator++() {
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  insert_iterator &
  operator++(int) {
    return *this;
  }
};

template <class _Container>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) insert_iterator<_Container>
inserter(_Container &__x, typename _Container::iterator __i) {
  return insert_iterator<_Container>(__x, __i);
}

template <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT>,
          class _Distance = ptrdiff_t>
class __attribute__((__type_visibility__("default"))) istream_iterator
    : public iterator<input_iterator_tag, _Tp, _Distance, const _Tp *,
                      const _Tp &> {
public:
  typedef _CharT char_type;
  typedef _Traits traits_type;
  typedef basic_istream<_CharT, _Traits> istream_type;

private:
  istream_type *__in_stream_;
  _Tp __value_;

public:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr istream_iterator()
      : __in_stream_(0), __value_() {}
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  istream_iterator(istream_type &__s)
      : __in_stream_(std::__1::addressof(__s)) {
    if (!(*__in_stream_ >> __value_))
      __in_stream_ = 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const _Tp &
  operator*() const {
    return __value_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const _Tp *
  operator->() const {
    return std::__1::addressof((operator*()));
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  istream_iterator &
  operator++() {
    if (!(*__in_stream_ >> __value_))
      __in_stream_ = 0;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  istream_iterator
  operator++(int) {
    istream_iterator __t(*this);
    ++(*this);
    return __t;
  }

  template <class _Up, class _CharU, class _TraitsU, class _DistanceU>
  friend __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator==(const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU> &__x,
             const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU> &__y);

  template <class _Up, class _CharU, class _TraitsU, class _DistanceU>
  friend __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator==(const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU> &__x,
             const istream_iterator<_Up, _CharU, _TraitsU, _DistanceU> &__y);
};

template <class _Tp, class _CharT, class _Traits, class _Distance>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator==(const istream_iterator<_Tp, _CharT, _Traits, _Distance> &__x,
           const istream_iterator<_Tp, _CharT, _Traits, _Distance> &__y) {
  return __x.__in_stream_ == __y.__in_stream_;
}

template <class _Tp, class _CharT, class _Traits, class _Distance>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator!=(const istream_iterator<_Tp, _CharT, _Traits, _Distance> &__x,
           const istream_iterator<_Tp, _CharT, _Traits, _Distance> &__y) {
  return !(__x == __y);
}

template <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT>>
class __attribute__((__type_visibility__("default"))) ostream_iterator
    : public iterator<output_iterator_tag, void, void, void, void> {
public:
  typedef _CharT char_type;
  typedef _Traits traits_type;
  typedef basic_ostream<_CharT, _Traits> ostream_type;

private:
  ostream_type *__out_stream_;
  const char_type *__delim_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  ostream_iterator(ostream_type &__s) noexcept
      : __out_stream_(std::__1::addressof(__s)), __delim_(0) {}
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  ostream_iterator(ostream_type &__s, const _CharT *__delimiter) noexcept
      : __out_stream_(std::__1::addressof(__s)), __delim_(__delimiter) {}
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  ostream_iterator &
  operator=(const _Tp &__value_) {
    *__out_stream_ << __value_;
    if (__delim_)
      *__out_stream_ << __delim_;
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  ostream_iterator &
  operator*() {
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  ostream_iterator &
  operator++() {
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  ostream_iterator &
  operator++(int) {
    return *this;
  }
};

template <class _CharT, class _Traits>
class __attribute__((__type_visibility__("default"))) istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
                      _CharT *, _CharT> {
public:
  typedef _CharT char_type;
  typedef _Traits traits_type;
  typedef typename _Traits::int_type int_type;
  typedef basic_streambuf<_CharT, _Traits> streambuf_type;
  typedef basic_istream<_CharT, _Traits> istream_type;

private:
  mutable streambuf_type *__sbuf_;

  class __proxy {
    char_type __keep_;
    streambuf_type *__sbuf_;
    __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
    __proxy(char_type __c, streambuf_type *__s)
        : __keep_(__c), __sbuf_(__s) {}
    friend class istreambuf_iterator;

  public:
    __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
    char_type
    operator*() const {
      return __keep_;
    }
  };

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  __test_for_eof() const {
    if (__sbuf_ &&
        traits_type::eq_int_type(__sbuf_->sgetc(), traits_type::eof()))
      __sbuf_ = 0;
    return __sbuf_ == 0;
  }

public:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr istreambuf_iterator() noexcept
      : __sbuf_(0) {}
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  istreambuf_iterator(istream_type &__s) noexcept
      : __sbuf_(__s.rdbuf()) {}
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  istreambuf_iterator(streambuf_type *__s) noexcept
      : __sbuf_(__s) {}
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  istreambuf_iterator(const __proxy &__p) noexcept
      : __sbuf_(__p.__sbuf_) {}

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  char_type
  operator*() const {
    return static_cast<char_type>(__sbuf_->sgetc());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  istreambuf_iterator &
  operator++() {
    __sbuf_->sbumpc();
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __proxy
  operator++(int) {
    return __proxy(__sbuf_->sbumpc(), __sbuf_);
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  equal(const istreambuf_iterator &__b) const {
    return __test_for_eof() == __b.__test_for_eof();
  }
};

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator==(const istreambuf_iterator<_CharT, _Traits> &__a,
           const istreambuf_iterator<_CharT, _Traits> &__b) {
  return __a.equal(__b);
}

template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator!=(const istreambuf_iterator<_CharT, _Traits> &__a,
           const istreambuf_iterator<_CharT, _Traits> &__b) {
  return !__a.equal(__b);
}

template <class _CharT, class _Traits>
class __attribute__((__type_visibility__("default"))) ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void> {
public:
  typedef _CharT char_type;
  typedef _Traits traits_type;
  typedef basic_streambuf<_CharT, _Traits> streambuf_type;
  typedef basic_ostream<_CharT, _Traits> ostream_type;

private:
  streambuf_type *__sbuf_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  ostreambuf_iterator(ostream_type &__s) noexcept
      : __sbuf_(__s.rdbuf()) {}
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  ostreambuf_iterator(streambuf_type *__s) noexcept
      : __sbuf_(__s) {}
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  ostreambuf_iterator &
  operator=(_CharT __c) {
    if (__sbuf_ &&
        traits_type::eq_int_type(__sbuf_->sputc(__c), traits_type::eof()))
      __sbuf_ = 0;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  ostreambuf_iterator &
  operator*() {
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  ostreambuf_iterator &
  operator++() {
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  ostreambuf_iterator &
  operator++(int) {
    return *this;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  failed() const noexcept {
    return __sbuf_ == 0;
  }

  template <class _Ch, class _Tr>
  friend __attribute__((__visibility__("hidden"))) ostreambuf_iterator<_Ch, _Tr>
  __pad_and_output(ostreambuf_iterator<_Ch, _Tr> __s, const _Ch *__ob,
                   const _Ch *__op, const _Ch *__oe, ios_base &__iob, _Ch __fl);
};

template <class _Iter>
class __attribute__((__type_visibility__("default"))) move_iterator {
private:
  _Iter __i;

public:
  typedef _Iter iterator_type;
  typedef typename iterator_traits<iterator_type>::iterator_category
      iterator_category;
  typedef typename iterator_traits<iterator_type>::value_type value_type;
  typedef
      typename iterator_traits<iterator_type>::difference_type difference_type;
  typedef iterator_type pointer;

  typedef typename iterator_traits<iterator_type>::reference __reference;
  typedef typename conditional<is_reference<__reference>::value,
                               typename remove_reference<__reference>::type &&,
                               __reference>::type reference;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  move_iterator()
      : __i() {}
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit move_iterator(_Iter __x)
      : __i(__x) {}
  template <class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  move_iterator(const move_iterator<_Up> &__u)
      : __i(__u.base()) {}
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  _Iter
  base() const {
    return __i;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reference
  operator*() const {
    return static_cast<reference>(*__i);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pointer
  operator->() const {
    return __i;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  move_iterator &
  operator++() {
    ++__i;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  move_iterator
  operator++(int) {
    move_iterator __tmp(*this);
    ++__i;
    return __tmp;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  move_iterator &
  operator--() {
    --__i;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  move_iterator
  operator--(int) {
    move_iterator __tmp(*this);
    --__i;
    return __tmp;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  move_iterator
  operator+(difference_type __n) const {
    return move_iterator(__i + __n);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  move_iterator &
  operator+=(difference_type __n) {
    __i += __n;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  move_iterator
  operator-(difference_type __n) const {
    return move_iterator(__i - __n);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  move_iterator &
  operator-=(difference_type __n) {
    __i -= __n;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reference
  operator[](difference_type __n) const {
    return static_cast<reference>(__i[__n]);
  }
};

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator==(const move_iterator<_Iter1> &__x, const move_iterator<_Iter2> &__y) {
  return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator<(const move_iterator<_Iter1> &__x, const move_iterator<_Iter2> &__y) {
  return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator!=(const move_iterator<_Iter1> &__x, const move_iterator<_Iter2> &__y) {
  return __x.base() != __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator>(const move_iterator<_Iter1> &__x, const move_iterator<_Iter2> &__y) {
  return __x.base() > __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator>=(const move_iterator<_Iter1> &__x, const move_iterator<_Iter2> &__y) {
  return __x.base() >= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator<=(const move_iterator<_Iter1> &__x, const move_iterator<_Iter2> &__y) {
  return __x.base() <= __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) auto
operator-(const move_iterator<_Iter1> &__x, const move_iterator<_Iter2> &__y)
    -> decltype(__x.base() - __y.base()) {
  return __x.base() - __y.base();
}
# 1307 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iterator" 3
template <class _Iter>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) move_iterator<_Iter>
operator+(typename move_iterator<_Iter>::difference_type __n,
          const move_iterator<_Iter> &__x) {
  return move_iterator<_Iter>(__x.base() + __n);
}

template <class _Iter>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) move_iterator<_Iter>
make_move_iterator(_Iter __i) {
  return move_iterator<_Iter>(__i);
}

template <class _Iter> class __wrap_iter;

template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr bool
operator==(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) noexcept;

template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr bool
operator<(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) noexcept;

template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr bool
operator!=(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) noexcept;

template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr bool
operator>(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) noexcept;

template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr bool
operator>=(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) noexcept;

template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr bool
operator<=(const __wrap_iter<_Iter1> &, const __wrap_iter<_Iter2> &) noexcept;

template <class _Iter1, class _Iter2>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr auto
operator-(const __wrap_iter<_Iter1> &__x,
          const __wrap_iter<_Iter2> &__y) noexcept
    -> decltype(__x.base() - __y.base());

template <class _Iter>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr __wrap_iter<_Iter>
operator+(typename __wrap_iter<_Iter>::difference_type,
          __wrap_iter<_Iter>) noexcept;

template <class _Ip, class _Op>
_Op __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
copy(_Ip, _Ip, _Op);
template <class _B1, class _B2>
_B2 __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
copy_backward(_B1, _B1, _B2);
template <class _Ip, class _Op>
_Op __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
move(_Ip, _Ip, _Op);
template <class _B1, class _B2>
_B2 __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
move_backward(_B1, _B1, _B2);

template <class _Tp>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr
    typename enable_if<is_trivially_copy_assignable<_Tp>::value, _Tp *>::type
        __unwrap_iter(__wrap_iter<_Tp *>);
# 1404 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iterator" 3
template <class _Iter> class __wrap_iter {
public:
  typedef _Iter iterator_type;
  typedef typename iterator_traits<iterator_type>::iterator_category
      iterator_category;
  typedef typename iterator_traits<iterator_type>::value_type value_type;
  typedef
      typename iterator_traits<iterator_type>::difference_type difference_type;
  typedef typename iterator_traits<iterator_type>::pointer pointer;
  typedef typename iterator_traits<iterator_type>::reference reference;

private:
  iterator_type __i;

public:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr __wrap_iter() noexcept

      : __i{}

  {}
  template <class _Up>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr __wrap_iter(
      const __wrap_iter<_Up> &__u,
      typename enable_if<is_convertible<_Up, iterator_type>::value>::type * =
          0) noexcept
      : __i(__u.base()) {}
# 1458 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iterator" 3
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr reference
  operator*() const noexcept {

    return *__i;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr pointer
  operator->() const noexcept {

    return (pointer)std::__1::addressof(*__i);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr __wrap_iter &
  operator++() noexcept {

    ++__i;
    return *this;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr __wrap_iter
  operator++(int) noexcept {
    __wrap_iter __tmp(*this);
    ++(*this);
    return __tmp;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr __wrap_iter &
  operator--() noexcept {

    --__i;
    return *this;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr __wrap_iter
  operator--(int) noexcept {
    __wrap_iter __tmp(*this);
    --(*this);
    return __tmp;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr __wrap_iter
  operator+(difference_type __n) const noexcept {
    __wrap_iter __w(*this);
    __w += __n;
    return __w;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr __wrap_iter &
  operator+=(difference_type __n) noexcept {

    __i += __n;
    return *this;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr __wrap_iter
  operator-(difference_type __n) const noexcept {
    return *this + (-__n);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr __wrap_iter &
  operator-=(difference_type __n) noexcept {
    *this += -__n;
    return *this;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr reference
  operator[](difference_type __n) const noexcept {

    return __i[__n];
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr iterator_type
  base() const noexcept {
    return __i;
  }

private:
  __attribute__((__visibility__("hidden"))) __attribute__((
      internal_linkage)) constexpr __wrap_iter(iterator_type __x) noexcept
      : __i(__x) {}

  template <class _Up> friend class __wrap_iter;
  template <class _CharT, class _Traits, class _Alloc>
  friend class basic_string;
  template <class _Tp, class _Alloc>
  friend class __attribute__((__type_visibility__("default"))) vector;
  template <class _Tp, size_t>
  friend class __attribute__((__type_visibility__("default"))) span;

  template <class _Iter1, class _Iter2>
  constexpr friend bool operator==(const __wrap_iter<_Iter1> &,
                                   const __wrap_iter<_Iter2> &) noexcept;

  template <class _Iter1, class _Iter2>
  constexpr friend bool operator<(const __wrap_iter<_Iter1> &,
                                  const __wrap_iter<_Iter2> &) noexcept;

  template <class _Iter1, class _Iter2>
  constexpr friend bool operator!=(const __wrap_iter<_Iter1> &,
                                   const __wrap_iter<_Iter2> &) noexcept;

  template <class _Iter1, class _Iter2>
  constexpr friend bool operator>(const __wrap_iter<_Iter1> &,
                                  const __wrap_iter<_Iter2> &) noexcept;

  template <class _Iter1, class _Iter2>
  constexpr friend bool operator>=(const __wrap_iter<_Iter1> &,
                                   const __wrap_iter<_Iter2> &) noexcept;

  template <class _Iter1, class _Iter2>
  constexpr friend bool operator<=(const __wrap_iter<_Iter1> &,
                                   const __wrap_iter<_Iter2> &) noexcept;

  template <class _Iter1, class _Iter2>
  constexpr friend auto operator-(const __wrap_iter<_Iter1> &__x,
                                  const __wrap_iter<_Iter2> &__y) noexcept
      -> decltype(__x.base() - __y.base());

  template <class _Iter1>
  constexpr friend __wrap_iter<_Iter1>
  operator+(typename __wrap_iter<_Iter1>::difference_type,
            __wrap_iter<_Iter1>) noexcept;

  template <class _Ip, class _Op> friend _Op copy(_Ip, _Ip, _Op);
  template <class _B1, class _B2> friend _B2 copy_backward(_B1, _B1, _B2);
  template <class _Ip, class _Op> friend _Op move(_Ip, _Ip, _Op);
  template <class _B1, class _B2> friend _B2 move_backward(_B1, _B1, _B2);

  template <class _Tp>
  constexpr friend
      typename enable_if<is_trivially_copy_assignable<_Tp>::value, _Tp *>::type
          __unwrap_iter(__wrap_iter<_Tp *>);
# 1610 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iterator" 3
};

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr bool
operator==(const __wrap_iter<_Iter1> &__x,
           const __wrap_iter<_Iter2> &__y) noexcept {
  return __x.base() == __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr bool
operator<(const __wrap_iter<_Iter1> &__x,
          const __wrap_iter<_Iter2> &__y) noexcept {

  return __x.base() < __y.base();
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr bool
operator!=(const __wrap_iter<_Iter1> &__x,
           const __wrap_iter<_Iter2> &__y) noexcept {
  return !(__x == __y);
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr bool
operator>(const __wrap_iter<_Iter1> &__x,
          const __wrap_iter<_Iter2> &__y) noexcept {
  return __y < __x;
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr bool
operator>=(const __wrap_iter<_Iter1> &__x,
           const __wrap_iter<_Iter2> &__y) noexcept {
  return !(__x < __y);
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr bool
operator<=(const __wrap_iter<_Iter1> &__x,
           const __wrap_iter<_Iter2> &__y) noexcept {
  return !(__y < __x);
}

template <class _Iter1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr bool
operator!=(const __wrap_iter<_Iter1> &__x,
           const __wrap_iter<_Iter1> &__y) noexcept {
  return !(__x == __y);
}

template <class _Iter1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr bool
operator>(const __wrap_iter<_Iter1> &__x,
          const __wrap_iter<_Iter1> &__y) noexcept {
  return __y < __x;
}

template <class _Iter1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr bool
operator>=(const __wrap_iter<_Iter1> &__x,
           const __wrap_iter<_Iter1> &__y) noexcept {
  return !(__x < __y);
}

template <class _Iter1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr bool
operator<=(const __wrap_iter<_Iter1> &__x,
           const __wrap_iter<_Iter1> &__y) noexcept {
  return !(__y < __x);
}

template <class _Iter1, class _Iter2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr auto
operator-(const __wrap_iter<_Iter1> &__x,
          const __wrap_iter<_Iter2> &__y) noexcept
    -> decltype(__x.base() - __y.base()) {

  return __x.base() - __y.base();
}
# 1723 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iterator" 3
template <class _Iter>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr __wrap_iter<_Iter>
operator+(typename __wrap_iter<_Iter>::difference_type __n,
          __wrap_iter<_Iter> __x) noexcept {
  __x += __n;
  return __x;
}

template <class _Iter>
struct __libcpp_is_trivial_iterator
    : public integral_constant<bool, (is_pointer<_Iter>::value)> {};

template <class _Iter>
struct __libcpp_is_trivial_iterator<move_iterator<_Iter>>
    : public integral_constant<bool,
                               (__libcpp_is_trivial_iterator<_Iter>::value)> {};

template <class _Iter>
struct __libcpp_is_trivial_iterator<reverse_iterator<_Iter>>
    : public integral_constant<bool,
                               (__libcpp_is_trivial_iterator<_Iter>::value)> {};

template <class _Iter>
struct __libcpp_is_trivial_iterator<__wrap_iter<_Iter>>
    : public integral_constant<bool,
                               (__libcpp_is_trivial_iterator<_Iter>::value)> {};

template <class _Tp, size_t _Np>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr _Tp *
begin(_Tp (&__array)[_Np]) {
  return __array;
}

template <class _Tp, size_t _Np>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr _Tp *
end(_Tp (&__array)[_Np]) {
  return __array + _Np;
}

template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) auto
begin(_Cp &__c) -> decltype(__c.begin()) {
  return __c.begin();
}

template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) auto
begin(const _Cp &__c) -> decltype(__c.begin()) {
  return __c.begin();
}

template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) auto
end(_Cp &__c) -> decltype(__c.end()) {
  return __c.end();
}

template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) auto
end(const _Cp &__c) -> decltype(__c.end()) {
  return __c.end();
}

template <class _Tp, size_t _Np>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
reverse_iterator<_Tp *>
rbegin(_Tp (&__array)[_Np]) {
  return reverse_iterator<_Tp *>(__array + _Np);
}

template <class _Tp, size_t _Np>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
reverse_iterator<_Tp *>
rend(_Tp (&__array)[_Np]) {
  return reverse_iterator<_Tp *>(__array);
}

template <class _Ep>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
reverse_iterator<const _Ep *>
rbegin(initializer_list<_Ep> __il) {
  return reverse_iterator<const _Ep *>(__il.end());
}

template <class _Ep>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
reverse_iterator<const _Ep *>
rend(initializer_list<_Ep> __il) {
  return reverse_iterator<const _Ep *>(__il.begin());
}

template <class _Cp>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr auto
cbegin(const _Cp &__c) -> decltype(std::__1::begin(__c)) {
  return std::__1::begin(__c);
}

template <class _Cp>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr auto
cend(const _Cp &__c) -> decltype(std::__1::end(__c)) {
  return std::__1::end(__c);
}

template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) auto
rbegin(_Cp &__c) -> decltype(__c.rbegin()) {
  return __c.rbegin();
}

template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) auto
rbegin(const _Cp &__c) -> decltype(__c.rbegin()) {
  return __c.rbegin();
}

template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) auto
rend(_Cp &__c) -> decltype(__c.rend()) {
  return __c.rend();
}

template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) auto
rend(const _Cp &__c) -> decltype(__c.rend()) {
  return __c.rend();
}

template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) auto
crbegin(const _Cp &__c) -> decltype(std::__1::rbegin(__c)) {
  return std::__1::rbegin(__c);
}

template <class _Cp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) auto
crend(const _Cp &__c) -> decltype(std::__1::rend(__c)) {
  return std::__1::rend(__c);
}
# 2004 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/iterator" 3
} // namespace __1
} // namespace std
# 660 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 2 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/tuple" 1 3
# 148 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/tuple" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 149 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/tuple" 2 3
# 158 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/tuple" 3

namespace std {
inline namespace __1 {

template <size_t _Ip, class _Hp,
          bool = is_empty<_Hp>::value && !__libcpp_is_final<_Hp>::value>
class __tuple_leaf;

template <size_t _Ip, class _Hp, bool _Ep>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
swap(__tuple_leaf<_Ip, _Hp, _Ep> &__x,
     __tuple_leaf<_Ip, _Hp, _Ep>
         &__y) noexcept(__is_nothrow_swappable<_Hp>::value) {
  swap(__x.get(), __y.get());
}

template <size_t _Ip, class _Hp, bool> class __tuple_leaf {
  _Hp __value_;

  template <class _Tp> static constexpr bool __can_bind_reference() {

    return !__reference_binds_to_temporary(_Hp, _Tp);
  }

  __tuple_leaf &operator=(const __tuple_leaf &);

public:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr __tuple_leaf() noexcept(
      is_nothrow_default_constructible<_Hp>::value)
      : __value_() {
    static_assert(
        !is_reference<_Hp>::value,
        "Attempted to default construct a reference element in a tuple");
  }

  template <class _Alloc>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __tuple_leaf(integral_constant<int, 0>, const _Alloc &)
      : __value_() {
    static_assert(
        !is_reference<_Hp>::value,
        "Attempted to default construct a reference element in a tuple");
  }

  template <class _Alloc>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __tuple_leaf(integral_constant<int, 1>, const _Alloc &__a)
      : __value_(allocator_arg_t(), __a) {
    static_assert(
        !is_reference<_Hp>::value,
        "Attempted to default construct a reference element in a tuple");
  }

  template <class _Alloc>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __tuple_leaf(integral_constant<int, 2>, const _Alloc &__a)
      : __value_(__a) {
    static_assert(
        !is_reference<_Hp>::value,
        "Attempted to default construct a reference element in a tuple");
  }

  template <class _Tp,
            class = _EnableIf<_And<_IsNotSame<__uncvref_t<_Tp>, __tuple_leaf>,
                                   is_constructible<_Hp, _Tp>>::value>>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr explicit __tuple_leaf(
      _Tp &&__t) noexcept((is_nothrow_constructible<_Hp, _Tp>::value))
      : __value_(std::__1::forward<_Tp>(__t)) {
    static_assert(__can_bind_reference<_Tp &&>(),
                  "Attempted construction of reference element binds to a "
                  "temporary whose lifetime has ended");
  }

  template <class _Tp, class _Alloc>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit __tuple_leaf(
      integral_constant<int, 0>, const _Alloc &, _Tp &&__t)
      : __value_(std::__1::forward<_Tp>(__t)) {
    static_assert(__can_bind_reference<_Tp &&>(),
                  "Attempted construction of reference element binds to a "
                  "temporary whose lifetime has ended");
  }

  template <class _Tp, class _Alloc>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit __tuple_leaf(
      integral_constant<int, 1>, const _Alloc &__a, _Tp &&__t)
      : __value_(allocator_arg_t(), __a, std::__1::forward<_Tp>(__t)) {
    static_assert(
        !is_reference<_Hp>::value,
        "Attempted to uses-allocator construct a reference element in a tuple");
  }

  template <class _Tp, class _Alloc>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit __tuple_leaf(
      integral_constant<int, 2>, const _Alloc &__a, _Tp &&__t)
      : __value_(std::__1::forward<_Tp>(__t), __a) {
    static_assert(
        !is_reference<_Hp>::value,
        "Attempted to uses-allocator construct a reference element in a tuple");
  }

  __tuple_leaf(const __tuple_leaf &__t) = default;
  __tuple_leaf(__tuple_leaf &&__t) = default;

  template <class _Tp>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __tuple_leaf &
  operator=(_Tp &&__t) noexcept((is_nothrow_assignable<_Hp &, _Tp>::value)) {
    __value_ = std::__1::forward<_Tp>(__t);
    return *this;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) int
  swap(__tuple_leaf &__t) noexcept(
      __is_nothrow_swappable<__tuple_leaf>::value) {
    std::__1::swap(*this, __t);
    return 0;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr _Hp &
  get() noexcept {
    return __value_;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr const _Hp &
  get() const noexcept {
    return __value_;
  }
};

template <size_t _Ip, class _Hp>
class __tuple_leaf<_Ip, _Hp, true> : private _Hp {

  __tuple_leaf &operator=(const __tuple_leaf &);

public:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr __tuple_leaf() noexcept(
      is_nothrow_default_constructible<_Hp>::value) {}

  template <class _Alloc>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __tuple_leaf(integral_constant<int, 0>, const _Alloc &) {}

  template <class _Alloc>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __tuple_leaf(integral_constant<int, 1>, const _Alloc &__a)
      : _Hp(allocator_arg_t(), __a) {}

  template <class _Alloc>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __tuple_leaf(integral_constant<int, 2>, const _Alloc &__a)
      : _Hp(__a) {}

  template <class _Tp,
            class = _EnableIf<_And<_IsNotSame<__uncvref_t<_Tp>, __tuple_leaf>,
                                   is_constructible<_Hp, _Tp>>::value>>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr explicit __tuple_leaf(
      _Tp &&__t) noexcept((is_nothrow_constructible<_Hp, _Tp>::value))
      : _Hp(std::__1::forward<_Tp>(__t)) {}

  template <class _Tp, class _Alloc>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit __tuple_leaf(
      integral_constant<int, 0>, const _Alloc &, _Tp &&__t)
      : _Hp(std::__1::forward<_Tp>(__t)) {}

  template <class _Tp, class _Alloc>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit __tuple_leaf(
      integral_constant<int, 1>, const _Alloc &__a, _Tp &&__t)
      : _Hp(allocator_arg_t(), __a, std::__1::forward<_Tp>(__t)) {}

  template <class _Tp, class _Alloc>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit __tuple_leaf(
      integral_constant<int, 2>, const _Alloc &__a, _Tp &&__t)
      : _Hp(std::__1::forward<_Tp>(__t), __a) {}

  __tuple_leaf(__tuple_leaf const &) = default;
  __tuple_leaf(__tuple_leaf &&) = default;

  template <class _Tp>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __tuple_leaf &
  operator=(_Tp &&__t) noexcept((is_nothrow_assignable<_Hp &, _Tp>::value)) {
    _Hp::operator=(std::__1::forward<_Tp>(__t));
    return *this;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) int
  swap(__tuple_leaf &__t) noexcept(
      __is_nothrow_swappable<__tuple_leaf>::value) {
    std::__1::swap(*this, __t);
    return 0;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr _Hp &
  get() noexcept {
    return static_cast<_Hp &>(*this);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr const _Hp &
  get() const noexcept {
    return static_cast<const _Hp &>(*this);
  }
};

template <class... _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) void
__swallow(_Tp &&...) noexcept {}

template <class _Tp> struct __all_default_constructible;

template <class... _Tp>
struct __all_default_constructible<__tuple_types<_Tp...>>
    : __all<is_default_constructible<_Tp>::value...> {};

template <class _Indx, class... _Tp> struct __tuple_impl;

template <size_t... _Indx, class... _Tp>
struct __tuple_impl<__tuple_indices<_Indx...>, _Tp...>
    : public __tuple_leaf<_Indx, _Tp>... {
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr __tuple_impl() noexcept(
      __all<is_nothrow_default_constructible<_Tp>::value...>::value) {}

  template <size_t... _Uf, class... _Tf, size_t... _Ul, class... _Tl,
            class... _Up>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr explicit __tuple_impl(
      __tuple_indices<_Uf...>, __tuple_types<_Tf...>, __tuple_indices<_Ul...>,
      __tuple_types<_Tl...>,
      _Up &&...__u) noexcept((__all<is_nothrow_constructible<_Tf, _Up>::
                                        value...>::value &&
                              __all<is_nothrow_default_constructible<
                                  _Tl>::value...>::value))
      :

        __tuple_leaf<_Uf, _Tf>(std::__1::forward<_Up>(__u))...,
        __tuple_leaf<_Ul, _Tl>()... {}

  template <class _Alloc, size_t... _Uf, class... _Tf, size_t... _Ul,
            class... _Tl, class... _Up>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit __tuple_impl(
      allocator_arg_t, const _Alloc &__a, __tuple_indices<_Uf...>,
      __tuple_types<_Tf...>, __tuple_indices<_Ul...>, __tuple_types<_Tl...>,
      _Up &&...__u)
      : __tuple_leaf<_Uf, _Tf>(__uses_alloc_ctor<_Tf, _Alloc, _Up>(), __a,
                               std::__1::forward<_Up>(__u))...,
        __tuple_leaf<_Ul, _Tl>(__uses_alloc_ctor<_Tl, _Alloc>(), __a)... {}

  template <class _Tuple, class = typename enable_if<__tuple_constructible<
                              _Tuple, tuple<_Tp...>>::value>::type>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr __tuple_impl(_Tuple &&__t) noexcept(
      (__all<is_nothrow_constructible<
           _Tp, typename tuple_element<
                    _Indx, typename __make_tuple_types<_Tuple>::type>::type>::
                 value...>::value))

      : __tuple_leaf<_Indx, _Tp>(
            std::__1::forward<typename tuple_element<
                _Indx, typename __make_tuple_types<_Tuple>::type>::type>(
                std::__1::get<_Indx>(__t)))... {}

  template <class _Alloc, class _Tuple,
            class = typename enable_if<
                __tuple_constructible<_Tuple, tuple<_Tp...>>::value>::type>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __tuple_impl(allocator_arg_t, const _Alloc &__a, _Tuple &&__t)
      : __tuple_leaf<_Indx, _Tp>(
            __uses_alloc_ctor<
                _Tp, _Alloc,
                typename tuple_element<
                    _Indx, typename __make_tuple_types<_Tuple>::type>::type>(),
            __a,
            std::__1::forward<typename tuple_element<
                _Indx, typename __make_tuple_types<_Tuple>::type>::type>(
                std::__1::get<_Indx>(__t)))... {}

  template <class _Tuple>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename enable_if<__tuple_assignable<_Tuple, tuple<_Tp...>>::value,
                     __tuple_impl &>::type
  operator=(_Tuple &&__t) noexcept(
      (__all<is_nothrow_assignable<
           _Tp &, typename tuple_element<
                      _Indx, typename __make_tuple_types<_Tuple>::type>::type>::
                 value...>::value))

  {
    __swallow(__tuple_leaf<_Indx, _Tp>::operator=(
        std::__1::forward<typename tuple_element<
            _Indx, typename __make_tuple_types<_Tuple>::type>::type>(
            std::__1::get<_Indx>(__t)))...);
    return *this;
  }

  __tuple_impl(const __tuple_impl &) = default;
  __tuple_impl(__tuple_impl &&) = default;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __tuple_impl &
  operator=(const __tuple_impl &__t) noexcept(
      (__all<is_nothrow_copy_assignable<_Tp>::value...>::value)) {
    __swallow(__tuple_leaf<_Indx, _Tp>::operator=(
        static_cast<const __tuple_leaf<_Indx, _Tp> &>(__t).get())...);
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __tuple_impl &
  operator=(__tuple_impl &&__t) noexcept(
      (__all<is_nothrow_move_assignable<_Tp>::value...>::value)) {
    __swallow(__tuple_leaf<_Indx, _Tp>::operator=(std::__1::forward<_Tp>(
        static_cast<__tuple_leaf<_Indx, _Tp> &>(__t).get()))...);
    return *this;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  swap(__tuple_impl &__t) noexcept(
      __all<__is_nothrow_swappable<_Tp>::value...>::value) {
    __swallow(__tuple_leaf<_Indx, _Tp>::swap(
        static_cast<__tuple_leaf<_Indx, _Tp> &>(__t))...);
  }
};

template <class... _Tp>
class __attribute__((__type_visibility__("default"))) tuple {
  typedef __tuple_impl<typename __make_tuple_indices<sizeof...(_Tp)>::type,
                       _Tp...>
      _BaseT;

  _BaseT __base_;

  static constexpr bool _EnableImplicitReducedArityExtension = false;

  template <class... _Args> struct _PackExpandsToThisTuple : false_type {};

  template <class _Arg>
  struct _PackExpandsToThisTuple<_Arg>
      : is_same<typename __uncvref<_Arg>::type, tuple> {};

  template <bool _MaybeEnable, class _Dummy = void>
  struct _CheckArgsConstructor : __check_tuple_constructor_fail {};

  template <class _Dummy> struct _CheckArgsConstructor<true, _Dummy> {
    template <int &...> static constexpr bool __enable_implicit_default() {
      return __all<__is_implicitly_default_constructible<_Tp>::value...>::value;
    }

    template <int &...> static constexpr bool __enable_explicit_default() {
      return __all<is_default_constructible<_Tp>::value...>::value &&
             !__enable_implicit_default<>();
    }

    template <class... _Args> static constexpr bool __enable_explicit() {
      return __tuple_constructible<
                 tuple<_Args...>,
                 typename __make_tuple_types<
                     tuple, sizeof...(_Args) < sizeof...(_Tp)
                                ? sizeof...(_Args)
                                : sizeof...(_Tp)>::type>::value &&
             !__tuple_convertible<
                 tuple<_Args...>,
                 typename __make_tuple_types<
                     tuple, sizeof...(_Args) < sizeof...(_Tp)
                                ? sizeof...(_Args)
                                : sizeof...(_Tp)>::type>::value &&
             __all_default_constructible<typename __make_tuple_types<
                 tuple, sizeof...(_Tp),
                 sizeof...(_Args) < sizeof...(_Tp)
                     ? sizeof...(_Args)
                     : sizeof...(_Tp)>::type>::value;
    }

    template <class... _Args> static constexpr bool __enable_implicit() {
      return __tuple_constructible<
                 tuple<_Args...>,
                 typename __make_tuple_types<
                     tuple, sizeof...(_Args) < sizeof...(_Tp)
                                ? sizeof...(_Args)
                                : sizeof...(_Tp)>::type>::value &&
             __tuple_convertible<
                 tuple<_Args...>,
                 typename __make_tuple_types<
                     tuple, sizeof...(_Args) < sizeof...(_Tp)
                                ? sizeof...(_Args)
                                : sizeof...(_Tp)>::type>::value &&
             __all_default_constructible<typename __make_tuple_types<
                 tuple, sizeof...(_Tp),
                 sizeof...(_Args) < sizeof...(_Tp)
                     ? sizeof...(_Args)
                     : sizeof...(_Tp)>::type>::value;
    }
  };

  template <bool _MaybeEnable, bool = sizeof...(_Tp) == 1, class _Dummy = void>
  struct _CheckTupleLikeConstructor : __check_tuple_constructor_fail {};

  template <class _Dummy>
  struct _CheckTupleLikeConstructor<true, false, _Dummy> {
    template <class _Tuple> static constexpr bool __enable_implicit() {
      return __tuple_constructible<_Tuple, tuple>::value &&
             __tuple_convertible<_Tuple, tuple>::value;
    }

    template <class _Tuple> static constexpr bool __enable_explicit() {
      return __tuple_constructible<_Tuple, tuple>::value &&
             !__tuple_convertible<_Tuple, tuple>::value;
    }
  };

  template <class _Dummy>
  struct _CheckTupleLikeConstructor<true, true, _Dummy> {

    template <class _Tuple>
    using _PreferTupleLikeConstructor = _Or<

        _IsSame<__uncvref_t<_Tuple>, tuple>,
        _Lazy<_And, _Not<is_constructible<_Tp..., _Tuple>>,
              _Not<is_convertible<_Tuple, _Tp...>>>>;

    template <class _Tuple> static constexpr bool __enable_implicit() {
      return _And<__tuple_constructible<_Tuple, tuple>,
                  __tuple_convertible<_Tuple, tuple>,
                  _PreferTupleLikeConstructor<_Tuple>>::value;
    }

    template <class _Tuple> static constexpr bool __enable_explicit() {
      return _And<__tuple_constructible<_Tuple, tuple>,
                  _PreferTupleLikeConstructor<_Tuple>,
                  _Not<__tuple_convertible<_Tuple, tuple>>>::value;
    }
  };

  template <class _Tuple, bool _DisableIfLValue>
  using _EnableImplicitTupleLikeConstructor =
      _EnableIf<_CheckTupleLikeConstructor<
                    __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value &&
                    !_PackExpandsToThisTuple<_Tuple>::value &&
                    (!is_lvalue_reference<_Tuple>::value ||
                     !_DisableIfLValue)>::template __enable_implicit<_Tuple>(),
                bool>;

  template <class _Tuple, bool _DisableIfLValue>
  using _EnableExplicitTupleLikeConstructor =
      _EnableIf<_CheckTupleLikeConstructor<
                    __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::value &&
                    !_PackExpandsToThisTuple<_Tuple>::value &&
                    (!is_lvalue_reference<_Tuple>::value ||
                     !_DisableIfLValue)>::template __enable_explicit<_Tuple>(),
                bool>;
  template <size_t _Jp, class... _Up>
  friend constexpr typename tuple_element<_Jp, tuple<_Up...>>::type &
  get(tuple<_Up...> &) noexcept;
  template <size_t _Jp, class... _Up>
  friend constexpr const typename tuple_element<_Jp, tuple<_Up...>>::type &
  get(const tuple<_Up...> &) noexcept;
  template <size_t _Jp, class... _Up>
  friend constexpr typename tuple_element<_Jp, tuple<_Up...>>::type &&
  get(tuple<_Up...> &&) noexcept;
  template <size_t _Jp, class... _Up>
  friend constexpr const typename tuple_element<_Jp, tuple<_Up...>>::type &&
  get(const tuple<_Up...> &&) noexcept;

public:
  template <
      bool _Dummy = true,
      _EnableIf<_CheckArgsConstructor<_Dummy>::__enable_implicit_default(),
                void *> = nullptr>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr tuple() noexcept(
      __all<is_nothrow_default_constructible<_Tp>::value...>::value) {}

  template <
      bool _Dummy = true,
      _EnableIf<_CheckArgsConstructor<_Dummy>::__enable_explicit_default(),
                void *> = nullptr>
  explicit __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr tuple() noexcept(
      __all<is_nothrow_default_constructible<_Tp>::value...>::value) {}

  tuple(tuple const &) = default;
  tuple(tuple &&) = default;

  template <
      class _AllocArgT, class _Alloc,
      _EnableIf<_CheckArgsConstructor<_IsSame<allocator_arg_t, _AllocArgT>::
                                          value>::__enable_implicit_default(),
                void *> = nullptr>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  tuple(_AllocArgT, _Alloc const &__a)
      : __base_(allocator_arg_t(), __a, __tuple_indices<>(), __tuple_types<>(),
                typename __make_tuple_indices<sizeof...(_Tp), 0>::type(),
                __tuple_types<_Tp...>()) {}

  template <
      class _AllocArgT, class _Alloc,
      _EnableIf<_CheckArgsConstructor<_IsSame<allocator_arg_t, _AllocArgT>::
                                          value>::__enable_explicit_default(),
                void *> = nullptr>
  explicit __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) tuple(_AllocArgT, _Alloc const &__a)
      : __base_(allocator_arg_t(), __a, __tuple_indices<>(), __tuple_types<>(),
                typename __make_tuple_indices<sizeof...(_Tp), 0>::type(),
                __tuple_types<_Tp...>()) {}

  template <bool _Dummy = true,
            typename enable_if<_CheckArgsConstructor<_Dummy>::
                                   template __enable_implicit<_Tp const &...>(),
                               bool>::type = false>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr tuple(const _Tp &...__t) noexcept(
      (__all<is_nothrow_copy_constructible<_Tp>::value...>::value))
      : __base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(), __t...) {}

  template <bool _Dummy = true,
            typename enable_if<_CheckArgsConstructor<_Dummy>::
                                   template __enable_explicit<_Tp const &...>(),
                               bool>::type = false>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr explicit tuple(
      const _Tp &...__t) noexcept((__all<is_nothrow_copy_constructible<_Tp>::
                                             value...>::value))
      : __base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(), __t...) {}

  template <class _Alloc, bool _Dummy = true,
            typename enable_if<_CheckArgsConstructor<_Dummy>::
                                   template __enable_implicit<_Tp const &...>(),
                               bool>::type = false>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  tuple(allocator_arg_t, const _Alloc &__a, const _Tp &...__t)
      : __base_(allocator_arg_t(), __a,
                typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(), __t...) {}

  template <class _Alloc, bool _Dummy = true,
            typename enable_if<_CheckArgsConstructor<_Dummy>::
                                   template __enable_explicit<_Tp const &...>(),
                               bool>::type = false>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit tuple(allocator_arg_t,
                                                   const _Alloc &__a,
                                                   const _Tp &...__t)
      : __base_(allocator_arg_t(), __a,
                typename __make_tuple_indices<sizeof...(_Tp)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
                typename __make_tuple_indices<0>::type(),
                typename __make_tuple_types<tuple, 0>::type(), __t...) {}

  template <class... _Up,
            bool _PackIsTuple = _PackExpandsToThisTuple<_Up...>::value,
            typename enable_if<
                _CheckArgsConstructor<
                    sizeof...(_Up) == sizeof...(_Tp) &&
                    !_PackIsTuple>::template __enable_implicit<_Up...>() ||
                    _CheckArgsConstructor<
                        _EnableImplicitReducedArityExtension &&
                        sizeof...(_Up) < sizeof...(_Tp) &&
                        !_PackIsTuple>::template __enable_implicit<_Up...>(),
                bool>::type = false>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr tuple(_Up &&...__u) noexcept(
      (is_nothrow_constructible<
          _BaseT, typename __make_tuple_indices<sizeof...(_Up)>::type,
          typename __make_tuple_types<tuple, sizeof...(_Up)>::type,
          typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type,
          typename __make_tuple_types<tuple, sizeof...(_Tp),
                                      sizeof...(_Up)>::type,
          _Up...>::value))
# 793 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/tuple" 3
      : __base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                typename __make_tuple_indices<sizeof...(_Tp),
                                              sizeof...(_Up)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp),
                                            sizeof...(_Up)>::type(),
                std::__1::forward<_Up>(__u)...) {
  }

  template <
      class... _Up,
      typename enable_if<
          _CheckArgsConstructor<sizeof...(_Up) <= sizeof...(_Tp) &&
                                !_PackExpandsToThisTuple<_Up...>::value>::
                  template __enable_explicit<_Up...>() ||
              _CheckArgsConstructor<!_EnableImplicitReducedArityExtension &&
                                    sizeof...(_Up) < sizeof...(_Tp) &&
                                    !_PackExpandsToThisTuple<_Up...>::value>::
                  template __enable_implicit<_Up...>(),
          bool>::type = false>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr explicit tuple(_Up &&...__u) noexcept(
      (is_nothrow_constructible<
          _BaseT, typename __make_tuple_indices<sizeof...(_Up)>::type,
          typename __make_tuple_types<tuple, sizeof...(_Up)>::type,
          typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type,
          typename __make_tuple_types<tuple, sizeof...(_Tp),
                                      sizeof...(_Up)>::type,
          _Up...>::value))
# 826 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/tuple" 3
      : __base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                typename __make_tuple_indices<sizeof...(_Tp),
                                              sizeof...(_Up)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp),
                                            sizeof...(_Up)>::type(),
                std::__1::forward<_Up>(__u)...) {
  }

  template <class _Alloc, class... _Up,
            typename enable_if<
                _CheckArgsConstructor<sizeof...(_Up) == sizeof...(_Tp) &&
                                      !_PackExpandsToThisTuple<_Up...>::value>::
                    template __enable_implicit<_Up...>(),
                bool>::type = false>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  tuple(allocator_arg_t, const _Alloc &__a, _Up &&...__u)
      : __base_(allocator_arg_t(), __a,
                typename __make_tuple_indices<sizeof...(_Up)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                typename __make_tuple_indices<sizeof...(_Tp),
                                              sizeof...(_Up)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp),
                                            sizeof...(_Up)>::type(),
                std::__1::forward<_Up>(__u)...) {}

  template <class _Alloc, class... _Up,
            typename enable_if<
                _CheckArgsConstructor<sizeof...(_Up) == sizeof...(_Tp) &&
                                      !_PackExpandsToThisTuple<_Up...>::value>::
                    template __enable_explicit<_Up...>(),
                bool>::type = false>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit tuple(allocator_arg_t,
                                                   const _Alloc &__a,
                                                   _Up &&...__u)
      : __base_(allocator_arg_t(), __a,
                typename __make_tuple_indices<sizeof...(_Up)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
                typename __make_tuple_indices<sizeof...(_Tp),
                                              sizeof...(_Up)>::type(),
                typename __make_tuple_types<tuple, sizeof...(_Tp),
                                            sizeof...(_Up)>::type(),
                std::__1::forward<_Up>(__u)...) {}

  template <class _Tuple,
            _EnableImplicitTupleLikeConstructor<_Tuple, true> = false>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr tuple(_Tuple &&__t) noexcept(
      (is_nothrow_constructible<_BaseT, _Tuple>::value))
      : __base_(std::__1::forward<_Tuple>(__t)) {}

  template <class _Tuple,
            _EnableImplicitTupleLikeConstructor<const _Tuple &, false> = false>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr tuple(const _Tuple &__t) noexcept(
      (is_nothrow_constructible<_BaseT, const _Tuple &>::value))
      : __base_(__t) {}
  template <class _Tuple,
            _EnableExplicitTupleLikeConstructor<_Tuple, true> = false>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr explicit tuple(
      _Tuple &&__t) noexcept((is_nothrow_constructible<_BaseT, _Tuple>::value))
      : __base_(std::__1::forward<_Tuple>(__t)) {}

  template <class _Tuple,
            _EnableExplicitTupleLikeConstructor<const _Tuple &, false> = false>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr explicit tuple(
      const _Tuple
          &__t) noexcept((is_nothrow_constructible<_BaseT,
                                                   const _Tuple &>::value))
      : __base_(__t) {}

  template <
      class _Alloc, class _Tuple,
      typename enable_if<_CheckTupleLikeConstructor<
                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::
                                 value>::template __enable_implicit<_Tuple>(),
                         bool>::type = false>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  tuple(allocator_arg_t, const _Alloc &__a, _Tuple &&__t)
      : __base_(allocator_arg_t(), __a, std::__1::forward<_Tuple>(__t)) {}

  template <
      class _Alloc, class _Tuple,
      typename enable_if<_CheckTupleLikeConstructor<
                             __tuple_like_with_size<_Tuple, sizeof...(_Tp)>::
                                 value>::template __enable_explicit<_Tuple>(),
                         bool>::type = false>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit tuple(allocator_arg_t,
                                                   const _Alloc &__a,
                                                   _Tuple &&__t)
      : __base_(allocator_arg_t(), __a, std::__1::forward<_Tuple>(__t)) {}

  using _CanCopyAssign = __all<is_copy_assignable<_Tp>::value...>;
  using _CanMoveAssign = __all<is_move_assignable<_Tp>::value...>;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  tuple &
  operator=(
      typename conditional<_CanCopyAssign::value, tuple, __nat>::type const
          &__t) noexcept((__all<is_nothrow_copy_assignable<_Tp>::value...>::
                              value)) {
    __base_.operator=(__t.__base_);
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  tuple &
  operator=(
      typename conditional<_CanMoveAssign::value, tuple, __nat>::type
          &&__t) noexcept((__all<is_nothrow_move_assignable<_Tp>::value...>::
                               value)) {
    __base_.operator=(static_cast<_BaseT &&>(__t.__base_));
    return *this;
  }

  template <class _Tuple, class = typename enable_if<
                              __tuple_assignable<_Tuple, tuple>::value>::type>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  tuple &
  operator=(_Tuple &&__t) noexcept(
      (is_nothrow_assignable<_BaseT &, _Tuple>::value)) {
    __base_.operator=(std::__1::forward<_Tuple>(__t));
    return *this;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  swap(tuple &__t) noexcept(
      __all<__is_nothrow_swappable<_Tp>::value...>::value) {
    __base_.swap(__t.__base_);
  }
};

template <> class __attribute__((__type_visibility__("default"))) tuple<> {
public:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr tuple() noexcept = default;
  template <class _Alloc>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  tuple(allocator_arg_t, const _Alloc &) noexcept {}
  template <class _Alloc>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  tuple(allocator_arg_t, const _Alloc &, const tuple &) noexcept {}
  template <class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  tuple(array<_Up, 0>) noexcept {}
  template <class _Alloc, class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  tuple(allocator_arg_t, const _Alloc &, array<_Up, 0>) noexcept {}
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  swap(tuple &) noexcept {}
};
# 992 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/tuple" 3
template <class... _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename enable_if<__all<__is_swappable<_Tp>::value...>::value, void>::type
swap(tuple<_Tp...> &__t, tuple<_Tp...> &__u) noexcept(
    __all<__is_nothrow_swappable<_Tp>::value...>::value) {
  __t.swap(__u);
}

template <size_t _Ip, class... _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr
    typename tuple_element<_Ip, tuple<_Tp...>>::type &
    get(tuple<_Tp...> &__t) noexcept {
  typedef typename tuple_element<_Ip, tuple<_Tp...>>::type type;
  return static_cast<__tuple_leaf<_Ip, type> &>(__t.__base_).get();
}

template <size_t _Ip, class... _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr const typename tuple_element<
    _Ip, tuple<_Tp...>>::type &
get(const tuple<_Tp...> &__t) noexcept {
  typedef typename tuple_element<_Ip, tuple<_Tp...>>::type type;
  return static_cast<const __tuple_leaf<_Ip, type> &>(__t.__base_).get();
}

template <size_t _Ip, class... _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr
    typename tuple_element<_Ip, tuple<_Tp...>>::type &&
    get(tuple<_Tp...> &&__t) noexcept {
  typedef typename tuple_element<_Ip, tuple<_Tp...>>::type type;
  return static_cast<type &&>(
      static_cast<__tuple_leaf<_Ip, type> &&>(__t.__base_).get());
}

template <size_t _Ip, class... _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr const typename tuple_element<
    _Ip, tuple<_Tp...>>::type &&
get(const tuple<_Tp...> &&__t) noexcept {
  typedef typename tuple_element<_Ip, tuple<_Tp...>>::type type;
  return static_cast<const type &&>(
      static_cast<const __tuple_leaf<_Ip, type> &&>(__t.__base_).get());
}

namespace __find_detail {

static constexpr size_t __not_found = -1;
static constexpr size_t __ambiguous = __not_found - 1;

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr size_t
__find_idx_return(size_t __curr_i, size_t __res, bool __matches) {
  return !__matches ? __res : (__res == __not_found ? __curr_i : __ambiguous);
}

template <size_t _Nx>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr size_t
__find_idx(size_t __i, const bool (&__matches)[_Nx]) {
  return __i == _Nx ? __not_found
                    : __find_idx_return(__i, __find_idx(__i + 1, __matches),
                                        __matches[__i]);
}

template <class _T1, class... _Args> struct __find_exactly_one_checked {
  static constexpr bool __matches[sizeof...(_Args)] = {
      is_same<_T1, _Args>::value...};
  static constexpr size_t value = __find_detail::__find_idx(0, __matches);
  static_assert(value != __not_found, "type not found in type list");
  static_assert(value != __ambiguous,
                "type occurs more than once in type list");
};

template <class _T1> struct __find_exactly_one_checked<_T1> {
  static_assert(!is_same<_T1, _T1>::value, "type not in empty type list");
};

} // namespace __find_detail

template <typename _T1, typename... _Args>
struct __find_exactly_one_t
    : public __find_detail::__find_exactly_one_checked<_T1, _Args...> {};

template <class _T1, class... _Args>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr _T1 &
get(tuple<_Args...> &__tup) noexcept {
  return std::__1::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);
}

template <class _T1, class... _Args>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr _T1 const &
get(tuple<_Args...> const &__tup) noexcept {
  return std::__1::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);
}

template <class _T1, class... _Args>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr _T1 &&
get(tuple<_Args...> &&__tup) noexcept {
  return std::__1::get<__find_exactly_one_t<_T1, _Args...>::value>(
      std::__1::move(__tup));
}

template <class _T1, class... _Args>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr _T1 const &&
get(tuple<_Args...> const &&__tup) noexcept {
  return std::__1::get<__find_exactly_one_t<_T1, _Args...>::value>(
      std::__1::move(__tup));
}

template <class... _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr tuple<_Tp &...>
tie(_Tp &...__t) noexcept {
  return tuple<_Tp &...>(__t...);
}

template <class _Up> struct __ignore_t {
  template <class _Tp>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr const __ignore_t &
  operator=(_Tp &&) const {
    return *this;
  }
};

namespace {
constexpr __ignore_t<unsigned char> ignore = __ignore_t<unsigned char>();
}

template <class... _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr tuple<
    typename __unwrap_ref_decay<_Tp>::type...>
make_tuple(_Tp &&...__t) {
  return tuple<typename __unwrap_ref_decay<_Tp>::type...>(
      std::__1::forward<_Tp>(__t)...);
}

template <class... _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr tuple<_Tp &&...>
forward_as_tuple(_Tp &&...__t) noexcept {
  return tuple<_Tp &&...>(std::__1::forward<_Tp>(__t)...);
}

template <size_t _Ip> struct __tuple_equal {
  template <class _Tp, class _Up>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr bool
  operator()(const _Tp &__x, const _Up &__y) {
    return __tuple_equal<_Ip - 1>()(__x, __y) &&
           std::__1::get<_Ip - 1>(__x) == std::__1::get<_Ip - 1>(__y);
  }
};

template <> struct __tuple_equal<0> {
  template <class _Tp, class _Up>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr bool
  operator()(const _Tp &, const _Up &) {
    return true;
  }
};

template <class... _Tp, class... _Up>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr bool
operator==(const tuple<_Tp...> &__x, const tuple<_Up...> &__y) {
  static_assert(sizeof...(_Tp) == sizeof...(_Up),
                "Can't compare tuples of different sizes");
  return __tuple_equal<sizeof...(_Tp)>()(__x, __y);
}

template <class... _Tp, class... _Up>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr bool
operator!=(const tuple<_Tp...> &__x, const tuple<_Up...> &__y) {
  return !(__x == __y);
}

template <size_t _Ip> struct __tuple_less {
  template <class _Tp, class _Up>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr bool
  operator()(const _Tp &__x, const _Up &__y) {
    const size_t __idx = tuple_size<_Tp>::value - _Ip;
    if (std::__1::get<__idx>(__x) < std::__1::get<__idx>(__y))
      return true;
    if (std::__1::get<__idx>(__y) < std::__1::get<__idx>(__x))
      return false;
    return __tuple_less<_Ip - 1>()(__x, __y);
  }
};

template <> struct __tuple_less<0> {
  template <class _Tp, class _Up>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr bool
  operator()(const _Tp &, const _Up &) {
    return false;
  }
};

template <class... _Tp, class... _Up>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr bool
operator<(const tuple<_Tp...> &__x, const tuple<_Up...> &__y) {
  static_assert(sizeof...(_Tp) == sizeof...(_Up),
                "Can't compare tuples of different sizes");
  return __tuple_less<sizeof...(_Tp)>()(__x, __y);
}

template <class... _Tp, class... _Up>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr bool
operator>(const tuple<_Tp...> &__x, const tuple<_Up...> &__y) {
  return __y < __x;
}

template <class... _Tp, class... _Up>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr bool
operator>=(const tuple<_Tp...> &__x, const tuple<_Up...> &__y) {
  return !(__x < __y);
}

template <class... _Tp, class... _Up>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr bool
operator<=(const tuple<_Tp...> &__x, const tuple<_Up...> &__y) {
  return !(__y < __x);
}

template <class _Tp, class _Up> struct __tuple_cat_type;

template <class... _Ttypes, class... _Utypes>
struct __tuple_cat_type<tuple<_Ttypes...>, __tuple_types<_Utypes...>> {
  typedef tuple<_Ttypes..., _Utypes...> type;
};

template <class _ResultTuple, bool _Is_Tuple0TupleLike, class... _Tuples>
struct __tuple_cat_return_1 {};

template <class... _Types, class _Tuple0>
struct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0> {
  typedef
      typename __tuple_cat_type<tuple<_Types...>,
                                typename __make_tuple_types<typename __uncvref<
                                    _Tuple0>::type>::type>::type type;
};

template <class... _Types, class _Tuple0, class _Tuple1, class... _Tuples>
struct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0, _Tuple1,
                            _Tuples...>
    : public __tuple_cat_return_1<
          typename __tuple_cat_type<
              tuple<_Types...>, typename __make_tuple_types<typename __uncvref<
                                    _Tuple0>::type>::type>::type,
          __tuple_like<typename remove_reference<_Tuple1>::type>::value,
          _Tuple1, _Tuples...> {};

template <class... _Tuples> struct __tuple_cat_return;

template <class _Tuple0, class... _Tuples>
struct __tuple_cat_return<_Tuple0, _Tuples...>
    : public __tuple_cat_return_1<
          tuple<>,
          __tuple_like<typename remove_reference<_Tuple0>::type>::value,
          _Tuple0, _Tuples...> {};

template <> struct __tuple_cat_return<> { typedef tuple<> type; };

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr tuple<>
tuple_cat() {
  return tuple<>();
}

template <class _Rp, class _Indices, class _Tuple0, class... _Tuples>
struct __tuple_cat_return_ref_imp;

template <class... _Types, size_t... _I0, class _Tuple0>
struct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>,
                                  _Tuple0> {
  typedef typename remove_reference<_Tuple0>::type _T0;
  typedef tuple<
      _Types...,
      typename __apply_cv<_Tuple0, typename tuple_element<_I0, _T0>::type>::type
          &&...>
      type;
};

template <class... _Types, size_t... _I0, class _Tuple0, class _Tuple1,
          class... _Tuples>
struct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>,
                                  _Tuple0, _Tuple1, _Tuples...>
    : public __tuple_cat_return_ref_imp<
          tuple<_Types...,
                typename __apply_cv<
                    _Tuple0, typename tuple_element<
                                 _I0, typename remove_reference<
                                          _Tuple0>::type>::type>::type &&...>,
          typename __make_tuple_indices<tuple_size<
              typename remove_reference<_Tuple1>::type>::value>::type,
          _Tuple1, _Tuples...> {};

template <class _Tuple0, class... _Tuples>
struct __tuple_cat_return_ref
    : public __tuple_cat_return_ref_imp<
          tuple<>,
          typename __make_tuple_indices<tuple_size<
              typename remove_reference<_Tuple0>::type>::value>::type,
          _Tuple0, _Tuples...> {};

template <class _Types, class _I0, class _J0> struct __tuple_cat;

template <class... _Types, size_t... _I0, size_t... _J0>
struct __tuple_cat<tuple<_Types...>, __tuple_indices<_I0...>,
                   __tuple_indices<_J0...>> {
  template <class _Tuple0>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr
      typename __tuple_cat_return_ref<tuple<_Types...> &&, _Tuple0 &&>::type
      operator()(tuple<_Types...> __t, _Tuple0 &&__t0) {
    return std::__1::forward_as_tuple(
        std::__1::forward<_Types>(std::__1::get<_I0>(__t))...,
        std::__1::get<_J0>(std::__1::forward<_Tuple0>(__t0))...);
  }

  template <class _Tuple0, class _Tuple1, class... _Tuples>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr
      typename __tuple_cat_return_ref<tuple<_Types...> &&, _Tuple0 &&,
                                      _Tuple1 &&, _Tuples &&...>::type
      operator()(tuple<_Types...> __t, _Tuple0 &&__t0, _Tuple1 &&__t1,
                 _Tuples &&...__tpls) {
    typedef typename remove_reference<_Tuple0>::type _T0;
    typedef typename remove_reference<_Tuple1>::type _T1;
    return __tuple_cat<
        tuple<_Types...,
              typename __apply_cv<
                  _Tuple0, typename tuple_element<_J0, _T0>::type>::type &&...>,
        typename __make_tuple_indices<sizeof...(_Types) +
                                      tuple_size<_T0>::value>::type,
        typename __make_tuple_indices<tuple_size<_T1>::value>::type>()(
        std::__1::forward_as_tuple(
            std::__1::forward<_Types>(std::__1::get<_I0>(__t))...,
            std::__1::get<_J0>(std::__1::forward<_Tuple0>(__t0))...),
        std::__1::forward<_Tuple1>(__t1),
        std::__1::forward<_Tuples>(__tpls)...);
  }
};

template <class _Tuple0, class... _Tuples>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr
    typename __tuple_cat_return<_Tuple0, _Tuples...>::type
    tuple_cat(_Tuple0 &&__t0, _Tuples &&...__tpls) {
  typedef typename remove_reference<_Tuple0>::type _T0;
  return __tuple_cat<
      tuple<>, __tuple_indices<>,
      typename __make_tuple_indices<tuple_size<_T0>::value>::type>()(
      tuple<>(), std::__1::forward<_Tuple0>(__t0),
      std::__1::forward<_Tuples>(__tpls)...);
}

template <class... _Tp, class _Alloc>
struct __attribute__((__type_visibility__("default")))
uses_allocator<tuple<_Tp...>, _Alloc> : true_type {};

template <class _T1, class _T2>
template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
pair<_T1, _T2>::pair(piecewise_construct_t, tuple<_Args1...> &__first_args,
                     tuple<_Args2...> &__second_args, __tuple_indices<_I1...>,
                     __tuple_indices<_I2...>)
    : first(std::__1::forward<_Args1>(std::__1::get<_I1>(__first_args))...),
      second(std::__1::forward<_Args2>(std::__1::get<_I2>(__second_args))...) {}
# 1451 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/tuple" 3
} // namespace __1
} // namespace std
# 663 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 2 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/stdexcept" 1 3
# 44 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/stdexcept" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 45 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/stdexcept" 2 3
# 53 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/stdexcept" 3

namespace std {
inline namespace __1 {

class __attribute__((__visibility__("hidden"))) __libcpp_refstring {
  const char *__imp_;

  bool __uses_refcount() const;

public:
  explicit __libcpp_refstring(const char *__msg);
  __libcpp_refstring(const __libcpp_refstring &__s) noexcept;
  __libcpp_refstring &operator=(const __libcpp_refstring &__s) noexcept;
  ~__libcpp_refstring();

  const char *c_str() const noexcept { return __imp_; }
};

} // namespace __1
} // namespace std

namespace std {

class __attribute__((__visibility__("default"))) logic_error
    : public exception {

private:
  std::__1::__libcpp_refstring __imp_;

public:
  explicit logic_error(const string &);
  explicit logic_error(const char *);

  logic_error(const logic_error &) noexcept;
  logic_error &operator=(const logic_error &) noexcept;

  virtual ~logic_error() noexcept;

  virtual const char *what() const noexcept;
};

class __attribute__((__visibility__("default"))) runtime_error
    : public exception {

private:
  std::__1::__libcpp_refstring __imp_;

public:
  explicit runtime_error(const string &);
  explicit runtime_error(const char *);

  runtime_error(const runtime_error &) noexcept;
  runtime_error &operator=(const runtime_error &) noexcept;

  virtual ~runtime_error() noexcept;

  virtual const char *what() const noexcept;
};

class __attribute__((__visibility__("default"))) domain_error
    : public logic_error {
public:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit domain_error(const string &__s)
      : logic_error(__s) {}
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit domain_error(const char *__s)
      : logic_error(__s) {}

  virtual ~domain_error() noexcept;
};

class __attribute__((__visibility__("default"))) invalid_argument
    : public logic_error {
public:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit invalid_argument(const string &__s)
      : logic_error(__s) {}
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit invalid_argument(const char *__s)
      : logic_error(__s) {}

  virtual ~invalid_argument() noexcept;
};

class __attribute__((__visibility__("default"))) length_error
    : public logic_error {
public:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit length_error(const string &__s)
      : logic_error(__s) {}
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit length_error(const char *__s)
      : logic_error(__s) {}

  virtual ~length_error() noexcept;
};

class __attribute__((__visibility__("default"))) out_of_range
    : public logic_error {
public:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit out_of_range(const string &__s)
      : logic_error(__s) {}
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit out_of_range(const char *__s)
      : logic_error(__s) {}

  virtual ~out_of_range() noexcept;
};

class __attribute__((__visibility__("default"))) range_error
    : public runtime_error {
public:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit range_error(const string &__s)
      : runtime_error(__s) {}
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit range_error(const char *__s)
      : runtime_error(__s) {}

  virtual ~range_error() noexcept;
};

class __attribute__((__visibility__("default"))) overflow_error
    : public runtime_error {
public:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit overflow_error(const string &__s)
      : runtime_error(__s) {}
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit overflow_error(const char *__s)
      : runtime_error(__s) {}

  virtual ~overflow_error() noexcept;
};

class __attribute__((__visibility__("default"))) underflow_error
    : public runtime_error {
public:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit underflow_error(const string &__s)
      : runtime_error(__s) {}
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit underflow_error(const char *__s)
      : runtime_error(__s) {}

  virtual ~underflow_error() noexcept;
};

} // namespace std

namespace std {
inline namespace __1 {

[[noreturn]] __attribute__((__visibility__("default"))) void
__throw_runtime_error(const char *);

[[noreturn]] inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
__throw_logic_error(const char *__msg) {

  throw logic_error(__msg);
}

[[noreturn]] inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
__throw_domain_error(const char *__msg) {

  throw domain_error(__msg);
}

[[noreturn]] inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
__throw_invalid_argument(const char *__msg) {

  throw invalid_argument(__msg);
}

[[noreturn]] inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
__throw_length_error(const char *__msg) {

  throw length_error(__msg);
}

[[noreturn]] inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
__throw_out_of_range(const char *__msg) {

  throw out_of_range(__msg);
}

[[noreturn]] inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
__throw_range_error(const char *__msg) {

  throw range_error(__msg);
}

[[noreturn]] inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
__throw_overflow_error(const char *__msg) {

  throw overflow_error(__msg);
}

[[noreturn]] inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
__throw_underflow_error(const char *__msg) {

  throw underflow_error(__msg);
}

} // namespace __1
} // namespace std
# 664 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 2 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/atomic" 1 3
# 549 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/atomic" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 550 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/atomic" 2 3
# 557 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/atomic" 3
# 585 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/atomic" 3
namespace std {
inline namespace __1 {

enum __legacy_memory_order {
  __mo_relaxed,
  __mo_consume,
  __mo_acquire,
  __mo_release,
  __mo_acq_rel,
  __mo_seq_cst
};

typedef underlying_type<__legacy_memory_order>::type
    __memory_order_underlying_t;
# 621 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/atomic" 3
typedef enum memory_order {
  memory_order_relaxed = __mo_relaxed,
  memory_order_consume = __mo_consume,
  memory_order_acquire = __mo_acquire,
  memory_order_release = __mo_release,
  memory_order_acq_rel = __mo_acq_rel,
  memory_order_seq_cst = __mo_seq_cst,
} memory_order;

static_assert((is_same<underlying_type<memory_order>::type,
                       __memory_order_underlying_t>::value),
              "unexpected underlying type for std::memory_order");
# 912 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/atomic" 3
template <typename _Tp> struct __cxx_atomic_base_impl {

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))

  __cxx_atomic_base_impl() noexcept = default;

  constexpr explicit __cxx_atomic_base_impl(_Tp value) noexcept
      : __a_value(value) {}
  __extension__ _Atomic(_Tp) __a_value;
};

__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) inline void
__cxx_atomic_thread_fence(memory_order __order) noexcept {
  __c11_atomic_thread_fence(static_cast<__memory_order_underlying_t>(__order));
}

__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) inline void
__cxx_atomic_signal_fence(memory_order __order) noexcept {
  __c11_atomic_signal_fence(static_cast<__memory_order_underlying_t>(__order));
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) void
__cxx_atomic_init(__cxx_atomic_base_impl<_Tp> volatile *__a,
                  _Tp __val) noexcept {
  __c11_atomic_init(&__a->__a_value, __val);
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) void
__cxx_atomic_init(__cxx_atomic_base_impl<_Tp> *__a, _Tp __val) noexcept {
  __c11_atomic_init(&__a->__a_value, __val);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) void
__cxx_atomic_store(__cxx_atomic_base_impl<_Tp> volatile *__a, _Tp __val,
                   memory_order __order) noexcept {
  __c11_atomic_store(&__a->__a_value, __val,
                     static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) void
__cxx_atomic_store(__cxx_atomic_base_impl<_Tp> *__a, _Tp __val,
                   memory_order __order) noexcept {
  __c11_atomic_store(&__a->__a_value, __val,
                     static_cast<__memory_order_underlying_t>(__order));
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) _Tp
__cxx_atomic_load(__cxx_atomic_base_impl<_Tp> const volatile *__a,
                  memory_order __order) noexcept {
  using __ptr_type = typename remove_const<decltype(__a->__a_value)>::type *;
  return __c11_atomic_load(const_cast<__ptr_type>(&__a->__a_value),
                           static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) _Tp
__cxx_atomic_load(__cxx_atomic_base_impl<_Tp> const *__a,
                  memory_order __order) noexcept {
  using __ptr_type = typename remove_const<decltype(__a->__a_value)>::type *;
  return __c11_atomic_load(const_cast<__ptr_type>(&__a->__a_value),
                           static_cast<__memory_order_underlying_t>(__order));
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) _Tp
__cxx_atomic_exchange(__cxx_atomic_base_impl<_Tp> volatile *__a, _Tp __value,
                      memory_order __order) noexcept {
  return __c11_atomic_exchange(
      &__a->__a_value, __value,
      static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) _Tp
__cxx_atomic_exchange(__cxx_atomic_base_impl<_Tp> *__a, _Tp __value,
                      memory_order __order) noexcept {
  return __c11_atomic_exchange(
      &__a->__a_value, __value,
      static_cast<__memory_order_underlying_t>(__order));
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) bool
__cxx_atomic_compare_exchange_strong(__cxx_atomic_base_impl<_Tp> volatile *__a,
                                     _Tp *__expected, _Tp __value,
                                     memory_order __success,
                                     memory_order __failure) noexcept {
  return __c11_atomic_compare_exchange_strong(
      &__a->__a_value, __expected, __value,
      static_cast<__memory_order_underlying_t>(__success),
      static_cast<__memory_order_underlying_t>(__failure));
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) bool
__cxx_atomic_compare_exchange_strong(__cxx_atomic_base_impl<_Tp> *__a,
                                     _Tp *__expected, _Tp __value,
                                     memory_order __success,
                                     memory_order __failure) noexcept {
  return __c11_atomic_compare_exchange_strong(
      &__a->__a_value, __expected, __value,
      static_cast<__memory_order_underlying_t>(__success),
      static_cast<__memory_order_underlying_t>(__failure));
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) bool
__cxx_atomic_compare_exchange_weak(__cxx_atomic_base_impl<_Tp> volatile *__a,
                                   _Tp *__expected, _Tp __value,
                                   memory_order __success,
                                   memory_order __failure) noexcept {
  return __c11_atomic_compare_exchange_weak(
      &__a->__a_value, __expected, __value,
      static_cast<__memory_order_underlying_t>(__success),
      static_cast<__memory_order_underlying_t>(__failure));
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) bool
__cxx_atomic_compare_exchange_weak(__cxx_atomic_base_impl<_Tp> *__a,
                                   _Tp *__expected, _Tp __value,
                                   memory_order __success,
                                   memory_order __failure) noexcept {
  return __c11_atomic_compare_exchange_weak(
      &__a->__a_value, __expected, __value,
      static_cast<__memory_order_underlying_t>(__success),
      static_cast<__memory_order_underlying_t>(__failure));
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) _Tp
__cxx_atomic_fetch_add(__cxx_atomic_base_impl<_Tp> volatile *__a, _Tp __delta,
                       memory_order __order) noexcept {
  return __c11_atomic_fetch_add(
      &__a->__a_value, __delta,
      static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) _Tp
__cxx_atomic_fetch_add(__cxx_atomic_base_impl<_Tp> *__a, _Tp __delta,
                       memory_order __order) noexcept {
  return __c11_atomic_fetch_add(
      &__a->__a_value, __delta,
      static_cast<__memory_order_underlying_t>(__order));
}

template <class _Tp>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _Tp *
__cxx_atomic_fetch_add(__cxx_atomic_base_impl<_Tp *> volatile *__a,
                       ptrdiff_t __delta, memory_order __order) noexcept {
  return __c11_atomic_fetch_add(
      &__a->__a_value, __delta,
      static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _Tp *
__cxx_atomic_fetch_add(__cxx_atomic_base_impl<_Tp *> *__a, ptrdiff_t __delta,
                       memory_order __order) noexcept {
  return __c11_atomic_fetch_add(
      &__a->__a_value, __delta,
      static_cast<__memory_order_underlying_t>(__order));
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) _Tp
__cxx_atomic_fetch_sub(__cxx_atomic_base_impl<_Tp> volatile *__a, _Tp __delta,
                       memory_order __order) noexcept {
  return __c11_atomic_fetch_sub(
      &__a->__a_value, __delta,
      static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) _Tp
__cxx_atomic_fetch_sub(__cxx_atomic_base_impl<_Tp> *__a, _Tp __delta,
                       memory_order __order) noexcept {
  return __c11_atomic_fetch_sub(
      &__a->__a_value, __delta,
      static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _Tp *
__cxx_atomic_fetch_sub(__cxx_atomic_base_impl<_Tp *> volatile *__a,
                       ptrdiff_t __delta, memory_order __order) noexcept {
  return __c11_atomic_fetch_sub(
      &__a->__a_value, __delta,
      static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _Tp *
__cxx_atomic_fetch_sub(__cxx_atomic_base_impl<_Tp *> *__a, ptrdiff_t __delta,
                       memory_order __order) noexcept {
  return __c11_atomic_fetch_sub(
      &__a->__a_value, __delta,
      static_cast<__memory_order_underlying_t>(__order));
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) _Tp
__cxx_atomic_fetch_and(__cxx_atomic_base_impl<_Tp> volatile *__a, _Tp __pattern,
                       memory_order __order) noexcept {
  return __c11_atomic_fetch_and(
      &__a->__a_value, __pattern,
      static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) _Tp
__cxx_atomic_fetch_and(__cxx_atomic_base_impl<_Tp> *__a, _Tp __pattern,
                       memory_order __order) noexcept {
  return __c11_atomic_fetch_and(
      &__a->__a_value, __pattern,
      static_cast<__memory_order_underlying_t>(__order));
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) _Tp
__cxx_atomic_fetch_or(__cxx_atomic_base_impl<_Tp> volatile *__a, _Tp __pattern,
                      memory_order __order) noexcept {
  return __c11_atomic_fetch_or(
      &__a->__a_value, __pattern,
      static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) _Tp
__cxx_atomic_fetch_or(__cxx_atomic_base_impl<_Tp> *__a, _Tp __pattern,
                      memory_order __order) noexcept {
  return __c11_atomic_fetch_or(
      &__a->__a_value, __pattern,
      static_cast<__memory_order_underlying_t>(__order));
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) _Tp
__cxx_atomic_fetch_xor(__cxx_atomic_base_impl<_Tp> volatile *__a, _Tp __pattern,
                       memory_order __order) noexcept {
  return __c11_atomic_fetch_xor(
      &__a->__a_value, __pattern,
      static_cast<__memory_order_underlying_t>(__order));
}
template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) _Tp
__cxx_atomic_fetch_xor(__cxx_atomic_base_impl<_Tp> *__a, _Tp __pattern,
                       memory_order __order) noexcept {
  return __c11_atomic_fetch_xor(
      &__a->__a_value, __pattern,
      static_cast<__memory_order_underlying_t>(__order));
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) _Tp
kill_dependency(_Tp __y) noexcept {
  return __y;
}
# 1440 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/atomic" 3
template <typename _Tp, typename _Base = __cxx_atomic_base_impl<_Tp>>

struct __cxx_atomic_impl : public _Base {

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __cxx_atomic_impl() noexcept = default;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr explicit __cxx_atomic_impl(
      _Tp value) noexcept
      : _Base(value) {}
};

template <class _Tp,
          bool = is_integral<_Tp>::value && !is_same<_Tp, bool>::value>
struct __atomic_base {
  mutable __cxx_atomic_impl<_Tp> __a_;

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  is_lock_free() const volatile noexcept {
    return __c11_atomic_is_lock_free(sizeof(_Tp));
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  is_lock_free() const noexcept {
    return static_cast<__atomic_base const volatile *>(this)->is_lock_free();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  store(_Tp __d, memory_order __m = memory_order_seq_cst) volatile noexcept
      __attribute__((diagnose_if(
          __m == memory_order_consume || __m == memory_order_acquire ||
              __m == memory_order_acq_rel,
          "memory order argument to atomic operation is invalid", "warning"))) {
    __cxx_atomic_store(&__a_, __d, __m);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  store(_Tp __d, memory_order __m = memory_order_seq_cst) noexcept
      __attribute__((diagnose_if(
          __m == memory_order_consume || __m == memory_order_acquire ||
              __m == memory_order_acq_rel,
          "memory order argument to atomic operation is invalid", "warning"))) {
    __cxx_atomic_store(&__a_, __d, __m);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  load(memory_order __m = memory_order_seq_cst) const volatile noexcept
      __attribute__((diagnose_if(
          __m == memory_order_release || __m == memory_order_acq_rel,
          "memory order argument to atomic operation is invalid", "warning"))) {
    return __cxx_atomic_load(&__a_, __m);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  load(memory_order __m = memory_order_seq_cst) const noexcept
      __attribute__((diagnose_if(
          __m == memory_order_release || __m == memory_order_acq_rel,
          "memory order argument to atomic operation is invalid", "warning"))) {
    return __cxx_atomic_load(&__a_, __m);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  operator _Tp() const volatile noexcept {
    return load();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  operator _Tp() const noexcept {
    return load();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  exchange(_Tp __d, memory_order __m = memory_order_seq_cst) volatile noexcept {
    return __cxx_atomic_exchange(&__a_, __d, __m);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  exchange(_Tp __d, memory_order __m = memory_order_seq_cst) noexcept {
    return __cxx_atomic_exchange(&__a_, __d, __m);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  compare_exchange_weak(_Tp &__e, _Tp __d, memory_order __s,
                        memory_order __f) volatile noexcept
      __attribute__((diagnose_if(
          __f == memory_order_release || __f == memory_order_acq_rel,
          "memory order argument to atomic operation is invalid", "warning"))) {
    return __cxx_atomic_compare_exchange_weak(&__a_, &__e, __d, __s, __f);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  compare_exchange_weak(_Tp &__e, _Tp __d, memory_order __s,
                        memory_order __f) noexcept
      __attribute__((diagnose_if(
          __f == memory_order_release || __f == memory_order_acq_rel,
          "memory order argument to atomic operation is invalid", "warning"))) {
    return __cxx_atomic_compare_exchange_weak(&__a_, &__e, __d, __s, __f);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  compare_exchange_strong(_Tp &__e, _Tp __d, memory_order __s,
                          memory_order __f) volatile noexcept
      __attribute__((diagnose_if(
          __f == memory_order_release || __f == memory_order_acq_rel,
          "memory order argument to atomic operation is invalid", "warning"))) {
    return __cxx_atomic_compare_exchange_strong(&__a_, &__e, __d, __s, __f);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  compare_exchange_strong(_Tp &__e, _Tp __d, memory_order __s,
                          memory_order __f) noexcept
      __attribute__((diagnose_if(
          __f == memory_order_release || __f == memory_order_acq_rel,
          "memory order argument to atomic operation is invalid", "warning"))) {
    return __cxx_atomic_compare_exchange_strong(&__a_, &__e, __d, __s, __f);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  compare_exchange_weak(
      _Tp &__e, _Tp __d,
      memory_order __m = memory_order_seq_cst) volatile noexcept {
    return __cxx_atomic_compare_exchange_weak(&__a_, &__e, __d, __m, __m);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  compare_exchange_weak(_Tp &__e, _Tp __d,
                        memory_order __m = memory_order_seq_cst) noexcept {
    return __cxx_atomic_compare_exchange_weak(&__a_, &__e, __d, __m, __m);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  compare_exchange_strong(
      _Tp &__e, _Tp __d,
      memory_order __m = memory_order_seq_cst) volatile noexcept {
    return __cxx_atomic_compare_exchange_strong(&__a_, &__e, __d, __m, __m);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  compare_exchange_strong(_Tp &__e, _Tp __d,
                          memory_order __m = memory_order_seq_cst) noexcept {
    return __cxx_atomic_compare_exchange_strong(&__a_, &__e, __d, __m, __m);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __atomic_base() noexcept = default;

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr __atomic_base(_Tp __d) noexcept
      : __a_(__d) {}

  __atomic_base(const __atomic_base &) = delete;
  __atomic_base &operator=(const __atomic_base &) = delete;
  __atomic_base &operator=(const __atomic_base &) volatile = delete;
};
# 1560 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/atomic" 3
template <class _Tp>
struct __atomic_base<_Tp, true> : public __atomic_base<_Tp, false> {
  typedef __atomic_base<_Tp, false> __base;
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __atomic_base() noexcept = default;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr __atomic_base(_Tp __d) noexcept
      : __base(__d) {}

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  fetch_add(_Tp __op,
            memory_order __m = memory_order_seq_cst) volatile noexcept {
    return __cxx_atomic_fetch_add(&this->__a_, __op, __m);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  fetch_add(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept {
    return __cxx_atomic_fetch_add(&this->__a_, __op, __m);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  fetch_sub(_Tp __op,
            memory_order __m = memory_order_seq_cst) volatile noexcept {
    return __cxx_atomic_fetch_sub(&this->__a_, __op, __m);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  fetch_sub(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept {
    return __cxx_atomic_fetch_sub(&this->__a_, __op, __m);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  fetch_and(_Tp __op,
            memory_order __m = memory_order_seq_cst) volatile noexcept {
    return __cxx_atomic_fetch_and(&this->__a_, __op, __m);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  fetch_and(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept {
    return __cxx_atomic_fetch_and(&this->__a_, __op, __m);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  fetch_or(_Tp __op,
           memory_order __m = memory_order_seq_cst) volatile noexcept {
    return __cxx_atomic_fetch_or(&this->__a_, __op, __m);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  fetch_or(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept {
    return __cxx_atomic_fetch_or(&this->__a_, __op, __m);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  fetch_xor(_Tp __op,
            memory_order __m = memory_order_seq_cst) volatile noexcept {
    return __cxx_atomic_fetch_xor(&this->__a_, __op, __m);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  fetch_xor(_Tp __op, memory_order __m = memory_order_seq_cst) noexcept {
    return __cxx_atomic_fetch_xor(&this->__a_, __op, __m);
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  operator++(int) volatile noexcept {
    return fetch_add(_Tp(1));
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  operator++(int) noexcept {
    return fetch_add(_Tp(1));
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  operator--(int) volatile noexcept {
    return fetch_sub(_Tp(1));
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  operator--(int) noexcept {
    return fetch_sub(_Tp(1));
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  operator++() volatile noexcept {
    return fetch_add(_Tp(1)) + _Tp(1);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  operator++() noexcept {
    return fetch_add(_Tp(1)) + _Tp(1);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  operator--() volatile noexcept {
    return fetch_sub(_Tp(1)) - _Tp(1);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  operator--() noexcept {
    return fetch_sub(_Tp(1)) - _Tp(1);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  operator+=(_Tp __op) volatile noexcept {
    return fetch_add(__op) + __op;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  operator+=(_Tp __op) noexcept {
    return fetch_add(__op) + __op;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  operator-=(_Tp __op) volatile noexcept {
    return fetch_sub(__op) - __op;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  operator-=(_Tp __op) noexcept {
    return fetch_sub(__op) - __op;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  operator&=(_Tp __op) volatile noexcept {
    return fetch_and(__op) & __op;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  operator&=(_Tp __op) noexcept {
    return fetch_and(__op) & __op;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  operator|=(_Tp __op) volatile noexcept {
    return fetch_or(__op) | __op;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  operator|=(_Tp __op) noexcept {
    return fetch_or(__op) | __op;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  operator^=(_Tp __op) volatile noexcept {
    return fetch_xor(__op) ^ __op;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  operator^=(_Tp __op) noexcept {
    return fetch_xor(__op) ^ __op;
  }
};

template <class _Tp> struct atomic : public __atomic_base<_Tp> {
  typedef __atomic_base<_Tp> __base;
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  atomic() noexcept = default;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr atomic(_Tp __d) noexcept
      : __base(__d) {}

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  operator=(_Tp __d) volatile noexcept {
    __base::store(__d);
    return __d;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  operator=(_Tp __d) noexcept {
    __base::store(__d);
    return __d;
  }
};

template <class _Tp> struct atomic<_Tp *> : public __atomic_base<_Tp *> {
  typedef __atomic_base<_Tp *> __base;
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  atomic() noexcept = default;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr atomic(_Tp *__d) noexcept
      : __base(__d) {}

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  _Tp *
  operator=(_Tp *__d) volatile noexcept {
    __base::store(__d);
    return __d;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  _Tp *
  operator=(_Tp *__d) noexcept {
    __base::store(__d);
    return __d;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  _Tp *
  fetch_add(ptrdiff_t __op,
            memory_order __m = memory_order_seq_cst) volatile noexcept {
    return __cxx_atomic_fetch_add(&this->__a_, __op, __m);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  _Tp *
  fetch_add(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) noexcept {
    return __cxx_atomic_fetch_add(&this->__a_, __op, __m);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  _Tp *
  fetch_sub(ptrdiff_t __op,
            memory_order __m = memory_order_seq_cst) volatile noexcept {
    return __cxx_atomic_fetch_sub(&this->__a_, __op, __m);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  _Tp *
  fetch_sub(ptrdiff_t __op, memory_order __m = memory_order_seq_cst) noexcept {
    return __cxx_atomic_fetch_sub(&this->__a_, __op, __m);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  _Tp *
  operator++(int) volatile noexcept {
    return fetch_add(1);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  _Tp *
  operator++(int) noexcept {
    return fetch_add(1);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  _Tp *
  operator--(int) volatile noexcept {
    return fetch_sub(1);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  _Tp *
  operator--(int) noexcept {
    return fetch_sub(1);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  _Tp *
  operator++() volatile noexcept {
    return fetch_add(1) + 1;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  _Tp *
  operator++() noexcept {
    return fetch_add(1) + 1;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  _Tp *
  operator--() volatile noexcept {
    return fetch_sub(1) - 1;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  _Tp *
  operator--() noexcept {
    return fetch_sub(1) - 1;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  _Tp *
  operator+=(ptrdiff_t __op) volatile noexcept {
    return fetch_add(__op) + __op;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  _Tp *
  operator+=(ptrdiff_t __op) noexcept {
    return fetch_add(__op) + __op;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  _Tp *
  operator-=(ptrdiff_t __op) volatile noexcept {
    return fetch_sub(__op) - __op;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  _Tp *
  operator-=(ptrdiff_t __op) noexcept {
    return fetch_sub(__op) - __op;
  }
};

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) bool
atomic_is_lock_free(const volatile atomic<_Tp> *__o) noexcept {
  return __o->is_lock_free();
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) bool
atomic_is_lock_free(const atomic<_Tp> *__o) noexcept {
  return __o->is_lock_free();
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) void
atomic_init(volatile atomic<_Tp> *__o, _Tp __d) noexcept {
  __cxx_atomic_init(&__o->__a_, __d);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) void
atomic_init(atomic<_Tp> *__o, _Tp __d) noexcept {
  __cxx_atomic_init(&__o->__a_, __d);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) void
atomic_store(volatile atomic<_Tp> *__o, _Tp __d) noexcept {
  __o->store(__d);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) void
atomic_store(atomic<_Tp> *__o, _Tp __d) noexcept {
  __o->store(__d);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) void
atomic_store_explicit(volatile atomic<_Tp> *__o, _Tp __d,
                      memory_order __m) noexcept
    __attribute__((diagnose_if(
        __m == memory_order_consume || __m == memory_order_acquire ||
            __m == memory_order_acq_rel,
        "memory order argument to atomic operation is invalid", "warning"))) {
  __o->store(__d, __m);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) void
atomic_store_explicit(atomic<_Tp> *__o, _Tp __d, memory_order __m) noexcept
    __attribute__((diagnose_if(
        __m == memory_order_consume || __m == memory_order_acquire ||
            __m == memory_order_acq_rel,
        "memory order argument to atomic operation is invalid", "warning"))) {
  __o->store(__d, __m);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) _Tp
atomic_load(const volatile atomic<_Tp> *__o) noexcept {
  return __o->load();
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) _Tp
atomic_load(const atomic<_Tp> *__o) noexcept {
  return __o->load();
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) _Tp
atomic_load_explicit(const volatile atomic<_Tp> *__o, memory_order __m) noexcept
    __attribute__((diagnose_if(
        __m == memory_order_release || __m == memory_order_acq_rel,
        "memory order argument to atomic operation is invalid", "warning"))) {
  return __o->load(__m);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) _Tp
atomic_load_explicit(const atomic<_Tp> *__o, memory_order __m) noexcept
    __attribute__((diagnose_if(
        __m == memory_order_release || __m == memory_order_acq_rel,
        "memory order argument to atomic operation is invalid", "warning"))) {
  return __o->load(__m);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) _Tp
atomic_exchange(volatile atomic<_Tp> *__o, _Tp __d) noexcept {
  return __o->exchange(__d);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) _Tp
atomic_exchange(atomic<_Tp> *__o, _Tp __d) noexcept {
  return __o->exchange(__d);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) _Tp
atomic_exchange_explicit(volatile atomic<_Tp> *__o, _Tp __d,
                         memory_order __m) noexcept {
  return __o->exchange(__d, __m);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) _Tp
atomic_exchange_explicit(atomic<_Tp> *__o, _Tp __d, memory_order __m) noexcept {
  return __o->exchange(__d, __m);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) bool
atomic_compare_exchange_weak(volatile atomic<_Tp> *__o, _Tp *__e,
                             _Tp __d) noexcept {
  return __o->compare_exchange_weak(*__e, __d);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) bool
atomic_compare_exchange_weak(atomic<_Tp> *__o, _Tp *__e, _Tp __d) noexcept {
  return __o->compare_exchange_weak(*__e, __d);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) bool
atomic_compare_exchange_strong(volatile atomic<_Tp> *__o, _Tp *__e,
                               _Tp __d) noexcept {
  return __o->compare_exchange_strong(*__e, __d);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) bool
atomic_compare_exchange_strong(atomic<_Tp> *__o, _Tp *__e, _Tp __d) noexcept {
  return __o->compare_exchange_strong(*__e, __d);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) bool
atomic_compare_exchange_weak_explicit(volatile atomic<_Tp> *__o, _Tp *__e,
                                      _Tp __d, memory_order __s,
                                      memory_order __f) noexcept
    __attribute__((diagnose_if(
        __f == memory_order_release || __f == memory_order_acq_rel,
        "memory order argument to atomic operation is invalid", "warning"))) {
  return __o->compare_exchange_weak(*__e, __d, __s, __f);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) bool
atomic_compare_exchange_weak_explicit(atomic<_Tp> *__o, _Tp *__e, _Tp __d,
                                      memory_order __s,
                                      memory_order __f) noexcept
    __attribute__((diagnose_if(
        __f == memory_order_release || __f == memory_order_acq_rel,
        "memory order argument to atomic operation is invalid", "warning"))) {
  return __o->compare_exchange_weak(*__e, __d, __s, __f);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) bool
atomic_compare_exchange_strong_explicit(volatile atomic<_Tp> *__o, _Tp *__e,
                                        _Tp __d, memory_order __s,
                                        memory_order __f) noexcept
    __attribute__((diagnose_if(
        __f == memory_order_release || __f == memory_order_acq_rel,
        "memory order argument to atomic operation is invalid", "warning"))) {
  return __o->compare_exchange_strong(*__e, __d, __s, __f);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) bool
atomic_compare_exchange_strong_explicit(atomic<_Tp> *__o, _Tp *__e, _Tp __d,
                                        memory_order __s,
                                        memory_order __f) noexcept
    __attribute__((diagnose_if(
        __f == memory_order_release || __f == memory_order_acq_rel,
        "memory order argument to atomic operation is invalid", "warning"))) {
  return __o->compare_exchange_strong(*__e, __d, __s, __f);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
                   _Tp>::type
atomic_fetch_add(volatile atomic<_Tp> *__o, _Tp __op) noexcept {
  return __o->fetch_add(__op);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
                   _Tp>::type
atomic_fetch_add(atomic<_Tp> *__o, _Tp __op) noexcept {
  return __o->fetch_add(__op);
}

template <class _Tp>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _Tp *
atomic_fetch_add(volatile atomic<_Tp *> *__o, ptrdiff_t __op) noexcept {
  return __o->fetch_add(__op);
}

template <class _Tp>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _Tp *
atomic_fetch_add(atomic<_Tp *> *__o, ptrdiff_t __op) noexcept {
  return __o->fetch_add(__op);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
                   _Tp>::type
atomic_fetch_add_explicit(volatile atomic<_Tp> *__o, _Tp __op,
                          memory_order __m) noexcept {
  return __o->fetch_add(__op, __m);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
                   _Tp>::type
atomic_fetch_add_explicit(atomic<_Tp> *__o, _Tp __op,
                          memory_order __m) noexcept {
  return __o->fetch_add(__op, __m);
}

template <class _Tp>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _Tp *
atomic_fetch_add_explicit(volatile atomic<_Tp *> *__o, ptrdiff_t __op,
                          memory_order __m) noexcept {
  return __o->fetch_add(__op, __m);
}

template <class _Tp>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _Tp *
atomic_fetch_add_explicit(atomic<_Tp *> *__o, ptrdiff_t __op,
                          memory_order __m) noexcept {
  return __o->fetch_add(__op, __m);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
                   _Tp>::type
atomic_fetch_sub(volatile atomic<_Tp> *__o, _Tp __op) noexcept {
  return __o->fetch_sub(__op);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
                   _Tp>::type
atomic_fetch_sub(atomic<_Tp> *__o, _Tp __op) noexcept {
  return __o->fetch_sub(__op);
}

template <class _Tp>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _Tp *
atomic_fetch_sub(volatile atomic<_Tp *> *__o, ptrdiff_t __op) noexcept {
  return __o->fetch_sub(__op);
}

template <class _Tp>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _Tp *
atomic_fetch_sub(atomic<_Tp *> *__o, ptrdiff_t __op) noexcept {
  return __o->fetch_sub(__op);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
                   _Tp>::type
atomic_fetch_sub_explicit(volatile atomic<_Tp> *__o, _Tp __op,
                          memory_order __m) noexcept {
  return __o->fetch_sub(__op, __m);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
                   _Tp>::type
atomic_fetch_sub_explicit(atomic<_Tp> *__o, _Tp __op,
                          memory_order __m) noexcept {
  return __o->fetch_sub(__op, __m);
}

template <class _Tp>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _Tp *
atomic_fetch_sub_explicit(volatile atomic<_Tp *> *__o, ptrdiff_t __op,
                          memory_order __m) noexcept {
  return __o->fetch_sub(__op, __m);
}

template <class _Tp>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _Tp *
atomic_fetch_sub_explicit(atomic<_Tp *> *__o, ptrdiff_t __op,
                          memory_order __m) noexcept {
  return __o->fetch_sub(__op, __m);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
                   _Tp>::type
atomic_fetch_and(volatile atomic<_Tp> *__o, _Tp __op) noexcept {
  return __o->fetch_and(__op);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
                   _Tp>::type
atomic_fetch_and(atomic<_Tp> *__o, _Tp __op) noexcept {
  return __o->fetch_and(__op);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
                   _Tp>::type
atomic_fetch_and_explicit(volatile atomic<_Tp> *__o, _Tp __op,
                          memory_order __m) noexcept {
  return __o->fetch_and(__op, __m);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
                   _Tp>::type
atomic_fetch_and_explicit(atomic<_Tp> *__o, _Tp __op,
                          memory_order __m) noexcept {
  return __o->fetch_and(__op, __m);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
                   _Tp>::type
atomic_fetch_or(volatile atomic<_Tp> *__o, _Tp __op) noexcept {
  return __o->fetch_or(__op);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
                   _Tp>::type
atomic_fetch_or(atomic<_Tp> *__o, _Tp __op) noexcept {
  return __o->fetch_or(__op);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
                   _Tp>::type
atomic_fetch_or_explicit(volatile atomic<_Tp> *__o, _Tp __op,
                         memory_order __m) noexcept {
  return __o->fetch_or(__op, __m);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
                   _Tp>::type
atomic_fetch_or_explicit(atomic<_Tp> *__o, _Tp __op,
                         memory_order __m) noexcept {
  return __o->fetch_or(__op, __m);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
                   _Tp>::type
atomic_fetch_xor(volatile atomic<_Tp> *__o, _Tp __op) noexcept {
  return __o->fetch_xor(__op);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
                   _Tp>::type
atomic_fetch_xor(atomic<_Tp> *__o, _Tp __op) noexcept {
  return __o->fetch_xor(__op);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
                   _Tp>::type
atomic_fetch_xor_explicit(volatile atomic<_Tp> *__o, _Tp __op,
                          memory_order __m) noexcept {
  return __o->fetch_xor(__op, __m);
}

template <class _Tp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
typename enable_if<is_integral<_Tp>::value && !is_same<_Tp, bool>::value,
                   _Tp>::type
atomic_fetch_xor_explicit(atomic<_Tp> *__o, _Tp __op,
                          memory_order __m) noexcept {
  return __o->fetch_xor(__op, __m);
}

typedef struct atomic_flag {
  __cxx_atomic_impl<bool> __a_;

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  test_and_set(memory_order __m = memory_order_seq_cst) volatile noexcept {
    return __cxx_atomic_exchange(&__a_, bool(true), __m);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  test_and_set(memory_order __m = memory_order_seq_cst) noexcept {
    return __cxx_atomic_exchange(&__a_, bool(true), __m);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  clear(memory_order __m = memory_order_seq_cst) volatile noexcept {
    __cxx_atomic_store(&__a_, bool(false), __m);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  clear(memory_order __m = memory_order_seq_cst) noexcept {
    __cxx_atomic_store(&__a_, bool(false), __m);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  atomic_flag() noexcept = default;

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr atomic_flag(bool __b) noexcept
      : __a_(__b) {}

  atomic_flag(const atomic_flag &) = delete;
  atomic_flag &operator=(const atomic_flag &) = delete;
  atomic_flag &operator=(const atomic_flag &) volatile = delete;

} atomic_flag;

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
atomic_flag_test_and_set(volatile atomic_flag *__o) noexcept {
  return __o->test_and_set();
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
atomic_flag_test_and_set(atomic_flag *__o) noexcept {
  return __o->test_and_set();
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
atomic_flag_test_and_set_explicit(volatile atomic_flag *__o,
                                  memory_order __m) noexcept {
  return __o->test_and_set(__m);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
atomic_flag_test_and_set_explicit(atomic_flag *__o, memory_order __m) noexcept {
  return __o->test_and_set(__m);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
atomic_flag_clear(volatile atomic_flag *__o) noexcept {
  __o->clear();
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
atomic_flag_clear(atomic_flag *__o) noexcept {
  __o->clear();
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
atomic_flag_clear_explicit(volatile atomic_flag *__o,
                           memory_order __m) noexcept {
  __o->clear(__m);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
atomic_flag_clear_explicit(atomic_flag *__o, memory_order __m) noexcept {
  __o->clear(__m);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
atomic_thread_fence(memory_order __m) noexcept {
  __cxx_atomic_thread_fence(__m);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
atomic_signal_fence(memory_order __m) noexcept {
  __cxx_atomic_signal_fence(__m);
}

typedef atomic<bool> atomic_bool;
typedef atomic<char> atomic_char;
typedef atomic<signed char> atomic_schar;
typedef atomic<unsigned char> atomic_uchar;
typedef atomic<short> atomic_short;
typedef atomic<unsigned short> atomic_ushort;
typedef atomic<int> atomic_int;
typedef atomic<unsigned int> atomic_uint;
typedef atomic<long> atomic_long;
typedef atomic<unsigned long> atomic_ulong;
typedef atomic<long long> atomic_llong;
typedef atomic<unsigned long long> atomic_ullong;
typedef atomic<char16_t> atomic_char16_t;
typedef atomic<char32_t> atomic_char32_t;
typedef atomic<wchar_t> atomic_wchar_t;

typedef atomic<int_least8_t> atomic_int_least8_t;
typedef atomic<uint_least8_t> atomic_uint_least8_t;
typedef atomic<int_least16_t> atomic_int_least16_t;
typedef atomic<uint_least16_t> atomic_uint_least16_t;
typedef atomic<int_least32_t> atomic_int_least32_t;
typedef atomic<uint_least32_t> atomic_uint_least32_t;
typedef atomic<int_least64_t> atomic_int_least64_t;
typedef atomic<uint_least64_t> atomic_uint_least64_t;

typedef atomic<int_fast8_t> atomic_int_fast8_t;
typedef atomic<uint_fast8_t> atomic_uint_fast8_t;
typedef atomic<int_fast16_t> atomic_int_fast16_t;
typedef atomic<uint_fast16_t> atomic_uint_fast16_t;
typedef atomic<int_fast32_t> atomic_int_fast32_t;
typedef atomic<uint_fast32_t> atomic_uint_fast32_t;
typedef atomic<int_fast64_t> atomic_int_fast64_t;
typedef atomic<uint_fast64_t> atomic_uint_fast64_t;

typedef atomic<int8_t> atomic_int8_t;
typedef atomic<uint8_t> atomic_uint8_t;
typedef atomic<int16_t> atomic_int16_t;
typedef atomic<uint16_t> atomic_uint16_t;
typedef atomic<int32_t> atomic_int32_t;
typedef atomic<uint32_t> atomic_uint32_t;
typedef atomic<int64_t> atomic_int64_t;
typedef atomic<uint64_t> atomic_uint64_t;

typedef atomic<intptr_t> atomic_intptr_t;
typedef atomic<uintptr_t> atomic_uintptr_t;
typedef atomic<size_t> atomic_size_t;
typedef atomic<ptrdiff_t> atomic_ptrdiff_t;
typedef atomic<intmax_t> atomic_intmax_t;
typedef atomic<uintmax_t> atomic_uintmax_t;

} // namespace __1
} // namespace std
# 667 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 2 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 1 3
# 19 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 20 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 2 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/stdlib.h" 1 3 4
# 45 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 75 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *)
    __attribute__((__noreturn__)) __attribute__((__cold__))
    __attribute__((__disable_tail_calls__));
}
# 21 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 2 3
# 24 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 3
# 674 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 2 3
# 677 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_macros" 1 3
# 681 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 2 3

namespace std {
inline namespace __1 {

template <class _ValueType>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _ValueType
__libcpp_relaxed_load(_ValueType const *__value) {

  return __atomic_load_n(__value, 0);
}

template <class _ValueType>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _ValueType
__libcpp_acquire_load(_ValueType const *__value) {

  return __atomic_load_n(__value, 2);
}

template <class _Tp> class allocator;

template <>
class __attribute__((__type_visibility__("default"))) allocator<void> {
public:
  typedef void *pointer;
  typedef const void *const_pointer;
  typedef void value_type;

  template <class _Up> struct rebind { typedef allocator<_Up> other; };
};

template <>
class __attribute__((__type_visibility__("default"))) allocator<const void> {
public:
  typedef const void *pointer;
  typedef const void *const_pointer;
  typedef const void value_type;

  template <class _Up> struct rebind { typedef allocator<_Up> other; };
};

template <class _Tp, class = void> struct __has_element_type : false_type {};

template <class _Tp>
struct __has_element_type<_Tp,
                          typename __void_t<typename _Tp::element_type>::type>
    : true_type {};

template <class _Ptr, bool = __has_element_type<_Ptr>::value>
struct __pointer_traits_element_type;

template <class _Ptr> struct __pointer_traits_element_type<_Ptr, true> {
  typedef typename _Ptr::element_type type;
};

template <template <class, class...> class _Sp, class _Tp, class... _Args>
struct __pointer_traits_element_type<_Sp<_Tp, _Args...>, true> {
  typedef typename _Sp<_Tp, _Args...>::element_type type;
};

template <template <class, class...> class _Sp, class _Tp, class... _Args>
struct __pointer_traits_element_type<_Sp<_Tp, _Args...>, false> {
  typedef _Tp type;
};
# 821 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
template <class _Tp, class = void> struct __has_difference_type : false_type {};

template <class _Tp>
struct __has_difference_type<
    _Tp, typename __void_t<typename _Tp::difference_type>::type> : true_type {};

template <class _Ptr, bool = __has_difference_type<_Ptr>::value>
struct __pointer_traits_difference_type {
  typedef ptrdiff_t type;
};

template <class _Ptr> struct __pointer_traits_difference_type<_Ptr, true> {
  typedef typename _Ptr::difference_type type;
};

template <class _Tp, class _Up> struct __has_rebind {
private:
  struct __two {
    char __lx;
    char __lxx;
  };
  template <class _Xp> static __two __test(...);
  template <class _Xp>
  static char __test(typename _Xp::template rebind<_Up> * = 0);

public:
  static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>
struct __pointer_traits_rebind {

  typedef typename _Tp::template rebind<_Up> type;
};

template <template <class, class...> class _Sp, class _Tp, class... _Args,
          class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true> {

  typedef typename _Sp<_Tp, _Args...>::template rebind<_Up> type;
};

template <template <class, class...> class _Sp, class _Tp, class... _Args,
          class _Up>
struct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, false> {
  typedef _Sp<_Up, _Args...> type;
};
# 951 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
template <class _Ptr>
struct __attribute__((__type_visibility__("default"))) pointer_traits {
  typedef _Ptr pointer;
  typedef typename __pointer_traits_element_type<pointer>::type element_type;
  typedef
      typename __pointer_traits_difference_type<pointer>::type difference_type;

  template <class _Up>
  using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;

private:
  struct __nat {};

public:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static pointer
  pointer_to(typename conditional<is_void<element_type>::value, __nat,
                                  element_type>::type &__r) {
    return pointer::pointer_to(__r);
  }
};

template <class _Tp>
struct __attribute__((__type_visibility__("default"))) pointer_traits<_Tp *> {
  typedef _Tp *pointer;
  typedef _Tp element_type;
  typedef ptrdiff_t difference_type;

  template <class _Up> using rebind = _Up *;

private:
  struct __nat {};

public:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static pointer
  pointer_to(typename conditional<is_void<element_type>::value, __nat,
                                  element_type>::type &__r) noexcept {
    return std::__1::addressof(__r);
  }
};

template <class _From, class _To> struct __rebind_pointer {

  typedef typename pointer_traits<_From>::template rebind<_To> type;
};

template <class _Tp, class = void> struct __has_pointer_type : false_type {};

template <class _Tp>
struct __has_pointer_type<_Tp, typename __void_t<typename _Tp::pointer>::type>
    : true_type {};

namespace __pointer_type_imp {

template <class _Tp, class _Dp, bool = __has_pointer_type<_Dp>::value>
struct __pointer_type {
  typedef typename _Dp::pointer type;
};

template <class _Tp, class _Dp> struct __pointer_type<_Tp, _Dp, false> {
  typedef _Tp *type;
};

} // namespace __pointer_type_imp

template <class _Tp, class _Dp> struct __pointer_type {
  typedef typename __pointer_type_imp::__pointer_type<
      _Tp, typename remove_reference<_Dp>::type>::type type;
};

template <class _Tp, class = void> struct __has_const_pointer : false_type {};

template <class _Tp>
struct __has_const_pointer<_Tp,
                           typename __void_t<typename _Tp::const_pointer>::type>
    : true_type {};

template <class _Tp, class _Ptr, class _Alloc,
          bool = __has_const_pointer<_Alloc>::value>
struct __const_pointer {
  typedef typename _Alloc::const_pointer type;
};

template <class _Tp, class _Ptr, class _Alloc>
struct __const_pointer<_Tp, _Ptr, _Alloc, false> {

  typedef typename pointer_traits<_Ptr>::template rebind<const _Tp> type;
};

template <class _Tp, class = void> struct __has_void_pointer : false_type {};

template <class _Tp>
struct __has_void_pointer<_Tp,
                          typename __void_t<typename _Tp::void_pointer>::type>
    : true_type {};

template <class _Ptr, class _Alloc, bool = __has_void_pointer<_Alloc>::value>
struct __void_pointer {
  typedef typename _Alloc::void_pointer type;
};

template <class _Ptr, class _Alloc> struct __void_pointer<_Ptr, _Alloc, false> {

  typedef typename pointer_traits<_Ptr>::template rebind<void> type;
};

template <class _Tp, class = void>
struct __has_const_void_pointer : false_type {};

template <class _Tp>
struct __has_const_void_pointer<
    _Tp, typename __void_t<typename _Tp::const_void_pointer>::type>
    : true_type {};

template <class _Ptr, class _Alloc,
          bool = __has_const_void_pointer<_Alloc>::value>
struct __const_void_pointer {
  typedef typename _Alloc::const_void_pointer type;
};

template <class _Ptr, class _Alloc>
struct __const_void_pointer<_Ptr, _Alloc, false> {

  typedef typename pointer_traits<_Ptr>::template rebind<const void> type;
};

template <bool _UsePointerTraits> struct __to_address_helper;

template <> struct __to_address_helper<true> {
  template <class _Pointer>
  using __return_type = decltype(
      pointer_traits<_Pointer>::to_address(std::declval<const _Pointer &>()));

  template <class _Pointer>
  constexpr static __return_type<_Pointer>
  __do_it(const _Pointer &__p) noexcept {
    return pointer_traits<_Pointer>::to_address(__p);
  }
};

template <class _Pointer, bool _Dummy = true>
using __choose_to_address = __to_address_helper<_IsValidExpansion<
    __to_address_helper<_Dummy>::template __return_type, _Pointer>::value>;

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr _Tp *
__to_address(_Tp *__p) noexcept {
  static_assert(!is_function<_Tp>::value, "_Tp is a function type");
  return __p;
}

template <class _Pointer>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr
    typename __choose_to_address<_Pointer>::template __return_type<_Pointer>
    __to_address(const _Pointer &__p) noexcept {
  return __choose_to_address<_Pointer>::__do_it(__p);
}

template <> struct __to_address_helper<false> {
  template <class _Pointer>
  using __return_type = typename pointer_traits<_Pointer>::element_type *;

  template <class _Pointer>
  constexpr static __return_type<_Pointer>
  __do_it(const _Pointer &__p) noexcept {
    return std::__to_address(__p.operator->());
  }
};
# 1169 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
template <class _Tp, class = void> struct __has_size_type : false_type {};

template <class _Tp>
struct __has_size_type<_Tp, typename __void_t<typename _Tp::size_type>::type>
    : true_type {};

template <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>
struct __size_type {
  typedef typename make_unsigned<_DiffType>::type type;
};

template <class _Alloc, class _DiffType>
struct __size_type<_Alloc, _DiffType, true> {
  typedef typename _Alloc::size_type type;
};

template <class _Tp, class = void>
struct __has_propagate_on_container_copy_assignment : false_type {};

template <class _Tp>
struct __has_propagate_on_container_copy_assignment<
    _Tp, typename __void_t<
             typename _Tp::propagate_on_container_copy_assignment>::type>
    : true_type {};

template <class _Alloc,
          bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>
struct __propagate_on_container_copy_assignment {
  typedef false_type type;
};

template <class _Alloc>
struct __propagate_on_container_copy_assignment<_Alloc, true> {
  typedef typename _Alloc::propagate_on_container_copy_assignment type;
};

template <class _Tp, class = void>
struct __has_propagate_on_container_move_assignment : false_type {};

template <class _Tp>
struct __has_propagate_on_container_move_assignment<
    _Tp, typename __void_t<
             typename _Tp::propagate_on_container_move_assignment>::type>
    : true_type {};

template <class _Alloc,
          bool = __has_propagate_on_container_move_assignment<_Alloc>::value>
struct __propagate_on_container_move_assignment {
  typedef false_type type;
};

template <class _Alloc>
struct __propagate_on_container_move_assignment<_Alloc, true> {
  typedef typename _Alloc::propagate_on_container_move_assignment type;
};

template <class _Tp, class = void>
struct __has_propagate_on_container_swap : false_type {};

template <class _Tp>
struct __has_propagate_on_container_swap<
    _Tp, typename __void_t<typename _Tp::propagate_on_container_swap>::type>
    : true_type {};

template <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>
struct __propagate_on_container_swap {
  typedef false_type type;
};

template <class _Alloc> struct __propagate_on_container_swap<_Alloc, true> {
  typedef typename _Alloc::propagate_on_container_swap type;
};

template <class _Tp, class = void> struct __has_is_always_equal : false_type {};

template <class _Tp>
struct __has_is_always_equal<
    _Tp, typename __void_t<typename _Tp::is_always_equal>::type> : true_type {};

template <class _Alloc, bool = __has_is_always_equal<_Alloc>::value>
struct __is_always_equal {
  typedef typename std::__1::is_empty<_Alloc>::type type;
};

template <class _Alloc> struct __is_always_equal<_Alloc, true> {
  typedef typename _Alloc::is_always_equal type;
};

template <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>
struct __has_rebind_other {
private:
  struct __two {
    char __lx;
    char __lxx;
  };
  template <class _Xp> static __two __test(...);
  template <class _Xp>
  static char __test(typename _Xp::template rebind<_Up>::other * = 0);

public:
  static const bool value = sizeof(__test<_Tp>(0)) == 1;
};

template <class _Tp, class _Up> struct __has_rebind_other<_Tp, _Up, false> {
  static const bool value = false;
};

template <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>
struct __allocator_traits_rebind {
  typedef typename _Tp::template rebind<_Up>::other type;
};

template <template <class, class...> class _Alloc, class _Tp, class... _Args,
          class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, true> {
  typedef typename _Alloc<_Tp, _Args...>::template rebind<_Up>::other type;
};

template <template <class, class...> class _Alloc, class _Tp, class... _Args,
          class _Up>
struct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, false> {
  typedef _Alloc<_Up, _Args...> type;
};
# 1363 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
template <class _Alloc, class _SizeType, class _ConstVoidPtr>
auto __has_allocate_hint_test(_Alloc &&__a, _SizeType &&__sz,
                              _ConstVoidPtr &&__p)
    -> decltype((void)__a.allocate(__sz, __p), true_type());

template <class _Alloc, class _SizeType, class _ConstVoidPtr>
auto __has_allocate_hint_test(const _Alloc &__a, _SizeType &&__sz,
                              _ConstVoidPtr &&__p) -> false_type;

template <class _Alloc, class _SizeType, class _ConstVoidPtr>
struct __has_allocate_hint
    : integral_constant<bool,
                        is_same<decltype(std::__1::__has_allocate_hint_test(
                                    declval<_Alloc>(), declval<_SizeType>(),
                                    declval<_ConstVoidPtr>())),
                                true_type>::value> {};
# 1396 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
template <class _Alloc, class _Tp, class... _Args>
decltype(std::__1::declval<_Alloc>().construct(std::__1::declval<_Tp *>(),
                                               std::__1::declval<_Args>()...),
         true_type())
__has_construct_test(_Alloc &&__a, _Tp *__p, _Args &&...__args);

template <class _Alloc, class _Pointer, class... _Args>
false_type __has_construct_test(const _Alloc &__a, _Pointer &&__p,
                                _Args &&...__args);

template <class _Alloc, class _Pointer, class... _Args>
struct __has_construct
    : integral_constant<bool,
                        is_same<decltype(std::__1::__has_construct_test(
                                    declval<_Alloc>(), declval<_Pointer>(),
                                    declval<_Args>()...)),
                                true_type>::value> {};

template <class _Alloc, class _Pointer>
auto __has_destroy_test(_Alloc &&__a, _Pointer &&__p)
    -> decltype(__a.destroy(__p), true_type());

template <class _Alloc, class _Pointer>
auto __has_destroy_test(const _Alloc &__a, _Pointer &&__p) -> false_type;

template <class _Alloc, class _Pointer>
struct __has_destroy
    : integral_constant<bool,
                        is_same<decltype(std::__1::__has_destroy_test(
                                    declval<_Alloc>(), declval<_Pointer>())),
                                true_type>::value> {};

template <class _Alloc>
auto __has_max_size_test(_Alloc &&__a) -> decltype(__a.max_size(), true_type());

template <class _Alloc>
auto __has_max_size_test(const volatile _Alloc &__a) -> false_type;

template <class _Alloc>
struct __has_max_size
    : integral_constant<bool, is_same<decltype(std::__1::__has_max_size_test(
                                          declval<_Alloc &>())),
                                      true_type>::value> {};

template <class _Alloc>
auto __has_select_on_container_copy_construction_test(_Alloc &&__a)
    -> decltype(__a.select_on_container_copy_construction(), true_type());

template <class _Alloc>
auto __has_select_on_container_copy_construction_test(
    const volatile _Alloc &__a) -> false_type;

template <class _Alloc>
struct __has_select_on_container_copy_construction
    : integral_constant<
          bool,
          is_same<decltype(std::__1::
                               __has_select_on_container_copy_construction_test(
                                   declval<_Alloc &>())),
                  true_type>::value> {};
# 1507 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
template <class _Alloc, class _Ptr, bool = __has_difference_type<_Alloc>::value>
struct __alloc_traits_difference_type {
  typedef typename pointer_traits<_Ptr>::difference_type type;
};

template <class _Alloc, class _Ptr>
struct __alloc_traits_difference_type<_Alloc, _Ptr, true> {
  typedef typename _Alloc::difference_type type;
};

template <class _Tp> struct __is_default_allocator : false_type {};

template <class _Tp>
struct __is_default_allocator<std::__1::allocator<_Tp>> : true_type {};

template <class _Alloc,
          bool = __has_construct<_Alloc, typename _Alloc::value_type *,
                                 typename _Alloc::value_type &&>::value &&
                 !__is_default_allocator<_Alloc>::value>
struct __is_cpp17_move_insertable;
template <class _Alloc>
struct __is_cpp17_move_insertable<_Alloc, true> : std::true_type {};
template <class _Alloc>
struct __is_cpp17_move_insertable<_Alloc, false>
    : std::is_move_constructible<typename _Alloc::value_type> {};

template <class _Alloc,
          bool = __has_construct<_Alloc, typename _Alloc::value_type *,
                                 const typename _Alloc::value_type &>::value &&
                 !__is_default_allocator<_Alloc>::value>
struct __is_cpp17_copy_insertable;
template <class _Alloc>
struct __is_cpp17_copy_insertable<_Alloc, true>
    : __is_cpp17_move_insertable<_Alloc> {};
template <class _Alloc>
struct __is_cpp17_copy_insertable<_Alloc, false>
    : integral_constant<bool, std::is_copy_constructible<
                                  typename _Alloc::value_type>::value &&
                                  __is_cpp17_move_insertable<_Alloc>::value> {};

template <class _Alloc>
struct __attribute__((__type_visibility__("default"))) allocator_traits {
  typedef _Alloc allocator_type;
  typedef typename allocator_type::value_type value_type;

  typedef typename __pointer_type<value_type, allocator_type>::type pointer;
  typedef typename __const_pointer<value_type, pointer, allocator_type>::type
      const_pointer;
  typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;
  typedef typename __const_void_pointer<pointer, allocator_type>::type
      const_void_pointer;

  typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type
      difference_type;
  typedef typename __size_type<allocator_type, difference_type>::type size_type;

  typedef
      typename __propagate_on_container_copy_assignment<allocator_type>::type
          propagate_on_container_copy_assignment;
  typedef
      typename __propagate_on_container_move_assignment<allocator_type>::type
          propagate_on_container_move_assignment;
  typedef typename __propagate_on_container_swap<allocator_type>::type
      propagate_on_container_swap;
  typedef typename __is_always_equal<allocator_type>::type is_always_equal;

  template <class _Tp>
  using rebind_alloc =
      typename __allocator_traits_rebind<allocator_type, _Tp>::type;
  template <class _Tp>
  using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static pointer
  allocate(allocator_type &__a, size_type __n) {
    return __a.allocate(__n);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static pointer
  allocate(allocator_type &__a, size_type __n, const_void_pointer __hint) {
    return __allocate(
        __a, __n, __hint,
        __has_allocate_hint<allocator_type, size_type, const_void_pointer>());
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static void
  deallocate(allocator_type &__a, pointer __p, size_type __n) noexcept {
    __a.deallocate(__p, __n);
  }

  template <class _Tp, class... _Args>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static void
  construct(allocator_type &__a, _Tp *__p, _Args &&...__args) {
    __construct(__has_construct<allocator_type, _Tp *, _Args...>(), __a, __p,
                std::__1::forward<_Args>(__args)...);
  }
# 1632 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
  template <class _Tp>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static void
  destroy(allocator_type &__a, _Tp *__p) {
    __destroy(__has_destroy<allocator_type, _Tp *>(), __a, __p);
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static size_type
  max_size(const allocator_type &__a) noexcept {
    return __max_size(__has_max_size<const allocator_type>(), __a);
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static allocator_type
  select_on_container_copy_construction(const allocator_type &__a) {
    return __select_on_container_copy_construction(
        __has_select_on_container_copy_construction<const allocator_type>(),
        __a);
  }

  template <class _Ptr>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static void
  __construct_forward_with_exception_guarantees(allocator_type &__a,
                                                _Ptr __begin1, _Ptr __end1,
                                                _Ptr &__begin2) {
    static_assert(__is_cpp17_move_insertable<allocator_type>::value,
                  "The specified type does not meet the requirements of "
                  "Cpp17MoveInsertible");
    for (; __begin1 != __end1; ++__begin1, (void)++__begin2)
      construct(__a, std::__1::__to_address(__begin2),

                std::__1::move_if_noexcept(*__begin1)

      );
  }

  template <class _Tp>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static typename enable_if<
      (__is_default_allocator<allocator_type>::value ||
       !__has_construct<allocator_type, _Tp *, _Tp>::value) &&
          is_trivially_move_constructible<_Tp>::value,
      void>::type
  __construct_forward_with_exception_guarantees(allocator_type &, _Tp *__begin1,
                                                _Tp *__end1, _Tp *&__begin2) {
    ptrdiff_t _Np = __end1 - __begin1;
    if (_Np > 0) {
      std::__1::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));
      __begin2 += _Np;
    }
  }

  template <class _Iter, class _Ptr>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static void
  __construct_range_forward(allocator_type &__a, _Iter __begin1, _Iter __end1,
                            _Ptr &__begin2) {
    for (; __begin1 != __end1; ++__begin1, (void)++__begin2)
      construct(__a, std::__1::__to_address(__begin2), *__begin1);
  }

  template <class _SourceTp, class _DestTp,
            class _RawSourceTp = typename remove_const<_SourceTp>::type,
            class _RawDestTp = typename remove_const<_DestTp>::type>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static typename enable_if<
      is_trivially_copy_constructible<_DestTp>::value &&
          is_same<_RawSourceTp, _RawDestTp>::value &&
          (__is_default_allocator<allocator_type>::value ||
           !__has_construct<allocator_type, _DestTp *, _SourceTp &>::value),
      void>::type
  __construct_range_forward(allocator_type &, _SourceTp *__begin1,
                            _SourceTp *__end1, _DestTp *&__begin2) {
    ptrdiff_t _Np = __end1 - __begin1;
    if (_Np > 0) {
      std::__1::memcpy(const_cast<_RawDestTp *>(__begin2), __begin1,
                       _Np * sizeof(_DestTp));
      __begin2 += _Np;
    }
  }

  template <class _Ptr>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static void
  __construct_backward_with_exception_guarantees(allocator_type &__a,
                                                 _Ptr __begin1, _Ptr __end1,
                                                 _Ptr &__end2) {
    static_assert(__is_cpp17_move_insertable<allocator_type>::value,
                  "The specified type does not meet the requirements of "
                  "Cpp17MoveInsertable");
    while (__end1 != __begin1) {
      construct(__a, std::__1::__to_address(__end2 - 1),

                std::__1::move_if_noexcept(*--__end1)

      );
      --__end2;
    }
  }

  template <class _Tp>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static typename enable_if<
      (__is_default_allocator<allocator_type>::value ||
       !__has_construct<allocator_type, _Tp *, _Tp>::value) &&
          is_trivially_move_constructible<_Tp>::value,
      void>::type
  __construct_backward_with_exception_guarantees(allocator_type &,
                                                 _Tp *__begin1, _Tp *__end1,
                                                 _Tp *&__end2) {
    ptrdiff_t _Np = __end1 - __begin1;
    __end2 -= _Np;
    if (_Np > 0)
      std::__1::memcpy(__end2, __begin1, _Np * sizeof(_Tp));
  }

private:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static pointer
  __allocate(allocator_type &__a, size_type __n, const_void_pointer __hint,
             true_type) {
    return __a.allocate(__n, __hint);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static pointer
  __allocate(allocator_type &__a, size_type __n, const_void_pointer,
             false_type) {
    return __a.allocate(__n);
  }

  template <class _Tp, class... _Args>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static void
  __construct(true_type, allocator_type &__a, _Tp *__p, _Args &&...__args) {
    __a.construct(__p, std::__1::forward<_Args>(__args)...);
  }
  template <class _Tp, class... _Args>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static void
  __construct(false_type, allocator_type &, _Tp *__p, _Args &&...__args) {
    ::new ((void *)__p) _Tp(std::__1::forward<_Args>(__args)...);
  }
# 1795 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
  template <class _Tp>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static void
  __destroy(true_type, allocator_type &__a, _Tp *__p) {
    __a.destroy(__p);
  }
  template <class _Tp>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static void
  __destroy(false_type, allocator_type &, _Tp *__p) {
    __p->~_Tp();
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static size_type
  __max_size(true_type, const allocator_type &__a) noexcept {
    return __a.max_size();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static size_type
  __max_size(false_type, const allocator_type &) noexcept {
    return numeric_limits<size_type>::max() / sizeof(value_type);
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static allocator_type
  __select_on_container_copy_construction(true_type,
                                          const allocator_type &__a) {
    return __a.select_on_container_copy_construction();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static allocator_type
  __select_on_container_copy_construction(false_type,
                                          const allocator_type &__a) {
    return __a;
  }
};

template <class _Traits, class _Tp> struct __rebind_alloc_helper {

  typedef typename _Traits::template rebind_alloc<_Tp> type;
};

template <class _Tp>
class __attribute__((__type_visibility__("default"))) allocator {
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef _Tp *pointer;
  typedef const _Tp *const_pointer;
  typedef _Tp &reference;
  typedef const _Tp &const_reference;
  typedef _Tp value_type;

  typedef true_type propagate_on_container_move_assignment;
  typedef true_type is_always_equal;

  template <class _Up> struct rebind { typedef allocator<_Up> other; };

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  allocator() noexcept {}

  template <class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  allocator(const allocator<_Up> &) noexcept {}

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pointer
  address(reference __x) const noexcept {
    return std::__1::addressof(__x);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_pointer
  address(const_reference __x) const noexcept {
    return std::__1::addressof(__x);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pointer
  allocate(size_type __n, allocator<void>::const_pointer = 0) {
    if (__n > max_size())
      __throw_length_error("allocator<T>::allocate(size_t n)"
                           " 'n' exceeds maximum supported size");
    return static_cast<pointer>(
        std::__1::__libcpp_allocate(__n * sizeof(_Tp), alignof(_Tp)));
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  deallocate(pointer __p, size_type __n) noexcept {
    std::__1::__libcpp_deallocate((void *)__p, __n * sizeof(_Tp), alignof(_Tp));
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  max_size() const noexcept {
    return size_type(~0) / sizeof(_Tp);
  }

  template <class _Up, class... _Args>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  construct(_Up *__p, _Args &&...__args) {
    ::new ((void *)__p) _Up(std::__1::forward<_Args>(__args)...);
  }
# 1936 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  destroy(pointer __p) {
    __p->~_Tp();
  }
};

template <class _Tp>
class __attribute__((__type_visibility__("default"))) allocator<const _Tp> {
public:
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  typedef const _Tp *pointer;
  typedef const _Tp *const_pointer;
  typedef const _Tp &reference;
  typedef const _Tp &const_reference;
  typedef const _Tp value_type;

  typedef true_type propagate_on_container_move_assignment;
  typedef true_type is_always_equal;

  template <class _Up> struct rebind { typedef allocator<_Up> other; };

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  allocator() noexcept {}

  template <class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  allocator(const allocator<_Up> &) noexcept {}

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_pointer
  address(const_reference __x) const noexcept {
    return std::__1::addressof(__x);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pointer
  allocate(size_type __n, allocator<void>::const_pointer = 0) {
    if (__n > max_size())
      __throw_length_error("allocator<const T>::allocate(size_t n)"
                           " 'n' exceeds maximum supported size");
    return static_cast<pointer>(
        std::__1::__libcpp_allocate(__n * sizeof(_Tp), alignof(_Tp)));
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  deallocate(pointer __p, size_type __n) noexcept {
    std::__1::__libcpp_deallocate((void *)const_cast<_Tp *>(__p),
                                  __n * sizeof(_Tp), alignof(_Tp));
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  max_size() const noexcept {
    return size_type(~0) / sizeof(_Tp);
  }

  template <class _Up, class... _Args>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  construct(_Up *__p, _Args &&...__args) {
    ::new ((void *)__p) _Up(std::__1::forward<_Args>(__args)...);
  }
# 2037 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  destroy(pointer __p) {
    __p->~_Tp();
  }
};

template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator==(const allocator<_Tp> &, const allocator<_Up> &) noexcept {
  return true;
}

template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator!=(const allocator<_Tp> &, const allocator<_Up> &) noexcept {
  return false;
}

template <class _OutputIterator, class _Tp>
class __attribute__((__type_visibility__("default"))) raw_storage_iterator
    : public iterator<output_iterator_tag, _Tp, ptrdiff_t, _Tp *,
                      raw_storage_iterator<_OutputIterator, _Tp> &> {
private:
  _OutputIterator __x_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((
      internal_linkage)) explicit raw_storage_iterator(_OutputIterator __x)
      : __x_(__x) {}
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  raw_storage_iterator &
  operator*() {
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  raw_storage_iterator &
  operator=(const _Tp &__element) {
    ::new (std::__1::addressof(*__x_)) _Tp(__element);
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  raw_storage_iterator &
  operator=(_Tp &&__element) {
    ::new (std::__1::addressof(*__x_)) _Tp(std::__1::move(__element));
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  raw_storage_iterator &
  operator++() {
    ++__x_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  raw_storage_iterator
  operator++(int) {
    raw_storage_iterator __t(*this);
    ++__x_;
    return __t;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  _OutputIterator
  base() const {
    return __x_;
  }
};

template <class _Tp>
__attribute__((__no_sanitize__("cfi"))) pair<_Tp *, ptrdiff_t>
get_temporary_buffer(ptrdiff_t __n) noexcept {
  pair<_Tp *, ptrdiff_t> __r(0, 0);
  const ptrdiff_t __m =
      (~ptrdiff_t(0) ^ ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * 8 - 1))) /
      sizeof(_Tp);
  if (__n > __m)
    __n = __m;
  while (__n > 0) {
# 2100 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
    if (__is_overaligned_for_new(alignof(_Tp))) {

      return __r;
    }

    __r.first = static_cast<_Tp *>(::operator new(__n * sizeof(_Tp), nothrow));

    if (__r.first) {
      __r.second = __n;
      break;
    }
    __n /= 2;
  }
  return __r;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
return_temporary_buffer(_Tp *__p) noexcept {
  std::__1::__libcpp_deallocate_unsized((void *)__p, alignof(_Tp));
}

template <class _Tp> struct __attribute__((deprecated)) auto_ptr_ref {
  _Tp *__ptr_;
};

template <class _Tp>
class __attribute__((__type_visibility__("default")))
__attribute__((deprecated)) auto_ptr {
private:
  _Tp *__ptr_;

public:
  typedef _Tp element_type;

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit auto_ptr(_Tp *__p = 0) throw()
      : __ptr_(__p) {}
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  auto_ptr(auto_ptr &__p) throw()
      : __ptr_(__p.release()) {}
  template <class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  auto_ptr(auto_ptr<_Up> &__p) throw()
      : __ptr_(__p.release()) {}
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  auto_ptr &
  operator=(auto_ptr &__p) throw() {
    reset(__p.release());
    return *this;
  }
  template <class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  auto_ptr &
  operator=(auto_ptr<_Up> &__p) throw() {
    reset(__p.release());
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  auto_ptr &
  operator=(auto_ptr_ref<_Tp> __p) throw() {
    reset(__p.__ptr_);
    return *this;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) ~auto_ptr() throw() {
    delete __ptr_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  _Tp &
  operator*() const throw() {
    return *__ptr_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  _Tp *
  operator->() const throw() {
    return __ptr_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  _Tp *
  get() const throw() {
    return __ptr_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  _Tp *
  release() throw() {
    _Tp *__t = __ptr_;
    __ptr_ = 0;
    return __t;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  reset(_Tp *__p = 0) throw() {
    if (__ptr_ != __p)
      delete __ptr_;
    __ptr_ = __p;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  auto_ptr(auto_ptr_ref<_Tp> __p) throw()
      : __ptr_(__p.__ptr_) {}
  template <class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  operator auto_ptr_ref<_Up>() throw() {
    auto_ptr_ref<_Up> __t;
    __t.__ptr_ = release();
    return __t;
  }
  template <class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  operator auto_ptr<_Up>() throw() {
    return auto_ptr<_Up>(release());
  }
};

template <>
class __attribute__((__type_visibility__("default")))
__attribute__((deprecated)) auto_ptr<void> {
public:
  typedef void element_type;
};

struct __default_init_tag {};
struct __value_init_tag {};

template <class _Tp, int _Idx,
          bool _CanBeEmptyBase =
              is_empty<_Tp>::value && !__libcpp_is_final<_Tp>::value>
struct __compressed_pair_elem {
  typedef _Tp _ParamT;
  typedef _Tp &reference;
  typedef const _Tp &const_reference;

  __attribute__((__visibility__("hidden"))) __attribute__((
      internal_linkage)) constexpr __compressed_pair_elem(__default_init_tag) {}
  __attribute__((__visibility__("hidden"))) __attribute__((
      internal_linkage)) constexpr __compressed_pair_elem(__value_init_tag)
      : __value_() {}

  template <class _Up, class = typename enable_if<
                           !is_same<__compressed_pair_elem,
                                    typename decay<_Up>::type>::value>::type>
  __attribute__((__visibility__("hidden"))) __attribute__((
      internal_linkage)) constexpr explicit __compressed_pair_elem(_Up &&__u)
      : __value_(std::__1::forward<_Up>(__u)) {}

  template <class... _Args, size_t... _Indexes>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __compressed_pair_elem(piecewise_construct_t, tuple<_Args...> __args,
                         __tuple_indices<_Indexes...>)
      : __value_(std::__1::forward<_Args>(std::__1::get<_Indexes>(__args))...) {
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reference
  __get() noexcept {
    return __value_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reference
  __get() const noexcept {
    return __value_;
  }

private:
  _Tp __value_;
};

template <class _Tp, int _Idx>
struct __compressed_pair_elem<_Tp, _Idx, true> : private _Tp {
  typedef _Tp _ParamT;
  typedef _Tp &reference;
  typedef const _Tp &const_reference;
  typedef _Tp __value_type;

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr __compressed_pair_elem() =
      default;
  __attribute__((__visibility__("hidden"))) __attribute__((
      internal_linkage)) constexpr __compressed_pair_elem(__default_init_tag) {}
  __attribute__((__visibility__("hidden"))) __attribute__((
      internal_linkage)) constexpr __compressed_pair_elem(__value_init_tag)
      : __value_type() {}

  template <class _Up, class = typename enable_if<
                           !is_same<__compressed_pair_elem,
                                    typename decay<_Up>::type>::value>::type>
  __attribute__((__visibility__("hidden"))) __attribute__((
      internal_linkage)) constexpr explicit __compressed_pair_elem(_Up &&__u)
      : __value_type(std::__1::forward<_Up>(__u)) {}

  template <class... _Args, size_t... _Indexes>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __compressed_pair_elem(piecewise_construct_t, tuple<_Args...> __args,
                         __tuple_indices<_Indexes...>)
      : __value_type(
            std::__1::forward<_Args>(std::__1::get<_Indexes>(__args))...) {}

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reference
  __get() noexcept {
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reference
  __get() const noexcept {
    return *this;
  }
};

template <class _T1, class _T2>
class __compressed_pair : private __compressed_pair_elem<_T1, 0>,
                          private __compressed_pair_elem<_T2, 1> {
  typedef __compressed_pair_elem<_T1, 0> _Base1;
  typedef __compressed_pair_elem<_T2, 1> _Base2;

  static_assert(
      (!is_same<_T1, _T2>::value),
      "__compressed_pair cannot be instantated when T1 and T2 are the same "
      "type; "
      "The current implementation is NOT ABI-compatible with the previous "
      "implementation for this configuration");

public:
  template <
      bool _Dummy = true,
      class = typename enable_if<
          __dependent_type<is_default_constructible<_T1>, _Dummy>::value &&
          __dependent_type<is_default_constructible<_T2>, _Dummy>::value>::type>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr __compressed_pair()
      : _Base1(__value_init_tag()), _Base2(__value_init_tag()) {}

  template <class _U1, class _U2>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr __compressed_pair(_U1 &&__t1,
                                                                _U2 &&__t2)
      : _Base1(std::forward<_U1>(__t1)), _Base2(std::forward<_U2>(__t2)) {}

  template <class... _Args1, class... _Args2>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __compressed_pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,
                    tuple<_Args2...> __second_args)
      : _Base1(__pc, std::__1::move(__first_args),
               typename __make_tuple_indices<sizeof...(_Args1)>::type()),
        _Base2(__pc, std::__1::move(__second_args),
               typename __make_tuple_indices<sizeof...(_Args2)>::type()) {}

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename _Base1::reference
  first() noexcept {
    return static_cast<_Base1 &>(*this).__get();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename _Base1::const_reference
  first() const noexcept {
    return static_cast<_Base1 const &>(*this).__get();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename _Base2::reference
  second() noexcept {
    return static_cast<_Base2 &>(*this).__get();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename _Base2::const_reference
  second() const noexcept {
    return static_cast<_Base2 const &>(*this).__get();
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  swap(__compressed_pair &__x) noexcept(
      __is_nothrow_swappable<_T1>::value &&__is_nothrow_swappable<_T2>::value)

  {
    using std::swap;
    swap(first(), __x.first());
    swap(second(), __x.second());
  }
};

template <class _T1, class _T2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
swap(__compressed_pair<_T1, _T2> &__x,
     __compressed_pair<_T1, _T2>
         &__y) noexcept(__is_nothrow_swappable<_T1>::value
                            &&__is_nothrow_swappable<_T2>::value) {

  __x.swap(__y);
}

template <class _Tp>
struct __attribute__((__type_visibility__("default"))) default_delete {
  static_assert(!is_function<_Tp>::value,
                "default_delete cannot be instantiated for function types");

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr default_delete() noexcept =
      default;

  template <class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  default_delete(const default_delete<_Up> &,
                 typename enable_if<is_convertible<_Up *, _Tp *>::value>::type
                     * = 0) noexcept {}

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  operator()(_Tp *__ptr) const noexcept {
    static_assert(sizeof(_Tp) > 0,
                  "default_delete can not delete incomplete type");
    static_assert(!is_void<_Tp>::value,
                  "default_delete can not delete incomplete type");
    delete __ptr;
  }
};

template <class _Tp>
struct __attribute__((__type_visibility__("default"))) default_delete<_Tp[]> {
private:
  template <class _Up>
  struct _EnableIfConvertible
      : enable_if<is_convertible<_Up (*)[], _Tp (*)[]>::value> {};

public:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr default_delete() noexcept =
      default;

  template <class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  default_delete(const default_delete<_Up[]> &,
                 typename _EnableIfConvertible<_Up>::type * = 0) noexcept {}

  template <class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename _EnableIfConvertible<_Up>::type
  operator()(_Up *__ptr) const noexcept {
    static_assert(sizeof(_Tp) > 0,
                  "default_delete can not delete incomplete type");
    static_assert(!is_void<_Tp>::value,
                  "default_delete can not delete void type");
    delete[] __ptr;
  }
};

template <class _Deleter> struct __unique_ptr_deleter_sfinae {
  static_assert(!is_reference<_Deleter>::value, "incorrect specialization");
  typedef const _Deleter &__lval_ref_type;
  typedef _Deleter &&__good_rval_ref_type;
  typedef true_type __enable_rval_overload;
};

template <class _Deleter> struct __unique_ptr_deleter_sfinae<_Deleter const &> {
  typedef const _Deleter &__lval_ref_type;
  typedef const _Deleter &&__bad_rval_ref_type;
  typedef false_type __enable_rval_overload;
};

template <class _Deleter> struct __unique_ptr_deleter_sfinae<_Deleter &> {
  typedef _Deleter &__lval_ref_type;
  typedef _Deleter &&__bad_rval_ref_type;
  typedef false_type __enable_rval_overload;
};

template <class _Tp, class _Dp = default_delete<_Tp>>
class __attribute__((__type_visibility__("default"))) unique_ptr {
public:
  typedef _Tp element_type;
  typedef _Dp deleter_type;
  typedef typename __pointer_type<_Tp, deleter_type>::type pointer;

  static_assert(!is_rvalue_reference<deleter_type>::value,
                "the specified deleter type cannot be an rvalue reference");

private:
  __compressed_pair<pointer, deleter_type> __ptr_;

  struct __nat {
    int __for_bool_;
  };

  typedef __unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE;

  template <bool _Dummy>
  using _LValRefType =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;

  template <bool _Dummy>
  using _GoodRValRefType =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;

  template <bool _Dummy>
  using _BadRValRefType =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;

  template <bool _Dummy, class _Deleter = typename __dependent_type<
                             __identity<deleter_type>, _Dummy>::type>
  using _EnableIfDeleterDefaultConstructible =
      typename enable_if<is_default_constructible<_Deleter>::value &&
                         !is_pointer<_Deleter>::value>::type;

  template <class _ArgType>
  using _EnableIfDeleterConstructible =
      typename enable_if<is_constructible<deleter_type, _ArgType>::value>::type;

  template <class _UPtr, class _Up>
  using _EnableIfMoveConvertible = typename enable_if<
      is_convertible<typename _UPtr::pointer, pointer>::value &&
      !is_array<_Up>::value>::type;

  template <class _UDel>
  using _EnableIfDeleterConvertible = typename enable_if<
      (is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) ||
      (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value)>::type;

  template <class _UDel>
  using _EnableIfDeleterAssignable =
      typename enable_if<is_assignable<_Dp &, _UDel &&>::value>::type;

public:
  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy>>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr unique_ptr() noexcept
      : __ptr_(pointer(), __default_init_tag()) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy>>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr unique_ptr(nullptr_t) noexcept
      : __ptr_(pointer(), __default_init_tag()) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy>>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit unique_ptr(pointer __p) noexcept
      : __ptr_(__p, __default_init_tag()) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy>>>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  unique_ptr(pointer __p, _LValRefType<_Dummy> __d) noexcept
      : __ptr_(__p, __d) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy>>>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  unique_ptr(pointer __p, _GoodRValRefType<_Dummy> __d) noexcept
      : __ptr_(__p, std::__1::move(__d)) {
    static_assert(!is_reference<deleter_type>::value,
                  "rvalue deleter bound to reference");
  }

  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy>>>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  unique_ptr(pointer __p, _BadRValRefType<_Dummy> __d) = delete;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  unique_ptr(unique_ptr &&__u) noexcept
      : __ptr_(__u.release(),
               std::__1::forward<deleter_type>(__u.get_deleter())) {}

  template <class _Up, class _Ep,
            class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
            class = _EnableIfDeleterConvertible<_Ep>>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  unique_ptr(unique_ptr<_Up, _Ep> &&__u) noexcept
      : __ptr_(__u.release(), std::__1::forward<_Ep>(__u.get_deleter())) {}

  template <class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  unique_ptr(auto_ptr<_Up> &&__p,
             typename enable_if<is_convertible<_Up *, _Tp *>::value &&
                                    is_same<_Dp, default_delete<_Tp>>::value,
                                __nat>::type = __nat()) noexcept
      : __ptr_(__p.release(), __default_init_tag()) {}

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  unique_ptr &
  operator=(unique_ptr &&__u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::__1::forward<deleter_type>(__u.get_deleter());
    return *this;
  }

  template <class _Up, class _Ep,
            class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
            class = _EnableIfDeleterAssignable<_Ep>>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  unique_ptr &
  operator=(unique_ptr<_Up, _Ep> &&__u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::__1::forward<_Ep>(__u.get_deleter());
    return *this;
  }

  template <class _Up>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename enable_if<is_convertible<_Up *, _Tp *>::value &&
                         is_same<_Dp, default_delete<_Tp>>::value,
                     unique_ptr &>::type
  operator=(auto_ptr<_Up> __p) {
    reset(__p.release());
    return *this;
  }
# 2576 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) ~unique_ptr() {
    reset();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  unique_ptr &
  operator=(nullptr_t) noexcept {
    reset();
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename add_lvalue_reference<_Tp>::type
  operator*() const {
    return *__ptr_.first();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pointer
  operator->() const noexcept {
    return __ptr_.first();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pointer
  get() const noexcept {
    return __ptr_.first();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  deleter_type &
  get_deleter() noexcept {
    return __ptr_.second();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const deleter_type &
  get_deleter() const noexcept {
    return __ptr_.second();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit
  operator bool() const noexcept {
    return __ptr_.first() != nullptr;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pointer
  release() noexcept {
    pointer __t = __ptr_.first();
    __ptr_.first() = pointer();
    return __t;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  reset(pointer __p = pointer()) noexcept {
    pointer __tmp = __ptr_.first();
    __ptr_.first() = __p;
    if (__tmp)
      __ptr_.second()(__tmp);
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  swap(unique_ptr &__u) noexcept {
    __ptr_.swap(__u.__ptr_);
  }
};

template <class _Tp, class _Dp>
class __attribute__((__type_visibility__("default"))) unique_ptr<_Tp[], _Dp> {
public:
  typedef _Tp element_type;
  typedef _Dp deleter_type;
  typedef typename __pointer_type<_Tp, deleter_type>::type pointer;

private:
  __compressed_pair<pointer, deleter_type> __ptr_;

  template <class _From>
  struct _CheckArrayPointerConversion : is_same<_From, pointer> {};

  template <class _FromElem>
  struct _CheckArrayPointerConversion<_FromElem *>
      : integral_constant<
            bool,
            is_same<_FromElem *, pointer>::value ||
                (is_same<pointer, element_type *>::value &&
                 is_convertible<_FromElem (*)[], element_type (*)[]>::value)> {
  };

  typedef __unique_ptr_deleter_sfinae<_Dp> _DeleterSFINAE;

  template <bool _Dummy>
  using _LValRefType =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__lval_ref_type;

  template <bool _Dummy>
  using _GoodRValRefType =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__good_rval_ref_type;

  template <bool _Dummy>
  using _BadRValRefType =
      typename __dependent_type<_DeleterSFINAE, _Dummy>::__bad_rval_ref_type;

  template <bool _Dummy, class _Deleter = typename __dependent_type<
                             __identity<deleter_type>, _Dummy>::type>
  using _EnableIfDeleterDefaultConstructible =
      typename enable_if<is_default_constructible<_Deleter>::value &&
                         !is_pointer<_Deleter>::value>::type;

  template <class _ArgType>
  using _EnableIfDeleterConstructible =
      typename enable_if<is_constructible<deleter_type, _ArgType>::value>::type;

  template <class _Pp>
  using _EnableIfPointerConvertible =
      typename enable_if<_CheckArrayPointerConversion<_Pp>::value>::type;

  template <class _UPtr, class _Up, class _ElemT = typename _UPtr::element_type>
  using _EnableIfMoveConvertible = typename enable_if<
      is_array<_Up>::value && is_same<pointer, element_type *>::value &&
      is_same<typename _UPtr::pointer, _ElemT *>::value &&
      is_convertible<_ElemT (*)[], element_type (*)[]>::value>::type;

  template <class _UDel>
  using _EnableIfDeleterConvertible = typename enable_if<
      (is_reference<_Dp>::value && is_same<_Dp, _UDel>::value) ||
      (!is_reference<_Dp>::value && is_convertible<_UDel, _Dp>::value)>::type;

  template <class _UDel>
  using _EnableIfDeleterAssignable =
      typename enable_if<is_assignable<_Dp &, _UDel &&>::value>::type;

public:
  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy>>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr unique_ptr() noexcept
      : __ptr_(pointer(), __default_init_tag()) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy>>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr unique_ptr(nullptr_t) noexcept
      : __ptr_(pointer(), __default_init_tag()) {}

  template <class _Pp, bool _Dummy = true,
            class = _EnableIfDeleterDefaultConstructible<_Dummy>,
            class = _EnableIfPointerConvertible<_Pp>>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit unique_ptr(_Pp __p) noexcept
      : __ptr_(__p, __default_init_tag()) {}

  template <class _Pp, bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy>>,
            class = _EnableIfPointerConvertible<_Pp>>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  unique_ptr(_Pp __p, _LValRefType<_Dummy> __d) noexcept
      : __ptr_(__p, __d) {}

  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_LValRefType<_Dummy>>>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  unique_ptr(nullptr_t, _LValRefType<_Dummy> __d) noexcept
      : __ptr_(nullptr, __d) {}

  template <class _Pp, bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy>>,
            class = _EnableIfPointerConvertible<_Pp>>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  unique_ptr(_Pp __p, _GoodRValRefType<_Dummy> __d) noexcept
      : __ptr_(__p, std::__1::move(__d)) {
    static_assert(!is_reference<deleter_type>::value,
                  "rvalue deleter bound to reference");
  }

  template <bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_GoodRValRefType<_Dummy>>>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  unique_ptr(nullptr_t, _GoodRValRefType<_Dummy> __d) noexcept
      : __ptr_(nullptr, std::__1::move(__d)) {
    static_assert(!is_reference<deleter_type>::value,
                  "rvalue deleter bound to reference");
  }

  template <class _Pp, bool _Dummy = true,
            class = _EnableIfDeleterConstructible<_BadRValRefType<_Dummy>>,
            class = _EnableIfPointerConvertible<_Pp>>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  unique_ptr(_Pp __p, _BadRValRefType<_Dummy> __d) = delete;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  unique_ptr(unique_ptr &&__u) noexcept
      : __ptr_(__u.release(),
               std::__1::forward<deleter_type>(__u.get_deleter())) {}

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  unique_ptr &
  operator=(unique_ptr &&__u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::__1::forward<deleter_type>(__u.get_deleter());
    return *this;
  }

  template <class _Up, class _Ep,
            class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
            class = _EnableIfDeleterConvertible<_Ep>>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  unique_ptr(unique_ptr<_Up, _Ep> &&__u) noexcept
      : __ptr_(__u.release(), std::__1::forward<_Ep>(__u.get_deleter())) {}

  template <class _Up, class _Ep,
            class = _EnableIfMoveConvertible<unique_ptr<_Up, _Ep>, _Up>,
            class = _EnableIfDeleterAssignable<_Ep>>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  unique_ptr &
  operator=(unique_ptr<_Up, _Ep> &&__u) noexcept {
    reset(__u.release());
    __ptr_.second() = std::__1::forward<_Ep>(__u.get_deleter());
    return *this;
  }

public:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) ~unique_ptr() {
    reset();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  unique_ptr &
  operator=(nullptr_t) noexcept {
    reset();
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename add_lvalue_reference<_Tp>::type
  operator[](size_t __i) const {
    return __ptr_.first()[__i];
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pointer
  get() const noexcept {
    return __ptr_.first();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  deleter_type &
  get_deleter() noexcept {
    return __ptr_.second();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const deleter_type &
  get_deleter() const noexcept {
    return __ptr_.second();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit
  operator bool() const noexcept {
    return __ptr_.first() != nullptr;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pointer
  release() noexcept {
    pointer __t = __ptr_.first();
    __ptr_.first() = pointer();
    return __t;
  }

  template <class _Pp>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename enable_if<_CheckArrayPointerConversion<_Pp>::value>::type
  reset(_Pp __p) noexcept {
    pointer __tmp = __ptr_.first();
    __ptr_.first() = __p;
    if (__tmp)
      __ptr_.second()(__tmp);
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  reset(nullptr_t = nullptr) noexcept {
    pointer __tmp = __ptr_.first();
    __ptr_.first() = nullptr;
    if (__tmp)
      __ptr_.second()(__tmp);
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  swap(unique_ptr &__u) noexcept {
    __ptr_.swap(__u.__ptr_);
  }
};

template <class _Tp, class _Dp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename enable_if<__is_swappable<_Dp>::value, void>::type
swap(unique_ptr<_Tp, _Dp> &__x, unique_ptr<_Tp, _Dp> &__y) noexcept {
  __x.swap(__y);
}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator==(const unique_ptr<_T1, _D1> &__x, const unique_ptr<_T2, _D2> &__y) {
  return __x.get() == __y.get();
}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator!=(const unique_ptr<_T1, _D1> &__x, const unique_ptr<_T2, _D2> &__y) {
  return !(__x == __y);
}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator<(const unique_ptr<_T1, _D1> &__x, const unique_ptr<_T2, _D2> &__y) {
  typedef typename unique_ptr<_T1, _D1>::pointer _P1;
  typedef typename unique_ptr<_T2, _D2>::pointer _P2;
  typedef typename common_type<_P1, _P2>::type _Vp;
  return less<_Vp>()(__x.get(), __y.get());
}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator>(const unique_ptr<_T1, _D1> &__x, const unique_ptr<_T2, _D2> &__y) {
  return __y < __x;
}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator<=(const unique_ptr<_T1, _D1> &__x, const unique_ptr<_T2, _D2> &__y) {
  return !(__y < __x);
}

template <class _T1, class _D1, class _T2, class _D2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator>=(const unique_ptr<_T1, _D1> &__x, const unique_ptr<_T2, _D2> &__y) {
  return !(__x < __y);
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator==(const unique_ptr<_T1, _D1> &__x, nullptr_t) noexcept {
  return !__x;
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator==(nullptr_t, const unique_ptr<_T1, _D1> &__x) noexcept {
  return !__x;
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator!=(const unique_ptr<_T1, _D1> &__x, nullptr_t) noexcept {
  return static_cast<bool>(__x);
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator!=(nullptr_t, const unique_ptr<_T1, _D1> &__x) noexcept {
  return static_cast<bool>(__x);
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator<(const unique_ptr<_T1, _D1> &__x, nullptr_t) {
  typedef typename unique_ptr<_T1, _D1>::pointer _P1;
  return less<_P1>()(__x.get(), nullptr);
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator<(nullptr_t, const unique_ptr<_T1, _D1> &__x) {
  typedef typename unique_ptr<_T1, _D1>::pointer _P1;
  return less<_P1>()(nullptr, __x.get());
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator>(const unique_ptr<_T1, _D1> &__x, nullptr_t) {
  return nullptr < __x;
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator>(nullptr_t, const unique_ptr<_T1, _D1> &__x) {
  return __x < nullptr;
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator<=(const unique_ptr<_T1, _D1> &__x, nullptr_t) {
  return !(nullptr < __x);
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator<=(nullptr_t, const unique_ptr<_T1, _D1> &__x) {
  return !(__x < nullptr);
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator>=(const unique_ptr<_T1, _D1> &__x, nullptr_t) {
  return !(__x < nullptr);
}

template <class _T1, class _D1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator>=(nullptr_t, const unique_ptr<_T1, _D1> &__x) {
  return !(nullptr < __x);
}

template <class _Tp> struct __unique_if {
  typedef unique_ptr<_Tp> __unique_single;
};

template <class _Tp> struct __unique_if<_Tp[]> {
  typedef unique_ptr<_Tp[]> __unique_array_unknown_bound;
};

template <class _Tp, size_t _Np> struct __unique_if<_Tp[_Np]> {
  typedef void __unique_array_known_bound;
};

template <class _Tp, class... _Args>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) typename __unique_if<_Tp>::__unique_single
make_unique(_Args &&...__args) {
  return unique_ptr<_Tp>(new _Tp(std::__1::forward<_Args>(__args)...));
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename __unique_if<_Tp>::__unique_array_unknown_bound
make_unique(size_t __n) {
  typedef typename remove_extent<_Tp>::type _Up;
  return unique_ptr<_Tp>(new _Up[__n]());
}

template <class _Tp, class... _Args>
typename __unique_if<_Tp>::__unique_array_known_bound
make_unique(_Args &&...) = delete;

template <class _Tp, class _Dp>

struct __attribute__((__type_visibility__("default")))
hash<__enable_hash_helper<unique_ptr<_Tp, _Dp>,
                          typename unique_ptr<_Tp, _Dp>::pointer>>

{
  typedef unique_ptr<_Tp, _Dp> argument_type;
  typedef size_t result_type;
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  result_type
  operator()(const argument_type &__ptr) const {
    typedef typename argument_type::pointer pointer;
    return hash<pointer>()(__ptr.get());
  }
};

struct __destruct_n {
private:
  size_t __size_;

  template <class _Tp>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __process(_Tp *__p, false_type) noexcept {
    for (size_t __i = 0; __i < __size_; ++__i, ++__p)
      __p->~_Tp();
  }

  template <class _Tp>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __process(_Tp *, true_type) noexcept {}

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __incr(false_type) noexcept {
    ++__size_;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __incr(true_type) noexcept {}

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __set(size_t __s, false_type) noexcept {
    __size_ = __s;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __set(size_t, true_type) noexcept {}

public:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit __destruct_n(size_t __s) noexcept
      : __size_(__s) {}

  template <class _Tp>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __incr(_Tp *) noexcept {
    __incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());
  }

  template <class _Tp>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __set(size_t __s, _Tp *) noexcept {
    __set(__s,
          integral_constant<bool, is_trivially_destructible<_Tp>::value>());
  }

  template <class _Tp>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  operator()(_Tp *__p) noexcept {
    __process(__p,
              integral_constant<bool, is_trivially_destructible<_Tp>::value>());
  }
};

template <class _Alloc> class __allocator_destructor {
  typedef allocator_traits<_Alloc> __alloc_traits;

public:
  typedef typename __alloc_traits::pointer pointer;
  typedef typename __alloc_traits::size_type size_type;

private:
  _Alloc &__alloc_;
  size_type __s_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __allocator_destructor(_Alloc &__a, size_type __s) noexcept
      : __alloc_(__a), __s_(__s) {}
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  operator()(pointer __p) noexcept {
    __alloc_traits::deallocate(__alloc_, __p, __s_);
  }
};

template <class _InputIterator, class _ForwardIterator>
_ForwardIterator uninitialized_copy(_InputIterator __f, _InputIterator __l,
                                    _ForwardIterator __r) {
  typedef typename iterator_traits<_ForwardIterator>::value_type value_type;

  _ForwardIterator __s = __r;
  try {

    for (; __f != __l; ++__f, (void)++__r)
      ::new (static_cast<void *>(std::__1::addressof(*__r))) value_type(*__f);

  } catch (...) {
    for (; __s != __r; ++__s)
      __s->~value_type();
    throw;
  }

  return __r;
}

template <class _InputIterator, class _Size, class _ForwardIterator>
_ForwardIterator uninitialized_copy_n(_InputIterator __f, _Size __n,
                                      _ForwardIterator __r) {
  typedef typename iterator_traits<_ForwardIterator>::value_type value_type;

  _ForwardIterator __s = __r;
  try {

    for (; __n > 0; ++__f, (void)++__r, (void)--__n)
      ::new (static_cast<void *>(std::__1::addressof(*__r))) value_type(*__f);

  } catch (...) {
    for (; __s != __r; ++__s)
      __s->~value_type();
    throw;
  }

  return __r;
}

template <class _ForwardIterator, class _Tp>
void uninitialized_fill(_ForwardIterator __f, _ForwardIterator __l,
                        const _Tp &__x) {
  typedef typename iterator_traits<_ForwardIterator>::value_type value_type;

  _ForwardIterator __s = __f;
  try {

    for (; __f != __l; ++__f)
      ::new (static_cast<void *>(std::__1::addressof(*__f))) value_type(__x);

  } catch (...) {
    for (; __s != __f; ++__s)
      __s->~value_type();
    throw;
  }
}

template <class _ForwardIterator, class _Size, class _Tp>
_ForwardIterator uninitialized_fill_n(_ForwardIterator __f, _Size __n,
                                      const _Tp &__x) {
  typedef typename iterator_traits<_ForwardIterator>::value_type value_type;

  _ForwardIterator __s = __f;
  try {

    for (; __n > 0; ++__f, (void)--__n)
      ::new (static_cast<void *>(std::__1::addressof(*__f))) value_type(__x);

  } catch (...) {
    for (; __s != __f; ++__s)
      __s->~value_type();
    throw;
  }

  return __f;
}
# 3375 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _Tp
__libcpp_atomic_refcount_increment(_Tp &__t) noexcept {

  return __atomic_add_fetch(&__t, 1, 0);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _Tp
__libcpp_atomic_refcount_decrement(_Tp &__t) noexcept {

  return __atomic_add_fetch(&__t, -1, 4);
}

class __attribute__((__visibility__("default"))) bad_weak_ptr
    : public std::exception {
public:
  virtual ~bad_weak_ptr() noexcept;
  virtual const char *what() const noexcept;
};

[[noreturn]] inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
__throw_bad_weak_ptr() {

  throw bad_weak_ptr();
}

template <class _Tp>
class __attribute__((__type_visibility__("default"))) weak_ptr;

class __attribute__((__visibility__("default"))) __shared_count {
  __shared_count(const __shared_count &);
  __shared_count &operator=(const __shared_count &);

protected:
  long __shared_owners_;
  virtual ~__shared_count();

private:
  virtual void __on_zero_shared() noexcept = 0;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((
      internal_linkage)) explicit __shared_count(long __refs = 0) noexcept
      : __shared_owners_(__refs) {}

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __add_shared() noexcept {
    __libcpp_atomic_refcount_increment(__shared_owners_);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  __release_shared() noexcept {
    if (__libcpp_atomic_refcount_decrement(__shared_owners_) == -1) {
      __on_zero_shared();
      return true;
    }
    return false;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) long
  use_count() const noexcept {
    return __libcpp_relaxed_load(&__shared_owners_) + 1;
  }
};

class __attribute__((__visibility__("default"))) __shared_weak_count
    : private __shared_count {
  long __shared_weak_owners_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((
      internal_linkage)) explicit __shared_weak_count(long __refs = 0) noexcept
      : __shared_count(__refs), __shared_weak_owners_(__refs) {}

protected:
  virtual ~__shared_weak_count();

public:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __add_shared() noexcept {
    __shared_count::__add_shared();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __add_weak() noexcept {
    __libcpp_atomic_refcount_increment(__shared_weak_owners_);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __release_shared() noexcept {
    if (__shared_count::__release_shared())
      __release_weak();
  }

  void __release_weak() noexcept;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) long
  use_count() const noexcept {
    return __shared_count::use_count();
  }
  __shared_weak_count *lock() noexcept;

  virtual const void *__get_deleter(const type_info &) const noexcept;

private:
  virtual void __on_zero_shared_weak() noexcept = 0;
};

template <class _Tp, class _Dp, class _Alloc>
class __shared_ptr_pointer : public __shared_weak_count {
  __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)
      : __data_(__compressed_pair<_Tp, _Dp>(__p, std::__1::move(__d)),
                std::__1::move(__a)) {}

  virtual const void *__get_deleter(const type_info &) const noexcept;

private:
  virtual void __on_zero_shared() noexcept;
  virtual void __on_zero_shared_weak() noexcept;
};

template <class _Tp, class _Dp, class _Alloc>
const void *__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__get_deleter(
    const type_info &__t) const noexcept {
  return __t == typeid(_Dp) ? std::__1::addressof(__data_.first().second())
                            : nullptr;
}

template <class _Tp, class _Dp, class _Alloc>
void __shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() noexcept {
  __data_.first().second()(__data_.first().first());
  __data_.first().second().~_Dp();
}

template <class _Tp, class _Dp, class _Alloc>
void __shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() noexcept {
  typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_pointer>::type
      _Al;
  typedef allocator_traits<_Al> _ATraits;
  typedef pointer_traits<typename _ATraits::pointer> _PTraits;

  _Al __a(__data_.second());
  __data_.second().~_Alloc();
  __a.deallocate(_PTraits::pointer_to(*this), 1);
}

template <class _Tp, class _Alloc>
class __shared_ptr_emplace : public __shared_weak_count {
  __compressed_pair<_Alloc, _Tp> __data_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __shared_ptr_emplace(_Alloc __a)
      : __data_(std::__1::move(__a), __value_init_tag()) {}

  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __shared_ptr_emplace(_Alloc __a, _Args &&...__args)
      : __data_(
            piecewise_construct, std::__1::forward_as_tuple(__a),
            std::__1::forward_as_tuple(std::__1::forward<_Args>(__args)...)) {}
# 3595 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
private:
  virtual void __on_zero_shared() noexcept;
  virtual void __on_zero_shared_weak() noexcept;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  _Tp *
  get() noexcept {
    return std::__1::addressof(__data_.second());
  }
};

template <class _Tp, class _Alloc>
void __shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared() noexcept {
  __data_.second().~_Tp();
}

template <class _Tp, class _Alloc>
void __shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared_weak() noexcept {
  typedef typename __allocator_traits_rebind<_Alloc, __shared_ptr_emplace>::type
      _Al;
  typedef allocator_traits<_Al> _ATraits;
  typedef pointer_traits<typename _ATraits::pointer> _PTraits;
  _Al __a(__data_.first());
  __data_.first().~_Alloc();
  __a.deallocate(_PTraits::pointer_to(*this), 1);
}

struct __shared_ptr_dummy_rebind_allocator_type;
template <>
class __attribute__((__type_visibility__("default")))
allocator<__shared_ptr_dummy_rebind_allocator_type> {
public:
  template <class _Other> struct rebind { typedef allocator<_Other> other; };
};

template <class _Tp>
class __attribute__((__type_visibility__("default"))) enable_shared_from_this;

template <class _Tp>
class __attribute__((__type_visibility__("default"))) shared_ptr {
public:
  typedef _Tp element_type;

private:
  element_type *__ptr_;
  __shared_weak_count *__cntrl_;

  struct __nat {
    int __for_bool_;
  };

public:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr shared_ptr() noexcept;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr shared_ptr(nullptr_t) noexcept;
  template <class _Yp>
  explicit shared_ptr(
      _Yp *__p, typename enable_if<is_convertible<_Yp *, element_type *>::value,
                                   __nat>::type = __nat());
  template <class _Yp, class _Dp>
  shared_ptr(_Yp *__p, _Dp __d,
             typename enable_if<is_convertible<_Yp *, element_type *>::value,
                                __nat>::type = __nat());
  template <class _Yp, class _Dp, class _Alloc>
  shared_ptr(_Yp *__p, _Dp __d, _Alloc __a,
             typename enable_if<is_convertible<_Yp *, element_type *>::value,
                                __nat>::type = __nat());
  template <class _Dp> shared_ptr(nullptr_t __p, _Dp __d);
  template <class _Dp, class _Alloc>
  shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);
  template <class _Yp>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  shared_ptr(const shared_ptr<_Yp> &__r, element_type *__p) noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  shared_ptr(const shared_ptr &__r) noexcept;
  template <class _Yp>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  shared_ptr(const shared_ptr<_Yp> &__r,
             typename enable_if<is_convertible<_Yp *, element_type *>::value,
                                __nat>::type = __nat()) noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  shared_ptr(shared_ptr &&__r) noexcept;
  template <class _Yp>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  shared_ptr(shared_ptr<_Yp> &&__r,
             typename enable_if<is_convertible<_Yp *, element_type *>::value,
                                __nat>::type = __nat()) noexcept;

  template <class _Yp>
  explicit shared_ptr(
      const weak_ptr<_Yp> &__r,
      typename enable_if<is_convertible<_Yp *, element_type *>::value,
                         __nat>::type = __nat());

  template <class _Yp>
  shared_ptr(auto_ptr<_Yp> &&__r,
             typename enable_if<is_convertible<_Yp *, element_type *>::value,
                                __nat>::type = __nat());

  template <class _Yp, class _Dp>
  shared_ptr(unique_ptr<_Yp, _Dp> &&,
             typename enable_if<
                 !is_lvalue_reference<_Dp>::value && !is_array<_Yp>::value &&
                     is_convertible<typename unique_ptr<_Yp, _Dp>::pointer,
                                    element_type *>::value,
                 __nat>::type = __nat());
  template <class _Yp, class _Dp>
  shared_ptr(unique_ptr<_Yp, _Dp> &&,
             typename enable_if<
                 is_lvalue_reference<_Dp>::value && !is_array<_Yp>::value &&
                     is_convertible<typename unique_ptr<_Yp, _Dp>::pointer,
                                    element_type *>::value,
                 __nat>::type = __nat());
# 3734 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
  ~shared_ptr();

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  shared_ptr &
  operator=(const shared_ptr &__r) noexcept;
  template <class _Yp>
  typename enable_if<is_convertible<_Yp *, element_type *>::value,
                     shared_ptr &>::type
      __attribute__((__visibility__("hidden")))
      __attribute__((internal_linkage))
      operator=(const shared_ptr<_Yp> &__r) noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  shared_ptr &
  operator=(shared_ptr &&__r) noexcept;
  template <class _Yp>
  typename enable_if<is_convertible<_Yp *, element_type *>::value,
                     shared_ptr<_Tp> &>::type
      __attribute__((__visibility__("hidden")))
      __attribute__((internal_linkage))
      operator=(shared_ptr<_Yp> &&__r);

  template <class _Yp>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename enable_if<!is_array<_Yp>::value &&
                         is_convertible<_Yp *, element_type *>::value,
                     shared_ptr>::type &
  operator=(auto_ptr<_Yp> &&__r);
# 3781 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
  template <class _Yp, class _Dp>
  typename enable_if<!is_array<_Yp>::value &&
                         is_convertible<typename unique_ptr<_Yp, _Dp>::pointer,
                                        element_type *>::value,
                     shared_ptr &>::type

      __attribute__((__visibility__("hidden")))
      __attribute__((internal_linkage))
      operator=(unique_ptr<_Yp, _Dp> &&__r);

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  swap(shared_ptr &__r) noexcept;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  reset() noexcept;
  template <class _Yp>
  typename enable_if<is_convertible<_Yp *, element_type *>::value, void>::type
      __attribute__((__visibility__("hidden")))
      __attribute__((internal_linkage)) reset(_Yp *__p);
  template <class _Yp, class _Dp>
  typename enable_if<is_convertible<_Yp *, element_type *>::value, void>::type
      __attribute__((__visibility__("hidden")))
      __attribute__((internal_linkage)) reset(_Yp *__p, _Dp __d);
  template <class _Yp, class _Dp, class _Alloc>
  typename enable_if<is_convertible<_Yp *, element_type *>::value, void>::type
      __attribute__((__visibility__("hidden")))
      __attribute__((internal_linkage)) reset(_Yp *__p, _Dp __d, _Alloc __a);

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  element_type *
  get() const noexcept {
    return __ptr_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename add_lvalue_reference<element_type>::type
  operator*() const noexcept {
    return *__ptr_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  element_type *
  operator->() const noexcept {
    return __ptr_;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) long
  use_count() const noexcept {
    return __cntrl_ ? __cntrl_->use_count() : 0;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  unique() const noexcept {
    return use_count() == 1;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit
  operator bool() const noexcept {
    return get() != 0;
  }
  template <class _Up>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  owner_before(shared_ptr<_Up> const &__p) const noexcept {
    return __cntrl_ < __p.__cntrl_;
  }
  template <class _Up>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  owner_before(weak_ptr<_Up> const &__p) const noexcept {
    return __cntrl_ < __p.__cntrl_;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  __owner_equivalent(const shared_ptr &__p) const {
    return __cntrl_ == __p.__cntrl_;
  }

  template <class _Dp>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  _Dp *
  __get_deleter() const noexcept {
    return static_cast<_Dp *>(
        __cntrl_ ? const_cast<void *>(__cntrl_->__get_deleter(typeid(_Dp)))
                 : nullptr);
  }

  template <class _Yp, class _CntrlBlk>
  static shared_ptr<_Tp> __create_with_control_block(_Yp *__p,
                                                     _CntrlBlk *__cntrl) {
    shared_ptr<_Tp> __r;
    __r.__ptr_ = __p;
    __r.__cntrl_ = __cntrl;
    __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);
    return __r;
  }

  template <class _Alloc, class... _Args>
  static shared_ptr<_Tp> allocate_shared(const _Alloc &__a, _Args &&...__args);

private:
  template <class _Yp, bool = is_function<_Yp>::value>
  struct __shared_ptr_default_allocator {
    typedef allocator<_Yp> type;
  };

  template <class _Yp> struct __shared_ptr_default_allocator<_Yp, true> {
    typedef allocator<__shared_ptr_dummy_rebind_allocator_type> type;
  };

  template <class _Yp, class _OrigPtr>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename enable_if<
      is_convertible<_OrigPtr *, const enable_shared_from_this<_Yp> *>::value,
      void>::type
  __enable_weak_this(const enable_shared_from_this<_Yp> *__e,
                     _OrigPtr *__ptr) noexcept {
    typedef typename remove_cv<_Yp>::type _RawYp;
    if (__e && __e->__weak_this_.expired()) {
      __e->__weak_this_ = shared_ptr<_RawYp>(
          *this, const_cast<_RawYp *>(static_cast<const _Yp *>(__ptr)));
    }
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __enable_weak_this(...) noexcept {}

  template <class _Up>
  friend class __attribute__((__type_visibility__("default"))) shared_ptr;
  template <class _Up>
  friend class __attribute__((__type_visibility__("default"))) weak_ptr;
};

template <class _Tp>
inline constexpr shared_ptr<_Tp>::shared_ptr() noexcept
    : __ptr_(0), __cntrl_(0) {}

template <class _Tp>
inline constexpr shared_ptr<_Tp>::shared_ptr(nullptr_t) noexcept
    : __ptr_(0), __cntrl_(0) {}

template <class _Tp>
template <class _Yp>
shared_ptr<_Tp>::shared_ptr(
    _Yp *__p, typename enable_if<is_convertible<_Yp *, element_type *>::value,
                                 __nat>::type)
    : __ptr_(__p) {
  unique_ptr<_Yp> __hold(__p);
  typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
  typedef __shared_ptr_pointer<_Yp *, default_delete<_Yp>, _AllocT> _CntrlBlk;
  __cntrl_ = new _CntrlBlk(__p, default_delete<_Yp>(), _AllocT());
  __hold.release();
  __enable_weak_this(__p, __p);
}

template <class _Tp>
template <class _Yp, class _Dp>
shared_ptr<_Tp>::shared_ptr(
    _Yp *__p, _Dp __d,
    typename enable_if<is_convertible<_Yp *, element_type *>::value,
                       __nat>::type)
    : __ptr_(__p) {

  try {

    typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
    typedef __shared_ptr_pointer<_Yp *, _Dp, _AllocT> _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__p, __d, _AllocT());
    __enable_weak_this(__p, __p);

  } catch (...) {
    __d(__p);
    throw;
  }
}

template <class _Tp>
template <class _Dp>
shared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d) : __ptr_(0) {

  try {

    typedef typename __shared_ptr_default_allocator<_Tp>::type _AllocT;
    typedef __shared_ptr_pointer<nullptr_t, _Dp, _AllocT> _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__p, __d, _AllocT());

  } catch (...) {
    __d(__p);
    throw;
  }
}

template <class _Tp>
template <class _Yp, class _Dp, class _Alloc>
shared_ptr<_Tp>::shared_ptr(
    _Yp *__p, _Dp __d, _Alloc __a,
    typename enable_if<is_convertible<_Yp *, element_type *>::value,
                       __nat>::type)
    : __ptr_(__p) {

  try {

    typedef __shared_ptr_pointer<_Yp *, _Dp, _Alloc> _CntrlBlk;
    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
    typedef __allocator_destructor<_A2> _D2;
    _A2 __a2(__a);
    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
    ::new (static_cast<void *>(std::__1::addressof(*__hold2.get())))
        _CntrlBlk(__p, __d, __a);
    __cntrl_ = std::__1::addressof(*__hold2.release());
    __enable_weak_this(__p, __p);

  } catch (...) {
    __d(__p);
    throw;
  }
}

template <class _Tp>
template <class _Dp, class _Alloc>
shared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a) : __ptr_(0) {

  try {

    typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;
    typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
    typedef __allocator_destructor<_A2> _D2;
    _A2 __a2(__a);
    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
    ::new (static_cast<void *>(std::__1::addressof(*__hold2.get())))
        _CntrlBlk(__p, __d, __a);
    __cntrl_ = std::__1::addressof(*__hold2.release());

  } catch (...) {
    __d(__p);
    throw;
  }
}

template <class _Tp>
template <class _Yp>
inline shared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp> &__r,
                                   element_type *__p) noexcept
    : __ptr_(__p), __cntrl_(__r.__cntrl_) {
  if (__cntrl_)
    __cntrl_->__add_shared();
}

template <class _Tp>
inline shared_ptr<_Tp>::shared_ptr(const shared_ptr &__r) noexcept
    : __ptr_(__r.__ptr_), __cntrl_(__r.__cntrl_) {
  if (__cntrl_)
    __cntrl_->__add_shared();
}

template <class _Tp>
template <class _Yp>
inline shared_ptr<_Tp>::shared_ptr(
    const shared_ptr<_Yp> &__r,
    typename enable_if<is_convertible<_Yp *, element_type *>::value,
                       __nat>::type) noexcept
    : __ptr_(__r.__ptr_), __cntrl_(__r.__cntrl_) {
  if (__cntrl_)
    __cntrl_->__add_shared();
}

template <class _Tp>
inline shared_ptr<_Tp>::shared_ptr(shared_ptr &&__r) noexcept
    : __ptr_(__r.__ptr_), __cntrl_(__r.__cntrl_) {
  __r.__ptr_ = 0;
  __r.__cntrl_ = 0;
}

template <class _Tp>
template <class _Yp>
inline shared_ptr<_Tp>::shared_ptr(
    shared_ptr<_Yp> &&__r,
    typename enable_if<is_convertible<_Yp *, element_type *>::value,
                       __nat>::type) noexcept
    : __ptr_(__r.__ptr_), __cntrl_(__r.__cntrl_) {
  __r.__ptr_ = 0;
  __r.__cntrl_ = 0;
}

template <class _Tp>
template <class _Yp>

shared_ptr<_Tp>::shared_ptr(
    auto_ptr<_Yp> &&__r,

    typename enable_if<is_convertible<_Yp *, element_type *>::value,
                       __nat>::type)
    : __ptr_(__r.get()) {
  typedef __shared_ptr_pointer<_Yp *, default_delete<_Yp>, allocator<_Yp>>
      _CntrlBlk;
  __cntrl_ = new _CntrlBlk(__r.get(), default_delete<_Yp>(), allocator<_Yp>());
  __enable_weak_this(__r.get(), __r.get());
  __r.release();
}

template <class _Tp>
template <class _Yp, class _Dp>

shared_ptr<_Tp>::shared_ptr(
    unique_ptr<_Yp, _Dp> &&__r,

    typename enable_if<
        !is_lvalue_reference<_Dp>::value && !is_array<_Yp>::value &&
            is_convertible<typename unique_ptr<_Yp, _Dp>::pointer,
                           element_type *>::value,
        __nat>::type)
    : __ptr_(__r.get()) {

  if (__ptr_ == nullptr)
    __cntrl_ = nullptr;
  else

  {
    typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
    typedef __shared_ptr_pointer<_Yp *, _Dp, _AllocT> _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__r.get(), __r.get_deleter(), _AllocT());
    __enable_weak_this(__r.get(), __r.get());
  }
  __r.release();
}

template <class _Tp>
template <class _Yp, class _Dp>

shared_ptr<_Tp>::shared_ptr(
    unique_ptr<_Yp, _Dp> &&__r,

    typename enable_if<
        is_lvalue_reference<_Dp>::value && !is_array<_Yp>::value &&
            is_convertible<typename unique_ptr<_Yp, _Dp>::pointer,
                           element_type *>::value,
        __nat>::type)
    : __ptr_(__r.get()) {

  if (__ptr_ == nullptr)
    __cntrl_ = nullptr;
  else

  {
    typedef typename __shared_ptr_default_allocator<_Yp>::type _AllocT;
    typedef __shared_ptr_pointer<
        _Yp *, reference_wrapper<typename remove_reference<_Dp>::type>, _AllocT>
        _CntrlBlk;
    __cntrl_ = new _CntrlBlk(__r.get(), ref(__r.get_deleter()), _AllocT());
    __enable_weak_this(__r.get(), __r.get());
  }
  __r.release();
}

template <class _Tp>
template <class _Alloc, class... _Args>
shared_ptr<_Tp> shared_ptr<_Tp>::allocate_shared(const _Alloc &__a,
                                                 _Args &&...__args) {
  static_assert(is_constructible<_Tp, _Args...>::value,
                "Can't construct object in allocate_shared");
  typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;
  typedef typename __allocator_traits_rebind<_Alloc, _CntrlBlk>::type _A2;
  typedef __allocator_destructor<_A2> _D2;
  _A2 __a2(__a);
  unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
  ::new (static_cast<void *>(std::__1::addressof(*__hold2.get())))
      _CntrlBlk(__a, std::__1::forward<_Args>(__args)...);
  shared_ptr<_Tp> __r;
  __r.__ptr_ = __hold2.get()->get();
  __r.__cntrl_ = std::__1::addressof(*__hold2.release());
  __r.__enable_weak_this(__r.__ptr_, __r.__ptr_);
  return __r;
}

template <class _Tp> shared_ptr<_Tp>::~shared_ptr() {
  if (__cntrl_)
    __cntrl_->__release_shared();
}

template <class _Tp>
inline shared_ptr<_Tp> &
shared_ptr<_Tp>::operator=(const shared_ptr &__r) noexcept {
  shared_ptr(__r).swap(*this);
  return *this;
}

template <class _Tp>
template <class _Yp>
inline typename enable_if<
    is_convertible<_Yp *, typename shared_ptr<_Tp>::element_type *>::value,
    shared_ptr<_Tp> &>::type
shared_ptr<_Tp>::operator=(const shared_ptr<_Yp> &__r) noexcept {
  shared_ptr(__r).swap(*this);
  return *this;
}

template <class _Tp>
inline shared_ptr<_Tp> &shared_ptr<_Tp>::operator=(shared_ptr &&__r) noexcept {
  shared_ptr(std::__1::move(__r)).swap(*this);
  return *this;
}

template <class _Tp>
template <class _Yp>
inline typename enable_if<
    is_convertible<_Yp *, typename shared_ptr<_Tp>::element_type *>::value,
    shared_ptr<_Tp> &>::type
shared_ptr<_Tp>::operator=(shared_ptr<_Yp> &&__r) {
  shared_ptr(std::__1::move(__r)).swap(*this);
  return *this;
}

template <class _Tp>
template <class _Yp>
inline typename enable_if<
    !is_array<_Yp>::value &&
        is_convertible<_Yp *, typename shared_ptr<_Tp>::element_type *>::value,
    shared_ptr<_Tp>>::type &
shared_ptr<_Tp>::operator=(auto_ptr<_Yp> &&__r) {
  shared_ptr(std::__1::move(__r)).swap(*this);
  return *this;
}

template <class _Tp>
template <class _Yp, class _Dp>
inline typename enable_if<
    !is_array<_Yp>::value &&
        is_convertible<typename unique_ptr<_Yp, _Dp>::pointer,
                       typename shared_ptr<_Tp>::element_type *>::value,
    shared_ptr<_Tp> &>::type
shared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp> &&__r) {
  shared_ptr(std::__1::move(__r)).swap(*this);
  return *this;
}
# 4333 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
template <class _Tp>
inline void shared_ptr<_Tp>::swap(shared_ptr &__r) noexcept {
  std::__1::swap(__ptr_, __r.__ptr_);
  std::__1::swap(__cntrl_, __r.__cntrl_);
}

template <class _Tp> inline void shared_ptr<_Tp>::reset() noexcept {
  shared_ptr().swap(*this);
}

template <class _Tp>
template <class _Yp>
inline typename enable_if<
    is_convertible<_Yp *, typename shared_ptr<_Tp>::element_type *>::value,
    void>::type
shared_ptr<_Tp>::reset(_Yp *__p) {
  shared_ptr(__p).swap(*this);
}

template <class _Tp>
template <class _Yp, class _Dp>
inline typename enable_if<
    is_convertible<_Yp *, typename shared_ptr<_Tp>::element_type *>::value,
    void>::type
shared_ptr<_Tp>::reset(_Yp *__p, _Dp __d) {
  shared_ptr(__p, __d).swap(*this);
}

template <class _Tp>
template <class _Yp, class _Dp, class _Alloc>
inline typename enable_if<
    is_convertible<_Yp *, typename shared_ptr<_Tp>::element_type *>::value,
    void>::type
shared_ptr<_Tp>::reset(_Yp *__p, _Dp __d, _Alloc __a) {
  shared_ptr(__p, __d, __a).swap(*this);
}

template <class _Tp, class... _Args>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename enable_if<!is_array<_Tp>::value, shared_ptr<_Tp>>::type
make_shared(_Args &&...__args) {
  static_assert(is_constructible<_Tp, _Args...>::value,
                "Can't construct object in make_shared");
  typedef __shared_ptr_emplace<_Tp, allocator<_Tp>> _CntrlBlk;
  typedef allocator<_CntrlBlk> _A2;
  typedef __allocator_destructor<_A2> _D2;

  _A2 __a2;
  unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));
  ::new (__hold2.get()) _CntrlBlk(__a2, std::__1::forward<_Args>(__args)...);

  _Tp *__ptr = __hold2.get()->get();
  return shared_ptr<_Tp>::__create_with_control_block(__ptr, __hold2.release());
}

template <class _Tp, class _Alloc, class... _Args>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename enable_if<!is_array<_Tp>::value, shared_ptr<_Tp>>::type
allocate_shared(const _Alloc &__a, _Args &&...__args) {
  return shared_ptr<_Tp>::allocate_shared(__a,
                                          std::__1::forward<_Args>(__args)...);
}

template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator==(const shared_ptr<_Tp> &__x, const shared_ptr<_Up> &__y) noexcept {
  return __x.get() == __y.get();
}

template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator!=(const shared_ptr<_Tp> &__x, const shared_ptr<_Up> &__y) noexcept {
  return !(__x == __y);
}

template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator<(const shared_ptr<_Tp> &__x, const shared_ptr<_Up> &__y) noexcept {

  return less<>()(__x.get(), __y.get());
}

template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator>(const shared_ptr<_Tp> &__x, const shared_ptr<_Up> &__y) noexcept {
  return __y < __x;
}

template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator<=(const shared_ptr<_Tp> &__x, const shared_ptr<_Up> &__y) noexcept {
  return !(__y < __x);
}

template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator>=(const shared_ptr<_Tp> &__x, const shared_ptr<_Up> &__y) noexcept {
  return !(__x < __y);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator==(const shared_ptr<_Tp> &__x, nullptr_t) noexcept {
  return !__x;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator==(nullptr_t, const shared_ptr<_Tp> &__x) noexcept {
  return !__x;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator!=(const shared_ptr<_Tp> &__x, nullptr_t) noexcept {
  return static_cast<bool>(__x);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator!=(nullptr_t, const shared_ptr<_Tp> &__x) noexcept {
  return static_cast<bool>(__x);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator<(const shared_ptr<_Tp> &__x, nullptr_t) noexcept {
  return less<_Tp *>()(__x.get(), nullptr);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator<(nullptr_t, const shared_ptr<_Tp> &__x) noexcept {
  return less<_Tp *>()(nullptr, __x.get());
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator>(const shared_ptr<_Tp> &__x, nullptr_t) noexcept {
  return nullptr < __x;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator>(nullptr_t, const shared_ptr<_Tp> &__x) noexcept {
  return __x < nullptr;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator<=(const shared_ptr<_Tp> &__x, nullptr_t) noexcept {
  return !(nullptr < __x);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator<=(nullptr_t, const shared_ptr<_Tp> &__x) noexcept {
  return !(__x < nullptr);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator>=(const shared_ptr<_Tp> &__x, nullptr_t) noexcept {
  return !(__x < nullptr);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator>=(nullptr_t, const shared_ptr<_Tp> &__x) noexcept {
  return !(nullptr < __x);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
swap(shared_ptr<_Tp> &__x, shared_ptr<_Tp> &__y) noexcept {
  __x.swap(__y);
}

template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename enable_if<!is_array<_Tp>::value && !is_array<_Up>::value,
                   shared_ptr<_Tp>>::type
static_pointer_cast(const shared_ptr<_Up> &__r) noexcept {
  return shared_ptr<_Tp>(__r, static_cast<_Tp *>(__r.get()));
}

template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename enable_if<!is_array<_Tp>::value && !is_array<_Up>::value,
                   shared_ptr<_Tp>>::type
dynamic_pointer_cast(const shared_ptr<_Up> &__r) noexcept {
  _Tp *__p = dynamic_cast<_Tp *>(__r.get());
  return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();
}

template <class _Tp, class _Up>
typename enable_if<is_array<_Tp>::value == is_array<_Up>::value,
                   shared_ptr<_Tp>>::type
const_pointer_cast(const shared_ptr<_Up> &__r) noexcept {
  typedef typename remove_extent<_Tp>::type _RTp;
  return shared_ptr<_Tp>(__r, const_cast<_RTp *>(__r.get()));
}

template <class _Dp, class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _Dp *
get_deleter(const shared_ptr<_Tp> &__p) noexcept {
  return __p.template __get_deleter<_Dp>();
}

template <class _Tp>
class __attribute__((__type_visibility__("default"))) weak_ptr {
public:
  typedef _Tp element_type;

private:
  element_type *__ptr_;
  __shared_weak_count *__cntrl_;

public:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr weak_ptr() noexcept;
  template <class _Yp>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  weak_ptr(shared_ptr<_Yp> const &__r,
           typename enable_if<is_convertible<_Yp *, _Tp *>::value,
                              __nat *>::type = 0) noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  weak_ptr(weak_ptr const &__r) noexcept;
  template <class _Yp>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  weak_ptr(weak_ptr<_Yp> const &__r,
           typename enable_if<is_convertible<_Yp *, _Tp *>::value,
                              __nat *>::type = 0) noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  weak_ptr(weak_ptr &&__r) noexcept;
  template <class _Yp>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  weak_ptr(weak_ptr<_Yp> &&__r,
           typename enable_if<is_convertible<_Yp *, _Tp *>::value,
                              __nat *>::type = 0) noexcept;

  ~weak_ptr();

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  weak_ptr &
  operator=(weak_ptr const &__r) noexcept;
  template <class _Yp>
  typename enable_if<is_convertible<_Yp *, element_type *>::value,
                     weak_ptr &>::type __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage))
  operator=(weak_ptr<_Yp> const &__r) noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  weak_ptr &
  operator=(weak_ptr &&__r) noexcept;
  template <class _Yp>
  typename enable_if<is_convertible<_Yp *, element_type *>::value,
                     weak_ptr &>::type __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage))
  operator=(weak_ptr<_Yp> &&__r) noexcept;

  template <class _Yp>
  typename enable_if<is_convertible<_Yp *, element_type *>::value,
                     weak_ptr &>::type __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage))
  operator=(shared_ptr<_Yp> const &__r) noexcept;

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  swap(weak_ptr &__r) noexcept;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  reset() noexcept;

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) long
  use_count() const noexcept {
    return __cntrl_ ? __cntrl_->use_count() : 0;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  expired() const noexcept {
    return __cntrl_ == 0 || __cntrl_->use_count() == 0;
  }
  shared_ptr<_Tp> lock() const noexcept;
  template <class _Up>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  owner_before(const shared_ptr<_Up> &__r) const noexcept {
    return __cntrl_ < __r.__cntrl_;
  }
  template <class _Up>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  owner_before(const weak_ptr<_Up> &__r) const noexcept {
    return __cntrl_ < __r.__cntrl_;
  }

  template <class _Up>
  friend class __attribute__((__type_visibility__("default"))) weak_ptr;
  template <class _Up>
  friend class __attribute__((__type_visibility__("default"))) shared_ptr;
};

template <class _Tp>
inline constexpr weak_ptr<_Tp>::weak_ptr() noexcept : __ptr_(0), __cntrl_(0) {}

template <class _Tp>
inline weak_ptr<_Tp>::weak_ptr(weak_ptr const &__r) noexcept
    : __ptr_(__r.__ptr_), __cntrl_(__r.__cntrl_) {
  if (__cntrl_)
    __cntrl_->__add_weak();
}

template <class _Tp>
template <class _Yp>
inline weak_ptr<_Tp>::weak_ptr(
    shared_ptr<_Yp> const &__r,
    typename enable_if<is_convertible<_Yp *, _Tp *>::value,
                       __nat *>::type) noexcept
    : __ptr_(__r.__ptr_), __cntrl_(__r.__cntrl_) {
  if (__cntrl_)
    __cntrl_->__add_weak();
}

template <class _Tp>
template <class _Yp>
inline weak_ptr<_Tp>::weak_ptr(
    weak_ptr<_Yp> const &__r,
    typename enable_if<is_convertible<_Yp *, _Tp *>::value,
                       __nat *>::type) noexcept
    : __ptr_(__r.__ptr_), __cntrl_(__r.__cntrl_) {
  if (__cntrl_)
    __cntrl_->__add_weak();
}

template <class _Tp>
inline weak_ptr<_Tp>::weak_ptr(weak_ptr &&__r) noexcept
    : __ptr_(__r.__ptr_), __cntrl_(__r.__cntrl_) {
  __r.__ptr_ = 0;
  __r.__cntrl_ = 0;
}

template <class _Tp>
template <class _Yp>
inline weak_ptr<_Tp>::weak_ptr(
    weak_ptr<_Yp> &&__r, typename enable_if<is_convertible<_Yp *, _Tp *>::value,
                                            __nat *>::type) noexcept
    : __ptr_(__r.__ptr_), __cntrl_(__r.__cntrl_) {
  __r.__ptr_ = 0;
  __r.__cntrl_ = 0;
}

template <class _Tp> weak_ptr<_Tp>::~weak_ptr() {
  if (__cntrl_)
    __cntrl_->__release_weak();
}

template <class _Tp>
inline weak_ptr<_Tp> &weak_ptr<_Tp>::operator=(weak_ptr const &__r) noexcept {
  weak_ptr(__r).swap(*this);
  return *this;
}

template <class _Tp>
template <class _Yp>
inline typename enable_if<is_convertible<_Yp *, _Tp *>::value,
                          weak_ptr<_Tp> &>::type
weak_ptr<_Tp>::operator=(weak_ptr<_Yp> const &__r) noexcept {
  weak_ptr(__r).swap(*this);
  return *this;
}

template <class _Tp>
inline weak_ptr<_Tp> &weak_ptr<_Tp>::operator=(weak_ptr &&__r) noexcept {
  weak_ptr(std::__1::move(__r)).swap(*this);
  return *this;
}

template <class _Tp>
template <class _Yp>
inline typename enable_if<is_convertible<_Yp *, _Tp *>::value,
                          weak_ptr<_Tp> &>::type
weak_ptr<_Tp>::operator=(weak_ptr<_Yp> &&__r) noexcept {
  weak_ptr(std::__1::move(__r)).swap(*this);
  return *this;
}

template <class _Tp>
template <class _Yp>
inline typename enable_if<is_convertible<_Yp *, _Tp *>::value,
                          weak_ptr<_Tp> &>::type
weak_ptr<_Tp>::operator=(shared_ptr<_Yp> const &__r) noexcept {
  weak_ptr(__r).swap(*this);
  return *this;
}

template <class _Tp> inline void weak_ptr<_Tp>::swap(weak_ptr &__r) noexcept {
  std::__1::swap(__ptr_, __r.__ptr_);
  std::__1::swap(__cntrl_, __r.__cntrl_);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
swap(weak_ptr<_Tp> &__x, weak_ptr<_Tp> &__y) noexcept {
  __x.swap(__y);
}

template <class _Tp> inline void weak_ptr<_Tp>::reset() noexcept {
  weak_ptr().swap(*this);
}

template <class _Tp>
template <class _Yp>
shared_ptr<_Tp>::shared_ptr(
    const weak_ptr<_Yp> &__r,
    typename enable_if<is_convertible<_Yp *, element_type *>::value,
                       __nat>::type)
    : __ptr_(__r.__ptr_),
      __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_) {
  if (__cntrl_ == 0)
    __throw_bad_weak_ptr();
}

template <class _Tp> shared_ptr<_Tp> weak_ptr<_Tp>::lock() const noexcept {
  shared_ptr<_Tp> __r;
  __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;
  if (__r.__cntrl_)
    __r.__ptr_ = __ptr_;
  return __r;
}

template <class _Tp> struct owner_less;

template <class _Tp>
struct __attribute__((__type_visibility__("default")))
owner_less<shared_ptr<_Tp>>
    : binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool> {
  typedef bool result_type;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator()(shared_ptr<_Tp> const &__x,
             shared_ptr<_Tp> const &__y) const noexcept {
    return __x.owner_before(__y);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator()(shared_ptr<_Tp> const &__x,
             weak_ptr<_Tp> const &__y) const noexcept {
    return __x.owner_before(__y);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator()(weak_ptr<_Tp> const &__x,
             shared_ptr<_Tp> const &__y) const noexcept {
    return __x.owner_before(__y);
  }
};

template <class _Tp>
struct __attribute__((__type_visibility__("default"))) owner_less<weak_ptr<_Tp>>
    : binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool> {
  typedef bool result_type;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator()(weak_ptr<_Tp> const &__x,
             weak_ptr<_Tp> const &__y) const noexcept {
    return __x.owner_before(__y);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator()(shared_ptr<_Tp> const &__x,
             weak_ptr<_Tp> const &__y) const noexcept {
    return __x.owner_before(__y);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator()(weak_ptr<_Tp> const &__x,
             shared_ptr<_Tp> const &__y) const noexcept {
    return __x.owner_before(__y);
  }
};
# 4972 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
template <class _Tp>
class __attribute__((__type_visibility__("default"))) enable_shared_from_this {
  mutable weak_ptr<_Tp> __weak_this_;

protected:
  __attribute__((__visibility__("hidden"))) __attribute__((
      internal_linkage)) constexpr enable_shared_from_this() noexcept {}
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  enable_shared_from_this(enable_shared_from_this const &) noexcept {}
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  enable_shared_from_this &
  operator=(enable_shared_from_this const &) noexcept {
    return *this;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) ~enable_shared_from_this() {}

public:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  shared_ptr<_Tp>
  shared_from_this() {
    return shared_ptr<_Tp>(__weak_this_);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  shared_ptr<_Tp const>
  shared_from_this() const {
    return shared_ptr<const _Tp>(__weak_this_);
  }
# 5004 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
  template <class _Up> friend class shared_ptr;
};

template <class _Tp>
struct __attribute__((__type_visibility__("default"))) hash<shared_ptr<_Tp>> {
  typedef shared_ptr<_Tp> argument_type;
  typedef size_t result_type;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  result_type
  operator()(const argument_type &__ptr) const noexcept {
    return hash<_Tp *>()(__ptr.get());
  }
};

template <class _CharT, class _Traits, class _Yp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) basic_ostream<_CharT, _Traits> &
operator<<(basic_ostream<_CharT, _Traits> &__os, shared_ptr<_Yp> const &__p);

class __attribute__((__visibility__("default"))) __sp_mut {
  void *__lx;

public:
  void lock() noexcept;
  void unlock() noexcept;

private:
  constexpr __sp_mut(void *) noexcept;
  __sp_mut(const __sp_mut &);
  __sp_mut &operator=(const __sp_mut &);

  friend __attribute__((__visibility__("default"))) __sp_mut &
  __get_sp_mut(const void *);
};

__attribute__((__visibility__("default")))
__attribute__((availability(macosx, strict, introduced = 10.9)))
__attribute__((availability(ios, strict, introduced = 7.0))) __sp_mut &
__get_sp_mut(const void *);

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
atomic_is_lock_free(const shared_ptr<_Tp> *) {
  return false;
}

template <class _Tp>
__attribute__((availability(macosx, strict, introduced = 10.9)))
__attribute__((availability(ios, strict, introduced = 7.0))) shared_ptr<_Tp>
atomic_load(const shared_ptr<_Tp> *__p) {
  __sp_mut &__m = __get_sp_mut(__p);
  __m.lock();
  shared_ptr<_Tp> __q = *__p;
  __m.unlock();
  return __q;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
__attribute__((availability(macosx, strict, introduced = 10.9)))
__attribute__((availability(ios, strict, introduced = 7.0))) shared_ptr<_Tp>
atomic_load_explicit(const shared_ptr<_Tp> *__p, memory_order) {
  return atomic_load(__p);
}

template <class _Tp>
__attribute__((availability(macosx, strict, introduced = 10.9)))
__attribute__((availability(ios, strict, introduced = 7.0))) void
atomic_store(shared_ptr<_Tp> *__p, shared_ptr<_Tp> __r) {
  __sp_mut &__m = __get_sp_mut(__p);
  __m.lock();
  __p->swap(__r);
  __m.unlock();
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
__attribute__((availability(macosx, strict, introduced = 10.9)))
__attribute__((availability(ios, strict, introduced = 7.0))) void
atomic_store_explicit(shared_ptr<_Tp> *__p, shared_ptr<_Tp> __r, memory_order) {
  atomic_store(__p, __r);
}

template <class _Tp>
__attribute__((availability(macosx, strict, introduced = 10.9)))
__attribute__((availability(ios, strict, introduced = 7.0))) shared_ptr<_Tp>
atomic_exchange(shared_ptr<_Tp> *__p, shared_ptr<_Tp> __r) {
  __sp_mut &__m = __get_sp_mut(__p);
  __m.lock();
  __p->swap(__r);
  __m.unlock();
  return __r;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
__attribute__((availability(macosx, strict, introduced = 10.9)))
__attribute__((availability(ios, strict, introduced = 7.0))) shared_ptr<_Tp>
atomic_exchange_explicit(shared_ptr<_Tp> *__p, shared_ptr<_Tp> __r,
                         memory_order) {
  return atomic_exchange(__p, __r);
}

template <class _Tp>
__attribute__((availability(macosx, strict, introduced = 10.9)))
__attribute__((availability(ios, strict, introduced = 7.0))) bool
atomic_compare_exchange_strong(shared_ptr<_Tp> *__p, shared_ptr<_Tp> *__v,
                               shared_ptr<_Tp> __w) {
  shared_ptr<_Tp> __temp;
  __sp_mut &__m = __get_sp_mut(__p);
  __m.lock();
  if (__p->__owner_equivalent(*__v)) {
    std::__1::swap(__temp, *__p);
    *__p = __w;
    __m.unlock();
    return true;
  }
  std::__1::swap(__temp, *__v);
  *__v = *__p;
  __m.unlock();
  return false;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
__attribute__((availability(macosx, strict, introduced = 10.9)))
__attribute__((availability(ios, strict, introduced = 7.0))) bool
atomic_compare_exchange_weak(shared_ptr<_Tp> *__p, shared_ptr<_Tp> *__v,
                             shared_ptr<_Tp> __w) {
  return atomic_compare_exchange_strong(__p, __v, __w);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
__attribute__((availability(macosx, strict, introduced = 10.9)))
__attribute__((availability(ios, strict, introduced = 7.0))) bool
atomic_compare_exchange_strong_explicit(shared_ptr<_Tp> *__p,
                                        shared_ptr<_Tp> *__v,
                                        shared_ptr<_Tp> __w, memory_order,
                                        memory_order) {
  return atomic_compare_exchange_strong(__p, __v, __w);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
__attribute__((availability(macosx, strict, introduced = 10.9)))
__attribute__((availability(ios, strict, introduced = 7.0))) bool
atomic_compare_exchange_weak_explicit(shared_ptr<_Tp> *__p,
                                      shared_ptr<_Tp> *__v, shared_ptr<_Tp> __w,
                                      memory_order, memory_order) {
  return atomic_compare_exchange_weak(__p, __v, __w);
}
# 5178 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
struct __attribute__((__visibility__("default"))) pointer_safety {
  enum __lx { relaxed, preferred, strict };

  __lx __v_;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pointer_safety()
      : __v_() {}

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pointer_safety(__lx __v)
      : __v_(__v) {}
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  operator int() const {
    return __v_;
  }
};
# 5205 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory" 3
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) pointer_safety
get_pointer_safety() noexcept {
  return pointer_safety::relaxed;
}

__attribute__((__visibility__("default"))) void declare_reachable(void *__p);
__attribute__((__visibility__("default"))) void declare_no_pointers(char *__p,
                                                                    size_t __n);
__attribute__((__visibility__("default"))) void
undeclare_no_pointers(char *__p, size_t __n);
__attribute__((__visibility__("default"))) void *
__undeclare_reachable(void *__p);

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _Tp *
undeclare_reachable(_Tp *__p) {
  return static_cast<_Tp *>(__undeclare_reachable(__p));
}

__attribute__((__visibility__("default"))) void *
align(size_t __align, size_t __sz, void *&__ptr, size_t &__space);

template <typename _Alloc>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
__swap_allocator(_Alloc &__a1, _Alloc &__a2)

    noexcept

{
  __swap_allocator(
      __a1, __a2,
      integral_constant<bool, std::__1::allocator_traits<_Alloc>::
                                  propagate_on_container_swap::value>());
}

template <typename _Alloc>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) void
__swap_allocator(_Alloc &__a1, _Alloc &__a2, true_type)

    noexcept

{
  using std::__1::swap;
  swap(__a1, __a2);
}

template <typename _Alloc>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
__swap_allocator(_Alloc &, _Alloc &, false_type) noexcept {}

template <typename _Alloc, typename _Traits = allocator_traits<_Alloc>>
struct __noexcept_move_assign_container
    : public integral_constant<
          bool, _Traits::propagate_on_container_move_assignment::value

                    && is_nothrow_move_assignable<_Alloc>::value

          > {};

template <class _Tp, class _Alloc> struct __temp_value {
  typedef allocator_traits<_Alloc> _Traits;

  typename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __v;
  _Alloc &__a;

  _Tp *__addr() { return reinterpret_cast<_Tp *>(addressof(__v)); }
  _Tp &get() { return *__addr(); }

  template <class... _Args>
  __attribute__((__no_sanitize__("cfi")))
  __temp_value(_Alloc &__alloc, _Args &&...__args)
      : __a(__alloc) {
    _Traits::construct(__a, reinterpret_cast<_Tp *>(addressof(__v)),
                       std::__1::forward<_Args>(__args)...);
  }

  ~__temp_value() { _Traits::destroy(__a, __addr()); }
};

template <typename _Alloc, typename = void, typename = void>
struct __is_allocator : false_type {};

template <typename _Alloc>
struct __is_allocator<
    _Alloc, typename __void_t<typename _Alloc::value_type>::type,
    typename __void_t<decltype(
        std::__1::declval<_Alloc &>().allocate(size_t(0)))>::type> : true_type {
};

struct __builtin_new_allocator {
  struct __builtin_new_deleter {
    typedef void *pointer_type;

    constexpr explicit __builtin_new_deleter(size_t __size, size_t __align)
        : __size_(__size), __align_(__align) {}

    void operator()(void *p) const noexcept {
      std::__libcpp_deallocate(p, __size_, __align_);
    }

  private:
    size_t __size_;
    size_t __align_;
  };

  typedef unique_ptr<void, __builtin_new_deleter> __holder_t;

  static __holder_t __allocate_bytes(size_t __s, size_t __align) {
    return __holder_t(std::__libcpp_allocate(__s, __align),
                      __builtin_new_deleter(__s, __align));
  }

  static void __deallocate_bytes(void *__p, size_t __s,
                                 size_t __align) noexcept {
    std::__libcpp_deallocate(__p, __s, __align);
  }

  template <class _Tp>
  __attribute__((__nodebug__))
  __attribute__((__always_inline__)) static __holder_t
  __allocate_type(size_t __n) {
    return __allocate_bytes(__n * sizeof(_Tp), alignof(_Tp));
  }

  template <class _Tp>
  __attribute__((__nodebug__)) __attribute__((__always_inline__)) static void
  __deallocate_type(void *__p, size_t __n) noexcept {
    __deallocate_bytes(__p, __n * sizeof(_Tp), alignof(_Tp));
  }
};

} // namespace __1
} // namespace std
# 644 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 2 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 1 3
# 500 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 501 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 2 3
# 513 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3

namespace std {
inline namespace __1 {

template <class _Tp = void>

struct __attribute__((__type_visibility__("default"))) plus
    : binary_function<_Tp, _Tp, _Tp> {
  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  operator()(const _Tp &__x, const _Tp &__y) const {
    return __x + __y;
  }
};

template <> struct __attribute__((__type_visibility__("default"))) plus<void> {
  template <class _T1, class _T2>
  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) auto
  operator()(_T1 &&__t,
             _T2 &&__u) const noexcept(noexcept(std::__1::forward<_T1>(__t) +
                                                std::__1::forward<_T2>(__u)))
      -> decltype(std::__1::forward<_T1>(__t) + std::__1::forward<_T2>(__u)) {
    return std::__1::forward<_T1>(__t) + std::__1::forward<_T2>(__u);
  }
  typedef void is_transparent;
};

template <class _Tp = void>

struct __attribute__((__type_visibility__("default"))) minus
    : binary_function<_Tp, _Tp, _Tp> {
  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  operator()(const _Tp &__x, const _Tp &__y) const {
    return __x - __y;
  }
};

template <> struct __attribute__((__type_visibility__("default"))) minus<void> {
  template <class _T1, class _T2>
  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) auto
  operator()(_T1 &&__t,
             _T2 &&__u) const noexcept(noexcept(std::__1::forward<_T1>(__t) -
                                                std::__1::forward<_T2>(__u)))
      -> decltype(std::__1::forward<_T1>(__t) - std::__1::forward<_T2>(__u)) {
    return std::__1::forward<_T1>(__t) - std::__1::forward<_T2>(__u);
  }
  typedef void is_transparent;
};

template <class _Tp = void>

struct __attribute__((__type_visibility__("default"))) multiplies
    : binary_function<_Tp, _Tp, _Tp> {
  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  operator()(const _Tp &__x, const _Tp &__y) const {
    return __x * __y;
  }
};

template <>
struct __attribute__((__type_visibility__("default"))) multiplies<void> {
  template <class _T1, class _T2>
  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) auto
  operator()(_T1 &&__t,
             _T2 &&__u) const noexcept(noexcept(std::__1::forward<_T1>(__t) *
                                                std::__1::forward<_T2>(__u)))
      -> decltype(std::__1::forward<_T1>(__t) * std::__1::forward<_T2>(__u)) {
    return std::__1::forward<_T1>(__t) * std::__1::forward<_T2>(__u);
  }
  typedef void is_transparent;
};

template <class _Tp = void>

struct __attribute__((__type_visibility__("default"))) divides
    : binary_function<_Tp, _Tp, _Tp> {
  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  operator()(const _Tp &__x, const _Tp &__y) const {
    return __x / __y;
  }
};

template <>
struct __attribute__((__type_visibility__("default"))) divides<void> {
  template <class _T1, class _T2>
  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) auto
  operator()(_T1 &&__t,
             _T2 &&__u) const noexcept(noexcept(std::__1::forward<_T1>(__t) /
                                                std::__1::forward<_T2>(__u)))
      -> decltype(std::__1::forward<_T1>(__t) / std::__1::forward<_T2>(__u)) {
    return std::__1::forward<_T1>(__t) / std::__1::forward<_T2>(__u);
  }
  typedef void is_transparent;
};

template <class _Tp = void>

struct __attribute__((__type_visibility__("default"))) modulus
    : binary_function<_Tp, _Tp, _Tp> {
  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  operator()(const _Tp &__x, const _Tp &__y) const {
    return __x % __y;
  }
};

template <>
struct __attribute__((__type_visibility__("default"))) modulus<void> {
  template <class _T1, class _T2>
  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) auto
  operator()(_T1 &&__t,
             _T2 &&__u) const noexcept(noexcept(std::__1::forward<_T1>(__t) %
                                                std::__1::forward<_T2>(__u)))
      -> decltype(std::__1::forward<_T1>(__t) % std::__1::forward<_T2>(__u)) {
    return std::__1::forward<_T1>(__t) % std::__1::forward<_T2>(__u);
  }
  typedef void is_transparent;
};

template <class _Tp = void>

struct __attribute__((__type_visibility__("default"))) negate
    : unary_function<_Tp, _Tp> {
  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  operator()(const _Tp &__x) const {
    return -__x;
  }
};

template <>
struct __attribute__((__type_visibility__("default"))) negate<void> {
  template <class _Tp>
  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) auto
  operator()(_Tp &&__x) const noexcept(noexcept(-std::__1::forward<_Tp>(__x)))
      -> decltype(-std::__1::forward<_Tp>(__x)) {
    return -std::__1::forward<_Tp>(__x);
  }
  typedef void is_transparent;
};

template <class _Tp = void>

struct __attribute__((__type_visibility__("default"))) equal_to
    : binary_function<_Tp, _Tp, bool> {
  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator()(const _Tp &__x, const _Tp &__y) const {
    return __x == __y;
  }
};

template <>
struct __attribute__((__type_visibility__("default"))) equal_to<void> {
  template <class _T1, class _T2>
  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) auto
  operator()(_T1 &&__t,
             _T2 &&__u) const noexcept(noexcept(std::__1::forward<_T1>(__t) ==
                                                std::__1::forward<_T2>(__u)))
      -> decltype(std::__1::forward<_T1>(__t) == std::__1::forward<_T2>(__u)) {
    return std::__1::forward<_T1>(__t) == std::__1::forward<_T2>(__u);
  }
  typedef void is_transparent;
};

template <class _Tp = void>

struct __attribute__((__type_visibility__("default"))) not_equal_to
    : binary_function<_Tp, _Tp, bool> {
  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator()(const _Tp &__x, const _Tp &__y) const {
    return __x != __y;
  }
};

template <>
struct __attribute__((__type_visibility__("default"))) not_equal_to<void> {
  template <class _T1, class _T2>
  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) auto
  operator()(_T1 &&__t,
             _T2 &&__u) const noexcept(noexcept(std::__1::forward<_T1>(__t) !=
                                                std::__1::forward<_T2>(__u)))
      -> decltype(std::__1::forward<_T1>(__t) != std::__1::forward<_T2>(__u)) {
    return std::__1::forward<_T1>(__t) != std::__1::forward<_T2>(__u);
  }
  typedef void is_transparent;
};

template <class _Tp = void>

struct __attribute__((__type_visibility__("default"))) greater
    : binary_function<_Tp, _Tp, bool> {
  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator()(const _Tp &__x, const _Tp &__y) const {
    return __x > __y;
  }
};

template <>
struct __attribute__((__type_visibility__("default"))) greater<void> {
  template <class _T1, class _T2>
  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) auto
  operator()(_T1 &&__t,
             _T2 &&__u) const noexcept(noexcept(std::__1::forward<_T1>(__t) >
                                                std::__1::forward<_T2>(__u)))
      -> decltype(std::__1::forward<_T1>(__t) > std::__1::forward<_T2>(__u)) {
    return std::__1::forward<_T1>(__t) > std::__1::forward<_T2>(__u);
  }
  typedef void is_transparent;
};

template <class _Tp = void>

struct __attribute__((__type_visibility__("default"))) greater_equal
    : binary_function<_Tp, _Tp, bool> {
  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator()(const _Tp &__x, const _Tp &__y) const {
    return __x >= __y;
  }
};

template <>
struct __attribute__((__type_visibility__("default"))) greater_equal<void> {
  template <class _T1, class _T2>
  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) auto
  operator()(_T1 &&__t,
             _T2 &&__u) const noexcept(noexcept(std::__1::forward<_T1>(__t) >=
                                                std::__1::forward<_T2>(__u)))
      -> decltype(std::__1::forward<_T1>(__t) >= std::__1::forward<_T2>(__u)) {
    return std::__1::forward<_T1>(__t) >= std::__1::forward<_T2>(__u);
  }
  typedef void is_transparent;
};

template <class _Tp = void>

struct __attribute__((__type_visibility__("default"))) less_equal
    : binary_function<_Tp, _Tp, bool> {
  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator()(const _Tp &__x, const _Tp &__y) const {
    return __x <= __y;
  }
};

template <>
struct __attribute__((__type_visibility__("default"))) less_equal<void> {
  template <class _T1, class _T2>
  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) auto
  operator()(_T1 &&__t,
             _T2 &&__u) const noexcept(noexcept(std::__1::forward<_T1>(__t) <=
                                                std::__1::forward<_T2>(__u)))
      -> decltype(std::__1::forward<_T1>(__t) <= std::__1::forward<_T2>(__u)) {
    return std::__1::forward<_T1>(__t) <= std::__1::forward<_T2>(__u);
  }
  typedef void is_transparent;
};

template <class _Tp = void>

struct __attribute__((__type_visibility__("default"))) logical_and
    : binary_function<_Tp, _Tp, bool> {
  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator()(const _Tp &__x, const _Tp &__y) const {
    return __x && __y;
  }
};

template <>
struct __attribute__((__type_visibility__("default"))) logical_and<void> {
  template <class _T1, class _T2>
  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) auto
  operator()(_T1 &&__t,
             _T2 &&__u) const noexcept(noexcept(std::__1::forward<_T1>(__t) &&
                                                std::__1::forward<_T2>(__u)))
      -> decltype(std::__1::forward<_T1>(__t) && std::__1::forward<_T2>(__u)) {
    return std::__1::forward<_T1>(__t) && std::__1::forward<_T2>(__u);
  }
  typedef void is_transparent;
};

template <class _Tp = void>

struct __attribute__((__type_visibility__("default"))) logical_or
    : binary_function<_Tp, _Tp, bool> {
  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator()(const _Tp &__x, const _Tp &__y) const {
    return __x || __y;
  }
};

template <>
struct __attribute__((__type_visibility__("default"))) logical_or<void> {
  template <class _T1, class _T2>
  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) auto
  operator()(_T1 &&__t,
             _T2 &&__u) const noexcept(noexcept(std::__1::forward<_T1>(__t) ||
                                                std::__1::forward<_T2>(__u)))
      -> decltype(std::__1::forward<_T1>(__t) || std::__1::forward<_T2>(__u)) {
    return std::__1::forward<_T1>(__t) || std::__1::forward<_T2>(__u);
  }
  typedef void is_transparent;
};

template <class _Tp = void>

struct __attribute__((__type_visibility__("default"))) logical_not
    : unary_function<_Tp, bool> {
  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator()(const _Tp &__x) const {
    return !__x;
  }
};

template <>
struct __attribute__((__type_visibility__("default"))) logical_not<void> {
  template <class _Tp>
  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) auto
  operator()(_Tp &&__x) const noexcept(noexcept(!std::__1::forward<_Tp>(__x)))
      -> decltype(!std::__1::forward<_Tp>(__x)) {
    return !std::__1::forward<_Tp>(__x);
  }
  typedef void is_transparent;
};

template <class _Tp = void>

struct __attribute__((__type_visibility__("default"))) bit_and
    : binary_function<_Tp, _Tp, _Tp> {
  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  operator()(const _Tp &__x, const _Tp &__y) const {
    return __x & __y;
  }
};

template <>
struct __attribute__((__type_visibility__("default"))) bit_and<void> {
  template <class _T1, class _T2>
  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) auto
  operator()(_T1 &&__t,
             _T2 &&__u) const noexcept(noexcept(std::__1::forward<_T1>(__t) &
                                                std::__1::forward<_T2>(__u)))
      -> decltype(std::__1::forward<_T1>(__t) & std::__1::forward<_T2>(__u)) {
    return std::__1::forward<_T1>(__t) & std::__1::forward<_T2>(__u);
  }
  typedef void is_transparent;
};

template <class _Tp = void>

struct __attribute__((__type_visibility__("default"))) bit_or
    : binary_function<_Tp, _Tp, _Tp> {
  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  operator()(const _Tp &__x, const _Tp &__y) const {
    return __x | __y;
  }
};

template <>
struct __attribute__((__type_visibility__("default"))) bit_or<void> {
  template <class _T1, class _T2>
  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) auto
  operator()(_T1 &&__t,
             _T2 &&__u) const noexcept(noexcept(std::__1::forward<_T1>(__t) |
                                                std::__1::forward<_T2>(__u)))
      -> decltype(std::__1::forward<_T1>(__t) | std::__1::forward<_T2>(__u)) {
    return std::__1::forward<_T1>(__t) | std::__1::forward<_T2>(__u);
  }
  typedef void is_transparent;
};

template <class _Tp = void>

struct __attribute__((__type_visibility__("default"))) bit_xor
    : binary_function<_Tp, _Tp, _Tp> {
  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  operator()(const _Tp &__x, const _Tp &__y) const {
    return __x ^ __y;
  }
};

template <>
struct __attribute__((__type_visibility__("default"))) bit_xor<void> {
  template <class _T1, class _T2>
  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) auto
  operator()(_T1 &&__t,
             _T2 &&__u) const noexcept(noexcept(std::__1::forward<_T1>(__t) ^
                                                std::__1::forward<_T2>(__u)))
      -> decltype(std::__1::forward<_T1>(__t) ^ std::__1::forward<_T2>(__u)) {
    return std::__1::forward<_T1>(__t) ^ std::__1::forward<_T2>(__u);
  }
  typedef void is_transparent;
};

template <class _Tp = void>
struct __attribute__((__type_visibility__("default"))) bit_not
    : unary_function<_Tp, _Tp> {
  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Tp
  operator()(const _Tp &__x) const {
    return ~__x;
  }
};

template <>
struct __attribute__((__type_visibility__("default"))) bit_not<void> {
  template <class _Tp>
  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) auto
  operator()(_Tp &&__x) const noexcept(noexcept(~std::__1::forward<_Tp>(__x)))
      -> decltype(~std::__1::forward<_Tp>(__x)) {
    return ~std::__1::forward<_Tp>(__x);
  }
  typedef void is_transparent;
};

template <class _Predicate>
class __attribute__((__type_visibility__("default"))) unary_negate
    : public unary_function<typename _Predicate::argument_type, bool> {
  _Predicate __pred_;

public:
  constexpr __attribute__((__visibility__("hidden"))) __attribute__((
      internal_linkage)) explicit unary_negate(const _Predicate &__pred)
      : __pred_(__pred) {}
  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator()(const typename _Predicate::argument_type &__x) const {
    return !__pred_(__x);
  }
};

template <class _Predicate>
inline constexpr __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) unary_negate<_Predicate>
not1(const _Predicate &__pred) {
  return unary_negate<_Predicate>(__pred);
}

template <class _Predicate>
class __attribute__((__type_visibility__("default"))) binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
                             typename _Predicate::second_argument_type, bool> {
  _Predicate __pred_;

public:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit constexpr binary_negate(
      const _Predicate &__pred)
      : __pred_(__pred) {}

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator()(const typename _Predicate::first_argument_type &__x,
             const typename _Predicate::second_argument_type &__y) const {
    return !__pred_(__x, __y);
  }
};

template <class _Predicate>
inline constexpr __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) binary_negate<_Predicate>
not2(const _Predicate &__pred) {
  return binary_negate<_Predicate>(__pred);
}

template <class __Operation>
class __attribute__((__type_visibility__("default")))
__attribute__((deprecated)) binder1st
    : public unary_function<typename __Operation::second_argument_type,
                            typename __Operation::result_type> {
protected:
  __Operation op;
  typename __Operation::first_argument_type value;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  binder1st(const __Operation &__x,
            const typename __Operation::first_argument_type __y)
      : op(__x), value(__y) {}
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename __Operation::result_type
  operator()(typename __Operation::second_argument_type &__x) const {
    return op(value, __x);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename __Operation::result_type
  operator()(const typename __Operation::second_argument_type &__x) const {
    return op(value, __x);
  }
};

template <class __Operation, class _Tp>
__attribute__((deprecated)) inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) binder1st<__Operation>
bind1st(const __Operation &__op, const _Tp &__x) {
  return binder1st<__Operation>(__op, __x);
}

template <class __Operation>
class __attribute__((__type_visibility__("default")))
__attribute__((deprecated)) binder2nd
    : public unary_function<typename __Operation::first_argument_type,
                            typename __Operation::result_type> {
protected:
  __Operation op;
  typename __Operation::second_argument_type value;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  binder2nd(const __Operation &__x,
            const typename __Operation::second_argument_type __y)
      : op(__x), value(__y) {}
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename __Operation::result_type
  operator()(typename __Operation::first_argument_type &__x) const {
    return op(__x, value);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename __Operation::result_type
  operator()(const typename __Operation::first_argument_type &__x) const {
    return op(__x, value);
  }
};

template <class __Operation, class _Tp>
__attribute__((deprecated)) inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) binder2nd<__Operation>
bind2nd(const __Operation &__op, const _Tp &__x) {
  return binder2nd<__Operation>(__op, __x);
}

template <class _Arg, class _Result>
class __attribute__((__type_visibility__("default")))
__attribute__((deprecated)) pointer_to_unary_function
    : public unary_function<_Arg, _Result> {
  _Result (*__f_)(_Arg);

public:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit pointer_to_unary_function(
      _Result (*__f)(_Arg))
      : __f_(__f) {}
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  _Result
  operator()(_Arg __x) const {
    return __f_(__x);
  }
};

template <class _Arg, class _Result>
__attribute__((deprecated)) inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) pointer_to_unary_function<_Arg, _Result>
ptr_fun(_Result (*__f)(_Arg)) {
  return pointer_to_unary_function<_Arg, _Result>(__f);
}

template <class _Arg1, class _Arg2, class _Result>
class __attribute__((__type_visibility__("default")))
__attribute__((deprecated)) pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result> {
  _Result (*__f_)(_Arg1, _Arg2);

public:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit pointer_to_binary_function(
      _Result (*__f)(_Arg1, _Arg2))
      : __f_(__f) {}
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  _Result
  operator()(_Arg1 __x, _Arg2 __y) const {
    return __f_(__x, __y);
  }
};

template <class _Arg1, class _Arg2, class _Result>
__attribute__((deprecated)) inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
pointer_to_binary_function<_Arg1, _Arg2, _Result>
ptr_fun(_Result (*__f)(_Arg1, _Arg2)) {
  return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__f);
}

template <class _Sp, class _Tp>
class __attribute__((__type_visibility__("default")))
__attribute__((deprecated)) mem_fun_t : public unary_function<_Tp *, _Sp> {
  _Sp (_Tp::*__p_)();

public:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit mem_fun_t(_Sp (_Tp::*__p)())
      : __p_(__p) {}
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Sp
  operator()(_Tp *__p) const {
    return (__p->*__p_)();
  }
};

template <class _Sp, class _Tp, class _Ap>
class __attribute__((__type_visibility__("default")))
__attribute__((deprecated)) mem_fun1_t
    : public binary_function<_Tp *, _Ap, _Sp> {
  _Sp (_Tp::*__p_)(_Ap);

public:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit mem_fun1_t(_Sp (_Tp::*__p)(_Ap))
      : __p_(__p) {}
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Sp
  operator()(_Tp *__p, _Ap __x) const {
    return (__p->*__p_)(__x);
  }
};

template <class _Sp, class _Tp>
__attribute__((deprecated)) inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) mem_fun_t<_Sp, _Tp>
mem_fun(_Sp (_Tp::*__f)()) {
  return mem_fun_t<_Sp, _Tp>(__f);
}

template <class _Sp, class _Tp, class _Ap>
__attribute__((deprecated)) inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) mem_fun1_t<_Sp, _Tp, _Ap>
mem_fun(_Sp (_Tp::*__f)(_Ap)) {
  return mem_fun1_t<_Sp, _Tp, _Ap>(__f);
}

template <class _Sp, class _Tp>
class __attribute__((__type_visibility__("default")))
__attribute__((deprecated)) mem_fun_ref_t : public unary_function<_Tp, _Sp> {
  _Sp (_Tp::*__p_)();

public:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit mem_fun_ref_t(_Sp (_Tp::*__p)())
      : __p_(__p) {}
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Sp
  operator()(_Tp &__p) const {
    return (__p.*__p_)();
  }
};

template <class _Sp, class _Tp, class _Ap>
class __attribute__((__type_visibility__("default")))
__attribute__((deprecated)) mem_fun1_ref_t
    : public binary_function<_Tp, _Ap, _Sp> {
  _Sp (_Tp::*__p_)(_Ap);

public:
  __attribute__((__visibility__("hidden"))) __attribute__((
      internal_linkage)) explicit mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap))
      : __p_(__p) {}
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Sp
  operator()(_Tp &__p, _Ap __x) const {
    return (__p.*__p_)(__x);
  }
};

template <class _Sp, class _Tp>
__attribute__((deprecated)) inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) mem_fun_ref_t<_Sp, _Tp>
mem_fun_ref(_Sp (_Tp::*__f)()) {
  return mem_fun_ref_t<_Sp, _Tp>(__f);
}

template <class _Sp, class _Tp, class _Ap>
__attribute__((deprecated)) inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) mem_fun1_ref_t<_Sp, _Tp, _Ap>
mem_fun_ref(_Sp (_Tp::*__f)(_Ap)) {
  return mem_fun1_ref_t<_Sp, _Tp, _Ap>(__f);
}

template <class _Sp, class _Tp>
class __attribute__((__type_visibility__("default")))
__attribute__((deprecated)) const_mem_fun_t
    : public unary_function<const _Tp *, _Sp> {
  _Sp (_Tp::*__p_)() const;

public:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit const_mem_fun_t(_Sp (_Tp::*__p)()
                                                                 const)
      : __p_(__p) {}
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Sp
  operator()(const _Tp *__p) const {
    return (__p->*__p_)();
  }
};

template <class _Sp, class _Tp, class _Ap>
class __attribute__((__type_visibility__("default")))
__attribute__((deprecated)) const_mem_fun1_t
    : public binary_function<const _Tp *, _Ap, _Sp> {
  _Sp (_Tp::*__p_)(_Ap) const;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((
      internal_linkage)) explicit const_mem_fun1_t(_Sp (_Tp::*__p)(_Ap) const)
      : __p_(__p) {}
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Sp
  operator()(const _Tp *__p, _Ap __x) const {
    return (__p->*__p_)(__x);
  }
};

template <class _Sp, class _Tp>
__attribute__((deprecated)) inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) const_mem_fun_t<_Sp, _Tp>
mem_fun(_Sp (_Tp::*__f)() const) {
  return const_mem_fun_t<_Sp, _Tp>(__f);
}

template <class _Sp, class _Tp, class _Ap>
__attribute__((deprecated)) inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) const_mem_fun1_t<_Sp, _Tp, _Ap>
mem_fun(_Sp (_Tp::*__f)(_Ap) const) {
  return const_mem_fun1_t<_Sp, _Tp, _Ap>(__f);
}

template <class _Sp, class _Tp>
class __attribute__((__type_visibility__("default")))
__attribute__((deprecated)) const_mem_fun_ref_t
    : public unary_function<_Tp, _Sp> {
  _Sp (_Tp::*__p_)() const;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((
      internal_linkage)) explicit const_mem_fun_ref_t(_Sp (_Tp::*__p)() const)
      : __p_(__p) {}
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Sp
  operator()(const _Tp &__p) const {
    return (__p.*__p_)();
  }
};

template <class _Sp, class _Tp, class _Ap>
class __attribute__((__type_visibility__("default")))
__attribute__((deprecated)) const_mem_fun1_ref_t
    : public binary_function<_Tp, _Ap, _Sp> {
  _Sp (_Tp::*__p_)(_Ap) const;

public:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit const_mem_fun1_ref_t(
      _Sp (_Tp::*__p)(_Ap) const)
      : __p_(__p) {}
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Sp
  operator()(const _Tp &__p, _Ap __x) const {
    return (__p.*__p_)(__x);
  }
};

template <class _Sp, class _Tp>
__attribute__((deprecated)) inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) const_mem_fun_ref_t<_Sp, _Tp>
mem_fun_ref(_Sp (_Tp::*__f)() const) {
  return const_mem_fun_ref_t<_Sp, _Tp>(__f);
}

template <class _Sp, class _Tp, class _Ap>
__attribute__((deprecated)) inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) const_mem_fun1_ref_t<_Sp, _Tp, _Ap>
mem_fun_ref(_Sp (_Tp::*__f)(_Ap) const) {
  return const_mem_fun1_ref_t<_Sp, _Tp, _Ap>(__f);
}

template <class _Tp> class __mem_fn : public __weak_result_type<_Tp> {
public:
  typedef _Tp type;

private:
  type __f_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __mem_fn(type __f) noexcept
      : __f_(__f) {}

  template <class... _ArgTypes>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename __invoke_return<type, _ArgTypes...>::type
  operator()(_ArgTypes &&...__args) const {
    return __invoke(__f_, std::__1::forward<_ArgTypes>(__args)...);
  }
# 1400 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
};

template <class _Rp, class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) __mem_fn<_Rp _Tp::*>
mem_fn(_Rp _Tp::*__pm) noexcept {
  return __mem_fn<_Rp _Tp::*>(__pm);
}

class __attribute__((__visibility__("default"))) bad_function_call
    : public exception {};

[[noreturn]] inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
__throw_bad_function_call() {

  throw bad_function_call();
}

template <class _Fp>
class __attribute__((__type_visibility__("default"))) function;

namespace __function {

template <class _Rp> struct __maybe_derive_from_unary_function {};

template <class _Rp, class _A1>
struct __maybe_derive_from_unary_function<_Rp(_A1)>
    : public unary_function<_A1, _Rp> {};

template <class _Rp> struct __maybe_derive_from_binary_function {};

template <class _Rp, class _A1, class _A2>
struct __maybe_derive_from_binary_function<_Rp(_A1, _A2)>
    : public binary_function<_A1, _A2, _Rp> {};

template <class _Fp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) bool
__not_null(_Fp const &) {
  return true;
}

template <class _Fp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) bool
__not_null(_Fp *__ptr) {
  return __ptr;
}

template <class _Ret, class _Class>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) bool
__not_null(_Ret _Class::*__ptr) {
  return __ptr;
}

template <class _Fp>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) bool
__not_null(function<_Fp> const &__f) {
  return !!__f;
}

template <class _Rp, class... _Args>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) bool
__not_null(_Rp (^__p)(_Args...)) {
  return __p;
}

} // namespace __function

namespace __function {

template <class _Fp, class _Ap, class _FB> class __alloc_func;
template <class _Fp, class _FB> class __default_alloc_func;

template <class _Fp, class _Ap, class _Rp, class... _ArgTypes>
class __alloc_func<_Fp, _Ap, _Rp(_ArgTypes...)> {
  __compressed_pair<_Fp, _Ap> __f_;

public:
  typedef _Fp _Target;
  typedef _Ap _Alloc;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const _Target &
  __target() const {
    return __f_.first();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const _Alloc &
  __get_allocator() const {
    return __f_.second();
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit __alloc_func(_Target &&__f)
      : __f_(piecewise_construct,
             std::__1::forward_as_tuple(std::__1::move(__f)),
             std::__1::forward_as_tuple()) {}

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit __alloc_func(const _Target &__f,
                                                          const _Alloc &__a)
      : __f_(piecewise_construct, std::__1::forward_as_tuple(__f),
             std::__1::forward_as_tuple(__a)) {}

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit __alloc_func(const _Target &__f,
                                                          _Alloc &&__a)
      : __f_(piecewise_construct, std::__1::forward_as_tuple(__f),
             std::__1::forward_as_tuple(std::__1::move(__a))) {}

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit __alloc_func(_Target &&__f,
                                                          _Alloc &&__a)
      : __f_(piecewise_construct,
             std::__1::forward_as_tuple(std::__1::move(__f)),
             std::__1::forward_as_tuple(std::__1::move(__a))) {}

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Rp
  operator()(_ArgTypes &&...__arg) {
    typedef __invoke_void_return_wrapper<_Rp> _Invoker;
    return _Invoker::__call(__f_.first(),
                            std::__1::forward<_ArgTypes>(__arg)...);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __alloc_func *
  __clone() const {
    typedef allocator_traits<_Alloc> __alloc_traits;
    typedef
        typename __rebind_alloc_helper<__alloc_traits, __alloc_func>::type _AA;
    _AA __a(__f_.second());
    typedef __allocator_destructor<_AA> _Dp;
    unique_ptr<__alloc_func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
    ::new ((void *)__hold.get()) __alloc_func(__f_.first(), _Alloc(__a));
    return __hold.release();
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  destroy() noexcept {
    __f_.~__compressed_pair<_Target, _Alloc>();
  }

  static void __destroy_and_delete(__alloc_func *__f) {
    typedef allocator_traits<_Alloc> __alloc_traits;
    typedef typename __rebind_alloc_helper<__alloc_traits, __alloc_func>::type
        _FunAlloc;
    _FunAlloc __a(__f->__get_allocator());
    __f->destroy();
    __a.deallocate(__f, 1);
  }
};

template <class _Fp, class _Rp, class... _ArgTypes>
class __default_alloc_func<_Fp, _Rp(_ArgTypes...)> {
  _Fp __f_;

public:
  typedef _Fp _Target;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const _Target &
  __target() const {
    return __f_;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit __default_alloc_func(_Target &&__f)
      : __f_(std::move(__f)) {}

  __attribute__((__visibility__("hidden"))) __attribute__((
      internal_linkage)) explicit __default_alloc_func(const _Target &__f)
      : __f_(__f) {}

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Rp
  operator()(_ArgTypes &&...__arg) {
    typedef __invoke_void_return_wrapper<_Rp> _Invoker;
    return _Invoker::__call(__f_, std::__1::forward<_ArgTypes>(__arg)...);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __default_alloc_func *
  __clone() const {
    __builtin_new_allocator::__holder_t __hold =
        __builtin_new_allocator::__allocate_type<__default_alloc_func>(1);
    __default_alloc_func *__res =
        ::new (__hold.get()) __default_alloc_func(__f_);
    (void)__hold.release();
    return __res;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  destroy() noexcept {
    __f_.~_Target();
  }

  static void __destroy_and_delete(__default_alloc_func *__f) {
    __f->destroy();
    __builtin_new_allocator::__deallocate_type<__default_alloc_func>(__f, 1);
  }
};

template <class _Fp> class __base;

template <class _Rp, class... _ArgTypes> class __base<_Rp(_ArgTypes...)> {
  __base(const __base &);
  __base &operator=(const __base &);

public:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __base() {}
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) virtual ~__base() {}
  virtual __base *__clone() const = 0;
  virtual void __clone(__base *) const = 0;
  virtual void destroy() noexcept = 0;
  virtual void destroy_deallocate() noexcept = 0;
  virtual _Rp operator()(_ArgTypes &&...) = 0;

  virtual const void *target(const type_info &) const noexcept = 0;
  virtual const std::type_info &target_type() const noexcept = 0;
};

template <class _FD, class _Alloc, class _FB> class __func;

template <class _Fp, class _Alloc, class _Rp, class... _ArgTypes>
class __func<_Fp, _Alloc, _Rp(_ArgTypes...)>
    : public __base<_Rp(_ArgTypes...)> {
  __alloc_func<_Fp, _Alloc, _Rp(_ArgTypes...)> __f_;

public:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit __func(_Fp &&__f)
      : __f_(std::__1::move(__f)) {}

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit __func(const _Fp &__f,
                                                    const _Alloc &__a)
      : __f_(__f, __a) {}

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit __func(const _Fp &__f,
                                                    _Alloc &&__a)
      : __f_(__f, std::__1::move(__a)) {}

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit __func(_Fp &&__f, _Alloc &&__a)
      : __f_(std::__1::move(__f), std::__1::move(__a)) {}

  virtual __base<_Rp(_ArgTypes...)> *__clone() const;
  virtual void __clone(__base<_Rp(_ArgTypes...)> *) const;
  virtual void destroy() noexcept;
  virtual void destroy_deallocate() noexcept;
  virtual _Rp operator()(_ArgTypes &&...__arg);

  virtual const void *target(const type_info &) const noexcept;
  virtual const std::type_info &target_type() const noexcept;
};

template <class _Fp, class _Alloc, class _Rp, class... _ArgTypes>
__base<_Rp(_ArgTypes...)> *
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone() const {
  typedef allocator_traits<_Alloc> __alloc_traits;
  typedef typename __rebind_alloc_helper<__alloc_traits, __func>::type _Ap;
  _Ap __a(__f_.__get_allocator());
  typedef __allocator_destructor<_Ap> _Dp;
  unique_ptr<__func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));
  ::new ((void *)__hold.get()) __func(__f_.__target(), _Alloc(__a));
  return __hold.release();
}

template <class _Fp, class _Alloc, class _Rp, class... _ArgTypes>
void __func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone(
    __base<_Rp(_ArgTypes...)> *__p) const {
  ::new (__p) __func(__f_.__target(), __f_.__get_allocator());
}

template <class _Fp, class _Alloc, class _Rp, class... _ArgTypes>
void __func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy() noexcept {
  __f_.destroy();
}

template <class _Fp, class _Alloc, class _Rp, class... _ArgTypes>
void __func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy_deallocate() noexcept {
  typedef allocator_traits<_Alloc> __alloc_traits;
  typedef typename __rebind_alloc_helper<__alloc_traits, __func>::type _Ap;
  _Ap __a(__f_.__get_allocator());
  __f_.destroy();
  __a.deallocate(this, 1);
}

template <class _Fp, class _Alloc, class _Rp, class... _ArgTypes>
_Rp __func<_Fp, _Alloc, _Rp(_ArgTypes...)>::operator()(_ArgTypes &&...__arg) {
  return __f_(std::__1::forward<_ArgTypes>(__arg)...);
}

template <class _Fp, class _Alloc, class _Rp, class... _ArgTypes>
const void *__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::target(
    const type_info &__ti) const noexcept {
  if (__ti == typeid(_Fp))
    return &__f_.__target();
  return (const void *)0;
}

template <class _Fp, class _Alloc, class _Rp, class... _ArgTypes>
const std::type_info &
__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::target_type() const noexcept {
  return typeid(_Fp);
}

template <class _Fp> class __value_func;

template <class _Rp, class... _ArgTypes> class __value_func<_Rp(_ArgTypes...)> {
  typename aligned_storage<3 * sizeof(void *)>::type __buf_;

  typedef __base<_Rp(_ArgTypes...)> __func;
  __func *__f_;

  __attribute__((__no_sanitize__("cfi"))) static __func *__as_base(void *p) {
    return reinterpret_cast<__func *>(p);
  }

public:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __value_func() noexcept
      : __f_(0) {}

  template <class _Fp, class _Alloc>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __value_func(_Fp &&__f, const _Alloc &__a)
      : __f_(0) {
    typedef allocator_traits<_Alloc> __alloc_traits;
    typedef __function::__func<_Fp, _Alloc, _Rp(_ArgTypes...)> _Fun;
    typedef
        typename __rebind_alloc_helper<__alloc_traits, _Fun>::type _FunAlloc;

    if (__function::__not_null(__f)) {
      _FunAlloc __af(__a);
      if (sizeof(_Fun) <= sizeof(__buf_) &&
          is_nothrow_copy_constructible<_Fp>::value &&
          is_nothrow_copy_constructible<_FunAlloc>::value) {
        __f_ = ::new ((void *)&__buf_) _Fun(std::__1::move(__f), _Alloc(__af));
      } else {
        typedef __allocator_destructor<_FunAlloc> _Dp;
        unique_ptr<__func, _Dp> __hold(__af.allocate(1), _Dp(__af, 1));
        ::new ((void *)__hold.get()) _Fun(std::__1::move(__f), _Alloc(__a));
        __f_ = __hold.release();
      }
    }
  }

  template <class _Fp,
            class = typename enable_if<
                !is_same<typename decay<_Fp>::type, __value_func>::value>::type>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit __value_func(_Fp &&__f)
      : __value_func(std::forward<_Fp>(__f), allocator<_Fp>()) {}

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __value_func(const __value_func &__f) {
    if (__f.__f_ == 0)
      __f_ = 0;
    else if ((void *)__f.__f_ == &__f.__buf_) {
      __f_ = __as_base(&__buf_);
      __f.__f_->__clone(__f_);
    } else
      __f_ = __f.__f_->__clone();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __value_func(__value_func &&__f) noexcept {
    if (__f.__f_ == 0)
      __f_ = 0;
    else if ((void *)__f.__f_ == &__f.__buf_) {
      __f_ = __as_base(&__buf_);
      __f.__f_->__clone(__f_);
    } else {
      __f_ = __f.__f_;
      __f.__f_ = 0;
    }
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) ~__value_func() {
    if ((void *)__f_ == &__buf_)
      __f_->destroy();
    else if (__f_)
      __f_->destroy_deallocate();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __value_func &
  operator=(__value_func &&__f) {
    *this = nullptr;
    if (__f.__f_ == 0)
      __f_ = 0;
    else if ((void *)__f.__f_ == &__f.__buf_) {
      __f_ = __as_base(&__buf_);
      __f.__f_->__clone(__f_);
    } else {
      __f_ = __f.__f_;
      __f.__f_ = 0;
    }
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __value_func &
  operator=(nullptr_t) {
    __func *__f = __f_;
    __f_ = 0;
    if ((void *)__f == &__buf_)
      __f->destroy();
    else if (__f)
      __f->destroy_deallocate();
    return *this;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Rp
  operator()(_ArgTypes &&...__args) const {
    if (__f_ == 0)
      __throw_bad_function_call();
    return (*__f_)(std::__1::forward<_ArgTypes>(__args)...);
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  swap(__value_func &__f) noexcept {
    if (&__f == this)
      return;
    if ((void *)__f_ == &__buf_ && (void *)__f.__f_ == &__f.__buf_) {
      typename aligned_storage<sizeof(__buf_)>::type __tempbuf;
      __func *__t = __as_base(&__tempbuf);
      __f_->__clone(__t);
      __f_->destroy();
      __f_ = 0;
      __f.__f_->__clone(__as_base(&__buf_));
      __f.__f_->destroy();
      __f.__f_ = 0;
      __f_ = __as_base(&__buf_);
      __t->__clone(__as_base(&__f.__buf_));
      __t->destroy();
      __f.__f_ = __as_base(&__f.__buf_);
    } else if ((void *)__f_ == &__buf_) {
      __f_->__clone(__as_base(&__f.__buf_));
      __f_->destroy();
      __f_ = __f.__f_;
      __f.__f_ = __as_base(&__f.__buf_);
    } else if ((void *)__f.__f_ == &__f.__buf_) {
      __f.__f_->__clone(__as_base(&__buf_));
      __f.__f_->destroy();
      __f.__f_ = __f_;
      __f_ = __as_base(&__buf_);
    } else
      std::__1::swap(__f_, __f.__f_);
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit
  operator bool() const noexcept {
    return __f_ != 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const std::type_info &
  target_type() const noexcept {
    if (__f_ == 0)
      return typeid(void);
    return __f_->target_type();
  }

  template <typename _Tp>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const _Tp *
  target() const noexcept {
    if (__f_ == 0)
      return 0;
    return (const _Tp *)__f_->target(typeid(_Tp));
  }
};

union __policy_storage {
  mutable char __small[sizeof(void *) * 2];
  void *__large;
};

template <typename _Fun>
struct __use_small_storage
    : public std::__1::integral_constant<
          bool, sizeof(_Fun) <= sizeof(__policy_storage) &&
                    alignof(_Fun) <= alignof(__policy_storage) &&
                    std::__1::is_trivially_copy_constructible<_Fun>::value &&
                    std::__1::is_trivially_destructible<_Fun>::value> {};

struct __policy {

  void *(*const __clone)(const void *);
  void (*const __destroy)(void *);

  const bool __is_null;

  const std::type_info *const __type_info;

  template <typename _Fun>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static const __policy *
  __create() {
    return __choose_policy<_Fun>(__use_small_storage<_Fun>());
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static const __policy *
  __create_empty() {
    static const constexpr __policy __policy_ = {nullptr, nullptr, true,

                                                 &typeid(void)

    };
    return &__policy_;
  }

private:
  template <typename _Fun> static void *__large_clone(const void *__s) {
    const _Fun *__f = static_cast<const _Fun *>(__s);
    return __f->__clone();
  }

  template <typename _Fun> static void __large_destroy(void *__s) {
    _Fun::__destroy_and_delete(static_cast<_Fun *>(__s));
  }

  template <typename _Fun>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static const __policy *
  __choose_policy(false_type) {
    static const constexpr __policy __policy_ = {&__large_clone<_Fun>,
                                                 &__large_destroy<_Fun>, false,

                                                 &typeid(typename _Fun::_Target)

    };
    return &__policy_;
  }

  template <typename _Fun>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static const __policy *
  __choose_policy(true_type) {
    static const constexpr __policy __policy_ = {nullptr, nullptr, false,

                                                 &typeid(typename _Fun::_Target)

    };
    return &__policy_;
  }
};

template <typename _Tp>
using __fast_forward =
    typename std::__1::conditional<std::__1::is_scalar<_Tp>::value, _Tp,
                                   _Tp &&>::type;

template <class _Fp> struct __policy_invoker;

template <class _Rp, class... _ArgTypes>
struct __policy_invoker<_Rp(_ArgTypes...)> {
  typedef _Rp (*__Call)(const __policy_storage *, __fast_forward<_ArgTypes>...);

  __Call __call_;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __policy_invoker()
      : __call_(&__call_empty) {}

  template <typename _Fun>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static __policy_invoker
  __create() {
    return __policy_invoker(&__call_impl<_Fun>);
  }

private:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit __policy_invoker(__Call __c)
      : __call_(__c) {}

  static _Rp __call_empty(const __policy_storage *,
                          __fast_forward<_ArgTypes>...) {
    __throw_bad_function_call();
  }

  template <typename _Fun>
  static _Rp __call_impl(const __policy_storage *__buf,
                         __fast_forward<_ArgTypes>... __args) {
    _Fun *__f = reinterpret_cast<_Fun *>(
        __use_small_storage<_Fun>::value ? &__buf->__small : __buf->__large);
    return (*__f)(std::__1::forward<_ArgTypes>(__args)...);
  }
};

template <class _Fp> class __policy_func;

template <class _Rp, class... _ArgTypes>
class __policy_func<_Rp(_ArgTypes...)> {

  __policy_storage __buf_;

  typedef __function::__policy_invoker<_Rp(_ArgTypes...)> __invoker;
  __invoker __invoker_;

  const __policy *__policy_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __policy_func()
      : __policy_(__policy::__create_empty()) {}

  template <class _Fp, class _Alloc>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __policy_func(_Fp &&__f, const _Alloc &__a)
      : __policy_(__policy::__create_empty()) {
    typedef __alloc_func<_Fp, _Alloc, _Rp(_ArgTypes...)> _Fun;
    typedef allocator_traits<_Alloc> __alloc_traits;
    typedef
        typename __rebind_alloc_helper<__alloc_traits, _Fun>::type _FunAlloc;

    if (__function::__not_null(__f)) {
      __invoker_ = __invoker::template __create<_Fun>();
      __policy_ = __policy::__create<_Fun>();

      _FunAlloc __af(__a);
      if (__use_small_storage<_Fun>()) {
        ::new ((void *)&__buf_.__small) _Fun(std::__1::move(__f), _Alloc(__af));
      } else {
        typedef __allocator_destructor<_FunAlloc> _Dp;
        unique_ptr<_Fun, _Dp> __hold(__af.allocate(1), _Dp(__af, 1));
        ::new ((void *)__hold.get()) _Fun(std::__1::move(__f), _Alloc(__af));
        __buf_.__large = __hold.release();
      }
    }
  }

  template <class _Fp,
            class = typename enable_if<!is_same<typename decay<_Fp>::type,
                                                __policy_func>::value>::type>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit __policy_func(_Fp &&__f)
      : __policy_(__policy::__create_empty()) {
    typedef __default_alloc_func<_Fp, _Rp(_ArgTypes...)> _Fun;

    if (__function::__not_null(__f)) {
      __invoker_ = __invoker::template __create<_Fun>();
      __policy_ = __policy::__create<_Fun>();
      if (__use_small_storage<_Fun>()) {
        ::new ((void *)&__buf_.__small) _Fun(std::__1::move(__f));
      } else {
        __builtin_new_allocator::__holder_t __hold =
            __builtin_new_allocator::__allocate_type<_Fun>(1);
        __buf_.__large = ::new (__hold.get()) _Fun(std::__1::move(__f));
        (void)__hold.release();
      }
    }
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __policy_func(const __policy_func &__f)
      : __buf_(__f.__buf_), __invoker_(__f.__invoker_),
        __policy_(__f.__policy_) {
    if (__policy_->__clone)
      __buf_.__large = __policy_->__clone(__f.__buf_.__large);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __policy_func(__policy_func &&__f)
      : __buf_(__f.__buf_), __invoker_(__f.__invoker_),
        __policy_(__f.__policy_) {
    if (__policy_->__destroy) {
      __f.__policy_ = __policy::__create_empty();
      __f.__invoker_ = __invoker();
    }
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) ~__policy_func() {
    if (__policy_->__destroy)
      __policy_->__destroy(__buf_.__large);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __policy_func &
  operator=(__policy_func &&__f) {
    *this = nullptr;
    __buf_ = __f.__buf_;
    __invoker_ = __f.__invoker_;
    __policy_ = __f.__policy_;
    __f.__policy_ = __policy::__create_empty();
    __f.__invoker_ = __invoker();
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __policy_func &
  operator=(nullptr_t) {
    const __policy *__p = __policy_;
    __policy_ = __policy::__create_empty();
    __invoker_ = __invoker();
    if (__p->__destroy)
      __p->__destroy(__buf_.__large);
    return *this;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) _Rp
  operator()(_ArgTypes &&...__args) const {
    return __invoker_.__call_(std::__1::addressof(__buf_),
                              std::__1::forward<_ArgTypes>(__args)...);
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  swap(__policy_func &__f) {
    std::__1::swap(__invoker_, __f.__invoker_);
    std::__1::swap(__policy_, __f.__policy_);
    std::__1::swap(__buf_, __f.__buf_);
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit
  operator bool() const noexcept {
    return !__policy_->__is_null;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const std::type_info &
  target_type() const noexcept {
    return *__policy_->__type_info;
  }

  template <typename _Tp>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const _Tp *
  target() const noexcept {
    if (__policy_->__is_null || typeid(_Tp) != *__policy_->__type_info)
      return nullptr;
    if (__policy_->__clone)
      return reinterpret_cast<const _Tp *>(__buf_.__large);
    else
      return reinterpret_cast<const _Tp *>(&__buf_.__small);
  }
};

extern "C" void *_Block_copy(const void *);
extern "C" void _Block_release(const void *);

template <class _Rp1, class... _ArgTypes1, class _Alloc, class _Rp,
          class... _ArgTypes>
class __func<_Rp1 (^)(_ArgTypes1...), _Alloc, _Rp(_ArgTypes...)>
    : public __base<_Rp(_ArgTypes...)> {
  typedef _Rp1 (^__block_type)(_ArgTypes1...);
  __block_type __f_;

public:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit __func(__block_type const &__f)
      : __f_(reinterpret_cast<__block_type>(__f ? _Block_copy(__f) : nullptr)) {
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit __func(__block_type __f,
                                                    const _Alloc &)
      : __f_(reinterpret_cast<__block_type>(__f ? _Block_copy(__f) : nullptr)) {
  }

  virtual __base<_Rp(_ArgTypes...)> *__clone() const {
    ((void)0);

    return nullptr;
  }

  virtual void __clone(__base<_Rp(_ArgTypes...)> *__p) const {
    ::new (__p) __func(__f_);
  }

  virtual void destroy() noexcept {
    if (__f_)
      _Block_release(__f_);
    __f_ = 0;
  }

  virtual void destroy_deallocate() noexcept { ((void)0); }

  virtual _Rp operator()(_ArgTypes &&...__arg) {
    return __invoke(__f_, std::__1::forward<_ArgTypes>(__arg)...);
  }

  virtual const void *target(type_info const &__ti) const noexcept {
    if (__ti == typeid(__func::__block_type))
      return &__f_;
    return (const void *)nullptr;
  }

  virtual const std::type_info &target_type() const noexcept {
    return typeid(__func::__block_type);
  }
};

} // namespace __function

template <class _Rp, class... _ArgTypes>
class __attribute__((__type_visibility__("default")))
function<_Rp(_ArgTypes...)>
    : public __function::__maybe_derive_from_unary_function<_Rp(_ArgTypes...)>,
      public __function::__maybe_derive_from_binary_function<_Rp(
          _ArgTypes...)> {

  typedef __function::__value_func<_Rp(_ArgTypes...)> __func;

  __func __f_;

  template <class _Fp, bool = _And<_IsNotSame<__uncvref_t<_Fp>, function>,
                                   __invokable<_Fp &, _ArgTypes...>>::value>
  struct __callable;
  template <class _Fp> struct __callable<_Fp, true> {
    static const bool value =
        is_same<void, _Rp>::value ||
        is_convertible<typename __invoke_of<_Fp &, _ArgTypes...>::type,
                       _Rp>::value;
  };
  template <class _Fp> struct __callable<_Fp, false> {
    static const bool value = false;
  };

  template <class _Fp>
  using _EnableIfCallable = typename enable_if<__callable<_Fp>::value>::type;

public:
  typedef _Rp result_type;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  function() noexcept {}
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  function(nullptr_t) noexcept {}
  function(const function &);
  function(function &&) noexcept;
  template <class _Fp, class = _EnableIfCallable<_Fp>> function(_Fp);

  template <class _Alloc>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  function(allocator_arg_t, const _Alloc &) noexcept {}
  template <class _Alloc>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  function(allocator_arg_t, const _Alloc &, nullptr_t) noexcept {}
  template <class _Alloc>
  function(allocator_arg_t, const _Alloc &, const function &);
  template <class _Alloc>
  function(allocator_arg_t, const _Alloc &, function &&);
  template <class _Fp, class _Alloc, class = _EnableIfCallable<_Fp>>
  function(allocator_arg_t, const _Alloc &__a, _Fp __f);

  function &operator=(const function &);
  function &operator=(function &&) noexcept;
  function &operator=(nullptr_t) noexcept;
  template <class _Fp, class = _EnableIfCallable<_Fp>>
  function &operator=(_Fp &&);

  ~function();

  void swap(function &) noexcept;

  template <class _Fp, class _Alloc>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  assign(_Fp &&__f, const _Alloc &__a) {
    function(allocator_arg, __a, std::__1::forward<_Fp>(__f)).swap(*this);
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit
  operator bool() const noexcept {
    return static_cast<bool>(__f_);
  }

  template <class _R2, class... _ArgTypes2>
  bool operator==(const function<_R2(_ArgTypes2...)> &) const = delete;
  template <class _R2, class... _ArgTypes2>
  bool operator!=(const function<_R2(_ArgTypes2...)> &) const = delete;

public:
  _Rp operator()(_ArgTypes...) const;

  const std::type_info &target_type() const noexcept;
  template <typename _Tp> _Tp *target() noexcept;
  template <typename _Tp> const _Tp *target() const noexcept;
};
# 2467 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
template <class _Rp, class... _ArgTypes>
function<_Rp(_ArgTypes...)>::function(const function &__f) : __f_(__f.__f_) {}

template <class _Rp, class... _ArgTypes>
template <class _Alloc>
function<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc &,
                                      const function &__f)
    : __f_(__f.__f_) {}

template <class _Rp, class... _ArgTypes>
function<_Rp(_ArgTypes...)>::function(function &&__f) noexcept
    : __f_(std::__1::move(__f.__f_)) {}

template <class _Rp, class... _ArgTypes>
template <class _Alloc>
function<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc &,
                                      function &&__f)
    : __f_(std::__1::move(__f.__f_)) {}

template <class _Rp, class... _ArgTypes>
template <class _Fp, class>
function<_Rp(_ArgTypes...)>::function(_Fp __f) : __f_(std::__1::move(__f)) {}

template <class _Rp, class... _ArgTypes>
template <class _Fp, class _Alloc, class>
function<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc &__a,
                                      _Fp __f)
    : __f_(std::__1::move(__f), __a) {}

template <class _Rp, class... _ArgTypes>
function<_Rp(_ArgTypes...)> &
function<_Rp(_ArgTypes...)>::operator=(const function &__f) {
  function(__f).swap(*this);
  return *this;
}

template <class _Rp, class... _ArgTypes>
function<_Rp(_ArgTypes...)> &
function<_Rp(_ArgTypes...)>::operator=(function &&__f) noexcept {
  __f_ = std::move(__f.__f_);
  return *this;
}

template <class _Rp, class... _ArgTypes>
function<_Rp(_ArgTypes...)> &
function<_Rp(_ArgTypes...)>::operator=(nullptr_t) noexcept {
  __f_ = nullptr;
  return *this;
}

template <class _Rp, class... _ArgTypes>
template <class _Fp, class>
function<_Rp(_ArgTypes...)> &function<_Rp(_ArgTypes...)>::operator=(_Fp &&__f) {
  function(std::__1::forward<_Fp>(__f)).swap(*this);
  return *this;
}

template <class _Rp, class... _ArgTypes>
function<_Rp(_ArgTypes...)>::~function() {}

template <class _Rp, class... _ArgTypes>
void function<_Rp(_ArgTypes...)>::swap(function &__f) noexcept {
  __f_.swap(__f.__f_);
}

template <class _Rp, class... _ArgTypes>
_Rp function<_Rp(_ArgTypes...)>::operator()(_ArgTypes... __arg) const {
  return __f_(std::__1::forward<_ArgTypes>(__arg)...);
}

template <class _Rp, class... _ArgTypes>
const std::type_info &
function<_Rp(_ArgTypes...)>::target_type() const noexcept {
  return __f_.target_type();
}

template <class _Rp, class... _ArgTypes>
template <typename _Tp>
_Tp *function<_Rp(_ArgTypes...)>::target() noexcept {
  return (_Tp *)(__f_.template target<_Tp>());
}

template <class _Rp, class... _ArgTypes>
template <typename _Tp>
const _Tp *function<_Rp(_ArgTypes...)>::target() const noexcept {
  return __f_.template target<_Tp>();
}

template <class _Rp, class... _ArgTypes>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator==(const function<_Rp(_ArgTypes...)> &__f, nullptr_t) noexcept {
  return !__f;
}

template <class _Rp, class... _ArgTypes>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator==(nullptr_t, const function<_Rp(_ArgTypes...)> &__f) noexcept {
  return !__f;
}

template <class _Rp, class... _ArgTypes>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator!=(const function<_Rp(_ArgTypes...)> &__f, nullptr_t) noexcept {
  return (bool)__f;
}

template <class _Rp, class... _ArgTypes>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator!=(nullptr_t, const function<_Rp(_ArgTypes...)> &__f) noexcept {
  return (bool)__f;
}

template <class _Rp, class... _ArgTypes>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
swap(function<_Rp(_ArgTypes...)> &__x,
     function<_Rp(_ArgTypes...)> &__y) noexcept {
  return __x.swap(__y);
}
# 2614 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
template <class _Tp> struct __is_bind_expression : public false_type {};
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_bind_expression
    : public __is_bind_expression<typename remove_cv<_Tp>::type> {};

template <class _Tp>
struct __is_placeholder : public integral_constant<int, 0> {};
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_placeholder
    : public __is_placeholder<typename remove_cv<_Tp>::type> {};

namespace placeholders {

template <int _Np> struct __ph {};
# 2649 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
constexpr __ph<1> _1{};
constexpr __ph<2> _2{};
constexpr __ph<3> _3{};
constexpr __ph<4> _4{};
constexpr __ph<5> _5{};
constexpr __ph<6> _6{};
constexpr __ph<7> _7{};
constexpr __ph<8> _8{};
constexpr __ph<9> _9{};
constexpr __ph<10> _10{};

} // namespace placeholders

template <int _Np>
struct __is_placeholder<placeholders::__ph<_Np>>
    : public integral_constant<int, _Np> {};

template <class _Tp, class _Uj>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _Tp &
__mu(reference_wrapper<_Tp> __t, _Uj &) {
  return __t.get();
}

template <class _Ti, class... _Uj, size_t... _Indx>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) typename __invoke_of<_Ti &, _Uj...>::type
__mu_expand(_Ti &__ti, tuple<_Uj...> &__uj, __tuple_indices<_Indx...>) {
  return __ti(std::__1::forward<_Uj>(std::__1::get<_Indx>(__uj))...);
}

template <class _Ti, class... _Uj>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename _EnableIf<is_bind_expression<_Ti>::value,
                   __invoke_of<_Ti &, _Uj...>>::type
__mu(_Ti &__ti, tuple<_Uj...> &__uj) {
  typedef typename __make_tuple_indices<sizeof...(_Uj)>::type __indices;
  return __mu_expand(__ti, __uj, __indices());
}

template <bool IsPh, class _Ti, class _Uj> struct __mu_return2 {};

template <class _Ti, class _Uj> struct __mu_return2<true, _Ti, _Uj> {
  typedef
      typename tuple_element<is_placeholder<_Ti>::value - 1, _Uj>::type type;
};

template <class _Ti, class _Uj>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) typename enable_if<
    0 < is_placeholder<_Ti>::value,
    typename __mu_return2<0 < is_placeholder<_Ti>::value, _Ti, _Uj>::type>::type
__mu(_Ti &, _Uj &__uj) {
  const size_t _Indx = is_placeholder<_Ti>::value - 1;
  return std::__1::forward<typename tuple_element<_Indx, _Uj>::type>(
      std::__1::get<_Indx>(__uj));
}

template <class _Ti, class _Uj>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename enable_if<!is_bind_expression<_Ti>::value &&
                       is_placeholder<_Ti>::value == 0 &&
                       !__is_reference_wrapper<_Ti>::value,
                   _Ti &>::type
__mu(_Ti &__ti, _Uj &) {
  return __ti;
}

template <class _Ti, bool IsReferenceWrapper, bool IsBindEx, bool IsPh,
          class _TupleUj>
struct __mu_return_impl;

template <bool _Invokable, class _Ti, class... _Uj>
struct __mu_return_invokable {
  typedef __nat type;
};

template <class _Ti, class... _Uj>
struct __mu_return_invokable<true, _Ti, _Uj...> {
  typedef typename __invoke_of<_Ti &, _Uj...>::type type;
};

template <class _Ti, class... _Uj>
struct __mu_return_impl<_Ti, false, true, false, tuple<_Uj...>>
    : public __mu_return_invokable<__invokable<_Ti &, _Uj...>::value, _Ti,
                                   _Uj...> {};

template <class _Ti, class _TupleUj>
struct __mu_return_impl<_Ti, false, false, true, _TupleUj> {
  typedef typename tuple_element<is_placeholder<_Ti>::value - 1, _TupleUj>::type
      &&type;
};

template <class _Ti, class _TupleUj>
struct __mu_return_impl<_Ti, true, false, false, _TupleUj> {
  typedef typename _Ti::type &type;
};

template <class _Ti, class _TupleUj>
struct __mu_return_impl<_Ti, false, false, false, _TupleUj> {
  typedef _Ti &type;
};

template <class _Ti, class _TupleUj>
struct __mu_return
    : public __mu_return_impl<_Ti, __is_reference_wrapper<_Ti>::value,
                              is_bind_expression<_Ti>::value,
                              0 < is_placeholder<_Ti>::value &&
                                  is_placeholder<_Ti>::value <=
                                      tuple_size<_TupleUj>::value,
                              _TupleUj> {};

template <class _Fp, class _BoundArgs, class _TupleUj>
struct __is_valid_bind_return {
  static const bool value = false;
};

template <class _Fp, class... _BoundArgs, class _TupleUj>
struct __is_valid_bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj> {
  static const bool value =
      __invokable<_Fp,
                  typename __mu_return<_BoundArgs, _TupleUj>::type...>::value;
};

template <class _Fp, class... _BoundArgs, class _TupleUj>
struct __is_valid_bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj> {
  static const bool value = __invokable<
      _Fp, typename __mu_return<const _BoundArgs, _TupleUj>::type...>::value;
};

template <class _Fp, class _BoundArgs, class _TupleUj,
          bool = __is_valid_bind_return<_Fp, _BoundArgs, _TupleUj>::value>
struct __bind_return;

template <class _Fp, class... _BoundArgs, class _TupleUj>
struct __bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj, true> {
  typedef typename __invoke_of<
      _Fp &, typename __mu_return<_BoundArgs, _TupleUj>::type...>::type type;
};

template <class _Fp, class... _BoundArgs, class _TupleUj>
struct __bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj, true> {
  typedef typename __invoke_of<
      _Fp &, typename __mu_return<const _BoundArgs, _TupleUj>::type...>::type
      type;
};

template <class _Fp, class _BoundArgs, size_t... _Indx, class _Args>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename __bind_return<_Fp, _BoundArgs, _Args>::type
__apply_functor(_Fp &__f, _BoundArgs &__bound_args, __tuple_indices<_Indx...>,
                _Args &&__args) {
  return std::__1::__invoke(
      __f, std::__1::__mu(std::__1::get<_Indx>(__bound_args), __args)...);
}

template <class _Fp, class... _BoundArgs>
class __bind : public __weak_result_type<typename decay<_Fp>::type> {
protected:
  typedef typename decay<_Fp>::type _Fd;
  typedef tuple<typename decay<_BoundArgs>::type...> _Td;

private:
  _Fd __f_;
  _Td __bound_args_;

  typedef typename __make_tuple_indices<sizeof...(_BoundArgs)>::type __indices;

public:
  template <
      class _Gp, class... _BA,
      class = typename enable_if<
          is_constructible<_Fd, _Gp>::value &&
          !is_same<typename remove_reference<_Gp>::type, __bind>::value>::type>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit __bind(_Gp &&__f,
                                                    _BA &&...__bound_args)
      : __f_(std::__1::forward<_Gp>(__f)),
        __bound_args_(std::__1::forward<_BA>(__bound_args)...) {}

  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename __bind_return<_Fd, _Td, tuple<_Args &&...>>::type
  operator()(_Args &&...__args) {
    return std::__1::__apply_functor(
        __f_, __bound_args_, __indices(),
        tuple<_Args &&...>(std::__1::forward<_Args>(__args)...));
  }

  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename __bind_return<const _Fd, const _Td, tuple<_Args &&...>>::type
  operator()(_Args &&...__args) const {
    return std::__1::__apply_functor(
        __f_, __bound_args_, __indices(),
        tuple<_Args &&...>(std::__1::forward<_Args>(__args)...));
  }
};

template <class _Fp, class... _BoundArgs>
struct __is_bind_expression<__bind<_Fp, _BoundArgs...>> : public true_type {};

template <class _Rp, class _Fp, class... _BoundArgs>
class __bind_r : public __bind<_Fp, _BoundArgs...> {
  typedef __bind<_Fp, _BoundArgs...> base;
  typedef typename base::_Fd _Fd;
  typedef typename base::_Td _Td;

public:
  typedef _Rp result_type;

  template <
      class _Gp, class... _BA,
      class = typename enable_if<is_constructible<_Fd, _Gp>::value &&
                                 !is_same<typename remove_reference<_Gp>::type,
                                          __bind_r>::value>::type>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit __bind_r(_Gp &&__f,
                                                      _BA &&...__bound_args)
      : base(std::__1::forward<_Gp>(__f),
             std::__1::forward<_BA>(__bound_args)...) {}

  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename enable_if<
      is_convertible<typename __bind_return<_Fd, _Td, tuple<_Args &&...>>::type,
                     result_type>::value ||
          is_void<_Rp>::value,
      result_type>::type
  operator()(_Args &&...__args) {
    typedef __invoke_void_return_wrapper<_Rp> _Invoker;
    return _Invoker::__call(static_cast<base &>(*this),
                            std::__1::forward<_Args>(__args)...);
  }

  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename enable_if<
      is_convertible<typename __bind_return<const _Fd, const _Td,
                                            tuple<_Args &&...>>::type,
                     result_type>::value ||
          is_void<_Rp>::value,
      result_type>::type
  operator()(_Args &&...__args) const {
    typedef __invoke_void_return_wrapper<_Rp> _Invoker;
    return _Invoker::__call(static_cast<base const &>(*this),
                            std::__1::forward<_Args>(__args)...);
  }
};

template <class _Rp, class _Fp, class... _BoundArgs>
struct __is_bind_expression<__bind_r<_Rp, _Fp, _BoundArgs...>>
    : public true_type {};

template <class _Fp, class... _BoundArgs>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) __bind<_Fp, _BoundArgs...>
bind(_Fp &&__f, _BoundArgs &&...__bound_args) {
  typedef __bind<_Fp, _BoundArgs...> type;
  return type(std::__1::forward<_Fp>(__f),
              std::__1::forward<_BoundArgs>(__bound_args)...);
}

template <class _Rp, class _Fp, class... _BoundArgs>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) __bind_r<_Rp, _Fp, _BoundArgs...>
bind(_Fp &&__f, _BoundArgs &&...__bound_args) {
  typedef __bind_r<_Rp, _Fp, _BoundArgs...> type;
  return type(std::__1::forward<_Fp>(__f),
              std::__1::forward<_BoundArgs>(__bound_args)...);
}
# 3038 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
template <class _BinaryPredicate, class _ForwardIterator1,
          class _ForwardIterator2>
pair<_ForwardIterator1, _ForwardIterator1> constexpr __search(
    _ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _BinaryPredicate __pred, forward_iterator_tag, forward_iterator_tag) {
  if (__first2 == __last2)
    return make_pair(__first1, __first1);
  while (true) {

    while (true) {
      if (__first1 == __last1)
        return make_pair(__last1, __last1);
      if (__pred(*__first1, *__first2))
        break;
      ++__first1;
    }

    _ForwardIterator1 __m1 = __first1;
    _ForwardIterator2 __m2 = __first2;
    while (true) {
      if (++__m2 == __last2)
        return make_pair(__first1, __m1);
      if (++__m1 == __last1)
        return make_pair(__last1, __last1);
      if (!__pred(*__m1, *__m2)) {
        ++__first1;
        break;
      }
    }
  }
}

template <class _BinaryPredicate, class _RandomAccessIterator1,
          class _RandomAccessIterator2>
constexpr pair<_RandomAccessIterator1, _RandomAccessIterator1>
__search(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,
         _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2,
         _BinaryPredicate __pred, random_access_iterator_tag,
         random_access_iterator_tag) {
  typedef typename iterator_traits<_RandomAccessIterator1>::difference_type _D1;
  typedef typename iterator_traits<_RandomAccessIterator2>::difference_type _D2;

  const _D2 __len2 = __last2 - __first2;
  if (__len2 == 0)
    return make_pair(__first1, __first1);
  const _D1 __len1 = __last1 - __first1;
  if (__len1 < __len2)
    return make_pair(__last1, __last1);
  const _RandomAccessIterator1 __s = __last1 - (__len2 - 1);

  while (true) {
    while (true) {
      if (__first1 == __s)
        return make_pair(__last1, __last1);
      if (__pred(*__first1, *__first2))
        break;
      ++__first1;
    }

    _RandomAccessIterator1 __m1 = __first1;
    _RandomAccessIterator2 __m2 = __first2;
    while (true) {
      if (++__m2 == __last2)
        return make_pair(__first1, __first1 + __len2);
      ++__m1;
      if (!__pred(*__m1, *__m2)) {
        ++__first1;
        break;
      }
    }
  }
}
# 3157 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional" 3
template <class _Container, class _Predicate>
inline void __libcpp_erase_if_container(_Container &__c, _Predicate __pred) {
  for (typename _Container::iterator __iter = __c.begin(), __last = __c.end();
       __iter != __last;) {
    if (__pred(*__iter))
      __iter = __c.erase(__iter);
    else
      ++__iter;
  }
}

} // namespace __1
} // namespace std
# 645 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 2 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/bit" 1 3
# 56 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/bit" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 57 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/bit" 2 3
# 71 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/bit" 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_macros" 1 3
# 75 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/bit" 2 3

namespace std {
inline namespace __1 {

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr int
__libcpp_ctz(unsigned __x) noexcept {
  return __builtin_ctz(__x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr int
__libcpp_ctz(unsigned long __x) noexcept {
  return __builtin_ctzl(__x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr int
__libcpp_ctz(unsigned long long __x) noexcept {
  return __builtin_ctzll(__x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr int
__libcpp_clz(unsigned __x) noexcept {
  return __builtin_clz(__x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr int
__libcpp_clz(unsigned long __x) noexcept {
  return __builtin_clzl(__x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr int
__libcpp_clz(unsigned long long __x) noexcept {
  return __builtin_clzll(__x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr int
__libcpp_popcount(unsigned __x) noexcept {
  return __builtin_popcount(__x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr int
__libcpp_popcount(unsigned long __x) noexcept {
  return __builtin_popcountl(__x);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr int
__libcpp_popcount(unsigned long long __x) noexcept {
  return __builtin_popcountll(__x);
}
# 195 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/bit" 3
template <class _Tp>
using __bitop_unsigned_integer = integral_constant<
    bool, is_integral<_Tp>::value && is_unsigned<_Tp>::value &&
              _IsNotSame<typename remove_cv<_Tp>::type, bool>::value &&
              _IsNotSame<typename remove_cv<_Tp>::type, signed char>::value &&
              _IsNotSame<typename remove_cv<_Tp>::type, wchar_t>::value &&
              _IsNotSame<typename remove_cv<_Tp>::type, char16_t>::value &&
              _IsNotSame<typename remove_cv<_Tp>::type, char32_t>::value>;

template <class _Tp>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr _Tp
__rotl(_Tp __t, unsigned int __cnt) noexcept {
  static_assert(__bitop_unsigned_integer<_Tp>::value,
                "__rotl requires unsigned");
  const unsigned int __dig = numeric_limits<_Tp>::digits;
  if ((__cnt % __dig) == 0)
    return __t;
  return (__t << (__cnt % __dig)) | (__t >> (__dig - (__cnt % __dig)));
}

template <class _Tp>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr _Tp
__rotr(_Tp __t, unsigned int __cnt) noexcept {
  static_assert(__bitop_unsigned_integer<_Tp>::value,
                "__rotr requires unsigned");
  const unsigned int __dig = numeric_limits<_Tp>::digits;
  if ((__cnt % __dig) == 0)
    return __t;
  return (__t >> (__cnt % __dig)) | (__t << (__dig - (__cnt % __dig)));
}

template <class _Tp>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr int
__countr_zero(_Tp __t) noexcept {
  static_assert(__bitop_unsigned_integer<_Tp>::value,
                "__countr_zero requires unsigned");
  if (__t == 0)
    return numeric_limits<_Tp>::digits;

  if (sizeof(_Tp) <= sizeof(unsigned int))
    return __libcpp_ctz(static_cast<unsigned int>(__t));
  else if (sizeof(_Tp) <= sizeof(unsigned long))
    return __libcpp_ctz(static_cast<unsigned long>(__t));
  else if (sizeof(_Tp) <= sizeof(unsigned long long))
    return __libcpp_ctz(static_cast<unsigned long long>(__t));
  else {
    int __ret = 0;
    int __iter = 0;
    const unsigned int __ulldigits = numeric_limits<unsigned long long>::digits;
    while ((__iter = __libcpp_ctz(static_cast<unsigned long long>(__t))) ==
           __ulldigits) {
      __ret += __iter;
      __t >>= __ulldigits;
    }
    return __ret + __iter;
  }
}

template <class _Tp>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr int
__countl_zero(_Tp __t) noexcept {
  static_assert(__bitop_unsigned_integer<_Tp>::value,
                "__countl_zero requires unsigned");
  if (__t == 0)
    return numeric_limits<_Tp>::digits;

  if (sizeof(_Tp) <= sizeof(unsigned int))
    return __libcpp_clz(static_cast<unsigned int>(__t)) -
           (numeric_limits<unsigned int>::digits - numeric_limits<_Tp>::digits);
  else if (sizeof(_Tp) <= sizeof(unsigned long))
    return __libcpp_clz(static_cast<unsigned long>(__t)) -
           (numeric_limits<unsigned long>::digits -
            numeric_limits<_Tp>::digits);
  else if (sizeof(_Tp) <= sizeof(unsigned long long))
    return __libcpp_clz(static_cast<unsigned long long>(__t)) -
           (numeric_limits<unsigned long long>::digits -
            numeric_limits<_Tp>::digits);
  else {
    int __ret = 0;
    int __iter = 0;
    const unsigned int __ulldigits = numeric_limits<unsigned long long>::digits;
    while (true) {
      __t = __rotr(__t, __ulldigits);
      if ((__iter = __countl_zero(static_cast<unsigned long long>(__t))) !=
          __ulldigits)
        break;
      __ret += __iter;
    }
    return __ret + __iter;
  }
}

template <class _Tp>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr int
__countl_one(_Tp __t) noexcept {
  static_assert(__bitop_unsigned_integer<_Tp>::value,
                "__countl_one requires unsigned");
  return __t != numeric_limits<_Tp>::max()
             ? __countl_zero(static_cast<_Tp>(~__t))
             : numeric_limits<_Tp>::digits;
}

template <class _Tp>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr int
__countr_one(_Tp __t) noexcept {
  static_assert(__bitop_unsigned_integer<_Tp>::value,
                "__countr_one requires unsigned");
  return __t != numeric_limits<_Tp>::max()
             ? __countr_zero(static_cast<_Tp>(~__t))
             : numeric_limits<_Tp>::digits;
}

template <class _Tp>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr int
__popcount(_Tp __t) noexcept {
  static_assert(__bitop_unsigned_integer<_Tp>::value,
                "__libcpp_popcount requires unsigned");
  if (sizeof(_Tp) <= sizeof(unsigned int))
    return __libcpp_popcount(static_cast<unsigned int>(__t));
  else if (sizeof(_Tp) <= sizeof(unsigned long))
    return __libcpp_popcount(static_cast<unsigned long>(__t));
  else if (sizeof(_Tp) <= sizeof(unsigned long long))
    return __libcpp_popcount(static_cast<unsigned long long>(__t));
  else {
    int __ret = 0;
    while (__t != 0) {
      __ret += __libcpp_popcount(static_cast<unsigned long long>(__t));
      __t >>= numeric_limits<unsigned long long>::digits;
    }
    return __ret;
  }
}

template <class _Tp>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr unsigned
__bit_log2(_Tp __t) noexcept {
  static_assert(__bitop_unsigned_integer<_Tp>::value,
                "__bit_log2 requires unsigned");
  return std::numeric_limits<_Tp>::digits - 1 - __countl_zero(__t);
}

template <class _Tp>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr bool
__ispow2(_Tp __t) noexcept {
  static_assert(__bitop_unsigned_integer<_Tp>::value,
                "__ispow2 requires unsigned");
  return __t != 0 && (((__t & (__t - 1)) == 0));
}
# 482 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/bit" 3
} // namespace __1
} // namespace std
# 648 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 2 3
# 654 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_macros" 1 3
# 658 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 2 3

namespace std {
inline namespace __1 {

template <class _T1, class _T2 = _T1> struct __equal_to {
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr bool
  operator()(const _T1 &__x, const _T1 &__y) const {
    return __x == __y;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr bool
  operator()(const _T1 &__x, const _T2 &__y) const {
    return __x == __y;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr bool
  operator()(const _T2 &__x, const _T1 &__y) const {
    return __x == __y;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr bool
  operator()(const _T2 &__x, const _T2 &__y) const {
    return __x == __y;
  }
};

template <class _T1> struct __equal_to<_T1, _T1> {
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr bool
  operator()(const _T1 &__x, const _T1 &__y) const {
    return __x == __y;
  }
};

template <class _T1> struct __equal_to<const _T1, _T1> {
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr bool
  operator()(const _T1 &__x, const _T1 &__y) const {
    return __x == __y;
  }
};

template <class _T1> struct __equal_to<_T1, const _T1> {
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr bool
  operator()(const _T1 &__x, const _T1 &__y) const {
    return __x == __y;
  }
};

template <class _T1, class _T2 = _T1> struct __less {
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr bool
  operator()(const _T1 &__x, const _T1 &__y) const {
    return __x < __y;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr bool
  operator()(const _T1 &__x, const _T2 &__y) const {
    return __x < __y;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr bool
  operator()(const _T2 &__x, const _T1 &__y) const {
    return __x < __y;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr bool
  operator()(const _T2 &__x, const _T2 &__y) const {
    return __x < __y;
  }
};

template <class _T1> struct __less<_T1, _T1> {
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr bool
  operator()(const _T1 &__x, const _T1 &__y) const {
    return __x < __y;
  }
};

template <class _T1> struct __less<const _T1, _T1> {
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr bool
  operator()(const _T1 &__x, const _T1 &__y) const {
    return __x < __y;
  }
};

template <class _T1> struct __less<_T1, const _T1> {
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr bool
  operator()(const _T1 &__x, const _T1 &__y) const {
    return __x < __y;
  }
};

template <class _Predicate> class __invert {
private:
  _Predicate __p_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __invert() {}

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit __invert(_Predicate __p)
      : __p_(__p) {}

  template <class _T1>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator()(const _T1 &__x) {
    return !__p_(__x);
  }

  template <class _T1, class _T2>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator()(const _T1 &__x, const _T2 &__y) {
    return __p_(__y, __x);
  }
};

template <typename _Integral>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr
    typename enable_if<is_integral<_Integral>::value, _Integral>::type
    __half_positive(_Integral __value) {
  return static_cast<_Integral>(
      static_cast<typename make_unsigned<_Integral>::type>(__value) / 2);
}

template <typename _Tp>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr
    typename enable_if<!is_integral<_Tp>::value, _Tp>::type
    __half_positive(_Tp __value) {
  return __value / 2;
}
# 825 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 3
template <class _Comp> struct __comp_ref_type {

  typedef typename add_lvalue_reference<_Comp>::type type;
};

template <class _InputIterator, class _Predicate>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
  for (; __first != __last; ++__first)
    if (!__pred(*__first))
      return false;
  return true;
}

template <class _InputIterator, class _Predicate>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
  for (; __first != __last; ++__first)
    if (__pred(*__first))
      return true;
  return false;
}

template <class _InputIterator, class _Predicate>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
  for (; __first != __last; ++__first)
    if (__pred(*__first))
      return false;
  return true;
}

template <class _InputIterator, class _Function>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _Function
for_each(_InputIterator __first, _InputIterator __last, _Function __f) {
  for (; __first != __last; ++__first)
    __f(*__first);
  return __f;
}
# 912 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 3
template <class _InputIterator, class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _InputIterator
find(_InputIterator __first, _InputIterator __last, const _Tp &__value_) {
  for (; __first != __last; ++__first)
    if (*__first == __value_)
      break;
  return __first;
}

template <class _InputIterator, class _Predicate>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _InputIterator
find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
  for (; __first != __last; ++__first)
    if (__pred(*__first))
      break;
  return __first;
}

template <class _InputIterator, class _Predicate>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _InputIterator
find_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
  for (; __first != __last; ++__first)
    if (!__pred(*__first))
      break;
  return __first;
}

template <class _BinaryPredicate, class _ForwardIterator1,
          class _ForwardIterator2>
_ForwardIterator1 __find_end(_ForwardIterator1 __first1,
                             _ForwardIterator1 __last1,
                             _ForwardIterator2 __first2,
                             _ForwardIterator2 __last2, _BinaryPredicate __pred,
                             forward_iterator_tag, forward_iterator_tag) {

  _ForwardIterator1 __r = __last1;
  if (__first2 == __last2)
    return __r;
  while (true) {
    while (true) {
      if (__first1 == __last1)
        return __r;
      if (__pred(*__first1, *__first2))
        break;
      ++__first1;
    }

    _ForwardIterator1 __m1 = __first1;
    _ForwardIterator2 __m2 = __first2;
    while (true) {
      if (++__m2 == __last2) {
        __r = __first1;
        ++__first1;
        break;
      }
      if (++__m1 == __last1)
        return __r;
      if (!__pred(*__m1, *__m2)) {
        ++__first1;
        break;
      }
    }
  }
}

template <class _BinaryPredicate, class _BidirectionalIterator1,
          class _BidirectionalIterator2>
_BidirectionalIterator1
__find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1,
           _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2,
           _BinaryPredicate __pred, bidirectional_iterator_tag,
           bidirectional_iterator_tag) {

  if (__first2 == __last2)
    return __last1;
  _BidirectionalIterator1 __l1 = __last1;
  _BidirectionalIterator2 __l2 = __last2;
  --__l2;
  while (true) {

    while (true) {
      if (__first1 == __l1)
        return __last1;
      if (__pred(*--__l1, *__l2))
        break;
    }

    _BidirectionalIterator1 __m1 = __l1;
    _BidirectionalIterator2 __m2 = __l2;
    while (true) {
      if (__m2 == __first2)
        return __m1;
      if (__m1 == __first1)
        return __last1;
      if (!__pred(*--__m1, *--__m2)) {
        break;
      }
    }
  }
}

template <class _BinaryPredicate, class _RandomAccessIterator1,
          class _RandomAccessIterator2>
constexpr _RandomAccessIterator1
__find_end(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,
           _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2,
           _BinaryPredicate __pred, random_access_iterator_tag,
           random_access_iterator_tag) {

  typename iterator_traits<_RandomAccessIterator2>::difference_type __len2 =
      __last2 - __first2;
  if (__len2 == 0)
    return __last1;
  typename iterator_traits<_RandomAccessIterator1>::difference_type __len1 =
      __last1 - __first1;
  if (__len1 < __len2)
    return __last1;
  const _RandomAccessIterator1 __s = __first1 + (__len2 - 1);
  _RandomAccessIterator1 __l1 = __last1;
  _RandomAccessIterator2 __l2 = __last2;
  --__l2;
  while (true) {
    while (true) {
      if (__s == __l1)
        return __last1;
      if (__pred(*--__l1, *__l2))
        break;
    }
    _RandomAccessIterator1 __m1 = __l1;
    _RandomAccessIterator2 __m2 = __l2;
    while (true) {
      if (__m2 == __first2)
        return __m1;

      if (!__pred(*--__m1, *--__m2)) {
        break;
      }
    }
  }
}

template <class _ForwardIterator1, class _ForwardIterator2,
          class _BinaryPredicate>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _ForwardIterator1
find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
         _ForwardIterator2 __first2, _ForwardIterator2 __last2,
         _BinaryPredicate __pred) {
  return std::__1::__find_end<
      typename add_lvalue_reference<_BinaryPredicate>::type>(
      __first1, __last1, __first2, __last2, __pred,
      typename iterator_traits<_ForwardIterator1>::iterator_category(),
      typename iterator_traits<_ForwardIterator2>::iterator_category());
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _ForwardIterator1
find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
         _ForwardIterator2 __first2, _ForwardIterator2 __last2) {
  typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
  typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
  return std::__1::find_end(__first1, __last1, __first2, __last2,
                            __equal_to<__v1, __v2>());
}

template <class _ForwardIterator1, class _ForwardIterator2,
          class _BinaryPredicate>
constexpr _ForwardIterator1
__find_first_of_ce(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                   _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                   _BinaryPredicate __pred) {
  for (; __first1 != __last1; ++__first1)
    for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
      if (__pred(*__first1, *__j))
        return __first1;
  return __last1;
}

template <class _ForwardIterator1, class _ForwardIterator2,
          class _BinaryPredicate>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _ForwardIterator1
find_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
              _ForwardIterator2 __first2, _ForwardIterator2 __last2,
              _BinaryPredicate __pred) {
  return std::__1::__find_first_of_ce(__first1, __last1, __first2, __last2,
                                      __pred);
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _ForwardIterator1
find_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
              _ForwardIterator2 __first2, _ForwardIterator2 __last2) {
  typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
  typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
  return std::__1::__find_first_of_ce(__first1, __last1, __first2, __last2,
                                      __equal_to<__v1, __v2>());
}

template <class _ForwardIterator, class _BinaryPredicate>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _ForwardIterator
adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
              _BinaryPredicate __pred) {
  if (__first != __last) {
    _ForwardIterator __i = __first;
    while (++__i != __last) {
      if (__pred(*__first, *__i))
        return __first;
      __first = __i;
    }
  }
  return __last;
}

template <class _ForwardIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _ForwardIterator
adjacent_find(_ForwardIterator __first, _ForwardIterator __last) {
  typedef typename iterator_traits<_ForwardIterator>::value_type __v;
  return std::__1::adjacent_find(__first, __last, __equal_to<__v>());
}

template <class _InputIterator, class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename iterator_traits<_InputIterator>::difference_type
count(_InputIterator __first, _InputIterator __last, const _Tp &__value_) {
  typename iterator_traits<_InputIterator>::difference_type __r(0);
  for (; __first != __last; ++__first)
    if (*__first == __value_)
      ++__r;
  return __r;
}

template <class _InputIterator, class _Predicate>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename iterator_traits<_InputIterator>::difference_type
count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred) {
  typename iterator_traits<_InputIterator>::difference_type __r(0);
  for (; __first != __last; ++__first)
    if (__pred(*__first))
      ++__r;
  return __r;
}

template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) pair<_InputIterator1, _InputIterator2>
mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _BinaryPredicate __pred) {
  for (; __first1 != __last1; ++__first1, (void)++__first2)
    if (!__pred(*__first1, *__first2))
      break;
  return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) pair<_InputIterator1, _InputIterator2>
mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2) {
  typedef typename iterator_traits<_InputIterator1>::value_type __v1;
  typedef typename iterator_traits<_InputIterator2>::value_type __v2;
  return std::__1::mismatch(__first1, __last1, __first2,
                            __equal_to<__v1, __v2>());
}

template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) pair<_InputIterator1, _InputIterator2>
mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _InputIterator2 __last2,
         _BinaryPredicate __pred) {
  for (; __first1 != __last1 && __first2 != __last2;
       ++__first1, (void)++__first2)
    if (!__pred(*__first1, *__first2))
      break;
  return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) pair<_InputIterator1, _InputIterator2>
mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _InputIterator2 __last2) {
  typedef typename iterator_traits<_InputIterator1>::value_type __v1;
  typedef typename iterator_traits<_InputIterator2>::value_type __v2;
  return std::__1::mismatch(__first1, __last1, __first2, __last2,
                            __equal_to<__v1, __v2>());
}

template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
equal(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __pred) {
  for (; __first1 != __last1; ++__first1, (void)++__first2)
    if (!__pred(*__first1, *__first2))
      return false;
  return true;
}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
equal(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2) {
  typedef typename iterator_traits<_InputIterator1>::value_type __v1;
  typedef typename iterator_traits<_InputIterator2>::value_type __v2;
  return std::__1::equal(__first1, __last1, __first2, __equal_to<__v1, __v2>());
}

template <class _BinaryPredicate, class _InputIterator1, class _InputIterator2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
__equal(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _BinaryPredicate __pred, input_iterator_tag, input_iterator_tag) {
  for (; __first1 != __last1 && __first2 != __last2;
       ++__first1, (void)++__first2)
    if (!__pred(*__first1, *__first2))
      return false;
  return __first1 == __last1 && __first2 == __last2;
}

template <class _BinaryPredicate, class _RandomAccessIterator1,
          class _RandomAccessIterator2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
__equal(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,
        _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2,
        _BinaryPredicate __pred, random_access_iterator_tag,
        random_access_iterator_tag) {
  if (std::__1::distance(__first1, __last1) !=
      std::__1::distance(__first2, __last2))
    return false;
  return std::__1::equal<_RandomAccessIterator1, _RandomAccessIterator2,
                         typename add_lvalue_reference<_BinaryPredicate>::type>(
      __first1, __last1, __first2, __pred);
}

template <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
equal(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _BinaryPredicate __pred) {
  return std::__1::__equal<
      typename add_lvalue_reference<_BinaryPredicate>::type>(
      __first1, __last1, __first2, __last2, __pred,
      typename iterator_traits<_InputIterator1>::iterator_category(),
      typename iterator_traits<_InputIterator2>::iterator_category());
}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
equal(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2) {
  typedef typename iterator_traits<_InputIterator1>::value_type __v1;
  typedef typename iterator_traits<_InputIterator2>::value_type __v2;
  return std::__1::__equal(
      __first1, __last1, __first2, __last2, __equal_to<__v1, __v2>(),
      typename iterator_traits<_InputIterator1>::iterator_category(),
      typename iterator_traits<_InputIterator2>::iterator_category());
}

template <class _ForwardIterator1, class _ForwardIterator2,
          class _BinaryPredicate>
bool is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                    _ForwardIterator2 __first2, _BinaryPredicate __pred) {

  for (; __first1 != __last1; ++__first1, (void)++__first2)
    if (!__pred(*__first1, *__first2))
      break;
  if (__first1 == __last1)
    return true;

  typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;
  _D1 __l1 = std::__1::distance(__first1, __last1);
  if (__l1 == _D1(1))
    return false;
  _ForwardIterator2 __last2 = std::__1::next(__first2, __l1);

  for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i) {

    _ForwardIterator1 __match = __first1;
    for (; __match != __i; ++__match)
      if (__pred(*__match, *__i))
        break;
    if (__match == __i) {

      _D1 __c2 = 0;
      for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
        if (__pred(*__i, *__j))
          ++__c2;
      if (__c2 == 0)
        return false;

      _D1 __c1 = 1;
      for (_ForwardIterator1 __j = std::__1::next(__i); __j != __last1; ++__j)
        if (__pred(*__i, *__j))
          ++__c1;
      if (__c1 != __c2)
        return false;
    }
  }
  return true;
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
               _ForwardIterator2 __first2) {
  typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
  typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
  return std::__1::is_permutation(__first1, __last1, __first2,
                                  __equal_to<__v1, __v2>());
}

template <class _BinaryPredicate, class _ForwardIterator1,
          class _ForwardIterator2>
bool __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
                      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
                      _BinaryPredicate __pred, forward_iterator_tag,
                      forward_iterator_tag) {

  for (; __first1 != __last1 && __first2 != __last2;
       ++__first1, (void)++__first2)
    if (!__pred(*__first1, *__first2))
      break;
  if (__first1 == __last1)
    return __first2 == __last2;
  else if (__first2 == __last2)
    return false;

  typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;
  _D1 __l1 = std::__1::distance(__first1, __last1);

  typedef typename iterator_traits<_ForwardIterator2>::difference_type _D2;
  _D2 __l2 = std::__1::distance(__first2, __last2);
  if (__l1 != __l2)
    return false;

  for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i) {

    _ForwardIterator1 __match = __first1;
    for (; __match != __i; ++__match)
      if (__pred(*__match, *__i))
        break;
    if (__match == __i) {

      _D1 __c2 = 0;
      for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
        if (__pred(*__i, *__j))
          ++__c2;
      if (__c2 == 0)
        return false;

      _D1 __c1 = 1;
      for (_ForwardIterator1 __j = std::__1::next(__i); __j != __last1; ++__j)
        if (__pred(*__i, *__j))
          ++__c1;
      if (__c1 != __c2)
        return false;
    }
  }
  return true;
}

template <class _BinaryPredicate, class _RandomAccessIterator1,
          class _RandomAccessIterator2>
bool __is_permutation(_RandomAccessIterator1 __first1,
                      _RandomAccessIterator2 __last1,
                      _RandomAccessIterator1 __first2,
                      _RandomAccessIterator2 __last2, _BinaryPredicate __pred,
                      random_access_iterator_tag, random_access_iterator_tag) {
  if (std::__1::distance(__first1, __last1) !=
      std::__1::distance(__first2, __last2))
    return false;
  return std::__1::is_permutation<
      _RandomAccessIterator1, _RandomAccessIterator2,
      typename add_lvalue_reference<_BinaryPredicate>::type>(__first1, __last1,
                                                             __first2, __pred);
}

template <class _ForwardIterator1, class _ForwardIterator2,
          class _BinaryPredicate>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
               _ForwardIterator2 __first2, _ForwardIterator2 __last2,
               _BinaryPredicate __pred) {
  return std::__1::__is_permutation<
      typename add_lvalue_reference<_BinaryPredicate>::type>(
      __first1, __last1, __first2, __last2, __pred,
      typename iterator_traits<_ForwardIterator1>::iterator_category(),
      typename iterator_traits<_ForwardIterator2>::iterator_category());
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
               _ForwardIterator2 __first2, _ForwardIterator2 __last2) {
  typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
  typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
  return std::__1::__is_permutation(
      __first1, __last1, __first2, __last2, __equal_to<__v1, __v2>(),
      typename iterator_traits<_ForwardIterator1>::iterator_category(),
      typename iterator_traits<_ForwardIterator2>::iterator_category());
}

template <class _ForwardIterator1, class _ForwardIterator2,
          class _BinaryPredicate>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _ForwardIterator1
search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _ForwardIterator2 __last2,
       _BinaryPredicate __pred) {
  return std::__1::__search<
             typename add_lvalue_reference<_BinaryPredicate>::type>(
             __first1, __last1, __first2, __last2, __pred,
             typename iterator_traits<_ForwardIterator1>::iterator_category(),
             typename iterator_traits<_ForwardIterator2>::iterator_category())
      .first;
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _ForwardIterator1
search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _ForwardIterator2 __last2) {
  typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
  typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
  return std::__1::search(__first1, __last1, __first2, __last2,
                          __equal_to<__v1, __v2>());
}
# 1532 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 3
template <class _BinaryPredicate, class _ForwardIterator, class _Size,
          class _Tp>
_ForwardIterator __search_n(_ForwardIterator __first, _ForwardIterator __last,
                            _Size __count, const _Tp &__value_,
                            _BinaryPredicate __pred, forward_iterator_tag) {
  if (__count <= 0)
    return __first;
  while (true) {

    while (true) {
      if (__first == __last)
        return __last;
      if (__pred(*__first, __value_))
        break;
      ++__first;
    }

    _ForwardIterator __m = __first;
    _Size __c(0);
    while (true) {
      if (++__c == __count)
        return __first;
      if (++__m == __last)
        return __last;
      if (!__pred(*__m, __value_)) {
        __first = __m;
        ++__first;
        break;
      }
    }
  }
}

template <class _BinaryPredicate, class _RandomAccessIterator, class _Size,
          class _Tp>
_RandomAccessIterator __search_n(_RandomAccessIterator __first,
                                 _RandomAccessIterator __last, _Size __count,
                                 const _Tp &__value_, _BinaryPredicate __pred,
                                 random_access_iterator_tag) {
  if (__count <= 0)
    return __first;
  _Size __len = static_cast<_Size>(__last - __first);
  if (__len < __count)
    return __last;
  const _RandomAccessIterator __s = __last - (__count - 1);
  while (true) {

    while (true) {
      if (__first >= __s)
        return __last;
      if (__pred(*__first, __value_))
        break;
      ++__first;
    }

    _RandomAccessIterator __m = __first;
    _Size __c(0);
    while (true) {
      if (++__c == __count)
        return __first;
      ++__m;
      if (!__pred(*__m, __value_)) {
        __first = __m;
        ++__first;
        break;
      }
    }
  }
}

template <class _ForwardIterator, class _Size, class _Tp,
          class _BinaryPredicate>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _ForwardIterator
search_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count,
         const _Tp &__value_, _BinaryPredicate __pred) {
  return std::__1::__search_n<
      typename add_lvalue_reference<_BinaryPredicate>::type>(
      __first, __last, __convert_to_integral(__count), __value_, __pred,
      typename iterator_traits<_ForwardIterator>::iterator_category());
}

template <class _ForwardIterator, class _Size, class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _ForwardIterator
search_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count,
         const _Tp &__value_) {
  typedef typename iterator_traits<_ForwardIterator>::value_type __v;
  return std::__1::search_n(__first, __last, __convert_to_integral(__count),
                            __value_, __equal_to<__v, _Tp>());
}

template <class _Iter>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _Iter
__unwrap_iter(_Iter __i) {
  return __i;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename enable_if<is_trivially_copy_assignable<_Tp>::value, _Tp *>::type
__unwrap_iter(move_iterator<_Tp *> __i) {
  return __i.base();
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr
    typename enable_if<is_trivially_copy_assignable<_Tp>::value, _Tp *>::type
    __unwrap_iter(__wrap_iter<_Tp *> __i) {
  return __i.base();
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr
    typename enable_if<is_trivially_copy_assignable<_Tp>::value,
                       const _Tp *>::type
    __unwrap_iter(__wrap_iter<const _Tp *> __i) {
  return __i.base();
}
# 1695 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 3
template <class _InputIterator, class _OutputIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _OutputIterator
__copy_constexpr(_InputIterator __first, _InputIterator __last,
                 _OutputIterator __result) {
  for (; __first != __last; ++__first, (void)++__result)
    *__result = *__first;
  return __result;
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _OutputIterator
__copy(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result) {
  return __copy_constexpr(__first, __last, __result);
}

template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename enable_if<is_same<typename remove_const<_Tp>::type, _Up>::value &&
                       is_trivially_copy_assignable<_Up>::value,
                   _Up *>::type
__copy(_Tp *__first, _Tp *__last, _Up *__result) {
  const size_t __n = static_cast<size_t>(__last - __first);
  if (__n > 0)
    std::__1::memmove(__result, __first, __n * sizeof(_Up));
  return __result + __n;
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _OutputIterator
copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result) {
  if (__libcpp_is_constant_evaluated()) {
    return std::__1::__copy_constexpr(
        __unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
  } else {
    return std::__1::__copy(__unwrap_iter(__first), __unwrap_iter(__last),
                            __unwrap_iter(__result));
  }
}

template <class _BidirectionalIterator, class _OutputIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _OutputIterator
__copy_backward_constexpr(_BidirectionalIterator __first,
                          _BidirectionalIterator __last,
                          _OutputIterator __result) {
  while (__first != __last)
    *--__result = *--__last;
  return __result;
}

template <class _BidirectionalIterator, class _OutputIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _OutputIterator
__copy_backward(_BidirectionalIterator __first, _BidirectionalIterator __last,
                _OutputIterator __result) {
  return __copy_backward_constexpr(__first, __last, __result);
}

template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename enable_if<is_same<typename remove_const<_Tp>::type, _Up>::value &&
                       is_trivially_copy_assignable<_Up>::value,
                   _Up *>::type
__copy_backward(_Tp *__first, _Tp *__last, _Up *__result) {
  const size_t __n = static_cast<size_t>(__last - __first);
  if (__n > 0) {
    __result -= __n;
    std::__1::memmove(__result, __first, __n * sizeof(_Up));
  }
  return __result;
}

template <class _BidirectionalIterator1, class _BidirectionalIterator2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _BidirectionalIterator2
copy_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,
              _BidirectionalIterator2 __result) {
  if (__libcpp_is_constant_evaluated()) {
    return std::__1::__copy_backward_constexpr(
        __unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
  } else {
    return std::__1::__copy_backward(
        __unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
  }
}

template <class _InputIterator, class _OutputIterator, class _Predicate>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _OutputIterator
copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result,
        _Predicate __pred) {
  for (; __first != __last; ++__first) {
    if (__pred(*__first)) {
      *__result = *__first;
      ++__result;
    }
  }
  return __result;
}

template <class _InputIterator, class _Size, class _OutputIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) typename enable_if<
    __is_cpp17_input_iterator<_InputIterator>::value &&
        !__is_cpp17_random_access_iterator<_InputIterator>::value,
    _OutputIterator>::type
copy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result) {
  typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;
  _IntegralSize __n = __orig_n;
  if (__n > 0) {
    *__result = *__first;
    ++__result;
    for (--__n; __n > 0; --__n) {
      ++__first;
      *__result = *__first;
      ++__result;
    }
  }
  return __result;
}

template <class _InputIterator, class _Size, class _OutputIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename enable_if<__is_cpp17_random_access_iterator<_InputIterator>::value,
                   _OutputIterator>::type
copy_n(_InputIterator __first, _Size __orig_n, _OutputIterator __result) {
  typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;
  _IntegralSize __n = __orig_n;
  return std::__1::copy(__first, __first + __n, __result);
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _OutputIterator
__move(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result) {
  for (; __first != __last; ++__first, (void)++__result)
    *__result = std::__1::move(*__first);
  return __result;
}

template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename enable_if<is_same<typename remove_const<_Tp>::type, _Up>::value &&
                       is_trivially_copy_assignable<_Up>::value,
                   _Up *>::type
__move(_Tp *__first, _Tp *__last, _Up *__result) {
  const size_t __n = static_cast<size_t>(__last - __first);
  if (__n > 0)
    std::__1::memmove(__result, __first, __n * sizeof(_Up));
  return __result + __n;
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _OutputIterator
move(_InputIterator __first, _InputIterator __last, _OutputIterator __result) {
  return std::__1::__move(__unwrap_iter(__first), __unwrap_iter(__last),
                          __unwrap_iter(__result));
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _OutputIterator
__move_backward(_InputIterator __first, _InputIterator __last,
                _OutputIterator __result) {
  while (__first != __last)
    *--__result = std::__1::move(*--__last);
  return __result;
}

template <class _Tp, class _Up>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename enable_if<is_same<typename remove_const<_Tp>::type, _Up>::value &&
                       is_trivially_copy_assignable<_Up>::value,
                   _Up *>::type
__move_backward(_Tp *__first, _Tp *__last, _Up *__result) {
  const size_t __n = static_cast<size_t>(__last - __first);
  if (__n > 0) {
    __result -= __n;
    std::__1::memmove(__result, __first, __n * sizeof(_Up));
  }
  return __result;
}

template <class _BidirectionalIterator1, class _BidirectionalIterator2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _BidirectionalIterator2
move_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,
              _BidirectionalIterator2 __result) {
  return std::__1::__move_backward(
      __unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
}

template <class _InputIterator, class _OutputIterator, class _UnaryOperation>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _OutputIterator
transform(_InputIterator __first, _InputIterator __last,
          _OutputIterator __result, _UnaryOperation __op) {
  for (; __first != __last; ++__first, (void)++__result)
    *__result = __op(*__first);
  return __result;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator,
          class _BinaryOperation>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _OutputIterator
transform(_InputIterator1 __first1, _InputIterator1 __last1,
          _InputIterator2 __first2, _OutputIterator __result,
          _BinaryOperation __binary_op) {
  for (; __first1 != __last1; ++__first1, (void)++__first2, ++__result)
    *__result = __binary_op(*__first1, *__first2);
  return __result;
}

template <class _ForwardIterator, class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
replace(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp &__old_value, const _Tp &__new_value) {
  for (; __first != __last; ++__first)
    if (*__first == __old_value)
      *__first = __new_value;
}

template <class _ForwardIterator, class _Predicate, class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
replace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,
           const _Tp &__new_value) {
  for (; __first != __last; ++__first)
    if (__pred(*__first))
      *__first = __new_value;
}

template <class _InputIterator, class _OutputIterator, class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _OutputIterator
replace_copy(_InputIterator __first, _InputIterator __last,
             _OutputIterator __result, const _Tp &__old_value,
             const _Tp &__new_value) {
  for (; __first != __last; ++__first, (void)++__result)
    if (*__first == __old_value)
      *__result = __new_value;
    else
      *__result = *__first;
  return __result;
}

template <class _InputIterator, class _OutputIterator, class _Predicate,
          class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _OutputIterator
replace_copy_if(_InputIterator __first, _InputIterator __last,
                _OutputIterator __result, _Predicate __pred,
                const _Tp &__new_value) {
  for (; __first != __last; ++__first, (void)++__result)
    if (__pred(*__first))
      *__result = __new_value;
    else
      *__result = *__first;
  return __result;
}

template <class _OutputIterator, class _Size, class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _OutputIterator
__fill_n(_OutputIterator __first, _Size __n, const _Tp &__value_) {
  for (; __n > 0; ++__first, (void)--__n)
    *__first = __value_;
  return __first;
}

template <class _OutputIterator, class _Size, class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _OutputIterator
fill_n(_OutputIterator __first, _Size __n, const _Tp &__value_) {
  return std::__1::__fill_n(__first, __convert_to_integral(__n), __value_);
}

template <class _ForwardIterator, class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
__fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value_,
       forward_iterator_tag) {
  for (; __first != __last; ++__first)
    *__first = __value_;
}

template <class _RandomAccessIterator, class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
__fill(_RandomAccessIterator __first, _RandomAccessIterator __last,
       const _Tp &__value_, random_access_iterator_tag) {
  std::__1::fill_n(__first, __last - __first, __value_);
}

template <class _ForwardIterator, class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value_) {
  std::__1::__fill(
      __first, __last, __value_,
      typename iterator_traits<_ForwardIterator>::iterator_category());
}

template <class _ForwardIterator, class _Generator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
generate(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen) {
  for (; __first != __last; ++__first)
    *__first = __gen();
}

template <class _OutputIterator, class _Size, class _Generator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _OutputIterator
generate_n(_OutputIterator __first, _Size __orig_n, _Generator __gen) {
  typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;
  _IntegralSize __n = __orig_n;
  for (; __n > 0; ++__first, (void)--__n)
    *__first = __gen();
  return __first;
}

template <class _ForwardIterator, class _Tp>
_ForwardIterator remove(_ForwardIterator __first, _ForwardIterator __last,
                        const _Tp &__value_) {
  __first = std::__1::find(__first, __last, __value_);
  if (__first != __last) {
    _ForwardIterator __i = __first;
    while (++__i != __last) {
      if (!(*__i == __value_)) {
        *__first = std::__1::move(*__i);
        ++__first;
      }
    }
  }
  return __first;
}

template <class _ForwardIterator, class _Predicate>
_ForwardIterator remove_if(_ForwardIterator __first, _ForwardIterator __last,
                           _Predicate __pred) {
  __first = std::__1::find_if<_ForwardIterator,
                              typename add_lvalue_reference<_Predicate>::type>(
      __first, __last, __pred);
  if (__first != __last) {
    _ForwardIterator __i = __first;
    while (++__i != __last) {
      if (!__pred(*__i)) {
        *__first = std::__1::move(*__i);
        ++__first;
      }
    }
  }
  return __first;
}

template <class _InputIterator, class _OutputIterator, class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _OutputIterator
remove_copy(_InputIterator __first, _InputIterator __last,
            _OutputIterator __result, const _Tp &__value_) {
  for (; __first != __last; ++__first) {
    if (!(*__first == __value_)) {
      *__result = *__first;
      ++__result;
    }
  }
  return __result;
}

template <class _InputIterator, class _OutputIterator, class _Predicate>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _OutputIterator
remove_copy_if(_InputIterator __first, _InputIterator __last,
               _OutputIterator __result, _Predicate __pred) {
  for (; __first != __last; ++__first) {
    if (!__pred(*__first)) {
      *__result = *__first;
      ++__result;
    }
  }
  return __result;
}

template <class _ForwardIterator, class _BinaryPredicate>
_ForwardIterator unique(_ForwardIterator __first, _ForwardIterator __last,
                        _BinaryPredicate __pred) {
  __first = std::__1::adjacent_find<
      _ForwardIterator, typename add_lvalue_reference<_BinaryPredicate>::type>(
      __first, __last, __pred);
  if (__first != __last) {

    _ForwardIterator __i = __first;
    for (++__i; ++__i != __last;)
      if (!__pred(*__first, *__i))
        *++__first = std::__1::move(*__i);
    ++__first;
  }
  return __first;
}

template <class _ForwardIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _ForwardIterator
unique(_ForwardIterator __first, _ForwardIterator __last) {
  typedef typename iterator_traits<_ForwardIterator>::value_type __v;
  return std::__1::unique(__first, __last, __equal_to<__v>());
}

template <class _BinaryPredicate, class _InputIterator, class _OutputIterator>
_OutputIterator __unique_copy(_InputIterator __first, _InputIterator __last,
                              _OutputIterator __result, _BinaryPredicate __pred,
                              input_iterator_tag, output_iterator_tag) {
  if (__first != __last) {
    typename iterator_traits<_InputIterator>::value_type __t(*__first);
    *__result = __t;
    ++__result;
    while (++__first != __last) {
      if (!__pred(__t, *__first)) {
        __t = *__first;
        *__result = __t;
        ++__result;
      }
    }
  }
  return __result;
}

template <class _BinaryPredicate, class _ForwardIterator, class _OutputIterator>
_OutputIterator __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
                              _OutputIterator __result, _BinaryPredicate __pred,
                              forward_iterator_tag, output_iterator_tag) {
  if (__first != __last) {
    _ForwardIterator __i = __first;
    *__result = *__i;
    ++__result;
    while (++__first != __last) {
      if (!__pred(*__i, *__first)) {
        *__result = *__first;
        ++__result;
        __i = __first;
      }
    }
  }
  return __result;
}

template <class _BinaryPredicate, class _InputIterator, class _ForwardIterator>
_ForwardIterator __unique_copy(_InputIterator __first, _InputIterator __last,
                               _ForwardIterator __result,
                               _BinaryPredicate __pred, input_iterator_tag,
                               forward_iterator_tag) {
  if (__first != __last) {
    *__result = *__first;
    while (++__first != __last)
      if (!__pred(*__result, *__first))
        *++__result = *__first;
    ++__result;
  }
  return __result;
}

template <class _InputIterator, class _OutputIterator, class _BinaryPredicate>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _OutputIterator
unique_copy(_InputIterator __first, _InputIterator __last,
            _OutputIterator __result, _BinaryPredicate __pred) {
  return std::__1::__unique_copy<
      typename add_lvalue_reference<_BinaryPredicate>::type>(
      __first, __last, __result, __pred,
      typename iterator_traits<_InputIterator>::iterator_category(),
      typename iterator_traits<_OutputIterator>::iterator_category());
}

template <class _InputIterator, class _OutputIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _OutputIterator
unique_copy(_InputIterator __first, _InputIterator __last,
            _OutputIterator __result) {
  typedef typename iterator_traits<_InputIterator>::value_type __v;
  return std::__1::unique_copy(__first, __last, __result, __equal_to<__v>());
}

template <class _BidirectionalIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
__reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
          bidirectional_iterator_tag) {
  while (__first != __last) {
    if (__first == --__last)
      break;
    std::__1::iter_swap(__first, __last);
    ++__first;
  }
}

template <class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
__reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
          random_access_iterator_tag) {
  if (__first != __last)
    for (; __first < --__last; ++__first)
      std::__1::iter_swap(__first, __last);
}

template <class _BidirectionalIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
reverse(_BidirectionalIterator __first, _BidirectionalIterator __last) {
  std::__1::__reverse(
      __first, __last,
      typename iterator_traits<_BidirectionalIterator>::iterator_category());
}

template <class _BidirectionalIterator, class _OutputIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _OutputIterator
reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
             _OutputIterator __result) {
  for (; __first != __last; ++__result)
    *__result = *--__last;
  return __result;
}

template <class _ForwardIterator>
_ForwardIterator __rotate_left(_ForwardIterator __first,
                               _ForwardIterator __last) {
  typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
  value_type __tmp = std::__1::move(*__first);
  _ForwardIterator __lm1 =
      std::__1::move(std::__1::next(__first), __last, __first);
  *__lm1 = std::__1::move(__tmp);
  return __lm1;
}

template <class _BidirectionalIterator>
_BidirectionalIterator __rotate_right(_BidirectionalIterator __first,
                                      _BidirectionalIterator __last) {
  typedef
      typename iterator_traits<_BidirectionalIterator>::value_type value_type;
  _BidirectionalIterator __lm1 = std::__1::prev(__last);
  value_type __tmp = std::__1::move(*__lm1);
  _BidirectionalIterator __fp1 =
      std::__1::move_backward(__first, __lm1, __last);
  *__first = std::__1::move(__tmp);
  return __fp1;
}

template <class _ForwardIterator>
_ForwardIterator __rotate_forward(_ForwardIterator __first,
                                  _ForwardIterator __middle,
                                  _ForwardIterator __last) {
  _ForwardIterator __i = __middle;
  while (true) {
    swap(*__first, *__i);
    ++__first;
    if (++__i == __last)
      break;
    if (__first == __middle)
      __middle = __i;
  }
  _ForwardIterator __r = __first;
  if (__first != __middle) {
    __i = __middle;
    while (true) {
      swap(*__first, *__i);
      ++__first;
      if (++__i == __last) {
        if (__first == __middle)
          break;
        __i = __middle;
      } else if (__first == __middle)
        __middle = __i;
    }
  }
  return __r;
}

template <typename _Integral>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _Integral
__algo_gcd(_Integral __x, _Integral __y) {
  do {
    _Integral __t = __x % __y;
    __x = __y;
    __y = __t;
  } while (__y);
  return __x;
}

template <typename _RandomAccessIterator>
_RandomAccessIterator __rotate_gcd(_RandomAccessIterator __first,
                                   _RandomAccessIterator __middle,
                                   _RandomAccessIterator __last) {
  typedef typename iterator_traits<_RandomAccessIterator>::difference_type
      difference_type;
  typedef
      typename iterator_traits<_RandomAccessIterator>::value_type value_type;

  const difference_type __m1 = __middle - __first;
  const difference_type __m2 = __last - __middle;
  if (__m1 == __m2) {
    std::__1::swap_ranges(__first, __middle, __middle);
    return __middle;
  }
  const difference_type __g = std::__1::__algo_gcd(__m1, __m2);
  for (_RandomAccessIterator __p = __first + __g; __p != __first;) {
    value_type __t(std::__1::move(*--__p));
    _RandomAccessIterator __p1 = __p;
    _RandomAccessIterator __p2 = __p1 + __m1;
    do {
      *__p1 = std::__1::move(*__p2);
      __p1 = __p2;
      const difference_type __d = __last - __p2;
      if (__m1 < __d)
        __p2 += __m1;
      else
        __p2 = __first + (__m1 - __d);
    } while (__p2 != __p);
    *__p1 = std::__1::move(__t);
  }
  return __first + __m2;
}

template <class _ForwardIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _ForwardIterator
__rotate(_ForwardIterator __first, _ForwardIterator __middle,
         _ForwardIterator __last, std::__1::forward_iterator_tag) {
  typedef typename std::__1::iterator_traits<_ForwardIterator>::value_type
      value_type;
  if (std::__1::is_trivially_move_assignable<value_type>::value) {
    if (std::__1::next(__first) == __middle)
      return std::__1::__rotate_left(__first, __last);
  }
  return std::__1::__rotate_forward(__first, __middle, __last);
}

template <class _BidirectionalIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _BidirectionalIterator
__rotate(_BidirectionalIterator __first, _BidirectionalIterator __middle,
         _BidirectionalIterator __last, std::__1::bidirectional_iterator_tag) {
  typedef typename std::__1::iterator_traits<_BidirectionalIterator>::value_type
      value_type;
  if (std::__1::is_trivially_move_assignable<value_type>::value) {
    if (std::__1::next(__first) == __middle)
      return std::__1::__rotate_left(__first, __last);
    if (std::__1::next(__middle) == __last)
      return std::__1::__rotate_right(__first, __last);
  }
  return std::__1::__rotate_forward(__first, __middle, __last);
}

template <class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _RandomAccessIterator
__rotate(_RandomAccessIterator __first, _RandomAccessIterator __middle,
         _RandomAccessIterator __last, std::__1::random_access_iterator_tag) {
  typedef typename std::__1::iterator_traits<_RandomAccessIterator>::value_type
      value_type;
  if (std::__1::is_trivially_move_assignable<value_type>::value) {
    if (std::__1::next(__first) == __middle)
      return std::__1::__rotate_left(__first, __last);
    if (std::__1::next(__middle) == __last)
      return std::__1::__rotate_right(__first, __last);
    return std::__1::__rotate_gcd(__first, __middle, __last);
  }
  return std::__1::__rotate_forward(__first, __middle, __last);
}

template <class _ForwardIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _ForwardIterator
rotate(_ForwardIterator __first, _ForwardIterator __middle,
       _ForwardIterator __last) {
  if (__first == __middle)
    return __last;
  if (__middle == __last)
    return __first;
  return std::__1::__rotate(__first, __middle, __last,
                            typename std::__1::iterator_traits<
                                _ForwardIterator>::iterator_category());
}

template <class _ForwardIterator, class _OutputIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _OutputIterator
rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
            _ForwardIterator __last, _OutputIterator __result) {
  return std::__1::copy(__first, __middle,
                        std::__1::copy(__middle, __last, __result));
}

template <class _ForwardIterator, class _Compare>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr _ForwardIterator
min_element(_ForwardIterator __first, _ForwardIterator __last,
            _Compare __comp) {
  static_assert(__is_cpp17_forward_iterator<_ForwardIterator>::value,
                "std::min_element requires a ForwardIterator");
  if (__first != __last) {
    _ForwardIterator __i = __first;
    while (++__i != __last)
      if (__comp(*__i, *__first))
        __first = __i;
  }
  return __first;
}

template <class _ForwardIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr _ForwardIterator
min_element(_ForwardIterator __first, _ForwardIterator __last) {
  return std::__1::min_element(
      __first, __last,
      __less<typename iterator_traits<_ForwardIterator>::value_type>());
}

template <class _Tp, class _Compare>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr const _Tp &
min(const _Tp &__a, const _Tp &__b, _Compare __comp) {
  return __comp(__b, __a) ? __b : __a;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr const _Tp &
min(const _Tp &__a, const _Tp &__b) {
  return std::__1::min(__a, __b, __less<_Tp>());
}

template <class _Tp, class _Compare>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr _Tp
min(initializer_list<_Tp> __t, _Compare __comp) {
  return *std::__1::min_element(__t.begin(), __t.end(), __comp);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr _Tp
min(initializer_list<_Tp> __t) {
  return *std::__1::min_element(__t.begin(), __t.end(), __less<_Tp>());
}

template <class _ForwardIterator, class _Compare>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr _ForwardIterator
max_element(_ForwardIterator __first, _ForwardIterator __last,
            _Compare __comp) {
  static_assert(__is_cpp17_forward_iterator<_ForwardIterator>::value,
                "std::max_element requires a ForwardIterator");
  if (__first != __last) {
    _ForwardIterator __i = __first;
    while (++__i != __last)
      if (__comp(*__first, *__i))
        __first = __i;
  }
  return __first;
}

template <class _ForwardIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr _ForwardIterator
max_element(_ForwardIterator __first, _ForwardIterator __last) {
  return std::__1::max_element(
      __first, __last,
      __less<typename iterator_traits<_ForwardIterator>::value_type>());
}

template <class _Tp, class _Compare>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr const _Tp &
max(const _Tp &__a, const _Tp &__b, _Compare __comp) {
  return __comp(__a, __b) ? __b : __a;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr const _Tp &
max(const _Tp &__a, const _Tp &__b) {
  return std::__1::max(__a, __b, __less<_Tp>());
}

template <class _Tp, class _Compare>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr _Tp
max(initializer_list<_Tp> __t, _Compare __comp) {
  return *std::__1::max_element(__t.begin(), __t.end(), __comp);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr _Tp
max(initializer_list<_Tp> __t) {
  return *std::__1::max_element(__t.begin(), __t.end(), __less<_Tp>());
}
# 2685 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 3
template <class _ForwardIterator, class _Compare>
constexpr std::pair<_ForwardIterator, _ForwardIterator>
minmax_element(_ForwardIterator __first, _ForwardIterator __last,
               _Compare __comp) {
  static_assert(__is_cpp17_forward_iterator<_ForwardIterator>::value,
                "std::minmax_element requires a ForwardIterator");
  std::pair<_ForwardIterator, _ForwardIterator> __result(__first, __first);
  if (__first != __last) {
    if (++__first != __last) {
      if (__comp(*__first, *__result.first))
        __result.first = __first;
      else
        __result.second = __first;
      while (++__first != __last) {
        _ForwardIterator __i = __first;
        if (++__first == __last) {
          if (__comp(*__i, *__result.first))
            __result.first = __i;
          else if (!__comp(*__i, *__result.second))
            __result.second = __i;
          break;
        } else {
          if (__comp(*__first, *__i)) {
            if (__comp(*__first, *__result.first))
              __result.first = __first;
            if (!__comp(*__i, *__result.second))
              __result.second = __i;
          } else {
            if (__comp(*__i, *__result.first))
              __result.first = __i;
            if (!__comp(*__first, *__result.second))
              __result.second = __first;
          }
        }
      }
    }
  }
  return __result;
}

template <class _ForwardIterator>
inline __attribute__((__visibility__("hidden"))) __attribute__((
    internal_linkage)) constexpr std::pair<_ForwardIterator, _ForwardIterator>
minmax_element(_ForwardIterator __first, _ForwardIterator __last) {
  return std::__1::minmax_element(
      __first, __last,
      __less<typename iterator_traits<_ForwardIterator>::value_type>());
}

template <class _Tp, class _Compare>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr pair<const _Tp &, const _Tp &>
minmax(const _Tp &__a, const _Tp &__b, _Compare __comp) {
  return __comp(__b, __a) ? pair<const _Tp &, const _Tp &>(__b, __a)
                          : pair<const _Tp &, const _Tp &>(__a, __b);
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr pair<const _Tp &, const _Tp &>
minmax(const _Tp &__a, const _Tp &__b) {
  return std::__1::minmax(__a, __b, __less<_Tp>());
}

template <class _Tp, class _Compare>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr pair<_Tp, _Tp>
minmax(initializer_list<_Tp> __t, _Compare __comp) {
  typedef typename initializer_list<_Tp>::const_iterator _Iter;
  _Iter __first = __t.begin();
  _Iter __last = __t.end();
  std::pair<_Tp, _Tp> __result(*__first, *__first);

  ++__first;
  if (__t.size() % 2 == 0) {
    if (__comp(*__first, __result.first))
      __result.first = *__first;
    else
      __result.second = *__first;
    ++__first;
  }

  while (__first != __last) {
    _Tp __prev = *__first++;
    if (__comp(*__first, __prev)) {
      if (__comp(*__first, __result.first))
        __result.first = *__first;
      if (!__comp(__prev, __result.second))
        __result.second = __prev;
    } else {
      if (__comp(__prev, __result.first))
        __result.first = __prev;
      if (!__comp(*__first, __result.second))
        __result.second = *__first;
    }

    __first++;
  }
  return __result;
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr pair<_Tp, _Tp>
minmax(initializer_list<_Tp> __t) {
  return std::__1::minmax(__t, __less<_Tp>());
}

template <unsigned long long _Xp, size_t _Rp> struct __log2_imp {
  static const size_t value = _Xp & ((unsigned long long)(1) << _Rp)
                                  ? _Rp
                                  : __log2_imp<_Xp, _Rp - 1>::value;
};

template <unsigned long long _Xp> struct __log2_imp<_Xp, 0> {
  static const size_t value = 0;
};

template <size_t _Rp> struct __log2_imp<0, _Rp> {
  static const size_t value = _Rp + 1;
};

template <class _UIntType, _UIntType _Xp> struct __log2 {
  static const size_t value = __log2_imp<_Xp, sizeof(_UIntType) * 8 - 1>::value;
};

template <class _Engine, class _UIntType> class __independent_bits_engine {
public:
  typedef _UIntType result_type;

private:
  typedef typename _Engine::result_type _Engine_result_type;
  typedef
      typename conditional<sizeof(_Engine_result_type) <= sizeof(result_type),
                           result_type, _Engine_result_type>::type
          _Working_result_type;

  _Engine &__e_;
  size_t __w_;
  size_t __w0_;
  size_t __n_;
  size_t __n0_;
  _Working_result_type __y0_;
  _Working_result_type __y1_;
  _Engine_result_type __mask0_;
  _Engine_result_type __mask1_;

  static constexpr const _Working_result_type _Rp =
      _Engine::max() - _Engine::min() + _Working_result_type(1);

  static constexpr const size_t __m = __log2<_Working_result_type, _Rp>::value;
  static constexpr const size_t _WDt =
      numeric_limits<_Working_result_type>::digits;
  static constexpr const size_t _EDt =
      numeric_limits<_Engine_result_type>::digits;

public:
  __independent_bits_engine(_Engine &__e, size_t __w);

  result_type operator()() {
    return __eval(integral_constant<bool, _Rp != 0>());
  }

private:
  result_type __eval(false_type);
  result_type __eval(true_type);
};

template <class _Engine, class _UIntType>
__independent_bits_engine<_Engine, _UIntType>::__independent_bits_engine(
    _Engine &__e, size_t __w)
    : __e_(__e), __w_(__w) {
  __n_ = __w_ / __m + (__w_ % __m != 0);
  __w0_ = __w_ / __n_;
  if (_Rp == 0)
    __y0_ = _Rp;
  else if (__w0_ < _WDt)
    __y0_ = (_Rp >> __w0_) << __w0_;
  else
    __y0_ = 0;
  if (_Rp - __y0_ > __y0_ / __n_) {
    ++__n_;
    __w0_ = __w_ / __n_;
    if (__w0_ < _WDt)
      __y0_ = (_Rp >> __w0_) << __w0_;
    else
      __y0_ = 0;
  }
  __n0_ = __n_ - __w_ % __n_;
  if (__w0_ < _WDt - 1)
    __y1_ = (_Rp >> (__w0_ + 1)) << (__w0_ + 1);
  else
    __y1_ = 0;
  __mask0_ = __w0_ > 0 ? _Engine_result_type(~0) >> (_EDt - __w0_)
                       : _Engine_result_type(0);
  __mask1_ = __w0_ < _EDt - 1 ? _Engine_result_type(~0) >> (_EDt - (__w0_ + 1))
                              : _Engine_result_type(~0);
}

template <class _Engine, class _UIntType>
inline _UIntType
__independent_bits_engine<_Engine, _UIntType>::__eval(false_type) {
  return static_cast<result_type>(__e_() & __mask0_);
}

template <class _Engine, class _UIntType>
_UIntType __independent_bits_engine<_Engine, _UIntType>::__eval(true_type) {
  const size_t _WRt = numeric_limits<result_type>::digits;
  result_type _Sp = 0;
  for (size_t __k = 0; __k < __n0_; ++__k) {
    _Engine_result_type __u;
    do {
      __u = __e_() - _Engine::min();
    } while (__u >= __y0_);
    if (__w0_ < _WRt)
      _Sp <<= __w0_;
    else
      _Sp = 0;
    _Sp += __u & __mask0_;
  }
  for (size_t __k = __n0_; __k < __n_; ++__k) {
    _Engine_result_type __u;
    do {
      __u = __e_() - _Engine::min();
    } while (__u >= __y1_);
    if (__w0_ < _WRt - 1)
      _Sp <<= __w0_ + 1;
    else
      _Sp = 0;
    _Sp += __u & __mask1_;
  }
  return _Sp;
}

template <class _IntType = int> class uniform_int_distribution {
public:
  typedef _IntType result_type;

  class param_type {
    result_type __a_;
    result_type __b_;

  public:
    typedef uniform_int_distribution distribution_type;

    explicit param_type(result_type __a = 0,
                        result_type __b = numeric_limits<result_type>::max())
        : __a_(__a), __b_(__b) {}

    result_type a() const { return __a_; }
    result_type b() const { return __b_; }

    friend bool operator==(const param_type &__x, const param_type &__y) {
      return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_;
    }
    friend bool operator!=(const param_type &__x, const param_type &__y) {
      return !(__x == __y);
    }
  };

private:
  param_type __p_;

public:
  explicit uniform_int_distribution(
      result_type __a = 0, result_type __b = numeric_limits<result_type>::max())
      : __p_(param_type(__a, __b)) {}
  explicit uniform_int_distribution(const param_type &__p) : __p_(__p) {}
  void reset() {}

  template <class _URNG> result_type operator()(_URNG &__g) {
    return (*this)(__g, __p_);
  }
  template <class _URNG>
  result_type operator()(_URNG &__g, const param_type &__p);

  result_type a() const { return __p_.a(); }
  result_type b() const { return __p_.b(); }

  param_type param() const { return __p_; }
  void param(const param_type &__p) { __p_ = __p; }

  result_type min() const { return a(); }
  result_type max() const { return b(); }

  friend bool operator==(const uniform_int_distribution &__x,
                         const uniform_int_distribution &__y) {
    return __x.__p_ == __y.__p_;
  }
  friend bool operator!=(const uniform_int_distribution &__x,
                         const uniform_int_distribution &__y) {
    return !(__x == __y);
  }
};

template <class _IntType>
template <class _URNG>
typename uniform_int_distribution<_IntType>::result_type
uniform_int_distribution<_IntType>::operator()(_URNG &__g,
                                               const param_type &__p)
    __attribute__((__no_sanitize__("unsigned-integer-overflow"))) {
  typedef typename conditional<sizeof(result_type) <= sizeof(uint32_t),
                               uint32_t, uint64_t>::type _UIntType;
  const _UIntType _Rp = _UIntType(__p.b()) - _UIntType(__p.a()) + _UIntType(1);
  if (_Rp == 1)
    return __p.a();
  const size_t _Dt = numeric_limits<_UIntType>::digits;
  typedef __independent_bits_engine<_URNG, _UIntType> _Eng;
  if (_Rp == 0)
    return static_cast<result_type>(_Eng(__g, _Dt)());
  size_t __w = _Dt - __libcpp_clz(_Rp) - 1;
  if ((_Rp & (std::numeric_limits<_UIntType>::max() >> (_Dt - __w))) != 0)
    ++__w;
  _Eng __e(__g, __w);
  _UIntType __u;
  do {
    __u = __e();
  } while (__u >= _Rp);
  return static_cast<result_type>(__u + __p.a());
}

class __attribute__((__visibility__("default"))) __rs_default;

__attribute__((__visibility__("default"))) __rs_default __rs_get();

class __attribute__((__visibility__("default"))) __rs_default {
  static unsigned __c_;

  __rs_default();

public:
  typedef uint_fast32_t result_type;

  static const result_type _Min = 0;
  static const result_type _Max = 0xFFFFFFFF;

  __rs_default(const __rs_default &);
  ~__rs_default();

  result_type operator()();

  static constexpr result_type min() { return _Min; }
  static constexpr result_type max() { return _Max; }

  friend __attribute__((__visibility__("default"))) __rs_default __rs_get();
};

__attribute__((__visibility__("default"))) __rs_default __rs_get();

template <class _RandomAccessIterator>
__attribute__((deprecated)) void random_shuffle(_RandomAccessIterator __first,
                                                _RandomAccessIterator __last) {
  typedef typename iterator_traits<_RandomAccessIterator>::difference_type
      difference_type;
  typedef uniform_int_distribution<ptrdiff_t> _Dp;
  typedef typename _Dp::param_type _Pp;
  difference_type __d = __last - __first;
  if (__d > 1) {
    _Dp __uid;
    __rs_default __g = __rs_get();
    for (--__last, (void)--__d; __first < __last; ++__first, (void)--__d) {
      difference_type __i = __uid(__g, _Pp(0, __d));
      if (__i != difference_type(0))
        swap(*__first, *(__first + __i));
    }
  }
}

template <class _RandomAccessIterator, class _RandomNumberGenerator>
__attribute__((deprecated)) void random_shuffle(_RandomAccessIterator __first,
                                                _RandomAccessIterator __last,

                                                _RandomNumberGenerator &&__rand)

{
  typedef typename iterator_traits<_RandomAccessIterator>::difference_type
      difference_type;
  difference_type __d = __last - __first;
  if (__d > 1) {
    for (--__last; __first < __last; ++__first, (void)--__d) {
      difference_type __i = __rand(__d);
      if (__i != difference_type(0))
        swap(*__first, *(__first + __i));
    }
  }
}

template <class _PopulationIterator, class _SampleIterator, class _Distance,
          class _UniformRandomNumberGenerator>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
_SampleIterator
__sample(_PopulationIterator __first, _PopulationIterator __last,
         _SampleIterator __output_iter, _Distance __n,
         _UniformRandomNumberGenerator &__g, input_iterator_tag) {

  _Distance __k = 0;
  for (; __first != __last && __k < __n; ++__first, (void)++__k)
    __output_iter[__k] = *__first;
  _Distance __sz = __k;
  for (; __first != __last; ++__first, (void)++__k) {
    _Distance __r = std::__1::uniform_int_distribution<_Distance>(0, __k)(__g);
    if (__r < __sz)
      __output_iter[__r] = *__first;
  }
  return __output_iter + std::__1::min(__n, __k);
}

template <class _PopulationIterator, class _SampleIterator, class _Distance,
          class _UniformRandomNumberGenerator>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
_SampleIterator
__sample(_PopulationIterator __first, _PopulationIterator __last,
         _SampleIterator __output_iter, _Distance __n,
         _UniformRandomNumberGenerator &__g, forward_iterator_tag) {
  _Distance __unsampled_sz = std::__1::distance(__first, __last);
  for (__n = std::__1::min(__n, __unsampled_sz); __n != 0; ++__first) {
    _Distance __r =
        std::__1::uniform_int_distribution<_Distance>(0, --__unsampled_sz)(__g);
    if (__r < __n) {
      *__output_iter++ = *__first;
      --__n;
    }
  }
  return __output_iter;
}

template <class _PopulationIterator, class _SampleIterator, class _Distance,
          class _UniformRandomNumberGenerator>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
_SampleIterator
__sample(_PopulationIterator __first, _PopulationIterator __last,
         _SampleIterator __output_iter, _Distance __n,
         _UniformRandomNumberGenerator &__g) {
  typedef typename iterator_traits<_PopulationIterator>::iterator_category
      _PopCategory;
  typedef typename iterator_traits<_PopulationIterator>::difference_type
      _Difference;
  static_assert(
      __is_cpp17_forward_iterator<_PopulationIterator>::value ||
          __is_cpp17_random_access_iterator<_SampleIterator>::value,
      "SampleIterator must meet the requirements of RandomAccessIterator");
  typedef typename common_type<_Distance, _Difference>::type _CommonType;
  ((void)0);
  return std::__1::__sample(__first, __last, __output_iter, _CommonType(__n),
                            __g, _PopCategory());
}
# 3210 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 3
template <class _RandomAccessIterator, class _UniformRandomNumberGenerator>
void shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
             _UniformRandomNumberGenerator &&__g) {
  typedef typename iterator_traits<_RandomAccessIterator>::difference_type
      difference_type;
  typedef uniform_int_distribution<ptrdiff_t> _Dp;
  typedef typename _Dp::param_type _Pp;
  difference_type __d = __last - __first;
  if (__d > 1) {
    _Dp __uid;
    for (--__last, (void)--__d; __first < __last; ++__first, (void)--__d) {
      difference_type __i = __uid(__g, _Pp(0, __d));
      if (__i != difference_type(0))
        swap(*__first, *(__first + __i));
    }
  }
}

template <class _InputIterator, class _Predicate>
bool is_partitioned(_InputIterator __first, _InputIterator __last,
                    _Predicate __pred) {
  for (; __first != __last; ++__first)
    if (!__pred(*__first))
      break;
  if (__first == __last)
    return true;
  ++__first;
  for (; __first != __last; ++__first)
    if (__pred(*__first))
      return false;
  return true;
}

template <class _Predicate, class _ForwardIterator>
_ForwardIterator __partition(_ForwardIterator __first, _ForwardIterator __last,
                             _Predicate __pred, forward_iterator_tag) {
  while (true) {
    if (__first == __last)
      return __first;
    if (!__pred(*__first))
      break;
    ++__first;
  }
  for (_ForwardIterator __p = __first; ++__p != __last;) {
    if (__pred(*__p)) {
      swap(*__first, *__p);
      ++__first;
    }
  }
  return __first;
}

template <class _Predicate, class _BidirectionalIterator>
_BidirectionalIterator
__partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
            _Predicate __pred, bidirectional_iterator_tag) {
  while (true) {
    while (true) {
      if (__first == __last)
        return __first;
      if (!__pred(*__first))
        break;
      ++__first;
    }
    do {
      if (__first == --__last)
        return __first;
    } while (!__pred(*__last));
    swap(*__first, *__last);
    ++__first;
  }
}

template <class _ForwardIterator, class _Predicate>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _ForwardIterator
partition(_ForwardIterator __first, _ForwardIterator __last,
          _Predicate __pred) {
  return std::__1::__partition<typename add_lvalue_reference<_Predicate>::type>(
      __first, __last, __pred,
      typename iterator_traits<_ForwardIterator>::iterator_category());
}

template <class _InputIterator, class _OutputIterator1, class _OutputIterator2,
          class _Predicate>
pair<_OutputIterator1, _OutputIterator2>
partition_copy(_InputIterator __first, _InputIterator __last,
               _OutputIterator1 __out_true, _OutputIterator2 __out_false,
               _Predicate __pred) {
  for (; __first != __last; ++__first) {
    if (__pred(*__first)) {
      *__out_true = *__first;
      ++__out_true;
    } else {
      *__out_false = *__first;
      ++__out_false;
    }
  }
  return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
}

template <class _ForwardIterator, class _Predicate>
_ForwardIterator partition_point(_ForwardIterator __first,
                                 _ForwardIterator __last, _Predicate __pred) {
  typedef typename iterator_traits<_ForwardIterator>::difference_type
      difference_type;
  difference_type __len = std::__1::distance(__first, __last);
  while (__len != 0) {
    difference_type __l2 = std::__1::__half_positive(__len);
    _ForwardIterator __m = __first;
    std::__1::advance(__m, __l2);
    if (__pred(*__m)) {
      __first = ++__m;
      __len -= __l2 + 1;
    } else
      __len = __l2;
  }
  return __first;
}

template <class _Predicate, class _ForwardIterator, class _Distance,
          class _Pair>
_ForwardIterator __stable_partition(_ForwardIterator __first,
                                    _ForwardIterator __last, _Predicate __pred,
                                    _Distance __len, _Pair __p,
                                    forward_iterator_tag __fit) {

  if (__len == 1)
    return __first;
  if (__len == 2) {
    _ForwardIterator __m = __first;
    if (__pred(*++__m)) {
      swap(*__first, *__m);
      return __m;
    }
    return __first;
  }
  if (__len <= __p.second) {
    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
    __destruct_n __d(0);
    unique_ptr<value_type, __destruct_n &> __h(__p.first, __d);

    value_type *__t = __p.first;
    ::new (__t) value_type(std::__1::move(*__first));
    __d.__incr((value_type *)0);
    ++__t;
    _ForwardIterator __i = __first;
    while (++__i != __last) {
      if (__pred(*__i)) {
        *__first = std::__1::move(*__i);
        ++__first;
      } else {
        ::new (__t) value_type(std::__1::move(*__i));
        __d.__incr((value_type *)0);
        ++__t;
      }
    }

    __i = __first;
    for (value_type *__t2 = __p.first; __t2 < __t; ++__t2, (void)++__i)
      *__i = std::__1::move(*__t2);

    return __first;
  }

  _ForwardIterator __m = __first;
  _Distance __len2 = __len / 2;
  std::__1::advance(__m, __len2);

  typedef typename add_lvalue_reference<_Predicate>::type _PredRef;
  _ForwardIterator __first_false =
      __stable_partition<_PredRef>(__first, __m, __pred, __len2, __p, __fit);

  _ForwardIterator __m1 = __m;
  _ForwardIterator __second_false = __last;
  _Distance __len_half = __len - __len2;
  while (__pred(*__m1)) {
    if (++__m1 == __last)
      goto __second_half_done;
    --__len_half;
  }

  __second_false = __stable_partition<_PredRef>(__m1, __last, __pred,
                                                __len_half, __p, __fit);
__second_half_done:

  return std::__1::rotate(__first_false, __m, __second_false);
}

struct __return_temporary_buffer {
  template <class _Tp>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  operator()(_Tp *__p) const {
    std::__1::return_temporary_buffer(__p);
  }
};

template <class _Predicate, class _ForwardIterator>
_ForwardIterator __stable_partition(_ForwardIterator __first,
                                    _ForwardIterator __last, _Predicate __pred,
                                    forward_iterator_tag) {
  const unsigned __alloc_limit = 3;

  while (true) {
    if (__first == __last)
      return __first;
    if (!__pred(*__first))
      break;
    ++__first;
  }

  typedef typename iterator_traits<_ForwardIterator>::difference_type
      difference_type;
  typedef typename iterator_traits<_ForwardIterator>::value_type value_type;
  difference_type __len = std::__1::distance(__first, __last);
  pair<value_type *, ptrdiff_t> __p(0, 0);
  unique_ptr<value_type, __return_temporary_buffer> __h;
  if (__len >= __alloc_limit) {
    __p = std::__1::get_temporary_buffer<value_type>(__len);
    __h.reset(__p.first);
  }
  return __stable_partition<typename add_lvalue_reference<_Predicate>::type>(
      __first, __last, __pred, __len, __p, forward_iterator_tag());
}

template <class _Predicate, class _BidirectionalIterator, class _Distance,
          class _Pair>
_BidirectionalIterator __stable_partition(_BidirectionalIterator __first,
                                          _BidirectionalIterator __last,
                                          _Predicate __pred, _Distance __len,
                                          _Pair __p,
                                          bidirectional_iterator_tag __bit) {

  if (__len == 2) {
    swap(*__first, *__last);
    return __last;
  }
  if (__len == 3) {
    _BidirectionalIterator __m = __first;
    if (__pred(*++__m)) {
      swap(*__first, *__m);
      swap(*__m, *__last);
      return __last;
    }
    swap(*__m, *__last);
    swap(*__first, *__m);
    return __m;
  }
  if (__len <= __p.second) {
    typedef
        typename iterator_traits<_BidirectionalIterator>::value_type value_type;
    __destruct_n __d(0);
    unique_ptr<value_type, __destruct_n &> __h(__p.first, __d);

    value_type *__t = __p.first;
    ::new (__t) value_type(std::__1::move(*__first));
    __d.__incr((value_type *)0);
    ++__t;
    _BidirectionalIterator __i = __first;
    while (++__i != __last) {
      if (__pred(*__i)) {
        *__first = std::__1::move(*__i);
        ++__first;
      } else {
        ::new (__t) value_type(std::__1::move(*__i));
        __d.__incr((value_type *)0);
        ++__t;
      }
    }

    *__first = std::__1::move(*__i);
    __i = ++__first;

    for (value_type *__t2 = __p.first; __t2 < __t; ++__t2, (void)++__i)
      *__i = std::__1::move(*__t2);

    return __first;
  }

  _BidirectionalIterator __m = __first;
  _Distance __len2 = __len / 2;
  std::__1::advance(__m, __len2);

  _BidirectionalIterator __m1 = __m;
  _BidirectionalIterator __first_false = __first;
  _Distance __len_half = __len2;
  while (!__pred(*--__m1)) {
    if (__m1 == __first)
      goto __first_half_done;
    --__len_half;
  }

  typedef typename add_lvalue_reference<_Predicate>::type _PredRef;
  __first_false = __stable_partition<_PredRef>(__first, __m1, __pred,
                                               __len_half, __p, __bit);
__first_half_done:

  __m1 = __m;
  _BidirectionalIterator __second_false = __last;
  ++__second_false;
  __len_half = __len - __len2;
  while (__pred(*__m1)) {
    if (++__m1 == __last)
      goto __second_half_done;
    --__len_half;
  }

  __second_false = __stable_partition<_PredRef>(__m1, __last, __pred,
                                                __len_half, __p, __bit);
__second_half_done:

  return std::__1::rotate(__first_false, __m, __second_false);
}

template <class _Predicate, class _BidirectionalIterator>
_BidirectionalIterator __stable_partition(_BidirectionalIterator __first,
                                          _BidirectionalIterator __last,
                                          _Predicate __pred,
                                          bidirectional_iterator_tag) {
  typedef typename iterator_traits<_BidirectionalIterator>::difference_type
      difference_type;
  typedef
      typename iterator_traits<_BidirectionalIterator>::value_type value_type;
  const difference_type __alloc_limit = 4;

  while (true) {
    if (__first == __last)
      return __first;
    if (!__pred(*__first))
      break;
    ++__first;
  }

  do {
    if (__first == --__last)
      return __first;
  } while (!__pred(*__last));

  difference_type __len = std::__1::distance(__first, __last) + 1;
  pair<value_type *, ptrdiff_t> __p(0, 0);
  unique_ptr<value_type, __return_temporary_buffer> __h;
  if (__len >= __alloc_limit) {
    __p = std::__1::get_temporary_buffer<value_type>(__len);
    __h.reset(__p.first);
  }
  return __stable_partition<typename add_lvalue_reference<_Predicate>::type>(
      __first, __last, __pred, __len, __p, bidirectional_iterator_tag());
}

template <class _ForwardIterator, class _Predicate>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _ForwardIterator
stable_partition(_ForwardIterator __first, _ForwardIterator __last,
                 _Predicate __pred) {
  return __stable_partition<typename add_lvalue_reference<_Predicate>::type>(
      __first, __last, __pred,
      typename iterator_traits<_ForwardIterator>::iterator_category());
}

template <class _ForwardIterator, class _Compare>
_ForwardIterator is_sorted_until(_ForwardIterator __first,
                                 _ForwardIterator __last, _Compare __comp) {
  if (__first != __last) {
    _ForwardIterator __i = __first;
    while (++__i != __last) {
      if (__comp(*__i, *__first))
        return __i;
      __first = __i;
    }
  }
  return __last;
}

template <class _ForwardIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _ForwardIterator
is_sorted_until(_ForwardIterator __first, _ForwardIterator __last) {
  return std::__1::is_sorted_until(
      __first, __last,
      __less<typename iterator_traits<_ForwardIterator>::value_type>());
}

template <class _ForwardIterator, class _Compare>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
is_sorted(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp) {
  return std::__1::is_sorted_until(__first, __last, __comp) == __last;
}

template <class _ForwardIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
is_sorted(_ForwardIterator __first, _ForwardIterator __last) {
  return std::__1::is_sorted(
      __first, __last,
      __less<typename iterator_traits<_ForwardIterator>::value_type>());
}

template <class _Compare, class _ForwardIterator>
unsigned __sort3(_ForwardIterator __x, _ForwardIterator __y,
                 _ForwardIterator __z, _Compare __c) {
  unsigned __r = 0;
  if (!__c(*__y, *__x)) {
    if (!__c(*__z, *__y))
      return __r;

    swap(*__y, *__z);
    __r = 1;
    if (__c(*__y, *__x)) {
      swap(*__x, *__y);
      __r = 2;
    }
    return __r;
  }
  if (__c(*__z, *__y)) {
    swap(*__x, *__z);
    __r = 1;
    return __r;
  }
  swap(*__x, *__y);
  __r = 1;
  if (__c(*__z, *__y)) {
    swap(*__y, *__z);
    __r = 2;
  }
  return __r;
}

template <class _Compare, class _ForwardIterator>
unsigned __sort4(_ForwardIterator __x1, _ForwardIterator __x2,
                 _ForwardIterator __x3, _ForwardIterator __x4, _Compare __c) {
  unsigned __r = __sort3<_Compare>(__x1, __x2, __x3, __c);
  if (__c(*__x4, *__x3)) {
    swap(*__x3, *__x4);
    ++__r;
    if (__c(*__x3, *__x2)) {
      swap(*__x2, *__x3);
      ++__r;
      if (__c(*__x2, *__x1)) {
        swap(*__x1, *__x2);
        ++__r;
      }
    }
  }
  return __r;
}

template <class _Compare, class _ForwardIterator>
__attribute__((__visibility__("hidden"))) unsigned
__sort5(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,
        _ForwardIterator __x4, _ForwardIterator __x5, _Compare __c) {
  unsigned __r = __sort4<_Compare>(__x1, __x2, __x3, __x4, __c);
  if (__c(*__x5, *__x4)) {
    swap(*__x4, *__x5);
    ++__r;
    if (__c(*__x4, *__x3)) {
      swap(*__x3, *__x4);
      ++__r;
      if (__c(*__x3, *__x2)) {
        swap(*__x2, *__x3);
        ++__r;
        if (__c(*__x2, *__x1)) {
          swap(*__x1, *__x2);
          ++__r;
        }
      }
    }
  }
  return __r;
}

template <class _Compare, class _BirdirectionalIterator>
void __selection_sort(_BirdirectionalIterator __first,
                      _BirdirectionalIterator __last, _Compare __comp) {
  _BirdirectionalIterator __lm1 = __last;
  for (--__lm1; __first != __lm1; ++__first) {
    _BirdirectionalIterator __i =
        std::__1::min_element<_BirdirectionalIterator,
                              typename add_lvalue_reference<_Compare>::type>(
            __first, __last, __comp);
    if (__i != __first)
      swap(*__first, *__i);
  }
}

template <class _Compare, class _BirdirectionalIterator>
void __insertion_sort(_BirdirectionalIterator __first,
                      _BirdirectionalIterator __last, _Compare __comp) {
  typedef
      typename iterator_traits<_BirdirectionalIterator>::value_type value_type;
  if (__first != __last) {
    _BirdirectionalIterator __i = __first;
    for (++__i; __i != __last; ++__i) {
      _BirdirectionalIterator __j = __i;
      value_type __t(std::__1::move(*__j));
      for (_BirdirectionalIterator __k = __i;
           __k != __first && __comp(__t, *--__k); --__j)
        *__j = std::__1::move(*__k);
      *__j = std::__1::move(__t);
    }
  }
}

template <class _Compare, class _RandomAccessIterator>
void __insertion_sort_3(_RandomAccessIterator __first,
                        _RandomAccessIterator __last, _Compare __comp) {
  typedef
      typename iterator_traits<_RandomAccessIterator>::value_type value_type;
  _RandomAccessIterator __j = __first + 2;
  __sort3<_Compare>(__first, __first + 1, __j, __comp);
  for (_RandomAccessIterator __i = __j + 1; __i != __last; ++__i) {
    if (__comp(*__i, *__j)) {
      value_type __t(std::__1::move(*__i));
      _RandomAccessIterator __k = __j;
      __j = __i;
      do {
        *__j = std::__1::move(*__k);
        __j = __k;
      } while (__j != __first && __comp(__t, *--__k));
      *__j = std::__1::move(__t);
    }
    __j = __i;
  }
}

template <class _Compare, class _RandomAccessIterator>
bool __insertion_sort_incomplete(_RandomAccessIterator __first,
                                 _RandomAccessIterator __last,
                                 _Compare __comp) {
  switch (__last - __first) {
  case 0:
  case 1:
    return true;
  case 2:
    if (__comp(*--__last, *__first))
      swap(*__first, *__last);
    return true;
  case 3:
    std::__1::__sort3<_Compare>(__first, __first + 1, --__last, __comp);
    return true;
  case 4:
    std::__1::__sort4<_Compare>(__first, __first + 1, __first + 2, --__last,
                                __comp);
    return true;
  case 5:
    std::__1::__sort5<_Compare>(__first, __first + 1, __first + 2, __first + 3,
                                --__last, __comp);
    return true;
  }
  typedef
      typename iterator_traits<_RandomAccessIterator>::value_type value_type;
  _RandomAccessIterator __j = __first + 2;
  __sort3<_Compare>(__first, __first + 1, __j, __comp);
  const unsigned __limit = 8;
  unsigned __count = 0;
  for (_RandomAccessIterator __i = __j + 1; __i != __last; ++__i) {
    if (__comp(*__i, *__j)) {
      value_type __t(std::__1::move(*__i));
      _RandomAccessIterator __k = __j;
      __j = __i;
      do {
        *__j = std::__1::move(*__k);
        __j = __k;
      } while (__j != __first && __comp(__t, *--__k));
      *__j = std::__1::move(__t);
      if (++__count == __limit)
        return ++__i == __last;
    }
    __j = __i;
  }
  return true;
}

template <class _Compare, class _BirdirectionalIterator>
void __insertion_sort_move(
    _BirdirectionalIterator __first1, _BirdirectionalIterator __last1,
    typename iterator_traits<_BirdirectionalIterator>::value_type *__first2,
    _Compare __comp) {
  typedef
      typename iterator_traits<_BirdirectionalIterator>::value_type value_type;
  if (__first1 != __last1) {
    __destruct_n __d(0);
    unique_ptr<value_type, __destruct_n &> __h(__first2, __d);
    value_type *__last2 = __first2;
    ::new (__last2) value_type(std::__1::move(*__first1));
    __d.__incr((value_type *)0);
    for (++__last2; ++__first1 != __last1; ++__last2) {
      value_type *__j2 = __last2;
      value_type *__i2 = __j2;
      if (__comp(*__first1, *--__i2)) {
        ::new (__j2) value_type(std::__1::move(*__i2));
        __d.__incr((value_type *)0);
        for (--__j2; __i2 != __first2 && __comp(*__first1, *--__i2); --__j2)
          *__j2 = std::__1::move(*__i2);
        *__j2 = std::__1::move(*__first1);
      } else {
        ::new (__j2) value_type(std::__1::move(*__first1));
        __d.__incr((value_type *)0);
      }
    }
    __h.release();
  }
}

template <class _Compare, class _RandomAccessIterator>
void __sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
            _Compare __comp) {

  typedef typename iterator_traits<_RandomAccessIterator>::difference_type
      difference_type;
  typedef
      typename iterator_traits<_RandomAccessIterator>::value_type value_type;
  const difference_type __limit =
      is_trivially_copy_constructible<value_type>::value &&
              is_trivially_copy_assignable<value_type>::value
          ? 30
          : 6;
  while (true) {
  __restart:
    difference_type __len = __last - __first;
    switch (__len) {
    case 0:
    case 1:
      return;
    case 2:
      if (__comp(*--__last, *__first))
        swap(*__first, *__last);
      return;
    case 3:
      std::__1::__sort3<_Compare>(__first, __first + 1, --__last, __comp);
      return;
    case 4:
      std::__1::__sort4<_Compare>(__first, __first + 1, __first + 2, --__last,
                                  __comp);
      return;
    case 5:
      std::__1::__sort5<_Compare>(__first, __first + 1, __first + 2,
                                  __first + 3, --__last, __comp);
      return;
    }
    if (__len <= __limit) {
      std::__1::__insertion_sort_3<_Compare>(__first, __last, __comp);
      return;
    }

    _RandomAccessIterator __m = __first;
    _RandomAccessIterator __lm1 = __last;
    --__lm1;
    unsigned __n_swaps;
    {
      difference_type __delta;
      if (__len >= 1000) {
        __delta = __len / 2;
        __m += __delta;
        __delta /= 2;
        __n_swaps = std::__1::__sort5<_Compare>(__first, __first + __delta, __m,
                                                __m + __delta, __lm1, __comp);
      } else {
        __delta = __len / 2;
        __m += __delta;
        __n_swaps = std::__1::__sort3<_Compare>(__first, __m, __lm1, __comp);
      }
    }

    _RandomAccessIterator __i = __first;
    _RandomAccessIterator __j = __lm1;

    if (!__comp(*__i, *__m)) {

      while (true) {
        if (__i == --__j) {

          ++__i;
          __j = __last;
          if (!__comp(*__first, *--__j)) {
            while (true) {
              if (__i == __j)
                return;
              if (__comp(*__first, *__i)) {
                swap(*__i, *__j);
                ++__n_swaps;
                ++__i;
                break;
              }
              ++__i;
            }
          }

          if (__i == __j)
            return;
          while (true) {
            while (!__comp(*__first, *__i))
              ++__i;
            while (__comp(*__first, *--__j))
              ;
            if (__i >= __j)
              break;
            swap(*__i, *__j);
            ++__n_swaps;
            ++__i;
          }

          __first = __i;
          goto __restart;
        }
        if (__comp(*__j, *__m)) {
          swap(*__i, *__j);
          ++__n_swaps;
          break;
        }
      }
    }

    ++__i;

    if (__i < __j) {

      while (true) {

        while (__comp(*__i, *__m))
          ++__i;

        while (!__comp(*--__j, *__m))
          ;
        if (__i > __j)
          break;
        swap(*__i, *__j);
        ++__n_swaps;

        if (__m == __i)
          __m = __j;
        ++__i;
      }
    }

    if (__i != __m && __comp(*__m, *__i)) {
      swap(*__i, *__m);
      ++__n_swaps;
    }

    if (__n_swaps == 0) {
      bool __fs =
          std::__1::__insertion_sort_incomplete<_Compare>(__first, __i, __comp);
      if (std::__1::__insertion_sort_incomplete<_Compare>(__i + 1, __last,
                                                          __comp)) {
        if (__fs)
          return;
        __last = __i;
        continue;
      } else {
        if (__fs) {
          __first = ++__i;
          continue;
        }
      }
    }

    if (__i - __first < __last - __i) {
      std::__1::__sort<_Compare>(__first, __i, __comp);

      __first = ++__i;
    } else {
      std::__1::__sort<_Compare>(__i + 1, __last, __comp);

      __last = __i;
    }
  }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _Compare __comp) {
  typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
  std::__1::__sort<_Comp_ref>(__first, __last, _Comp_ref(__comp));
}

template <class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
sort(_RandomAccessIterator __first, _RandomAccessIterator __last) {
  std::__1::sort(
      __first, __last,
      __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
sort(_Tp **__first, _Tp **__last) {
  std::__1::sort((size_t *)__first, (size_t *)__last, __less<size_t>());
}

template <class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
sort(__wrap_iter<_Tp *> __first, __wrap_iter<_Tp *> __last) {
  std::__1::sort(__first.base(), __last.base());
}

template <class _Tp, class _Compare>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
sort(__wrap_iter<_Tp *> __first, __wrap_iter<_Tp *> __last, _Compare __comp) {
  typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
  std::__1::sort<_Tp *, _Comp_ref>(__first.base(), __last.base(), __comp);
}

extern template __attribute__((__visibility__("default"))) void
__sort<__less<char> &, char *>(char *, char *, __less<char> &);
extern template __attribute__((__visibility__("default"))) void
__sort<__less<wchar_t> &, wchar_t *>(wchar_t *, wchar_t *, __less<wchar_t> &);
extern template __attribute__((__visibility__("default"))) void
__sort<__less<signed char> &, signed char *>(signed char *, signed char *,
                                             __less<signed char> &);
extern template __attribute__((__visibility__("default"))) void
__sort<__less<unsigned char> &, unsigned char *>(unsigned char *,
                                                 unsigned char *,
                                                 __less<unsigned char> &);
extern template __attribute__((__visibility__("default"))) void
__sort<__less<short> &, short *>(short *, short *, __less<short> &);
extern template __attribute__((__visibility__("default"))) void
__sort<__less<unsigned short> &, unsigned short *>(unsigned short *,
                                                   unsigned short *,
                                                   __less<unsigned short> &);
extern template __attribute__((__visibility__("default"))) void
__sort<__less<int> &, int *>(int *, int *, __less<int> &);
extern template __attribute__((__visibility__("default"))) void
__sort<__less<unsigned> &, unsigned *>(unsigned *, unsigned *,
                                       __less<unsigned> &);
extern template __attribute__((__visibility__("default"))) void
__sort<__less<long> &, long *>(long *, long *, __less<long> &);
extern template __attribute__((__visibility__("default"))) void
__sort<__less<unsigned long> &, unsigned long *>(unsigned long *,
                                                 unsigned long *,
                                                 __less<unsigned long> &);
extern template __attribute__((__visibility__("default"))) void
__sort<__less<long long> &, long long *>(long long *, long long *,
                                         __less<long long> &);
extern template __attribute__((__visibility__("default"))) void
__sort<__less<unsigned long long> &, unsigned long long *>(
    unsigned long long *, unsigned long long *, __less<unsigned long long> &);
extern template __attribute__((__visibility__("default"))) void
__sort<__less<float> &, float *>(float *, float *, __less<float> &);
extern template __attribute__((__visibility__("default"))) void
__sort<__less<double> &, double *>(double *, double *, __less<double> &);
extern template __attribute__((__visibility__("default"))) void
__sort<__less<long double> &, long double *>(long double *, long double *,
                                             __less<long double> &);

extern template __attribute__((__visibility__("default"))) bool
__insertion_sort_incomplete<__less<char> &, char *>(char *, char *,
                                                    __less<char> &);
extern template __attribute__((__visibility__("default"))) bool
__insertion_sort_incomplete<__less<wchar_t> &, wchar_t *>(wchar_t *, wchar_t *,
                                                          __less<wchar_t> &);
extern template __attribute__((__visibility__("default"))) bool
__insertion_sort_incomplete<__less<signed char> &, signed char *>(
    signed char *, signed char *, __less<signed char> &);
extern template __attribute__((__visibility__("default"))) bool
__insertion_sort_incomplete<__less<unsigned char> &, unsigned char *>(
    unsigned char *, unsigned char *, __less<unsigned char> &);
extern template __attribute__((__visibility__("default"))) bool
__insertion_sort_incomplete<__less<short> &, short *>(short *, short *,
                                                      __less<short> &);
extern template __attribute__((__visibility__("default"))) bool
__insertion_sort_incomplete<__less<unsigned short> &, unsigned short *>(
    unsigned short *, unsigned short *, __less<unsigned short> &);
extern template __attribute__((__visibility__("default"))) bool
__insertion_sort_incomplete<__less<int> &, int *>(int *, int *, __less<int> &);
extern template __attribute__((__visibility__("default"))) bool
__insertion_sort_incomplete<__less<unsigned> &, unsigned *>(unsigned *,
                                                            unsigned *,
                                                            __less<unsigned> &);
extern template __attribute__((__visibility__("default"))) bool
__insertion_sort_incomplete<__less<long> &, long *>(long *, long *,
                                                    __less<long> &);
extern template __attribute__((__visibility__("default"))) bool
__insertion_sort_incomplete<__less<unsigned long> &, unsigned long *>(
    unsigned long *, unsigned long *, __less<unsigned long> &);
extern template __attribute__((__visibility__("default"))) bool
__insertion_sort_incomplete<__less<long long> &, long long *>(
    long long *, long long *, __less<long long> &);
extern template __attribute__((__visibility__("default"))) bool
__insertion_sort_incomplete<__less<unsigned long long> &, unsigned long long *>(
    unsigned long long *, unsigned long long *, __less<unsigned long long> &);
extern template __attribute__((__visibility__("default"))) bool
__insertion_sort_incomplete<__less<float> &, float *>(float *, float *,
                                                      __less<float> &);
extern template __attribute__((__visibility__("default"))) bool
__insertion_sort_incomplete<__less<double> &, double *>(double *, double *,
                                                        __less<double> &);
extern template __attribute__((__visibility__("default"))) bool
__insertion_sort_incomplete<__less<long double> &, long double *>(
    long double *, long double *, __less<long double> &);

extern template __attribute__((__visibility__("default"))) unsigned
__sort5<__less<long double> &, long double *>(long double *, long double *,
                                              long double *, long double *,
                                              long double *,
                                              __less<long double> &);

template <class _Compare, class _ForwardIterator, class _Tp>
_ForwardIterator __lower_bound(_ForwardIterator __first,
                               _ForwardIterator __last, const _Tp &__value_,
                               _Compare __comp) {
  typedef typename iterator_traits<_ForwardIterator>::difference_type
      difference_type;
  difference_type __len = std::__1::distance(__first, __last);
  while (__len != 0) {
    difference_type __l2 = std::__1::__half_positive(__len);
    _ForwardIterator __m = __first;
    std::__1::advance(__m, __l2);
    if (__comp(*__m, __value_)) {
      __first = ++__m;
      __len -= __l2 + 1;
    } else
      __len = __l2;
  }
  return __first;
}

template <class _ForwardIterator, class _Tp, class _Compare>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _ForwardIterator
lower_bound(_ForwardIterator __first, _ForwardIterator __last,
            const _Tp &__value_, _Compare __comp) {
  typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
  return __lower_bound<_Comp_ref>(__first, __last, __value_, __comp);
}

template <class _ForwardIterator, class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _ForwardIterator
lower_bound(_ForwardIterator __first, _ForwardIterator __last,
            const _Tp &__value_) {
  return std::__1::lower_bound(
      __first, __last, __value_,
      __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}

template <class _Compare, class _ForwardIterator, class _Tp>
_ForwardIterator __upper_bound(_ForwardIterator __first,
                               _ForwardIterator __last, const _Tp &__value_,
                               _Compare __comp) {
  typedef typename iterator_traits<_ForwardIterator>::difference_type
      difference_type;
  difference_type __len = std::__1::distance(__first, __last);
  while (__len != 0) {
    difference_type __l2 = std::__1::__half_positive(__len);
    _ForwardIterator __m = __first;
    std::__1::advance(__m, __l2);
    if (__comp(__value_, *__m))
      __len = __l2;
    else {
      __first = ++__m;
      __len -= __l2 + 1;
    }
  }
  return __first;
}

template <class _ForwardIterator, class _Tp, class _Compare>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _ForwardIterator
upper_bound(_ForwardIterator __first, _ForwardIterator __last,
            const _Tp &__value_, _Compare __comp) {
  typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;
  return __upper_bound<_Comp_ref>(__first, __last, __value_, __comp);
}

template <class _ForwardIterator, class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _ForwardIterator
upper_bound(_ForwardIterator __first, _ForwardIterator __last,
            const _Tp &__value_) {
  return std::__1::upper_bound(
      __first, __last, __value_,
      __less<_Tp, typename iterator_traits<_ForwardIterator>::value_type>());
}

template <class _Compare, class _ForwardIterator, class _Tp>
pair<_ForwardIterator, _ForwardIterator>
__equal_range(_ForwardIterator __first, _ForwardIterator __last,
              const _Tp &__value_, _Compare __comp) {
  typedef typename iterator_traits<_ForwardIterator>::difference_type
      difference_type;
  difference_type __len = std::__1::distance(__first, __last);
  while (__len != 0) {
    difference_type __l2 = std::__1::__half_positive(__len);
    _ForwardIterator __m = __first;
    std::__1::advance(__m, __l2);
    if (__comp(*__m, __value_)) {
      __first = ++__m;
      __len -= __l2 + 1;
    } else if (__comp(__value_, *__m)) {
      __last = __m;
      __len = __l2;
    } else {
      _ForwardIterator __mp1 = __m;
      return pair<_ForwardIterator, _ForwardIterator>(
          __lower_bound<_Compare>(__first, __m, __value_, __comp),
          __upper_bound<_Compare>(++__mp1, __last, __value_, __comp));
    }
  }
  return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
}

template <class _ForwardIterator, class _Tp, class _Compare>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) pair<_ForwardIterator, _ForwardIterator>
equal_range(_ForwardIterator __first, _ForwardIterator __last,
            const _Tp &__value_, _Compare __comp) {
  typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
  return __equal_range<_Comp_ref>(__first, __last, __value_, __comp);
}

template <class _ForwardIterator, class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) pair<_ForwardIterator, _ForwardIterator>
equal_range(_ForwardIterator __first, _ForwardIterator __last,
            const _Tp &__value_) {
  return std::__1::equal_range(
      __first, __last, __value_,
      __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}

template <class _Compare, class _ForwardIterator, class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
__binary_search(_ForwardIterator __first, _ForwardIterator __last,
                const _Tp &__value_, _Compare __comp) {
  __first = __lower_bound<_Compare>(__first, __last, __value_, __comp);
  return __first != __last && !__comp(__value_, *__first);
}

template <class _ForwardIterator, class _Tp, class _Compare>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
binary_search(_ForwardIterator __first, _ForwardIterator __last,
              const _Tp &__value_, _Compare __comp) {
  typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
  return __binary_search<_Comp_ref>(__first, __last, __value_, __comp);
}

template <class _ForwardIterator, class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
binary_search(_ForwardIterator __first, _ForwardIterator __last,
              const _Tp &__value_) {
  return std::__1::binary_search(
      __first, __last, __value_,
      __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());
}

template <class _Compare, class _InputIterator1, class _InputIterator2,
          class _OutputIterator>
_OutputIterator __merge(_InputIterator1 __first1, _InputIterator1 __last1,
                        _InputIterator2 __first2, _InputIterator2 __last2,
                        _OutputIterator __result, _Compare __comp) {
  for (; __first1 != __last1; ++__result) {
    if (__first2 == __last2)
      return std::__1::copy(__first1, __last1, __result);
    if (__comp(*__first2, *__first1)) {
      *__result = *__first2;
      ++__first2;
    } else {
      *__result = *__first1;
      ++__first1;
    }
  }
  return std::__1::copy(__first2, __last2, __result);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator,
          class _Compare>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _OutputIterator
merge(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _OutputIterator __result, _Compare __comp) {
  typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
  return std::__1::__merge<_Comp_ref>(__first1, __last1, __first2, __last2,
                                      __result, __comp);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _OutputIterator
merge(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _OutputIterator __result) {
  typedef typename iterator_traits<_InputIterator1>::value_type __v1;
  typedef typename iterator_traits<_InputIterator2>::value_type __v2;
  return std::__1::merge(__first1, __last1, __first2, __last2, __result,
                         __less<__v1, __v2>());
}

template <class _Compare, class _InputIterator1, class _InputIterator2,
          class _OutputIterator>
void __half_inplace_merge(_InputIterator1 __first1, _InputIterator1 __last1,
                          _InputIterator2 __first2, _InputIterator2 __last2,
                          _OutputIterator __result, _Compare __comp) {
  for (; __first1 != __last1; ++__result) {
    if (__first2 == __last2) {
      std::__1::move(__first1, __last1, __result);
      return;
    }

    if (__comp(*__first2, *__first1)) {
      *__result = std::__1::move(*__first2);
      ++__first2;
    } else {
      *__result = std::__1::move(*__first1);
      ++__first1;
    }
  }
}

template <class _Compare, class _BidirectionalIterator>
void __buffered_inplace_merge(
    _BidirectionalIterator __first, _BidirectionalIterator __middle,
    _BidirectionalIterator __last, _Compare __comp,
    typename iterator_traits<_BidirectionalIterator>::difference_type __len1,
    typename iterator_traits<_BidirectionalIterator>::difference_type __len2,
    typename iterator_traits<_BidirectionalIterator>::value_type *__buff) {
  typedef
      typename iterator_traits<_BidirectionalIterator>::value_type value_type;
  __destruct_n __d(0);
  unique_ptr<value_type, __destruct_n &> __h2(__buff, __d);
  if (__len1 <= __len2) {
    value_type *__p = __buff;
    for (_BidirectionalIterator __i = __first; __i != __middle;
         __d.__incr((value_type *)0), (void)++__i, (void)++__p)
      ::new (__p) value_type(std::__1::move(*__i));
    __half_inplace_merge(__buff, __p, __middle, __last, __first, __comp);
  } else {
    value_type *__p = __buff;
    for (_BidirectionalIterator __i = __middle; __i != __last;
         __d.__incr((value_type *)0), (void)++__i, (void)++__p)
      ::new (__p) value_type(std::__1::move(*__i));
    typedef reverse_iterator<_BidirectionalIterator> _RBi;
    typedef reverse_iterator<value_type *> _Rv;
    __half_inplace_merge(_Rv(__p), _Rv(__buff), _RBi(__middle), _RBi(__first),
                         _RBi(__last), __invert<_Compare>(__comp));
  }
}

template <class _Compare, class _BidirectionalIterator>
void __inplace_merge(
    _BidirectionalIterator __first, _BidirectionalIterator __middle,
    _BidirectionalIterator __last, _Compare __comp,
    typename iterator_traits<_BidirectionalIterator>::difference_type __len1,
    typename iterator_traits<_BidirectionalIterator>::difference_type __len2,
    typename iterator_traits<_BidirectionalIterator>::value_type *__buff,
    ptrdiff_t __buff_size) {
  typedef typename iterator_traits<_BidirectionalIterator>::difference_type
      difference_type;
  while (true) {

    if (__len2 == 0)
      return;
    if (__len1 <= __buff_size || __len2 <= __buff_size)
      return __buffered_inplace_merge<_Compare>(__first, __middle, __last,
                                                __comp, __len1, __len2, __buff);

    for (; true; ++__first, (void)--__len1) {
      if (__len1 == 0)
        return;
      if (__comp(*__middle, *__first))
        break;
    }
# 4508 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm" 3
    _BidirectionalIterator __m1;
    _BidirectionalIterator __m2;
    difference_type __len11;
    difference_type __len21;

    if (__len1 < __len2) {
      __len21 = __len2 / 2;
      __m2 = __middle;
      std::__1::advance(__m2, __len21);
      __m1 = __upper_bound<_Compare>(__first, __middle, *__m2, __comp);
      __len11 = std::__1::distance(__first, __m1);
    } else {
      if (__len1 == 1) {

        swap(*__first, *__middle);
        return;
      }

      __len11 = __len1 / 2;
      __m1 = __first;
      std::__1::advance(__m1, __len11);
      __m2 = __lower_bound<_Compare>(__middle, __last, *__m1, __comp);
      __len21 = std::__1::distance(__middle, __m2);
    }
    difference_type __len12 = __len1 - __len11;
    difference_type __len22 = __len2 - __len21;

    __middle = std::__1::rotate(__m1, __middle, __m2);

    if (__len11 + __len21 < __len12 + __len22) {
      __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11,
                                __len21, __buff, __buff_size);

      __first = __middle;
      __middle = __m2;
      __len1 = __len12;
      __len2 = __len22;
    } else {
      __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12,
                                __len22, __buff, __buff_size);

      __last = __middle;
      __middle = __m1;
      __len1 = __len11;
      __len2 = __len21;
    }
  }
}

template <class _BidirectionalIterator, class _Compare>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle,
              _BidirectionalIterator __last, _Compare __comp) {
  typedef
      typename iterator_traits<_BidirectionalIterator>::value_type value_type;
  typedef typename iterator_traits<_BidirectionalIterator>::difference_type
      difference_type;
  difference_type __len1 = std::__1::distance(__first, __middle);
  difference_type __len2 = std::__1::distance(__middle, __last);
  difference_type __buf_size = std::__1::min(__len1, __len2);
  pair<value_type *, ptrdiff_t> __buf =
      std::__1::get_temporary_buffer<value_type>(__buf_size);
  unique_ptr<value_type, __return_temporary_buffer> __h(__buf.first);
  typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
  return std::__1::__inplace_merge<_Comp_ref>(__first, __middle, __last, __comp,
                                              __len1, __len2, __buf.first,
                                              __buf.second);
}

template <class _BidirectionalIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle,
              _BidirectionalIterator __last) {
  std::__1::inplace_merge(
      __first, __middle, __last,
      __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}

template <class _Compare, class _InputIterator1, class _InputIterator2>
void __merge_move_construct(
    _InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,
    _InputIterator2 __last2,
    typename iterator_traits<_InputIterator1>::value_type *__result,
    _Compare __comp) {
  typedef typename iterator_traits<_InputIterator1>::value_type value_type;
  __destruct_n __d(0);
  unique_ptr<value_type, __destruct_n &> __h(__result, __d);
  for (; true; ++__result) {
    if (__first1 == __last1) {
      for (; __first2 != __last2;
           ++__first2, ++__result, (void)__d.__incr((value_type *)0))
        ::new (__result) value_type(std::__1::move(*__first2));
      __h.release();
      return;
    }
    if (__first2 == __last2) {
      for (; __first1 != __last1;
           ++__first1, ++__result, (void)__d.__incr((value_type *)0))
        ::new (__result) value_type(std::__1::move(*__first1));
      __h.release();
      return;
    }
    if (__comp(*__first2, *__first1)) {
      ::new (__result) value_type(std::__1::move(*__first2));
      __d.__incr((value_type *)0);
      ++__first2;
    } else {
      ::new (__result) value_type(std::__1::move(*__first1));
      __d.__incr((value_type *)0);
      ++__first1;
    }
  }
}

template <class _Compare, class _InputIterator1, class _InputIterator2,
          class _OutputIterator>
void __merge_move_assign(_InputIterator1 __first1, _InputIterator1 __last1,
                         _InputIterator2 __first2, _InputIterator2 __last2,
                         _OutputIterator __result, _Compare __comp) {
  for (; __first1 != __last1; ++__result) {
    if (__first2 == __last2) {
      for (; __first1 != __last1; ++__first1, (void)++__result)
        *__result = std::__1::move(*__first1);
      return;
    }
    if (__comp(*__first2, *__first1)) {
      *__result = std::__1::move(*__first2);
      ++__first2;
    } else {
      *__result = std::__1::move(*__first1);
      ++__first1;
    }
  }
  for (; __first2 != __last2; ++__first2, (void)++__result)
    *__result = std::__1::move(*__first2);
}

template <class _Compare, class _RandomAccessIterator>
void __stable_sort(
    _RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp,
    typename iterator_traits<_RandomAccessIterator>::difference_type __len,
    typename iterator_traits<_RandomAccessIterator>::value_type *__buff,
    ptrdiff_t __buff_size);

template <class _Compare, class _RandomAccessIterator>
void __stable_sort_move(
    _RandomAccessIterator __first1, _RandomAccessIterator __last1,
    _Compare __comp,
    typename iterator_traits<_RandomAccessIterator>::difference_type __len,
    typename iterator_traits<_RandomAccessIterator>::value_type *__first2) {
  typedef
      typename iterator_traits<_RandomAccessIterator>::value_type value_type;
  switch (__len) {
  case 0:
    return;
  case 1:
    ::new (__first2) value_type(std::__1::move(*__first1));
    return;
  case 2:
    __destruct_n __d(0);
    unique_ptr<value_type, __destruct_n &> __h2(__first2, __d);
    if (__comp(*--__last1, *__first1)) {
      ::new (__first2) value_type(std::__1::move(*__last1));
      __d.__incr((value_type *)0);
      ++__first2;
      ::new (__first2) value_type(std::__1::move(*__first1));
    } else {
      ::new (__first2) value_type(std::__1::move(*__first1));
      __d.__incr((value_type *)0);
      ++__first2;
      ::new (__first2) value_type(std::__1::move(*__last1));
    }
    __h2.release();
    return;
  }
  if (__len <= 8) {
    __insertion_sort_move<_Compare>(__first1, __last1, __first2, __comp);
    return;
  }
  typename iterator_traits<_RandomAccessIterator>::difference_type __l2 =
      __len / 2;
  _RandomAccessIterator __m = __first1 + __l2;
  __stable_sort<_Compare>(__first1, __m, __comp, __l2, __first2, __l2);
  __stable_sort<_Compare>(__m, __last1, __comp, __len - __l2, __first2 + __l2,
                          __len - __l2);
  __merge_move_construct<_Compare>(__first1, __m, __m, __last1, __first2,
                                   __comp);
}

template <class _Tp> struct __stable_sort_switch {
  static const unsigned value = 128 * is_trivially_copy_assignable<_Tp>::value;
};

template <class _Compare, class _RandomAccessIterator>
void __stable_sort(
    _RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp,
    typename iterator_traits<_RandomAccessIterator>::difference_type __len,
    typename iterator_traits<_RandomAccessIterator>::value_type *__buff,
    ptrdiff_t __buff_size) {
  typedef
      typename iterator_traits<_RandomAccessIterator>::value_type value_type;
  typedef typename iterator_traits<_RandomAccessIterator>::difference_type
      difference_type;
  switch (__len) {
  case 0:
  case 1:
    return;
  case 2:
    if (__comp(*--__last, *__first))
      swap(*__first, *__last);
    return;
  }
  if (__len <=
      static_cast<difference_type>(__stable_sort_switch<value_type>::value)) {
    __insertion_sort<_Compare>(__first, __last, __comp);
    return;
  }
  typename iterator_traits<_RandomAccessIterator>::difference_type __l2 =
      __len / 2;
  _RandomAccessIterator __m = __first + __l2;
  if (__len <= __buff_size) {
    __destruct_n __d(0);
    unique_ptr<value_type, __destruct_n &> __h2(__buff, __d);
    __stable_sort_move<_Compare>(__first, __m, __comp, __l2, __buff);
    __d.__set(__l2, (value_type *)0);
    __stable_sort_move<_Compare>(__m, __last, __comp, __len - __l2,
                                 __buff + __l2);
    __d.__set(__len, (value_type *)0);
    __merge_move_assign<_Compare>(__buff, __buff + __l2, __buff + __l2,
                                  __buff + __len, __first, __comp);

    return;
  }
  __stable_sort<_Compare>(__first, __m, __comp, __l2, __buff, __buff_size);
  __stable_sort<_Compare>(__m, __last, __comp, __len - __l2, __buff,
                          __buff_size);
  __inplace_merge<_Compare>(__first, __m, __last, __comp, __l2, __len - __l2,
                            __buff, __buff_size);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
            _Compare __comp) {
  typedef
      typename iterator_traits<_RandomAccessIterator>::value_type value_type;
  typedef typename iterator_traits<_RandomAccessIterator>::difference_type
      difference_type;
  difference_type __len = __last - __first;
  pair<value_type *, ptrdiff_t> __buf(0, 0);
  unique_ptr<value_type, __return_temporary_buffer> __h;
  if (__len >
      static_cast<difference_type>(__stable_sort_switch<value_type>::value)) {
    __buf = std::__1::get_temporary_buffer<value_type>(__len);
    __h.reset(__buf.first);
  }
  typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
  __stable_sort<_Comp_ref>(__first, __last, __comp, __len, __buf.first,
                           __buf.second);
}

template <class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last) {
  std::__1::stable_sort(
      __first, __last,
      __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

template <class _RandomAccessIterator, class _Compare>
_RandomAccessIterator is_heap_until(_RandomAccessIterator __first,
                                    _RandomAccessIterator __last,
                                    _Compare __comp) {
  typedef
      typename std::__1::iterator_traits<_RandomAccessIterator>::difference_type
          difference_type;
  difference_type __len = __last - __first;
  difference_type __p = 0;
  difference_type __c = 1;
  _RandomAccessIterator __pp = __first;
  while (__c < __len) {
    _RandomAccessIterator __cp = __first + __c;
    if (__comp(*__pp, *__cp))
      return __cp;
    ++__c;
    ++__cp;
    if (__c == __len)
      return __last;
    if (__comp(*__pp, *__cp))
      return __cp;
    ++__p;
    ++__pp;
    __c = 2 * __p + 1;
  }
  return __last;
}

template <class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _RandomAccessIterator
is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last) {
  return std::__1::is_heap_until(
      __first, __last,
      __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _Compare __comp) {
  return std::__1::is_heap_until(__first, __last, __comp) == __last;
}

template <class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) {
  return std::__1::is_heap(
      __first, __last,
      __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

template <class _Compare, class _RandomAccessIterator>
void __sift_up(
    _RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp,
    typename iterator_traits<_RandomAccessIterator>::difference_type __len) {
  typedef
      typename iterator_traits<_RandomAccessIterator>::value_type value_type;
  if (__len > 1) {
    __len = (__len - 2) / 2;
    _RandomAccessIterator __ptr = __first + __len;
    if (__comp(*__ptr, *--__last)) {
      value_type __t(std::__1::move(*__last));
      do {
        *__last = std::__1::move(*__ptr);
        __last = __ptr;
        if (__len == 0)
          break;
        __len = (__len - 1) / 2;
        __ptr = __first + __len;
      } while (__comp(*__ptr, __t));
      *__last = std::__1::move(__t);
    }
  }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
          _Compare __comp) {
  typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
  __sift_up<_Comp_ref>(__first, __last, __comp, __last - __first);
}

template <class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) {
  std::__1::push_heap(
      __first, __last,
      __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

template <class _Compare, class _RandomAccessIterator>
void __sift_down(
    _RandomAccessIterator __first, _RandomAccessIterator, _Compare __comp,
    typename iterator_traits<_RandomAccessIterator>::difference_type __len,
    _RandomAccessIterator __start) {
  typedef typename iterator_traits<_RandomAccessIterator>::difference_type
      difference_type;
  typedef
      typename iterator_traits<_RandomAccessIterator>::value_type value_type;

  difference_type __child = __start - __first;

  if (__len < 2 || (__len - 2) / 2 < __child)
    return;

  __child = 2 * __child + 1;
  _RandomAccessIterator __child_i = __first + __child;

  if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {

    ++__child_i;
    ++__child;
  }

  if (__comp(*__child_i, *__start))

    return;

  value_type __top(std::__1::move(*__start));
  do {

    *__start = std::__1::move(*__child_i);
    __start = __child_i;

    if ((__len - 2) / 2 < __child)
      break;

    __child = 2 * __child + 1;
    __child_i = __first + __child;

    if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {

      ++__child_i;
      ++__child;
    }

  } while (!__comp(*__child_i, __top));
  *__start = std::__1::move(__top);
}

template <class _Compare, class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
__pop_heap(
    _RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp,
    typename iterator_traits<_RandomAccessIterator>::difference_type __len) {
  if (__len > 1) {
    swap(*__first, *--__last);
    __sift_down<_Compare>(__first, __last, __comp, __len - 1, __first);
  }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
         _Compare __comp) {
  typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
  __pop_heap<_Comp_ref>(__first, __last, __comp, __last - __first);
}

template <class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) {
  std::__1::pop_heap(
      __first, __last,
      __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

template <class _Compare, class _RandomAccessIterator>
void __make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
                 _Compare __comp) {
  typedef typename iterator_traits<_RandomAccessIterator>::difference_type
      difference_type;
  difference_type __n = __last - __first;
  if (__n > 1) {

    for (difference_type __start = (__n - 2) / 2; __start >= 0; --__start) {
      __sift_down<_Compare>(__first, __last, __comp, __n, __first + __start);
    }
  }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
          _Compare __comp) {
  typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
  __make_heap<_Comp_ref>(__first, __last, __comp);
}

template <class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) {
  std::__1::make_heap(
      __first, __last,
      __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

template <class _Compare, class _RandomAccessIterator>
void __sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
                 _Compare __comp) {
  typedef typename iterator_traits<_RandomAccessIterator>::difference_type
      difference_type;
  for (difference_type __n = __last - __first; __n > 1; --__last, (void)--__n)
    __pop_heap<_Compare>(__first, __last, __comp, __n);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
          _Compare __comp) {
  typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
  __sort_heap<_Comp_ref>(__first, __last, __comp);
}

template <class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) {
  std::__1::sort_heap(
      __first, __last,
      __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

template <class _Compare, class _RandomAccessIterator>
void __partial_sort(_RandomAccessIterator __first,
                    _RandomAccessIterator __middle,
                    _RandomAccessIterator __last, _Compare __comp) {
  __make_heap<_Compare>(__first, __middle, __comp);
  typename iterator_traits<_RandomAccessIterator>::difference_type __len =
      __middle - __first;
  for (_RandomAccessIterator __i = __middle; __i != __last; ++__i) {
    if (__comp(*__i, *__first)) {
      swap(*__i, *__first);
      __sift_down<_Compare>(__first, __middle, __comp, __len, __first);
    }
  }
  __sort_heap<_Compare>(__first, __middle, __comp);
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle,
             _RandomAccessIterator __last, _Compare __comp) {
  typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
  __partial_sort<_Comp_ref>(__first, __middle, __last, __comp);
}

template <class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle,
             _RandomAccessIterator __last) {
  std::__1::partial_sort(
      __first, __middle, __last,
      __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

template <class _Compare, class _InputIterator, class _RandomAccessIterator>
_RandomAccessIterator
__partial_sort_copy(_InputIterator __first, _InputIterator __last,
                    _RandomAccessIterator __result_first,
                    _RandomAccessIterator __result_last, _Compare __comp) {
  _RandomAccessIterator __r = __result_first;
  if (__r != __result_last) {
    for (; __first != __last && __r != __result_last; ++__first, (void)++__r)
      *__r = *__first;
    __make_heap<_Compare>(__result_first, __r, __comp);
    typename iterator_traits<_RandomAccessIterator>::difference_type __len =
        __r - __result_first;
    for (; __first != __last; ++__first)
      if (__comp(*__first, *__result_first)) {
        *__result_first = *__first;
        __sift_down<_Compare>(__result_first, __r, __comp, __len,
                              __result_first);
      }
    __sort_heap<_Compare>(__result_first, __r, __comp);
  }
  return __r;
}

template <class _InputIterator, class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _RandomAccessIterator
partial_sort_copy(_InputIterator __first, _InputIterator __last,
                  _RandomAccessIterator __result_first,
                  _RandomAccessIterator __result_last, _Compare __comp) {
  typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
  return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first,
                                        __result_last, __comp);
}

template <class _InputIterator, class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _RandomAccessIterator
partial_sort_copy(_InputIterator __first, _InputIterator __last,
                  _RandomAccessIterator __result_first,
                  _RandomAccessIterator __result_last) {
  return std::__1::partial_sort_copy(
      __first, __last, __result_first, __result_last,
      __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

template <class _Compare, class _RandomAccessIterator>
void __nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
                   _RandomAccessIterator __last, _Compare __comp) {

  typedef typename iterator_traits<_RandomAccessIterator>::difference_type
      difference_type;
  const difference_type __limit = 7;
  while (true) {
  __restart:
    if (__nth == __last)
      return;
    difference_type __len = __last - __first;
    switch (__len) {
    case 0:
    case 1:
      return;
    case 2:
      if (__comp(*--__last, *__first))
        swap(*__first, *__last);
      return;
    case 3: {
      _RandomAccessIterator __m = __first;
      std::__1::__sort3<_Compare>(__first, ++__m, --__last, __comp);
      return;
    }
    }
    if (__len <= __limit) {
      __selection_sort<_Compare>(__first, __last, __comp);
      return;
    }

    _RandomAccessIterator __m = __first + __len / 2;
    _RandomAccessIterator __lm1 = __last;
    unsigned __n_swaps =
        std::__1::__sort3<_Compare>(__first, __m, --__lm1, __comp);

    _RandomAccessIterator __i = __first;
    _RandomAccessIterator __j = __lm1;

    if (!__comp(*__i, *__m)) {

      while (true) {
        if (__i == --__j) {

          ++__i;
          __j = __last;
          if (!__comp(*__first, *--__j)) {
            while (true) {
              if (__i == __j)
                return;
              if (__comp(*__first, *__i)) {
                swap(*__i, *__j);
                ++__n_swaps;
                ++__i;
                break;
              }
              ++__i;
            }
          }

          if (__i == __j)
            return;
          while (true) {
            while (!__comp(*__first, *__i))
              ++__i;
            while (__comp(*__first, *--__j))
              ;
            if (__i >= __j)
              break;
            swap(*__i, *__j);
            ++__n_swaps;
            ++__i;
          }

          if (__nth < __i)
            return;

          __first = __i;
          goto __restart;
        }
        if (__comp(*__j, *__m)) {
          swap(*__i, *__j);
          ++__n_swaps;
          break;
        }
      }
    }
    ++__i;

    if (__i < __j) {

      while (true) {

        while (__comp(*__i, *__m))
          ++__i;

        while (!__comp(*--__j, *__m))
          ;
        if (__i >= __j)
          break;
        swap(*__i, *__j);
        ++__n_swaps;

        if (__m == __i)
          __m = __j;
        ++__i;
      }
    }

    if (__i != __m && __comp(*__m, *__i)) {
      swap(*__i, *__m);
      ++__n_swaps;
    }

    if (__nth == __i)
      return;
    if (__n_swaps == 0) {

      if (__nth < __i) {

        __j = __m = __first;
        while (++__j != __i) {
          if (__comp(*__j, *__m))

            goto not_sorted;
          __m = __j;
        }

        return;
      } else {

        __j = __m = __i;
        while (++__j != __last) {
          if (__comp(*__j, *__m))

            goto not_sorted;
          __m = __j;
        }

        return;
      }
    }
  not_sorted:

    if (__nth < __i) {

      __last = __i;
    } else {

      __first = ++__i;
    }
  }
}

template <class _RandomAccessIterator, class _Compare>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
            _RandomAccessIterator __last, _Compare __comp) {
  typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
  __nth_element<_Comp_ref>(__first, __nth, __last, __comp);
}

template <class _RandomAccessIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
            _RandomAccessIterator __last) {
  std::__1::nth_element(
      __first, __nth, __last,
      __less<typename iterator_traits<_RandomAccessIterator>::value_type>());
}

template <class _Compare, class _InputIterator1, class _InputIterator2>
bool __includes(_InputIterator1 __first1, _InputIterator1 __last1,
                _InputIterator2 __first2, _InputIterator2 __last2,
                _Compare __comp) {
  for (; __first2 != __last2; ++__first1) {
    if (__first1 == __last1 || __comp(*__first2, *__first1))
      return false;
    if (!__comp(*__first1, *__first2))
      ++__first2;
  }
  return true;
}

template <class _InputIterator1, class _InputIterator2, class _Compare>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
includes(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp) {
  typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
  return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);
}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
includes(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _InputIterator2 __last2) {
  return std::__1::includes(
      __first1, __last1, __first2, __last2,
      __less<typename iterator_traits<_InputIterator1>::value_type,
             typename iterator_traits<_InputIterator2>::value_type>());
}

template <class _Compare, class _InputIterator1, class _InputIterator2,
          class _OutputIterator>
_OutputIterator __set_union(_InputIterator1 __first1, _InputIterator1 __last1,
                            _InputIterator2 __first2, _InputIterator2 __last2,
                            _OutputIterator __result, _Compare __comp) {
  for (; __first1 != __last1; ++__result) {
    if (__first2 == __last2)
      return std::__1::copy(__first1, __last1, __result);
    if (__comp(*__first2, *__first1)) {
      *__result = *__first2;
      ++__first2;
    } else {
      if (!__comp(*__first1, *__first2))
        ++__first2;
      *__result = *__first1;
      ++__first1;
    }
  }
  return std::__1::copy(__first2, __last2, __result);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator,
          class _Compare>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _OutputIterator
set_union(_InputIterator1 __first1, _InputIterator1 __last1,
          _InputIterator2 __first2, _InputIterator2 __last2,
          _OutputIterator __result, _Compare __comp) {
  typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
  return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result,
                                __comp);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _OutputIterator
set_union(_InputIterator1 __first1, _InputIterator1 __last1,
          _InputIterator2 __first2, _InputIterator2 __last2,
          _OutputIterator __result) {
  return std::__1::set_union(
      __first1, __last1, __first2, __last2, __result,
      __less<typename iterator_traits<_InputIterator1>::value_type,
             typename iterator_traits<_InputIterator2>::value_type>());
}

template <class _Compare, class _InputIterator1, class _InputIterator2,
          class _OutputIterator>
_OutputIterator
__set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                   _InputIterator2 __first2, _InputIterator2 __last2,
                   _OutputIterator __result, _Compare __comp) {
  while (__first1 != __last1 && __first2 != __last2) {
    if (__comp(*__first1, *__first2))
      ++__first1;
    else {
      if (!__comp(*__first2, *__first1)) {
        *__result = *__first1;
        ++__result;
        ++__first1;
      }
      ++__first2;
    }
  }
  return __result;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator,
          class _Compare>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _OutputIterator
set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                 _InputIterator2 __first2, _InputIterator2 __last2,
                 _OutputIterator __result, _Compare __comp) {
  typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
  return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2,
                                       __result, __comp);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _OutputIterator
set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
                 _InputIterator2 __first2, _InputIterator2 __last2,
                 _OutputIterator __result) {
  return std::__1::set_intersection(
      __first1, __last1, __first2, __last2, __result,
      __less<typename iterator_traits<_InputIterator1>::value_type,
             typename iterator_traits<_InputIterator2>::value_type>());
}

template <class _Compare, class _InputIterator1, class _InputIterator2,
          class _OutputIterator>
_OutputIterator
__set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                 _InputIterator2 __first2, _InputIterator2 __last2,
                 _OutputIterator __result, _Compare __comp) {
  while (__first1 != __last1) {
    if (__first2 == __last2)
      return std::__1::copy(__first1, __last1, __result);
    if (__comp(*__first1, *__first2)) {
      *__result = *__first1;
      ++__result;
      ++__first1;
    } else {
      if (!__comp(*__first2, *__first1))
        ++__first1;
      ++__first2;
    }
  }
  return __result;
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator,
          class _Compare>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _OutputIterator
set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
               _InputIterator2 __first2, _InputIterator2 __last2,
               _OutputIterator __result, _Compare __comp) {
  typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
  return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2,
                                     __result, __comp);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _OutputIterator
set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
               _InputIterator2 __first2, _InputIterator2 __last2,
               _OutputIterator __result) {
  return std::__1::set_difference(
      __first1, __last1, __first2, __last2, __result,
      __less<typename iterator_traits<_InputIterator1>::value_type,
             typename iterator_traits<_InputIterator2>::value_type>());
}

template <class _Compare, class _InputIterator1, class _InputIterator2,
          class _OutputIterator>
_OutputIterator
__set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                           _InputIterator2 __first2, _InputIterator2 __last2,
                           _OutputIterator __result, _Compare __comp) {
  while (__first1 != __last1) {
    if (__first2 == __last2)
      return std::__1::copy(__first1, __last1, __result);
    if (__comp(*__first1, *__first2)) {
      *__result = *__first1;
      ++__result;
      ++__first1;
    } else {
      if (__comp(*__first2, *__first1)) {
        *__result = *__first2;
        ++__result;
      } else
        ++__first1;
      ++__first2;
    }
  }
  return std::__1::copy(__first2, __last2, __result);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator,
          class _Compare>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _OutputIterator
set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                         _InputIterator2 __first2, _InputIterator2 __last2,
                         _OutputIterator __result, _Compare __comp) {
  typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
  return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2,
                                               __last2, __result, __comp);
}

template <class _InputIterator1, class _InputIterator2, class _OutputIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _OutputIterator
set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
                         _InputIterator2 __first2, _InputIterator2 __last2,
                         _OutputIterator __result) {
  return std::__1::set_symmetric_difference(
      __first1, __last1, __first2, __last2, __result,
      __less<typename iterator_traits<_InputIterator1>::value_type,
             typename iterator_traits<_InputIterator2>::value_type>());
}

template <class _Compare, class _InputIterator1, class _InputIterator2>
bool __lexicographical_compare(_InputIterator1 __first1,
                               _InputIterator1 __last1,
                               _InputIterator2 __first2,
                               _InputIterator2 __last2, _Compare __comp) {
  for (; __first2 != __last2; ++__first1, (void)++__first2) {
    if (__first1 == __last1 || __comp(*__first1, *__first2))
      return true;
    if (__comp(*__first2, *__first1))
      return false;
  }
  return false;
}

template <class _InputIterator1, class _InputIterator2, class _Compare>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                        _InputIterator2 __first2, _InputIterator2 __last2,
                        _Compare __comp) {
  typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
  return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2,
                                              __last2, __comp);
}

template <class _InputIterator1, class _InputIterator2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,
                        _InputIterator2 __first2, _InputIterator2 __last2) {
  return std::__1::lexicographical_compare(
      __first1, __last1, __first2, __last2,
      __less<typename iterator_traits<_InputIterator1>::value_type,
             typename iterator_traits<_InputIterator2>::value_type>());
}

template <class _Compare, class _BidirectionalIterator>
bool __next_permutation(_BidirectionalIterator __first,
                        _BidirectionalIterator __last, _Compare __comp) {
  _BidirectionalIterator __i = __last;
  if (__first == __last || __first == --__i)
    return false;
  while (true) {
    _BidirectionalIterator __ip1 = __i;
    if (__comp(*--__i, *__ip1)) {
      _BidirectionalIterator __j = __last;
      while (!__comp(*__i, *--__j))
        ;
      swap(*__i, *__j);
      std::__1::reverse(__ip1, __last);
      return true;
    }
    if (__i == __first) {
      std::__1::reverse(__first, __last);
      return false;
    }
  }
}

template <class _BidirectionalIterator, class _Compare>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last,
                 _Compare __comp) {
  typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
  return __next_permutation<_Comp_ref>(__first, __last, __comp);
}

template <class _BidirectionalIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
next_permutation(_BidirectionalIterator __first,
                 _BidirectionalIterator __last) {
  return std::__1::next_permutation(
      __first, __last,
      __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}

template <class _Compare, class _BidirectionalIterator>
bool __prev_permutation(_BidirectionalIterator __first,
                        _BidirectionalIterator __last, _Compare __comp) {
  _BidirectionalIterator __i = __last;
  if (__first == __last || __first == --__i)
    return false;
  while (true) {
    _BidirectionalIterator __ip1 = __i;
    if (__comp(*__ip1, *--__i)) {
      _BidirectionalIterator __j = __last;
      while (!__comp(*--__j, *__i))
        ;
      swap(*__i, *__j);
      std::__1::reverse(__ip1, __last);
      return true;
    }
    if (__i == __first) {
      std::__1::reverse(__first, __last);
      return false;
    }
  }
}

template <class _BidirectionalIterator, class _Compare>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last,
                 _Compare __comp) {
  typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
  return __prev_permutation<_Comp_ref>(__first, __last, __comp);
}

template <class _BidirectionalIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
prev_permutation(_BidirectionalIterator __first,
                 _BidirectionalIterator __last) {
  return std::__1::prev_permutation(
      __first, __last,
      __less<typename iterator_traits<_BidirectionalIterator>::value_type>());
}

} // namespace __1
} // namespace std
# 143 "/usr/local/include/QtCore/qglobal.h" 2
# 233 "/usr/local/include/QtCore/qglobal.h"
typedef signed char qint8;
typedef unsigned char quint8;
typedef short qint16;
typedef unsigned short quint16;
typedef int qint32;
typedef unsigned int quint32;
# 252 "/usr/local/include/QtCore/qglobal.h"
typedef long long qint64;
typedef unsigned long long quint64;

typedef qint64 qlonglong;
typedef quint64 qulonglong;
# 273 "/usr/local/include/QtCore/qglobal.h"
typedef unsigned char uchar;
typedef unsigned short ushort;
typedef unsigned int uint;
typedef unsigned long ulong;

typedef double qreal;
# 387 "/usr/local/include/QtCore/qglobal.h"
namespace QtPrivate {
enum class Deprecated_t {};
constexpr __attribute__((__unused__)) Deprecated_t Deprecated = {};
} // namespace QtPrivate
# 473 "/usr/local/include/QtCore/qglobal.h"
extern "C"

    __attribute__((visibility("default"))) __attribute__((const)) const char *
    qVersion(void) noexcept;
# 501 "/usr/local/include/QtCore/qglobal.h"
namespace QtPrivate {
template <class T> struct AlignOfHelper {
  char c;
  T type;

  AlignOfHelper();
  ~AlignOfHelper();
};

template <class T> struct AlignOf_Default {
  enum { Value = sizeof(AlignOfHelper<T>) - sizeof(T) };
};

template <class T> struct AlignOf : AlignOf_Default<T> {};
template <class T> struct AlignOf<T &> : AlignOf<T> {};
template <class T> struct AlignOf<T &&> : AlignOf<T> {};
template <size_t N, class T> struct AlignOf<T[N]> : AlignOf<T> {};
# 538 "/usr/local/include/QtCore/qglobal.h"
} // namespace QtPrivate
# 557 "/usr/local/include/QtCore/qglobal.h"
template <int> struct QIntegerForSize;
template <> struct QIntegerForSize<1> {
  typedef quint8 Unsigned;
  typedef qint8 Signed;
};
template <> struct QIntegerForSize<2> {
  typedef quint16 Unsigned;
  typedef qint16 Signed;
};
template <> struct QIntegerForSize<4> {
  typedef quint32 Unsigned;
  typedef qint32 Signed;
};
template <> struct QIntegerForSize<8> {
  typedef quint64 Unsigned;
  typedef qint64 Signed;
};

template <> struct QIntegerForSize<16> {
  __extension__ typedef unsigned __int128 Unsigned;
  __extension__ typedef __int128 Signed;
};

template <class T> struct QIntegerForSizeof : QIntegerForSize<sizeof(T)> {};
typedef QIntegerForSize<8>::Signed qregisterint;
typedef QIntegerForSize<8>::Unsigned qregisteruint;
typedef QIntegerForSizeof<void *>::Unsigned quintptr;
typedef QIntegerForSizeof<void *>::Signed qptrdiff;
typedef qptrdiff qintptr;
using qsizetype = QIntegerForSizeof<std::size_t>::Signed;
# 641 "/usr/local/include/QtCore/qglobal.h"
typedef int QNoImplicitBoolCast;

template <typename T> constexpr inline T qAbs(const T &t) {
  return t >= 0 ? t : -t;
}

constexpr inline int qRound(double d) {
  return d >= 0.0 ? int(d + 0.5)
                  : int(d - double(int(d - 1)) + 0.5) + int(d - 1);
}
constexpr inline int qRound(float d) {
  return d >= 0.0f ? int(d + 0.5f)
                   : int(d - float(int(d - 1)) + 0.5f) + int(d - 1);
}

constexpr inline qint64 qRound64(double d) {
  return d >= 0.0 ? qint64(d + 0.5)
                  : qint64(d - double(qint64(d - 1)) + 0.5) + qint64(d - 1);
}
constexpr inline qint64 qRound64(float d) {
  return d >= 0.0f ? qint64(d + 0.5f)
                   : qint64(d - float(qint64(d - 1)) + 0.5f) + qint64(d - 1);
}

template <typename T> constexpr inline const T &qMin(const T &a, const T &b) {
  return (a < b) ? a : b;
}
template <typename T> constexpr inline const T &qMax(const T &a, const T &b) {
  return (a < b) ? b : a;
}
template <typename T>
constexpr inline const T &qBound(const T &min, const T &val, const T &max) {
  return qMax(min, qMin(max, val));
}
# 730 "/usr/local/include/QtCore/qglobal.h"
class __attribute__((visibility("default"))) QMacAutoReleasePool {
public:
  QMacAutoReleasePool();
  ~QMacAutoReleasePool();

private:
  QMacAutoReleasePool(const QMacAutoReleasePool &) = delete;
  QMacAutoReleasePool &operator=(const QMacAutoReleasePool &) = delete;
  void *pool;
};
# 758 "/usr/local/include/QtCore/qglobal.h"
class QDataStream;

inline void qt_noop(void) {}
# 792 "/usr/local/include/QtCore/qglobal.h"
__attribute__((__noreturn__)) __attribute__((cold))
__attribute__((visibility("default"))) void
qTerminate() noexcept;

__attribute__((visibility("default"))) __attribute__((const)) bool
qSharedBuild() noexcept;
# 835 "/usr/local/include/QtCore/qglobal.h"
class QString;
__attribute__((cold)) __attribute__((visibility("default"))) QString
qt_error_string(int errorCode = -1);

__attribute__((__noreturn__))

__attribute__((cold)) __attribute__((visibility("default"))) void
qt_assert(const char *assertion, const char *file, int line) noexcept;
# 854 "/usr/local/include/QtCore/qglobal.h"
__attribute__((__noreturn__))

__attribute__((cold)) __attribute__((visibility("default"))) void
qt_assert_x(const char *where, const char *what, const char *file,
            int line) noexcept;
# 867 "/usr/local/include/QtCore/qglobal.h"
__attribute__((__noreturn__)) __attribute__((visibility("default"))) void
qt_check_pointer(const char *, int) noexcept;
__attribute__((cold)) __attribute__((visibility("default"))) void qBadAlloc();
# 881 "/usr/local/include/QtCore/qglobal.h"
template <typename T> inline T *q_check_ptr(T *p) {
  do {
    if (!(p))
      qBadAlloc();
  } while (false);
  return p;
}

typedef void (*QFunctionPointer)();

__attribute__((__warn_unused_result__)) constexpr static inline
    __attribute__((__unused__)) bool
    qFuzzyCompare(double p1, double p2) {
  return (qAbs(p1 - p2) * 1000000000000. <= qMin(qAbs(p1), qAbs(p2)));
}

__attribute__((__warn_unused_result__)) constexpr static inline
    __attribute__((__unused__)) bool
    qFuzzyCompare(float p1, float p2) {
  return (qAbs(p1 - p2) * 100000.f <= qMin(qAbs(p1), qAbs(p2)));
}

__attribute__((__warn_unused_result__)) constexpr static inline
    __attribute__((__unused__)) bool
    qFuzzyIsNull(double d) {
  return qAbs(d) <= 0.000000000001;
}

__attribute__((__warn_unused_result__)) constexpr static inline
    __attribute__((__unused__)) bool
    qFuzzyIsNull(float f) {
  return qAbs(f) <= 0.00001f;
}

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wfloat-equal"

__attribute__((__warn_unused_result__)) constexpr static inline
    __attribute__((__unused__)) bool
    qIsNull(double d) noexcept {
  return d == 0.0;
}

__attribute__((__warn_unused_result__)) constexpr static inline
    __attribute__((__unused__)) bool
    qIsNull(float f) noexcept {
  return f == 0.0f;
}

#pragma clang diagnostic pop
# 947 "/usr/local/include/QtCore/qglobal.h"
#pragma clang diagnostic push

namespace QtPrivate {
namespace SwapExceptionTester {
using std::swap;
template <typename T> void checkSwap(T &t) noexcept(noexcept(swap(t, t)));

} // namespace SwapExceptionTester
} // namespace QtPrivate

template <typename T>
inline void qSwap(T &value1, T &value2) noexcept(
    noexcept(QtPrivate::SwapExceptionTester::checkSwap(value1))) {
  using std::swap;
  swap(value1, value2);
}

#pragma clang diagnostic pop

__attribute__((visibility("default"))) void *qMallocAligned(size_t size,
                                                            size_t alignment);
__attribute__((visibility("default"))) void *
qReallocAligned(void *ptr, size_t size, size_t oldsize, size_t alignment);
__attribute__((visibility("default"))) void qFreeAligned(void *ptr);
# 1030 "/usr/local/include/QtCore/qglobal.h"
template <typename ForwardIterator1, typename ForwardIterator2>
inline bool qt_is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,
                              ForwardIterator2 first2, ForwardIterator2 last2) {
  return [&first1, &last1, &first2, &last2]() {
    (void)last2;
    ;
    return std::is_permutation(first1, last1, first2);
  }();
}

template <typename T>
constexpr typename std::add_const<T>::type &qAsConst(T &t) noexcept {
  return t;
}

template <typename T> void qAsConst(const T &&) = delete;

template <typename T, typename U = T>
constexpr T qExchange(T &t, U &&newValue) {
  T old = std::move(t);
  t = std::forward<U>(newValue);
  return old;
}

namespace QtPrivate {

template <typename T> class QForeachContainer {
  QForeachContainer(const QForeachContainer &) = delete;
  QForeachContainer &operator=(const QForeachContainer &) = delete;

public:
  QForeachContainer(const T &t)
      : c(t), i(qAsConst(c).begin()), e(qAsConst(c).end()) {}
  QForeachContainer(T &&t)
      : c(std::move(t)), i(qAsConst(c).begin()), e(qAsConst(c).end()) {}

  QForeachContainer(QForeachContainer &&other)
      : c(std::move(other.c)), i(qAsConst(c).begin()), e(qAsConst(c).end()),
        control(std::move(other.control)) {}

  QForeachContainer &operator=(QForeachContainer &&other) {
    c = std::move(other.c);
    i = qAsConst(c).begin();
    e = qAsConst(c).end();
    control = std::move(other.control);
    return *this;
  }

  T c;
  typename T::const_iterator i, e;
  int control = 1;
};

template <typename T>
QForeachContainer<typename std::decay<T>::type> qMakeForeachContainer(T &&t) {
  return QForeachContainer<typename std::decay<T>::type>(std::forward<T>(t));
}

} // namespace QtPrivate
# 1132 "/usr/local/include/QtCore/qglobal.h"
template <typename T> inline T *qGetPtrHelper(T *ptr) { return ptr; }
template <typename Ptr>
inline auto qGetPtrHelper(Ptr &ptr) -> decltype(ptr.operator->()) {
  return ptr.operator->();
}
# 1175 "/usr/local/include/QtCore/qglobal.h"
__attribute__((visibility("default"))) QString qtTrId(const char *id,
                                                      int n = -1);
# 1207 "/usr/local/include/QtCore/qglobal.h"
template <typename... Args> struct QNonConstOverload {
  template <typename R, typename T>
  constexpr auto operator()(R (T::*ptr)(Args...)) const noexcept
      -> decltype(ptr) {
    return ptr;
  }

  template <typename R, typename T>
  static constexpr auto of(R (T::*ptr)(Args...)) noexcept -> decltype(ptr) {
    return ptr;
  }
};

template <typename... Args> struct QConstOverload {
  template <typename R, typename T>
  constexpr auto operator()(R (T::*ptr)(Args...) const) const noexcept
      -> decltype(ptr) {
    return ptr;
  }

  template <typename R, typename T>
  static constexpr auto of(R (T::*ptr)(Args...) const) noexcept
      -> decltype(ptr) {
    return ptr;
  }
};

template <typename... Args>
struct QOverload : QConstOverload<Args...>, QNonConstOverload<Args...> {
  using QConstOverload<Args...>::of;
  using QConstOverload<Args...>::operator();
  using QNonConstOverload<Args...>::of;
  using QNonConstOverload<Args...>::operator();

  template <typename R>
  constexpr auto operator()(R (*ptr)(Args...)) const noexcept -> decltype(ptr) {
    return ptr;
  }

  template <typename R>
  static constexpr auto of(R (*ptr)(Args...)) noexcept -> decltype(ptr) {
    return ptr;
  }
};

template <typename... Args>
constexpr __attribute__((__unused__)) QOverload<Args...> qOverload = {};
template <typename... Args>
constexpr __attribute__((__unused__)) QConstOverload<Args...> qConstOverload =
    {};
template <typename... Args>
constexpr __attribute__((__unused__)) QNonConstOverload<Args...>
    qNonConstOverload = {};

class QByteArray;
__attribute__((visibility("default"))) QByteArray qgetenv(const char *varName);

__attribute__((visibility("default"))) QString
qEnvironmentVariable(const char *varName);
__attribute__((visibility("default"))) QString
qEnvironmentVariable(const char *varName, const QString &defaultValue);
__attribute__((visibility("default"))) bool qputenv(const char *varName,
                                                    const QByteArray &value);
__attribute__((visibility("default"))) bool qunsetenv(const char *varName);

__attribute__((visibility("default"))) bool
qEnvironmentVariableIsEmpty(const char *varName) noexcept;
__attribute__((visibility("default"))) bool
qEnvironmentVariableIsSet(const char *varName) noexcept;
__attribute__((visibility("default"))) int
qEnvironmentVariableIntValue(const char *varName, bool *ok = nullptr) noexcept;

inline int qIntCast(double f) { return int(f); }
inline int qIntCast(float f) { return int(f); }

__attribute__((visibility("default")))
__attribute__((__deprecated__("use QRandomGenerator instead"))) void
qsrand(uint seed);
__attribute__((visibility("default")))
__attribute__((__deprecated__("use QRandomGenerator instead"))) int
qrand();
# 1288 "/usr/local/include/QtCore/qglobal.h"
namespace QtPrivate {

template <bool B, typename T = void> struct QEnableIf;
template <typename T> struct QEnableIf<true, T> { typedef T Type; };
} // namespace QtPrivate

# 1 "/usr/local/include/QtCore/qtypeinfo.h" 1
# 41 "/usr/local/include/QtCore/qtypeinfo.h"
# 1 "/usr/local/include/QtCore/qglobal.h" 1
# 42 "/usr/local/include/QtCore/qtypeinfo.h" 2
# 52 "/usr/local/include/QtCore/qtypeinfo.h"
template <typename T> static constexpr bool qIsRelocatable() {

  return std::is_trivially_copyable<T>::value &&
         std::is_trivially_destructible<T>::value;
}

template <typename T> static constexpr bool qIsTrivial() {

  return std::is_trivial<T>::value;
}

template <typename T> class QTypeInfo {
public:
  enum {
    isSpecialized = std::is_enum<T>::value,
    isPointer = false,
    isIntegral = std::is_integral<T>::value,
    isComplex = !qIsTrivial<T>(),
    isStatic = true,
    isRelocatable = qIsRelocatable<T>(),
    isLarge = (sizeof(T) > sizeof(void *)),
    isDummy = false,
    sizeOf = sizeof(T)
  };
};

template <> class QTypeInfo<void> {
public:
  enum {
    isSpecialized = true,
    isPointer = false,
    isIntegral = false,
    isComplex = false,
    isStatic = false,
    isRelocatable = false,
    isLarge = false,
    isDummy = false,
    sizeOf = 0
  };
};

template <typename T> class QTypeInfo<T *> {
public:
  enum {
    isSpecialized = true,
    isPointer = true,
    isIntegral = false,
    isComplex = false,
    isStatic = false,
    isRelocatable = true,
    isLarge = false,
    isDummy = false,
    sizeOf = sizeof(T *)
  };
};
# 142 "/usr/local/include/QtCore/qtypeinfo.h"
template <typename T, typename = void>
struct QTypeInfoQuery : public QTypeInfo<T> {
  enum { isRelocatable = !QTypeInfo<T>::isStatic };
};

template <typename T>
struct QTypeInfoQuery<
    T, typename std::enable_if<QTypeInfo<T>::isRelocatable || true>::type>
    : public QTypeInfo<T> {};
# 173 "/usr/local/include/QtCore/qtypeinfo.h"
template <class T, class T1, class T2 = T1, class T3 = T1, class T4 = T1>
class QTypeInfoMerger {
public:
  enum {
    isSpecialized = true,
    isComplex = QTypeInfoQuery<T1>::isComplex ||
                QTypeInfoQuery<T2>::isComplex ||
                QTypeInfoQuery<T3>::isComplex || QTypeInfoQuery<T4>::isComplex,
    isStatic = QTypeInfoQuery<T1>::isStatic || QTypeInfoQuery<T2>::isStatic ||
               QTypeInfoQuery<T3>::isStatic || QTypeInfoQuery<T4>::isStatic,
    isRelocatable = QTypeInfoQuery<T1>::isRelocatable &&
                    QTypeInfoQuery<T2>::isRelocatable &&
                    QTypeInfoQuery<T3>::isRelocatable &&
                    QTypeInfoQuery<T4>::isRelocatable,
    isLarge = sizeof(T) > sizeof(void *),
    isPointer = false,
    isIntegral = false,
    isDummy = false,
    sizeOf = sizeof(T)
  };
};
# 212 "/usr/local/include/QtCore/qtypeinfo.h"
template <typename T> class QList;
template <typename T> class QTypeInfo<QList<T>> {
public:
  enum {
    isSpecialized = true,
    isPointer = false,
    isIntegral = false,
    isComplex = true,
    isRelocatable = true,
    isStatic = false,
    isLarge = (sizeof(QList<T>) > sizeof(void *)),
    isDummy = false,
    sizeOf = sizeof(QList<T>)
  };
};
template <typename T> class QVector;
template <typename T> class QTypeInfo<QVector<T>> {
public:
  enum {
    isSpecialized = true,
    isPointer = false,
    isIntegral = false,
    isComplex = true,
    isRelocatable = true,
    isStatic = false,
    isLarge = (sizeof(QVector<T>) > sizeof(void *)),
    isDummy = false,
    sizeOf = sizeof(QVector<T>)
  };
};
template <typename T> class QQueue;
template <typename T> class QTypeInfo<QQueue<T>> {
public:
  enum {
    isSpecialized = true,
    isPointer = false,
    isIntegral = false,
    isComplex = true,
    isRelocatable = true,
    isStatic = false,
    isLarge = (sizeof(QQueue<T>) > sizeof(void *)),
    isDummy = false,
    sizeOf = sizeof(QQueue<T>)
  };
};
template <typename T> class QStack;
template <typename T> class QTypeInfo<QStack<T>> {
public:
  enum {
    isSpecialized = true,
    isPointer = false,
    isIntegral = false,
    isComplex = true,
    isRelocatable = true,
    isStatic = false,
    isLarge = (sizeof(QStack<T>) > sizeof(void *)),
    isDummy = false,
    sizeOf = sizeof(QStack<T>)
  };
};
template <typename T> class QSet;
template <typename T> class QTypeInfo<QSet<T>> {
public:
  enum {
    isSpecialized = true,
    isPointer = false,
    isIntegral = false,
    isComplex = true,
    isRelocatable = true,
    isStatic = false,
    isLarge = (sizeof(QSet<T>) > sizeof(void *)),
    isDummy = false,
    sizeOf = sizeof(QSet<T>)
  };
};
# 240 "/usr/local/include/QtCore/qtypeinfo.h"
template <typename K, typename V> class QMap;
template <typename K, typename V> class QTypeInfo<QMap<K, V>> {
public:
  enum {
    isSpecialized = true,
    isPointer = false,
    isIntegral = false,
    isComplex = true,
    isStatic = (((5 << 16) | (15 << 8) | (0)) < ((6 << 16) | (0 << 8) | (0))),
    isRelocatable = true,
    isLarge = (sizeof(QMap<K, V>) > sizeof(void *)),
    isDummy = false,
    sizeOf = sizeof(QMap<K, V>)
  };
};
template <typename K, typename V> class QMultiMap;
template <typename K, typename V> class QTypeInfo<QMultiMap<K, V>> {
public:
  enum {
    isSpecialized = true,
    isPointer = false,
    isIntegral = false,
    isComplex = true,
    isStatic = (((5 << 16) | (15 << 8) | (0)) < ((6 << 16) | (0 << 8) | (0))),
    isRelocatable = true,
    isLarge = (sizeof(QMultiMap<K, V>) > sizeof(void *)),
    isDummy = false,
    sizeOf = sizeof(QMultiMap<K, V>)
  };
};
template <typename K, typename V> class QHash;
template <typename K, typename V> class QTypeInfo<QHash<K, V>> {
public:
  enum {
    isSpecialized = true,
    isPointer = false,
    isIntegral = false,
    isComplex = true,
    isStatic = (((5 << 16) | (15 << 8) | (0)) < ((6 << 16) | (0 << 8) | (0))),
    isRelocatable = true,
    isLarge = (sizeof(QHash<K, V>) > sizeof(void *)),
    isDummy = false,
    sizeOf = sizeof(QHash<K, V>)
  };
};
template <typename K, typename V> class QMultiHash;
template <typename K, typename V> class QTypeInfo<QMultiHash<K, V>> {
public:
  enum {
    isSpecialized = true,
    isPointer = false,
    isIntegral = false,
    isComplex = true,
    isStatic = (((5 << 16) | (15 << 8) | (0)) < ((6 << 16) | (0 << 8) | (0))),
    isRelocatable = true,
    isLarge = (sizeof(QMultiHash<K, V>) > sizeof(void *)),
    isDummy = false,
    sizeOf = sizeof(QMultiHash<K, V>)
  };
};
# 255 "/usr/local/include/QtCore/qtypeinfo.h"
enum {
  Q_COMPLEX_TYPE = 0,
  Q_PRIMITIVE_TYPE = 0x1,
  Q_STATIC_TYPE = 0,
  Q_MOVABLE_TYPE = 0x2,
  Q_DUMMY_TYPE = 0x4,
  Q_RELOCATABLE_TYPE = 0x8
};
# 287 "/usr/local/include/QtCore/qtypeinfo.h"
template <typename T> class QFlags;
template <typename T> class QTypeInfo<QFlags<T>> {
public:
  enum {
    isSpecialized = true,
    isComplex = (((Q_PRIMITIVE_TYPE)&Q_PRIMITIVE_TYPE) == 0) &&
                !qIsTrivial<QFlags<T>>(),
    isStatic =
        (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0),
    isRelocatable = !isStatic || ((Q_PRIMITIVE_TYPE)&Q_RELOCATABLE_TYPE) ||
                    qIsRelocatable<QFlags<T>>(),
    isLarge = (sizeof(QFlags<T>) > sizeof(void *)),
    isPointer = false,
    isIntegral = std::is_integral<QFlags<T>>::value,
    isDummy = (((Q_PRIMITIVE_TYPE)&Q_DUMMY_TYPE) != 0),
    sizeOf = sizeof(QFlags<T>)
  };
  static inline const char *name() { return "QFlags<T>"; }
};
# 319 "/usr/local/include/QtCore/qtypeinfo.h"
template <> class QTypeInfo<bool> {
public:
  enum {
    isSpecialized = true,
    isComplex =
        (((Q_PRIMITIVE_TYPE)&Q_PRIMITIVE_TYPE) == 0) && !qIsTrivial<bool>(),
    isStatic =
        (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0),
    isRelocatable = !isStatic || ((Q_PRIMITIVE_TYPE)&Q_RELOCATABLE_TYPE) ||
                    qIsRelocatable<bool>(),
    isLarge = (sizeof(bool) > sizeof(void *)),
    isPointer = false,
    isIntegral = std::is_integral<bool>::value,
    isDummy = (((Q_PRIMITIVE_TYPE)&Q_DUMMY_TYPE) != 0),
    sizeOf = sizeof(bool)
  };
  static inline const char *name() { return "bool"; }
};
template <> class QTypeInfo<char> {
public:
  enum {
    isSpecialized = true,
    isComplex =
        (((Q_PRIMITIVE_TYPE)&Q_PRIMITIVE_TYPE) == 0) && !qIsTrivial<char>(),
    isStatic =
        (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0),
    isRelocatable = !isStatic || ((Q_PRIMITIVE_TYPE)&Q_RELOCATABLE_TYPE) ||
                    qIsRelocatable<char>(),
    isLarge = (sizeof(char) > sizeof(void *)),
    isPointer = false,
    isIntegral = std::is_integral<char>::value,
    isDummy = (((Q_PRIMITIVE_TYPE)&Q_DUMMY_TYPE) != 0),
    sizeOf = sizeof(char)
  };
  static inline const char *name() { return "char"; }
};
template <> class QTypeInfo<signed char> {
public:
  enum {
    isSpecialized = true,
    isComplex = (((Q_PRIMITIVE_TYPE)&Q_PRIMITIVE_TYPE) == 0) &&
                !qIsTrivial<signed char>(),
    isStatic =
        (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0),
    isRelocatable = !isStatic || ((Q_PRIMITIVE_TYPE)&Q_RELOCATABLE_TYPE) ||
                    qIsRelocatable<signed char>(),
    isLarge = (sizeof(signed char) > sizeof(void *)),
    isPointer = false,
    isIntegral = std::is_integral<signed char>::value,
    isDummy = (((Q_PRIMITIVE_TYPE)&Q_DUMMY_TYPE) != 0),
    sizeOf = sizeof(signed char)
  };
  static inline const char *name() { return "signed char"; }
};
template <> class QTypeInfo<uchar> {
public:
  enum {
    isSpecialized = true,
    isComplex =
        (((Q_PRIMITIVE_TYPE)&Q_PRIMITIVE_TYPE) == 0) && !qIsTrivial<uchar>(),
    isStatic =
        (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0),
    isRelocatable = !isStatic || ((Q_PRIMITIVE_TYPE)&Q_RELOCATABLE_TYPE) ||
                    qIsRelocatable<uchar>(),
    isLarge = (sizeof(uchar) > sizeof(void *)),
    isPointer = false,
    isIntegral = std::is_integral<uchar>::value,
    isDummy = (((Q_PRIMITIVE_TYPE)&Q_DUMMY_TYPE) != 0),
    sizeOf = sizeof(uchar)
  };
  static inline const char *name() { return "uchar"; }
};
template <> class QTypeInfo<short> {
public:
  enum {
    isSpecialized = true,
    isComplex =
        (((Q_PRIMITIVE_TYPE)&Q_PRIMITIVE_TYPE) == 0) && !qIsTrivial<short>(),
    isStatic =
        (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0),
    isRelocatable = !isStatic || ((Q_PRIMITIVE_TYPE)&Q_RELOCATABLE_TYPE) ||
                    qIsRelocatable<short>(),
    isLarge = (sizeof(short) > sizeof(void *)),
    isPointer = false,
    isIntegral = std::is_integral<short>::value,
    isDummy = (((Q_PRIMITIVE_TYPE)&Q_DUMMY_TYPE) != 0),
    sizeOf = sizeof(short)
  };
  static inline const char *name() { return "short"; }
};
template <> class QTypeInfo<ushort> {
public:
  enum {
    isSpecialized = true,
    isComplex =
        (((Q_PRIMITIVE_TYPE)&Q_PRIMITIVE_TYPE) == 0) && !qIsTrivial<ushort>(),
    isStatic =
        (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0),
    isRelocatable = !isStatic || ((Q_PRIMITIVE_TYPE)&Q_RELOCATABLE_TYPE) ||
                    qIsRelocatable<ushort>(),
    isLarge = (sizeof(ushort) > sizeof(void *)),
    isPointer = false,
    isIntegral = std::is_integral<ushort>::value,
    isDummy = (((Q_PRIMITIVE_TYPE)&Q_DUMMY_TYPE) != 0),
    sizeOf = sizeof(ushort)
  };
  static inline const char *name() { return "ushort"; }
};
template <> class QTypeInfo<int> {
public:
  enum {
    isSpecialized = true,
    isComplex =
        (((Q_PRIMITIVE_TYPE)&Q_PRIMITIVE_TYPE) == 0) && !qIsTrivial<int>(),
    isStatic =
        (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0),
    isRelocatable = !isStatic || ((Q_PRIMITIVE_TYPE)&Q_RELOCATABLE_TYPE) ||
                    qIsRelocatable<int>(),
    isLarge = (sizeof(int) > sizeof(void *)),
    isPointer = false,
    isIntegral = std::is_integral<int>::value,
    isDummy = (((Q_PRIMITIVE_TYPE)&Q_DUMMY_TYPE) != 0),
    sizeOf = sizeof(int)
  };
  static inline const char *name() { return "int"; }
};
template <> class QTypeInfo<uint> {
public:
  enum {
    isSpecialized = true,
    isComplex =
        (((Q_PRIMITIVE_TYPE)&Q_PRIMITIVE_TYPE) == 0) && !qIsTrivial<uint>(),
    isStatic =
        (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0),
    isRelocatable = !isStatic || ((Q_PRIMITIVE_TYPE)&Q_RELOCATABLE_TYPE) ||
                    qIsRelocatable<uint>(),
    isLarge = (sizeof(uint) > sizeof(void *)),
    isPointer = false,
    isIntegral = std::is_integral<uint>::value,
    isDummy = (((Q_PRIMITIVE_TYPE)&Q_DUMMY_TYPE) != 0),
    sizeOf = sizeof(uint)
  };
  static inline const char *name() { return "uint"; }
};
template <> class QTypeInfo<long> {
public:
  enum {
    isSpecialized = true,
    isComplex =
        (((Q_PRIMITIVE_TYPE)&Q_PRIMITIVE_TYPE) == 0) && !qIsTrivial<long>(),
    isStatic =
        (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0),
    isRelocatable = !isStatic || ((Q_PRIMITIVE_TYPE)&Q_RELOCATABLE_TYPE) ||
                    qIsRelocatable<long>(),
    isLarge = (sizeof(long) > sizeof(void *)),
    isPointer = false,
    isIntegral = std::is_integral<long>::value,
    isDummy = (((Q_PRIMITIVE_TYPE)&Q_DUMMY_TYPE) != 0),
    sizeOf = sizeof(long)
  };
  static inline const char *name() { return "long"; }
};
template <> class QTypeInfo<ulong> {
public:
  enum {
    isSpecialized = true,
    isComplex =
        (((Q_PRIMITIVE_TYPE)&Q_PRIMITIVE_TYPE) == 0) && !qIsTrivial<ulong>(),
    isStatic =
        (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0),
    isRelocatable = !isStatic || ((Q_PRIMITIVE_TYPE)&Q_RELOCATABLE_TYPE) ||
                    qIsRelocatable<ulong>(),
    isLarge = (sizeof(ulong) > sizeof(void *)),
    isPointer = false,
    isIntegral = std::is_integral<ulong>::value,
    isDummy = (((Q_PRIMITIVE_TYPE)&Q_DUMMY_TYPE) != 0),
    sizeOf = sizeof(ulong)
  };
  static inline const char *name() { return "ulong"; }
};
template <> class QTypeInfo<qint64> {
public:
  enum {
    isSpecialized = true,
    isComplex =
        (((Q_PRIMITIVE_TYPE)&Q_PRIMITIVE_TYPE) == 0) && !qIsTrivial<qint64>(),
    isStatic =
        (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0),
    isRelocatable = !isStatic || ((Q_PRIMITIVE_TYPE)&Q_RELOCATABLE_TYPE) ||
                    qIsRelocatable<qint64>(),
    isLarge = (sizeof(qint64) > sizeof(void *)),
    isPointer = false,
    isIntegral = std::is_integral<qint64>::value,
    isDummy = (((Q_PRIMITIVE_TYPE)&Q_DUMMY_TYPE) != 0),
    sizeOf = sizeof(qint64)
  };
  static inline const char *name() { return "qint64"; }
};
template <> class QTypeInfo<quint64> {
public:
  enum {
    isSpecialized = true,
    isComplex =
        (((Q_PRIMITIVE_TYPE)&Q_PRIMITIVE_TYPE) == 0) && !qIsTrivial<quint64>(),
    isStatic =
        (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0),
    isRelocatable = !isStatic || ((Q_PRIMITIVE_TYPE)&Q_RELOCATABLE_TYPE) ||
                    qIsRelocatable<quint64>(),
    isLarge = (sizeof(quint64) > sizeof(void *)),
    isPointer = false,
    isIntegral = std::is_integral<quint64>::value,
    isDummy = (((Q_PRIMITIVE_TYPE)&Q_DUMMY_TYPE) != 0),
    sizeOf = sizeof(quint64)
  };
  static inline const char *name() { return "quint64"; }
};
template <> class QTypeInfo<float> {
public:
  enum {
    isSpecialized = true,
    isComplex =
        (((Q_PRIMITIVE_TYPE)&Q_PRIMITIVE_TYPE) == 0) && !qIsTrivial<float>(),
    isStatic =
        (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0),
    isRelocatable = !isStatic || ((Q_PRIMITIVE_TYPE)&Q_RELOCATABLE_TYPE) ||
                    qIsRelocatable<float>(),
    isLarge = (sizeof(float) > sizeof(void *)),
    isPointer = false,
    isIntegral = std::is_integral<float>::value,
    isDummy = (((Q_PRIMITIVE_TYPE)&Q_DUMMY_TYPE) != 0),
    sizeOf = sizeof(float)
  };
  static inline const char *name() { return "float"; }
};
template <> class QTypeInfo<double> {
public:
  enum {
    isSpecialized = true,
    isComplex =
        (((Q_PRIMITIVE_TYPE)&Q_PRIMITIVE_TYPE) == 0) && !qIsTrivial<double>(),
    isStatic =
        (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0),
    isRelocatable = !isStatic || ((Q_PRIMITIVE_TYPE)&Q_RELOCATABLE_TYPE) ||
                    qIsRelocatable<double>(),
    isLarge = (sizeof(double) > sizeof(void *)),
    isPointer = false,
    isIntegral = std::is_integral<double>::value,
    isDummy = (((Q_PRIMITIVE_TYPE)&Q_DUMMY_TYPE) != 0),
    sizeOf = sizeof(double)
  };
  static inline const char *name() { return "double"; }
};
# 349 "/usr/local/include/QtCore/qtypeinfo.h"
template <> class QTypeInfo<long double> {
public:
  enum {
    isSpecialized = true,
    isComplex = (((Q_RELOCATABLE_TYPE)&Q_PRIMITIVE_TYPE) == 0) &&
                !qIsTrivial<long double>(),
    isStatic =
        (((Q_RELOCATABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0),
    isRelocatable = !isStatic || ((Q_RELOCATABLE_TYPE)&Q_RELOCATABLE_TYPE) ||
                    qIsRelocatable<long double>(),
    isLarge = (sizeof(long double) > sizeof(void *)),
    isPointer = false,
    isIntegral = std::is_integral<long double>::value,
    isDummy = (((Q_RELOCATABLE_TYPE)&Q_DUMMY_TYPE) != 0),
    sizeOf = sizeof(long double)
  };
  static inline const char *name() { return "long double"; }
};

template <> class QTypeInfo<char16_t> {
public:
  enum {
    isSpecialized = true,
    isComplex = (((Q_RELOCATABLE_TYPE)&Q_PRIMITIVE_TYPE) == 0) &&
                !qIsTrivial<char16_t>(),
    isStatic =
        (((Q_RELOCATABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0),
    isRelocatable = !isStatic || ((Q_RELOCATABLE_TYPE)&Q_RELOCATABLE_TYPE) ||
                    qIsRelocatable<char16_t>(),
    isLarge = (sizeof(char16_t) > sizeof(void *)),
    isPointer = false,
    isIntegral = std::is_integral<char16_t>::value,
    isDummy = (((Q_RELOCATABLE_TYPE)&Q_DUMMY_TYPE) != 0),
    sizeOf = sizeof(char16_t)
  };
  static inline const char *name() { return "char16_t"; }
};
template <> class QTypeInfo<char32_t> {
public:
  enum {
    isSpecialized = true,
    isComplex = (((Q_RELOCATABLE_TYPE)&Q_PRIMITIVE_TYPE) == 0) &&
                !qIsTrivial<char32_t>(),
    isStatic =
        (((Q_RELOCATABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0),
    isRelocatable = !isStatic || ((Q_RELOCATABLE_TYPE)&Q_RELOCATABLE_TYPE) ||
                    qIsRelocatable<char32_t>(),
    isLarge = (sizeof(char32_t) > sizeof(void *)),
    isPointer = false,
    isIntegral = std::is_integral<char32_t>::value,
    isDummy = (((Q_RELOCATABLE_TYPE)&Q_DUMMY_TYPE) != 0),
    sizeOf = sizeof(char32_t)
  };
  static inline const char *name() { return "char32_t"; }
};

template <> class QTypeInfo<wchar_t> {
public:
  enum {
    isSpecialized = true,
    isComplex = (((Q_RELOCATABLE_TYPE)&Q_PRIMITIVE_TYPE) == 0) &&
                !qIsTrivial<wchar_t>(),
    isStatic =
        (((Q_RELOCATABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0),
    isRelocatable = !isStatic || ((Q_RELOCATABLE_TYPE)&Q_RELOCATABLE_TYPE) ||
                    qIsRelocatable<wchar_t>(),
    isLarge = (sizeof(wchar_t) > sizeof(void *)),
    isPointer = false,
    isIntegral = std::is_integral<wchar_t>::value,
    isDummy = (((Q_RELOCATABLE_TYPE)&Q_DUMMY_TYPE) != 0),
    sizeOf = sizeof(wchar_t)
  };
  static inline const char *name() { return "wchar_t"; }
};
# 1299 "/usr/local/include/QtCore/qglobal.h" 2
# 1 "/usr/local/include/QtCore/qsysinfo.h" 1
# 41 "/usr/local/include/QtCore/qsysinfo.h"
# 1 "/usr/local/include/QtCore/qglobal.h" 1
# 42 "/usr/local/include/QtCore/qsysinfo.h" 2
# 69 "/usr/local/include/QtCore/qsysinfo.h"
class QString;
class __attribute__((visibility("default"))) QSysInfo {
public:
  enum Sizes { WordSize = (sizeof(void *) << 3) };
# 84 "/usr/local/include/QtCore/qsysinfo.h"
  enum Endian {
    BigEndian,
    LittleEndian

    ,
    ByteOrder = LittleEndian

  };

  enum __attribute__((__deprecated__("Use QOperatingSystemVersion")))
  WinVersion {
    WV_None = 0x0000,

    WV_32s = 0x0001,
    WV_95 = 0x0002,
    WV_98 = 0x0003,
    WV_Me = 0x0004,
    WV_DOS_based = 0x000f,

    WV_NT = 0x0010,
    WV_2000 = 0x0020,
    WV_XP = 0x0030,
    WV_2003 = 0x0040,
    WV_VISTA = 0x0080,
    WV_WINDOWS7 = 0x0090,
    WV_WINDOWS8 = 0x00a0,
    WV_WINDOWS8_1 = 0x00b0,
    WV_WINDOWS10 = 0x00c0,
    WV_NT_based = 0x00f0,

    WV_4_0 = WV_NT,
    WV_5_0 = WV_2000,
    WV_5_1 = WV_XP,
    WV_5_2 = WV_2003,
    WV_6_0 = WV_VISTA,
    WV_6_1 = WV_WINDOWS7,
    WV_6_2 = WV_WINDOWS8,
    WV_6_3 = WV_WINDOWS8_1,
    WV_10_0 = WV_WINDOWS10,

    WV_CE = 0x0100,
    WV_CENET = 0x0200,
    WV_CE_5 = 0x0300,
    WV_CE_6 = 0x0400,
    WV_CE_based = 0x0f00
  };

  enum __attribute__((__deprecated__("Use QOperatingSystemVersion")))
  MacVersion {
    MV_None = 0xffff,
    MV_Unknown = 0x0000,

    MV_9 = (9 == 10 ? 0 + 2 : (9 == 9 ? 1 : 0)),
    MV_10_0 = (10 == 10 ? 0 + 2 : (10 == 9 ? 1 : 0)),
    MV_10_1 = (10 == 10 ? 1 + 2 : (10 == 9 ? 1 : 0)),
    MV_10_2 = (10 == 10 ? 2 + 2 : (10 == 9 ? 1 : 0)),
    MV_10_3 = (10 == 10 ? 3 + 2 : (10 == 9 ? 1 : 0)),
    MV_10_4 = (10 == 10 ? 4 + 2 : (10 == 9 ? 1 : 0)),
    MV_10_5 = (10 == 10 ? 5 + 2 : (10 == 9 ? 1 : 0)),
    MV_10_6 = (10 == 10 ? 6 + 2 : (10 == 9 ? 1 : 0)),
    MV_10_7 = (10 == 10 ? 7 + 2 : (10 == 9 ? 1 : 0)),
    MV_10_8 = (10 == 10 ? 8 + 2 : (10 == 9 ? 1 : 0)),
    MV_10_9 = (10 == 10 ? 9 + 2 : (10 == 9 ? 1 : 0)),
    MV_10_10 = (10 == 10 ? 10 + 2 : (10 == 9 ? 1 : 0)),
    MV_10_11 = (10 == 10 ? 11 + 2 : (10 == 9 ? 1 : 0)),
    MV_10_12 = (10 == 10 ? 12 + 2 : (10 == 9 ? 1 : 0)),

    MV_CHEETAH = MV_10_0,
    MV_PUMA = MV_10_1,
    MV_JAGUAR = MV_10_2,
    MV_PANTHER = MV_10_3,
    MV_TIGER = MV_10_4,
    MV_LEOPARD = MV_10_5,
    MV_SNOWLEOPARD = MV_10_6,
    MV_LION = MV_10_7,
    MV_MOUNTAINLION = MV_10_8,
    MV_MAVERICKS = MV_10_9,
    MV_YOSEMITE = MV_10_10,
    MV_ELCAPITAN = MV_10_11,
    MV_SIERRA = MV_10_12,

    MV_IOS = 1 << 8,
    MV_IOS_4_3 = (QSysInfo::MV_IOS | 4 << 4 | 3),
    MV_IOS_5_0 = (QSysInfo::MV_IOS | 5 << 4 | 0),
    MV_IOS_5_1 = (QSysInfo::MV_IOS | 5 << 4 | 1),
    MV_IOS_6_0 = (QSysInfo::MV_IOS | 6 << 4 | 0),
    MV_IOS_6_1 = (QSysInfo::MV_IOS | 6 << 4 | 1),
    MV_IOS_7_0 = (QSysInfo::MV_IOS | 7 << 4 | 0),
    MV_IOS_7_1 = (QSysInfo::MV_IOS | 7 << 4 | 1),
    MV_IOS_8_0 = (QSysInfo::MV_IOS | 8 << 4 | 0),
    MV_IOS_8_1 = (QSysInfo::MV_IOS | 8 << 4 | 1),
    MV_IOS_8_2 = (QSysInfo::MV_IOS | 8 << 4 | 2),
    MV_IOS_8_3 = (QSysInfo::MV_IOS | 8 << 4 | 3),
    MV_IOS_8_4 = (QSysInfo::MV_IOS | 8 << 4 | 4),
    MV_IOS_9_0 = (QSysInfo::MV_IOS | 9 << 4 | 0),
    MV_IOS_9_1 = (QSysInfo::MV_IOS | 9 << 4 | 1),
    MV_IOS_9_2 = (QSysInfo::MV_IOS | 9 << 4 | 2),
    MV_IOS_9_3 = (QSysInfo::MV_IOS | 9 << 4 | 3),
    MV_IOS_10_0 = (QSysInfo::MV_IOS | 10 << 4 | 0),

    MV_TVOS = 1 << 9,
    MV_TVOS_9_0 = (QSysInfo::MV_TVOS | 9 << 4 | 0),
    MV_TVOS_9_1 = (QSysInfo::MV_TVOS | 9 << 4 | 1),
    MV_TVOS_9_2 = (QSysInfo::MV_TVOS | 9 << 4 | 2),
    MV_TVOS_10_0 = (QSysInfo::MV_TVOS | 10 << 4 | 0),

    MV_WATCHOS = 1 << 10,
    MV_WATCHOS_2_0 = (QSysInfo::MV_WATCHOS | 2 << 4 | 0),
    MV_WATCHOS_2_1 = (QSysInfo::MV_WATCHOS | 2 << 4 | 1),
    MV_WATCHOS_2_2 = (QSysInfo::MV_WATCHOS | 2 << 4 | 2),
    MV_WATCHOS_3_0 = (QSysInfo::MV_WATCHOS | 3 << 4 | 0)
  };

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

  static const WinVersion WindowsVersion = WV_None;
  static WinVersion windowsVersion() { return WV_None; }

  static const MacVersion MacintoshVersion;
  static MacVersion macVersion();

#pragma clang diagnostic pop

  static QString buildCpuArchitecture();
  static QString currentCpuArchitecture();
  static QString buildAbi();

  static QString kernelType();
  static QString kernelVersion();
  static QString productType();
  static QString productVersion();
  static QString prettyProductName();

  static QString machineHostName();
  static QByteArray machineUniqueId();
  static QByteArray bootUniqueId();
};
# 1300 "/usr/local/include/QtCore/qglobal.h" 2
# 1 "/usr/local/include/QtCore/qlogging.h" 1
# 40 "/usr/local/include/QtCore/qlogging.h"
# 1 "/usr/local/include/QtCore/qglobal.h" 1
# 41 "/usr/local/include/QtCore/qlogging.h" 2
# 57 "/usr/local/include/QtCore/qlogging.h"
class QDebug;
class QNoDebug;

enum QtMsgType {
  QtDebugMsg,
  QtWarningMsg,
  QtCriticalMsg,
  QtFatalMsg,
  QtInfoMsg,
  QtSystemMsg = QtCriticalMsg
};

class QMessageLogContext {
  QMessageLogContext(const QMessageLogContext &) = delete;
  QMessageLogContext &operator=(const QMessageLogContext &) = delete;

public:
  constexpr QMessageLogContext() noexcept = default;
  constexpr QMessageLogContext(const char *fileName, int lineNumber,
                               const char *functionName,
                               const char *categoryName) noexcept
      : line(lineNumber), file(fileName), function(functionName),
        category(categoryName) {}

  int version = 2;
  int line = 0;
  const char *file = nullptr;
  const char *function = nullptr;
  const char *category = nullptr;

private:
  QMessageLogContext &
  copyContextFrom(const QMessageLogContext &logContext) noexcept;

  friend class QMessageLogger;
  friend class QDebug;
};

class QLoggingCategory;

class __attribute__((visibility("default"))) QMessageLogger {
  QMessageLogger(const QMessageLogger &) = delete;
  QMessageLogger &operator=(const QMessageLogger &) = delete;

public:
  constexpr QMessageLogger() : context() {}
  constexpr QMessageLogger(const char *file, int line, const char *function)
      : context(file, line, function, "default") {}
  constexpr QMessageLogger(const char *file, int line, const char *function,
                           const char *category)
      : context(file, line, function, category) {}

  void debug(const char *msg, ...) const
      __attribute__((format(printf, (2), (3))));
  void noDebug(const char *, ...) const
      __attribute__((format(printf, (2), (3)))) {}
  void info(const char *msg, ...) const
      __attribute__((format(printf, (2), (3))));
  __attribute__((cold)) void warning(const char *msg, ...) const
      __attribute__((format(printf, (2), (3))));
  __attribute__((cold)) void critical(const char *msg, ...) const
      __attribute__((format(printf, (2), (3))));

  typedef const QLoggingCategory &(*CategoryFunction)();

  void debug(const QLoggingCategory &cat, const char *msg, ...) const
      __attribute__((format(printf, (3), (4))));
  void debug(CategoryFunction catFunc, const char *msg, ...) const
      __attribute__((format(printf, (3), (4))));
  void info(const QLoggingCategory &cat, const char *msg, ...) const
      __attribute__((format(printf, (3), (4))));
  void info(CategoryFunction catFunc, const char *msg, ...) const
      __attribute__((format(printf, (3), (4))));
  __attribute__((cold)) void warning(const QLoggingCategory &cat,
                                     const char *msg, ...) const
      __attribute__((format(printf, (3), (4))));
  __attribute__((cold)) void warning(CategoryFunction catFunc, const char *msg,
                                     ...) const
      __attribute__((format(printf, (3), (4))));
  __attribute__((cold)) void critical(const QLoggingCategory &cat,
                                      const char *msg, ...) const
      __attribute__((format(printf, (3), (4))));
  __attribute__((cold)) void critical(CategoryFunction catFunc, const char *msg,
                                      ...) const
      __attribute__((format(printf, (3), (4))));

  __attribute__((__noreturn__))

  __attribute__((cold)) void
  fatal(const char *msg, ...) const noexcept
      __attribute__((format(printf, (2), (3))));

  QDebug debug() const;
  QDebug debug(const QLoggingCategory &cat) const;
  QDebug debug(CategoryFunction catFunc) const;
  QDebug info() const;
  QDebug info(const QLoggingCategory &cat) const;
  QDebug info(CategoryFunction catFunc) const;
  QDebug warning() const;
  QDebug warning(const QLoggingCategory &cat) const;
  QDebug warning(CategoryFunction catFunc) const;
  QDebug critical() const;
  QDebug critical(const QLoggingCategory &cat) const;
  QDebug critical(CategoryFunction catFunc) const;

  QNoDebug noDebug() const noexcept;

private:
  QMessageLogContext context;
};
# 185 "/usr/local/include/QtCore/qlogging.h"
__attribute__((visibility("default"))) void
qt_message_output(QtMsgType, const QMessageLogContext &context,
                  const QString &message);

__attribute__((visibility("default"))) __attribute__((cold)) void
qErrnoWarning(int code, const char *msg, ...);
__attribute__((visibility("default"))) __attribute__((cold)) void
qErrnoWarning(const char *msg, ...);

typedef void (*QtMessageHandler)(QtMsgType, const QMessageLogContext &,
                                 const QString &);
__attribute__((visibility("default")))
QtMessageHandler qInstallMessageHandler(QtMessageHandler);

__attribute__((visibility("default"))) void
qSetMessagePattern(const QString &messagePattern);
__attribute__((visibility("default"))) QString
qFormatLogMessage(QtMsgType type, const QMessageLogContext &context,
                  const QString &buf);
# 1301 "/usr/local/include/QtCore/qglobal.h" 2

# 1 "/usr/local/include/QtCore/qflags.h" 1
# 40 "/usr/local/include/QtCore/qflags.h"
# 1 "/usr/local/include/QtCore/qglobal.h" 1
# 41 "/usr/local/include/QtCore/qflags.h" 2

class QDataStream;

class QFlag {
  int i;

public:
  constexpr inline QFlag(int value) noexcept : i(value) {}
  constexpr inline operator int() const noexcept { return i; }
# 66 "/usr/local/include/QtCore/qflags.h"
  constexpr inline QFlag(uint value) noexcept : i(int(value)) {}
  constexpr inline QFlag(short value) noexcept : i(int(value)) {}
  constexpr inline QFlag(ushort value) noexcept : i(int(uint(value))) {}
  constexpr inline operator uint() const noexcept { return uint(i); }
};
template <> class QTypeInfo<QFlag> {
public:
  enum {
    isSpecialized = true,
    isComplex =
        (((Q_PRIMITIVE_TYPE)&Q_PRIMITIVE_TYPE) == 0) && !qIsTrivial<QFlag>(),
    isStatic =
        (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0),
    isRelocatable = !isStatic || ((Q_PRIMITIVE_TYPE)&Q_RELOCATABLE_TYPE) ||
                    qIsRelocatable<QFlag>(),
    isLarge = (sizeof(QFlag) > sizeof(void *)),
    isPointer = false,
    isIntegral = std::is_integral<QFlag>::value,
    isDummy = (((Q_PRIMITIVE_TYPE)&Q_DUMMY_TYPE) != 0),
    sizeOf = sizeof(QFlag)
  };
  static inline const char *name() { return "QFlag"; }
};

class QIncompatibleFlag {
  int i;

public:
  constexpr inline explicit QIncompatibleFlag(int i) noexcept;
  constexpr inline operator int() const noexcept { return i; }
};
template <> class QTypeInfo<QIncompatibleFlag> {
public:
  enum {
    isSpecialized = true,
    isComplex = (((Q_PRIMITIVE_TYPE)&Q_PRIMITIVE_TYPE) == 0) &&
                !qIsTrivial<QIncompatibleFlag>(),
    isStatic =
        (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0),
    isRelocatable = !isStatic || ((Q_PRIMITIVE_TYPE)&Q_RELOCATABLE_TYPE) ||
                    qIsRelocatable<QIncompatibleFlag>(),
    isLarge = (sizeof(QIncompatibleFlag) > sizeof(void *)),
    isPointer = false,
    isIntegral = std::is_integral<QIncompatibleFlag>::value,
    isDummy = (((Q_PRIMITIVE_TYPE)&Q_DUMMY_TYPE) != 0),
    sizeOf = sizeof(QIncompatibleFlag)
  };
  static inline const char *name() { return "QIncompatibleFlag"; }
};

constexpr inline QIncompatibleFlag::QIncompatibleFlag(int value) noexcept
    : i(value) {}

template <typename Enum> class QFlags {
  static_assert(bool((sizeof(Enum) <= sizeof(int))),
                "QFlags uses an int as storage, so an enum with underlying "
                "long long will overflow.");

  static_assert(bool((std::is_enum<Enum>::value)),
                "QFlags is only usable on enumeration types.");

  struct Private;
  typedef int(Private::*Zero);

  template <typename E>
  friend QDataStream &operator>>(QDataStream &, QFlags<E> &);
  template <typename E>
  friend QDataStream &operator<<(QDataStream &, QFlags<E>);

public:
  typedef typename std::conditional<
      std::is_unsigned<typename std::underlying_type<Enum>::type>::value,
      unsigned int, signed int>::type Int;

  typedef Enum enum_type;

  constexpr inline QFlags() noexcept : i(0) {}
  constexpr inline QFlags(Enum flags) noexcept : i(Int(flags)) {}

  __attribute__((__deprecated__("Use default constructor "
                                "instead"))) constexpr inline QFlags(
      Zero) noexcept
      : i(0) {}

  constexpr inline QFlags(QFlag flag) noexcept : i(flag) {}

  constexpr inline QFlags(std::initializer_list<Enum> flags) noexcept
      : i(initializer_list_helper(flags.begin(), flags.end())) {}

  constexpr inline QFlags &operator&=(int mask) noexcept {
    i &= mask;
    return *this;
  }
  constexpr inline QFlags &operator&=(uint mask) noexcept {
    i &= mask;
    return *this;
  }
  constexpr inline QFlags &operator&=(Enum mask) noexcept {
    i &= Int(mask);
    return *this;
  }
  constexpr inline QFlags &operator|=(QFlags other) noexcept {
    i |= other.i;
    return *this;
  }
  constexpr inline QFlags &operator|=(Enum other) noexcept {
    i |= Int(other);
    return *this;
  }
  constexpr inline QFlags &operator^=(QFlags other) noexcept {
    i ^= other.i;
    return *this;
  }
  constexpr inline QFlags &operator^=(Enum other) noexcept {
    i ^= Int(other);
    return *this;
  }

  constexpr inline operator Int() const noexcept { return i; }

  constexpr inline QFlags operator|(QFlags other) const noexcept {
    return QFlags(QFlag(i | other.i));
  }
  constexpr inline QFlags operator|(Enum other) const noexcept {
    return QFlags(QFlag(i | Int(other)));
  }
  constexpr inline QFlags operator^(QFlags other) const noexcept {
    return QFlags(QFlag(i ^ other.i));
  }
  constexpr inline QFlags operator^(Enum other) const noexcept {
    return QFlags(QFlag(i ^ Int(other)));
  }
  constexpr inline QFlags operator&(int mask) const noexcept {
    return QFlags(QFlag(i & mask));
  }
  constexpr inline QFlags operator&(uint mask) const noexcept {
    return QFlags(QFlag(i & mask));
  }
  constexpr inline QFlags operator&(Enum other) const noexcept {
    return QFlags(QFlag(i & Int(other)));
  }
  constexpr inline QFlags operator~() const noexcept {
    return QFlags(QFlag(~i));
  }

  constexpr inline bool operator!() const noexcept { return !i; }

  constexpr inline bool testFlag(Enum flag) const noexcept {
    return (i & Int(flag)) == Int(flag) && (Int(flag) != 0 || i == Int(flag));
  }
  constexpr inline QFlags &setFlag(Enum flag, bool on = true) noexcept {
    return on ? (*this |= flag) : (*this &= ~Int(flag));
  }

private:
  constexpr static inline Int initializer_list_helper(
      typename std::initializer_list<Enum>::const_iterator it,
      typename std::initializer_list<Enum>::const_iterator end) noexcept {
    return (it == end ? Int(0)
                      : (Int(*it) | initializer_list_helper(it + 1, end)));
  }

  Int i;
};
# 1303 "/usr/local/include/QtCore/qglobal.h" 2

# 1 "/usr/local/include/QtCore/qatomic.h" 1
# 41 "/usr/local/include/QtCore/qatomic.h"
# 1 "/usr/local/include/QtCore/qglobal.h" 1
# 42 "/usr/local/include/QtCore/qatomic.h" 2

# 1 "/usr/local/include/QtCore/qbasicatomic.h" 1
# 41 "/usr/local/include/QtCore/qbasicatomic.h"
# 1 "/usr/local/include/QtCore/qglobal.h" 1
# 42 "/usr/local/include/QtCore/qbasicatomic.h" 2
# 53 "/usr/local/include/QtCore/qbasicatomic.h"
# 1 "/usr/local/include/QtCore/qatomic_cxx11.h" 1
# 44 "/usr/local/include/QtCore/qatomic_cxx11.h"
# 1 "/usr/local/include/QtCore/qgenericatomic.h" 1
# 44 "/usr/local/include/QtCore/qgenericatomic.h"
# 1 "/usr/local/include/QtCore/qglobal.h" 1
# 45 "/usr/local/include/QtCore/qgenericatomic.h" 2
# 1 "/usr/local/include/QtCore/qtypeinfo.h" 1
# 41 "/usr/local/include/QtCore/qtypeinfo.h"
# 1 "/usr/local/include/QtCore/qglobal.h" 1
# 42 "/usr/local/include/QtCore/qtypeinfo.h" 2
# 46 "/usr/local/include/QtCore/qgenericatomic.h" 2
# 56 "/usr/local/include/QtCore/qgenericatomic.h"
template <int> struct QAtomicOpsSupport {
  enum { IsSupported = 0 };
};
template <> struct QAtomicOpsSupport<4> {
  enum { IsSupported = 1 };
};

template <typename T> struct QAtomicAdditiveType {
  typedef T AdditiveT;
  static const int AddScale = 1;
};
template <typename T> struct QAtomicAdditiveType<T *> {
  typedef qptrdiff AdditiveT;
  static const int AddScale = sizeof(T);
};

template <typename BaseClass> struct QGenericAtomicOps {
  template <typename T> struct AtomicType {
    typedef T Type;
    typedef T *PointerType;
  };

  template <typename T>
  static void acquireMemoryFence(const T &_q_value) noexcept {
    BaseClass::orderedMemoryFence(_q_value);
  }
  template <typename T>
  static void releaseMemoryFence(const T &_q_value) noexcept {
    BaseClass::orderedMemoryFence(_q_value);
  }
  template <typename T> static void orderedMemoryFence(const T &) noexcept {}

  template <typename T>
  static inline __attribute__((always_inline)) T
  load(const T &_q_value) noexcept {
    return _q_value;
  }

  template <typename T, typename X>
  static inline __attribute__((always_inline)) void store(T &_q_value,
                                                          X newValue) noexcept {
    _q_value = newValue;
  }

  template <typename T>
  static inline __attribute__((always_inline)) T
  loadRelaxed(const T &_q_value) noexcept {
    return _q_value;
  }

  template <typename T, typename X>
  static inline __attribute__((always_inline)) void
  storeRelaxed(T &_q_value, X newValue) noexcept {
    _q_value = newValue;
  }

  template <typename T>
  static inline __attribute__((always_inline)) T
  loadAcquire(const T &_q_value) noexcept {
    T tmp = *static_cast<const volatile T *>(&_q_value);
    BaseClass::acquireMemoryFence(_q_value);
    return tmp;
  }

  template <typename T, typename X>
  static inline __attribute__((always_inline)) void
  storeRelease(T &_q_value, X newValue) noexcept {
    BaseClass::releaseMemoryFence(_q_value);
    *static_cast<volatile T *>(&_q_value) = newValue;
  }

  static inline constexpr bool isReferenceCountingNative() noexcept {
    return BaseClass::isFetchAndAddNative();
  }
  static inline constexpr bool isReferenceCountingWaitFree() noexcept {
    return BaseClass::isFetchAndAddWaitFree();
  }
  template <typename T>
  static inline __attribute__((always_inline)) bool ref(T &_q_value) noexcept {
    return BaseClass::fetchAndAddRelaxed(_q_value, 1) != T(-1);
  }

  template <typename T>
  static inline __attribute__((always_inline)) bool
  deref(T &_q_value) noexcept {
    return BaseClass::fetchAndAddRelaxed(_q_value, -1) != 1;
  }
# 153 "/usr/local/include/QtCore/qgenericatomic.h"
  template <typename T, typename X>
  static inline __attribute__((always_inline)) bool
  testAndSetAcquire(T &_q_value, X expectedValue, X newValue) noexcept {
    bool tmp = BaseClass::testAndSetRelaxed(_q_value, expectedValue, newValue);
    BaseClass::acquireMemoryFence(_q_value);
    return tmp;
  }

  template <typename T, typename X>
  static inline __attribute__((always_inline)) bool
  testAndSetRelease(T &_q_value, X expectedValue, X newValue) noexcept {
    BaseClass::releaseMemoryFence(_q_value);
    return BaseClass::testAndSetRelaxed(_q_value, expectedValue, newValue);
  }

  template <typename T, typename X>
  static inline __attribute__((always_inline)) bool
  testAndSetOrdered(T &_q_value, X expectedValue, X newValue) noexcept {
    BaseClass::orderedMemoryFence(_q_value);
    return BaseClass::testAndSetRelaxed(_q_value, expectedValue, newValue);
  }

  template <typename T, typename X>
  static inline __attribute__((always_inline)) bool
  testAndSetAcquire(T &_q_value, X expectedValue, X newValue,
                    X *currentValue) noexcept {
    bool tmp = BaseClass::testAndSetRelaxed(_q_value, expectedValue, newValue,
                                            currentValue);
    BaseClass::acquireMemoryFence(_q_value);
    return tmp;
  }

  template <typename T, typename X>
  static inline __attribute__((always_inline)) bool
  testAndSetRelease(T &_q_value, X expectedValue, X newValue,
                    X *currentValue) noexcept {
    BaseClass::releaseMemoryFence(_q_value);
    return BaseClass::testAndSetRelaxed(_q_value, expectedValue, newValue,
                                        currentValue);
  }

  template <typename T, typename X>
  static inline __attribute__((always_inline)) bool
  testAndSetOrdered(T &_q_value, X expectedValue, X newValue,
                    X *currentValue) noexcept {
    BaseClass::orderedMemoryFence(_q_value);
    return BaseClass::testAndSetRelaxed(_q_value, expectedValue, newValue,
                                        currentValue);
  }

  static inline constexpr bool isFetchAndStoreNative() noexcept {
    return false;
  }
  static inline constexpr bool isFetchAndStoreWaitFree() noexcept {
    return false;
  }

  template <typename T, typename X>
  static inline __attribute__((always_inline)) T
  fetchAndStoreRelaxed(T &_q_value, X newValue) noexcept {

    for (;;) {
      T tmp = loadRelaxed(_q_value);
      if (BaseClass::testAndSetRelaxed(_q_value, tmp, newValue))
        return tmp;
    }
  }

  template <typename T, typename X>
  static inline __attribute__((always_inline)) T
  fetchAndStoreAcquire(T &_q_value, X newValue) noexcept {
    T tmp = BaseClass::fetchAndStoreRelaxed(_q_value, newValue);
    BaseClass::acquireMemoryFence(_q_value);
    return tmp;
  }

  template <typename T, typename X>
  static inline __attribute__((always_inline)) T
  fetchAndStoreRelease(T &_q_value, X newValue) noexcept {
    BaseClass::releaseMemoryFence(_q_value);
    return BaseClass::fetchAndStoreRelaxed(_q_value, newValue);
  }

  template <typename T, typename X>
  static inline __attribute__((always_inline)) T
  fetchAndStoreOrdered(T &_q_value, X newValue) noexcept {
    BaseClass::orderedMemoryFence(_q_value);
    return BaseClass::fetchAndStoreRelaxed(_q_value, newValue);
  }

  static inline constexpr bool isFetchAndAddNative() noexcept { return false; }
  static inline constexpr bool isFetchAndAddWaitFree() noexcept {
    return false;
  }
  template <typename T>
  static inline __attribute__((always_inline)) T fetchAndAddRelaxed(
      T &_q_value,
      typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) noexcept {

    for (;;) {
      T tmp = BaseClass::loadRelaxed(_q_value);
      if (BaseClass::testAndSetRelaxed(_q_value, tmp, T(tmp + valueToAdd)))
        return tmp;
    }
  }

  template <typename T>
  static inline __attribute__((always_inline)) T fetchAndAddAcquire(
      T &_q_value,
      typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) noexcept {
    T tmp = BaseClass::fetchAndAddRelaxed(_q_value, valueToAdd);
    BaseClass::acquireMemoryFence(_q_value);
    return tmp;
  }

  template <typename T>
  static inline __attribute__((always_inline)) T fetchAndAddRelease(
      T &_q_value,
      typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) noexcept {
    BaseClass::releaseMemoryFence(_q_value);
    return BaseClass::fetchAndAddRelaxed(_q_value, valueToAdd);
  }

  template <typename T>
  static inline __attribute__((always_inline)) T fetchAndAddOrdered(
      T &_q_value,
      typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) noexcept {
    BaseClass::orderedMemoryFence(_q_value);
    return BaseClass::fetchAndAddRelaxed(_q_value, valueToAdd);
  }

#pragma clang diagnostic push

  template <typename T>
  static inline __attribute__((always_inline)) T fetchAndSubRelaxed(
      T &_q_value,
      typename QAtomicAdditiveType<T>::AdditiveT operand) noexcept {

    return fetchAndAddRelaxed(_q_value, -operand);
  }
#pragma clang diagnostic pop

  template <typename T>
  static inline __attribute__((always_inline)) T fetchAndSubAcquire(
      T &_q_value,
      typename QAtomicAdditiveType<T>::AdditiveT operand) noexcept {
    T tmp = BaseClass::fetchAndSubRelaxed(_q_value, operand);
    BaseClass::acquireMemoryFence(_q_value);
    return tmp;
  }

  template <typename T>
  static inline __attribute__((always_inline)) T fetchAndSubRelease(
      T &_q_value,
      typename QAtomicAdditiveType<T>::AdditiveT operand) noexcept {
    BaseClass::releaseMemoryFence(_q_value);
    return BaseClass::fetchAndSubRelaxed(_q_value, operand);
  }

  template <typename T>
  static inline __attribute__((always_inline)) T fetchAndSubOrdered(
      T &_q_value,
      typename QAtomicAdditiveType<T>::AdditiveT operand) noexcept {
    BaseClass::orderedMemoryFence(_q_value);
    return BaseClass::fetchAndSubRelaxed(_q_value, operand);
  }

  template <typename T>
  static inline __attribute__((always_inline)) T
  fetchAndAndRelaxed(T &_q_value,
                     typename std::enable_if<QTypeInfo<T>::isIntegral, T>::type
                         operand) noexcept {

    T tmp = BaseClass::loadRelaxed(_q_value);
    for (;;) {
      if (BaseClass::testAndSetRelaxed(_q_value, tmp, T(tmp & operand), &tmp))
        return tmp;
    }
  }

  template <typename T>
  static inline __attribute__((always_inline)) T
  fetchAndAndAcquire(T &_q_value,
                     typename std::enable_if<QTypeInfo<T>::isIntegral, T>::type
                         operand) noexcept {
    T tmp = BaseClass::fetchAndAndRelaxed(_q_value, operand);
    BaseClass::acquireMemoryFence(_q_value);
    return tmp;
  }

  template <typename T>
  static inline __attribute__((always_inline)) T
  fetchAndAndRelease(T &_q_value,
                     typename std::enable_if<QTypeInfo<T>::isIntegral, T>::type
                         operand) noexcept {
    BaseClass::releaseMemoryFence(_q_value);
    return BaseClass::fetchAndAndRelaxed(_q_value, operand);
  }

  template <typename T>
  static inline __attribute__((always_inline)) T
  fetchAndAndOrdered(T &_q_value,
                     typename std::enable_if<QTypeInfo<T>::isIntegral, T>::type
                         operand) noexcept {
    BaseClass::orderedMemoryFence(_q_value);
    return BaseClass::fetchAndAndRelaxed(_q_value, operand);
  }

  template <typename T>
  static inline __attribute__((always_inline)) T
  fetchAndOrRelaxed(T &_q_value,
                    typename std::enable_if<QTypeInfo<T>::isIntegral, T>::type
                        operand) noexcept {

    T tmp = BaseClass::loadRelaxed(_q_value);
    for (;;) {
      if (BaseClass::testAndSetRelaxed(_q_value, tmp, T(tmp | operand), &tmp))
        return tmp;
    }
  }

  template <typename T>
  static inline __attribute__((always_inline)) T
  fetchAndOrAcquire(T &_q_value,
                    typename std::enable_if<QTypeInfo<T>::isIntegral, T>::type
                        operand) noexcept {
    T tmp = BaseClass::fetchAndOrRelaxed(_q_value, operand);
    BaseClass::acquireMemoryFence(_q_value);
    return tmp;
  }

  template <typename T>
  static inline __attribute__((always_inline)) T
  fetchAndOrRelease(T &_q_value,
                    typename std::enable_if<QTypeInfo<T>::isIntegral, T>::type
                        operand) noexcept {
    BaseClass::releaseMemoryFence(_q_value);
    return BaseClass::fetchAndOrRelaxed(_q_value, operand);
  }

  template <typename T>
  static inline __attribute__((always_inline)) T
  fetchAndOrOrdered(T &_q_value,
                    typename std::enable_if<QTypeInfo<T>::isIntegral, T>::type
                        operand) noexcept {
    BaseClass::orderedMemoryFence(_q_value);
    return BaseClass::fetchAndOrRelaxed(_q_value, operand);
  }

  template <typename T>
  static inline __attribute__((always_inline)) T
  fetchAndXorRelaxed(T &_q_value,
                     typename std::enable_if<QTypeInfo<T>::isIntegral, T>::type
                         operand) noexcept {

    T tmp = BaseClass::loadRelaxed(_q_value);
    for (;;) {
      if (BaseClass::testAndSetRelaxed(_q_value, tmp, T(tmp ^ operand), &tmp))
        return tmp;
    }
  }

  template <typename T>
  static inline __attribute__((always_inline)) T
  fetchAndXorAcquire(T &_q_value,
                     typename std::enable_if<QTypeInfo<T>::isIntegral, T>::type
                         operand) noexcept {
    T tmp = BaseClass::fetchAndXorRelaxed(_q_value, operand);
    BaseClass::acquireMemoryFence(_q_value);
    return tmp;
  }

  template <typename T>
  static inline __attribute__((always_inline)) T
  fetchAndXorRelease(T &_q_value,
                     typename std::enable_if<QTypeInfo<T>::isIntegral, T>::type
                         operand) noexcept {
    BaseClass::releaseMemoryFence(_q_value);
    return BaseClass::fetchAndXorRelaxed(_q_value, operand);
  }

  template <typename T>
  static inline __attribute__((always_inline)) T
  fetchAndXorOrdered(T &_q_value,
                     typename std::enable_if<QTypeInfo<T>::isIntegral, T>::type
                         operand) noexcept {
    BaseClass::orderedMemoryFence(_q_value);
    return BaseClass::fetchAndXorRelaxed(_q_value, operand);
  }
};
# 45 "/usr/local/include/QtCore/qatomic_cxx11.h" 2
# 75 "/usr/local/include/QtCore/qatomic_cxx11.h"
template <int N> struct QAtomicTraits {
  static constexpr inline bool isLockFree();
};
# 89 "/usr/local/include/QtCore/qatomic_cxx11.h"
template <> constexpr inline bool QAtomicTraits<4>::isLockFree() {
  return true;
}
# 134 "/usr/local/include/QtCore/qatomic_cxx11.h"
template <> struct QAtomicOpsSupport<1> {
  enum { IsSupported = 1 };
};

template <> constexpr inline bool QAtomicTraits<1>::isLockFree() {
  return true;
}
# 162 "/usr/local/include/QtCore/qatomic_cxx11.h"
template <> struct QAtomicOpsSupport<2> {
  enum { IsSupported = 1 };
};

template <> constexpr inline bool QAtomicTraits<2>::isLockFree() {
  return false;
}
# 191 "/usr/local/include/QtCore/qatomic_cxx11.h"
template <> struct QAtomicOpsSupport<8> {
  enum { IsSupported = 1 };
};

template <> constexpr inline bool QAtomicTraits<8>::isLockFree() {
  return true;
}
# 220 "/usr/local/include/QtCore/qatomic_cxx11.h"
template <typename X> struct QAtomicOps {
  typedef std::atomic<X> Type;

  template <typename T>
  static inline T load(const std::atomic<T> &_q_value) noexcept {
    return _q_value.load(std::memory_order_relaxed);
  }

  template <typename T>
  static inline T load(const volatile std::atomic<T> &_q_value) noexcept {
    return _q_value.load(std::memory_order_relaxed);
  }

  template <typename T>
  static inline T loadRelaxed(const std::atomic<T> &_q_value) noexcept {
    return _q_value.load(std::memory_order_relaxed);
  }

  template <typename T>
  static inline T
  loadRelaxed(const volatile std::atomic<T> &_q_value) noexcept {
    return _q_value.load(std::memory_order_relaxed);
  }

  template <typename T>
  static inline T loadAcquire(const std::atomic<T> &_q_value) noexcept {
    return _q_value.load(std::memory_order_acquire);
  }

  template <typename T>
  static inline T
  loadAcquire(const volatile std::atomic<T> &_q_value) noexcept {
    return _q_value.load(std::memory_order_acquire);
  }

  template <typename T>
  static inline void store(std::atomic<T> &_q_value, T newValue) noexcept {
    _q_value.store(newValue, std::memory_order_relaxed);
  }

  template <typename T>
  static inline void storeRelaxed(std::atomic<T> &_q_value,
                                  T newValue) noexcept {
    _q_value.store(newValue, std::memory_order_relaxed);
  }

  template <typename T>
  static inline void storeRelease(std::atomic<T> &_q_value,
                                  T newValue) noexcept {
    _q_value.store(newValue, std::memory_order_release);
  }

  static inline constexpr bool isReferenceCountingNative() noexcept {
    return isTestAndSetNative();
  }
  static inline constexpr bool isReferenceCountingWaitFree() noexcept {
    return false;
  }
  template <typename T> static inline bool ref(std::atomic<T> &_q_value) {
    return ++_q_value != 0;
  }

  template <typename T>
  static inline bool deref(std::atomic<T> &_q_value) noexcept {
    return --_q_value != 0;
  }

  static inline constexpr bool isTestAndSetNative() noexcept {
    return QAtomicTraits<sizeof(X)>::isLockFree();
  }
  static inline constexpr bool isTestAndSetWaitFree() noexcept { return false; }

  template <typename T>
  static bool testAndSetRelaxed(std::atomic<T> &_q_value, T expectedValue,
                                T newValue,
                                T *currentValue = nullptr) noexcept {
    bool tmp = _q_value.compare_exchange_strong(expectedValue, newValue,
                                                std::memory_order_relaxed,
                                                std::memory_order_relaxed);
    if (currentValue)
      *currentValue = expectedValue;
    return tmp;
  }

  template <typename T>
  static bool testAndSetAcquire(std::atomic<T> &_q_value, T expectedValue,
                                T newValue,
                                T *currentValue = nullptr) noexcept {
    bool tmp = _q_value.compare_exchange_strong(expectedValue, newValue,
                                                std::memory_order_acquire,
                                                std::memory_order_acquire);
    if (currentValue)
      *currentValue = expectedValue;
    return tmp;
  }

  template <typename T>
  static bool testAndSetRelease(std::atomic<T> &_q_value, T expectedValue,
                                T newValue,
                                T *currentValue = nullptr) noexcept {
    bool tmp = _q_value.compare_exchange_strong(expectedValue, newValue,
                                                std::memory_order_release,
                                                std::memory_order_relaxed);
    if (currentValue)
      *currentValue = expectedValue;
    return tmp;
  }

  template <typename T>
  static bool testAndSetOrdered(std::atomic<T> &_q_value, T expectedValue,
                                T newValue,
                                T *currentValue = nullptr) noexcept {
    bool tmp = _q_value.compare_exchange_strong(expectedValue, newValue,
                                                std::memory_order_acq_rel,
                                                std::memory_order_acquire);
    if (currentValue)
      *currentValue = expectedValue;
    return tmp;
  }

  static inline constexpr bool isFetchAndStoreNative() noexcept {
    return isTestAndSetNative();
  }
  static inline constexpr bool isFetchAndStoreWaitFree() noexcept {
    return false;
  }

  template <typename T>
  static T fetchAndStoreRelaxed(std::atomic<T> &_q_value, T newValue) noexcept {
    return _q_value.exchange(newValue, std::memory_order_relaxed);
  }

  template <typename T>
  static T fetchAndStoreAcquire(std::atomic<T> &_q_value, T newValue) noexcept {
    return _q_value.exchange(newValue, std::memory_order_acquire);
  }

  template <typename T>
  static T fetchAndStoreRelease(std::atomic<T> &_q_value, T newValue) noexcept {
    return _q_value.exchange(newValue, std::memory_order_release);
  }

  template <typename T>
  static T fetchAndStoreOrdered(std::atomic<T> &_q_value, T newValue) noexcept {
    return _q_value.exchange(newValue, std::memory_order_acq_rel);
  }

  static inline constexpr bool isFetchAndAddNative() noexcept {
    return isTestAndSetNative();
  }
  static inline constexpr bool isFetchAndAddWaitFree() noexcept {
    return false;
  }

  template <typename T>
  static inline T fetchAndAddRelaxed(
      std::atomic<T> &_q_value,
      typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) noexcept {
    return _q_value.fetch_add(valueToAdd, std::memory_order_relaxed);
  }

  template <typename T>
  static inline T fetchAndAddAcquire(
      std::atomic<T> &_q_value,
      typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) noexcept {
    return _q_value.fetch_add(valueToAdd, std::memory_order_acquire);
  }

  template <typename T>
  static inline T fetchAndAddRelease(
      std::atomic<T> &_q_value,
      typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) noexcept {
    return _q_value.fetch_add(valueToAdd, std::memory_order_release);
  }

  template <typename T>
  static inline T fetchAndAddOrdered(
      std::atomic<T> &_q_value,
      typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) noexcept {
    return _q_value.fetch_add(valueToAdd, std::memory_order_acq_rel);
  }

  template <typename T>
  static inline T fetchAndSubRelaxed(
      std::atomic<T> &_q_value,
      typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) noexcept {
    return _q_value.fetch_sub(valueToAdd, std::memory_order_relaxed);
  }

  template <typename T>
  static inline T fetchAndSubAcquire(
      std::atomic<T> &_q_value,
      typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) noexcept {
    return _q_value.fetch_sub(valueToAdd, std::memory_order_acquire);
  }

  template <typename T>
  static inline T fetchAndSubRelease(
      std::atomic<T> &_q_value,
      typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) noexcept {
    return _q_value.fetch_sub(valueToAdd, std::memory_order_release);
  }

  template <typename T>
  static inline T fetchAndSubOrdered(
      std::atomic<T> &_q_value,
      typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) noexcept {
    return _q_value.fetch_sub(valueToAdd, std::memory_order_acq_rel);
  }

  template <typename T>
  static inline T fetchAndAndRelaxed(
      std::atomic<T> &_q_value,
      typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) noexcept {
    return _q_value.fetch_and(valueToAdd, std::memory_order_relaxed);
  }

  template <typename T>
  static inline T fetchAndAndAcquire(
      std::atomic<T> &_q_value,
      typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) noexcept {
    return _q_value.fetch_and(valueToAdd, std::memory_order_acquire);
  }

  template <typename T>
  static inline T fetchAndAndRelease(
      std::atomic<T> &_q_value,
      typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) noexcept {
    return _q_value.fetch_and(valueToAdd, std::memory_order_release);
  }

  template <typename T>
  static inline T fetchAndAndOrdered(
      std::atomic<T> &_q_value,
      typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) noexcept {
    return _q_value.fetch_and(valueToAdd, std::memory_order_acq_rel);
  }

  template <typename T>
  static inline T fetchAndOrRelaxed(
      std::atomic<T> &_q_value,
      typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) noexcept {
    return _q_value.fetch_or(valueToAdd, std::memory_order_relaxed);
  }

  template <typename T>
  static inline T fetchAndOrAcquire(
      std::atomic<T> &_q_value,
      typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) noexcept {
    return _q_value.fetch_or(valueToAdd, std::memory_order_acquire);
  }

  template <typename T>
  static inline T fetchAndOrRelease(
      std::atomic<T> &_q_value,
      typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) noexcept {
    return _q_value.fetch_or(valueToAdd, std::memory_order_release);
  }

  template <typename T>
  static inline T fetchAndOrOrdered(
      std::atomic<T> &_q_value,
      typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) noexcept {
    return _q_value.fetch_or(valueToAdd, std::memory_order_acq_rel);
  }

  template <typename T>
  static inline T fetchAndXorRelaxed(
      std::atomic<T> &_q_value,
      typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) noexcept {
    return _q_value.fetch_xor(valueToAdd, std::memory_order_relaxed);
  }

  template <typename T>
  static inline T fetchAndXorAcquire(
      std::atomic<T> &_q_value,
      typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) noexcept {
    return _q_value.fetch_xor(valueToAdd, std::memory_order_acquire);
  }

  template <typename T>
  static inline T fetchAndXorRelease(
      std::atomic<T> &_q_value,
      typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) noexcept {
    return _q_value.fetch_xor(valueToAdd, std::memory_order_release);
  }

  template <typename T>
  static inline T fetchAndXorOrdered(
      std::atomic<T> &_q_value,
      typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) noexcept {
    return _q_value.fetch_xor(valueToAdd, std::memory_order_acq_rel);
  }
};
# 54 "/usr/local/include/QtCore/qbasicatomic.h" 2
# 64 "/usr/local/include/QtCore/qbasicatomic.h"
#pragma clang diagnostic push
# 89 "/usr/local/include/QtCore/qbasicatomic.h"
template <typename T> class QBasicAtomicInteger {
public:
  typedef T Type;
  typedef QAtomicOps<T> Ops;

  static_assert(bool(QTypeInfo<T>::isIntegral),
                "template parameter is not an integral type");
  static_assert(bool(QAtomicOpsSupport<sizeof(T)>::IsSupported),
                "template parameter is an integral of a size not supported on "
                "this platform");

  typename Ops::Type _q_value;

  __attribute__((__deprecated__("Use loadRelaxed"))) T load() const noexcept {
    return loadRelaxed();
  }
  __attribute__((__deprecated__("Use storeRelaxed"))) void
  store(T newValue) noexcept {
    storeRelaxed(newValue);
  }

  T loadRelaxed() const noexcept { return Ops::loadRelaxed(_q_value); }
  void storeRelaxed(T newValue) noexcept {
    Ops::storeRelaxed(_q_value, newValue);
  }

  T loadAcquire() const noexcept { return Ops::loadAcquire(_q_value); }
  void storeRelease(T newValue) noexcept {
    Ops::storeRelease(_q_value, newValue);
  }
  operator T() const noexcept { return loadAcquire(); }
  T operator=(T newValue) noexcept {
    storeRelease(newValue);
    return newValue;
  }

  static constexpr bool isReferenceCountingNative() noexcept {
    return Ops::isReferenceCountingNative();
  }
  static constexpr bool isReferenceCountingWaitFree() noexcept {
    return Ops::isReferenceCountingWaitFree();
  }

  bool ref() noexcept { return Ops::ref(_q_value); }
  bool deref() noexcept { return Ops::deref(_q_value); }

  static constexpr bool isTestAndSetNative() noexcept {
    return Ops::isTestAndSetNative();
  }
  static constexpr bool isTestAndSetWaitFree() noexcept {
    return Ops::isTestAndSetWaitFree();
  }

  bool testAndSetRelaxed(T expectedValue, T newValue) noexcept {
    return Ops::testAndSetRelaxed(_q_value, expectedValue, newValue);
  }
  bool testAndSetAcquire(T expectedValue, T newValue) noexcept {
    return Ops::testAndSetAcquire(_q_value, expectedValue, newValue);
  }
  bool testAndSetRelease(T expectedValue, T newValue) noexcept {
    return Ops::testAndSetRelease(_q_value, expectedValue, newValue);
  }
  bool testAndSetOrdered(T expectedValue, T newValue) noexcept {
    return Ops::testAndSetOrdered(_q_value, expectedValue, newValue);
  }

  bool testAndSetRelaxed(T expectedValue, T newValue,
                         T &currentValue) noexcept {
    return Ops::testAndSetRelaxed(_q_value, expectedValue, newValue,
                                  &currentValue);
  }
  bool testAndSetAcquire(T expectedValue, T newValue,
                         T &currentValue) noexcept {
    return Ops::testAndSetAcquire(_q_value, expectedValue, newValue,
                                  &currentValue);
  }
  bool testAndSetRelease(T expectedValue, T newValue,
                         T &currentValue) noexcept {
    return Ops::testAndSetRelease(_q_value, expectedValue, newValue,
                                  &currentValue);
  }
  bool testAndSetOrdered(T expectedValue, T newValue,
                         T &currentValue) noexcept {
    return Ops::testAndSetOrdered(_q_value, expectedValue, newValue,
                                  &currentValue);
  }

  static constexpr bool isFetchAndStoreNative() noexcept {
    return Ops::isFetchAndStoreNative();
  }
  static constexpr bool isFetchAndStoreWaitFree() noexcept {
    return Ops::isFetchAndStoreWaitFree();
  }

  T fetchAndStoreRelaxed(T newValue) noexcept {
    return Ops::fetchAndStoreRelaxed(_q_value, newValue);
  }
  T fetchAndStoreAcquire(T newValue) noexcept {
    return Ops::fetchAndStoreAcquire(_q_value, newValue);
  }
  T fetchAndStoreRelease(T newValue) noexcept {
    return Ops::fetchAndStoreRelease(_q_value, newValue);
  }
  T fetchAndStoreOrdered(T newValue) noexcept {
    return Ops::fetchAndStoreOrdered(_q_value, newValue);
  }

  static constexpr bool isFetchAndAddNative() noexcept {
    return Ops::isFetchAndAddNative();
  }
  static constexpr bool isFetchAndAddWaitFree() noexcept {
    return Ops::isFetchAndAddWaitFree();
  }

  T fetchAndAddRelaxed(T valueToAdd) noexcept {
    return Ops::fetchAndAddRelaxed(_q_value, valueToAdd);
  }
  T fetchAndAddAcquire(T valueToAdd) noexcept {
    return Ops::fetchAndAddAcquire(_q_value, valueToAdd);
  }
  T fetchAndAddRelease(T valueToAdd) noexcept {
    return Ops::fetchAndAddRelease(_q_value, valueToAdd);
  }
  T fetchAndAddOrdered(T valueToAdd) noexcept {
    return Ops::fetchAndAddOrdered(_q_value, valueToAdd);
  }

  T fetchAndSubRelaxed(T valueToAdd) noexcept {
    return Ops::fetchAndSubRelaxed(_q_value, valueToAdd);
  }
  T fetchAndSubAcquire(T valueToAdd) noexcept {
    return Ops::fetchAndSubAcquire(_q_value, valueToAdd);
  }
  T fetchAndSubRelease(T valueToAdd) noexcept {
    return Ops::fetchAndSubRelease(_q_value, valueToAdd);
  }
  T fetchAndSubOrdered(T valueToAdd) noexcept {
    return Ops::fetchAndSubOrdered(_q_value, valueToAdd);
  }

  T fetchAndAndRelaxed(T valueToAdd) noexcept {
    return Ops::fetchAndAndRelaxed(_q_value, valueToAdd);
  }
  T fetchAndAndAcquire(T valueToAdd) noexcept {
    return Ops::fetchAndAndAcquire(_q_value, valueToAdd);
  }
  T fetchAndAndRelease(T valueToAdd) noexcept {
    return Ops::fetchAndAndRelease(_q_value, valueToAdd);
  }
  T fetchAndAndOrdered(T valueToAdd) noexcept {
    return Ops::fetchAndAndOrdered(_q_value, valueToAdd);
  }

  T fetchAndOrRelaxed(T valueToAdd) noexcept {
    return Ops::fetchAndOrRelaxed(_q_value, valueToAdd);
  }
  T fetchAndOrAcquire(T valueToAdd) noexcept {
    return Ops::fetchAndOrAcquire(_q_value, valueToAdd);
  }
  T fetchAndOrRelease(T valueToAdd) noexcept {
    return Ops::fetchAndOrRelease(_q_value, valueToAdd);
  }
  T fetchAndOrOrdered(T valueToAdd) noexcept {
    return Ops::fetchAndOrOrdered(_q_value, valueToAdd);
  }

  T fetchAndXorRelaxed(T valueToAdd) noexcept {
    return Ops::fetchAndXorRelaxed(_q_value, valueToAdd);
  }
  T fetchAndXorAcquire(T valueToAdd) noexcept {
    return Ops::fetchAndXorAcquire(_q_value, valueToAdd);
  }
  T fetchAndXorRelease(T valueToAdd) noexcept {
    return Ops::fetchAndXorRelease(_q_value, valueToAdd);
  }
  T fetchAndXorOrdered(T valueToAdd) noexcept {
    return Ops::fetchAndXorOrdered(_q_value, valueToAdd);
  }

  T operator++() noexcept { return fetchAndAddOrdered(1) + 1; }
  T operator++(int) noexcept { return fetchAndAddOrdered(1); }
  T operator--() noexcept { return fetchAndSubOrdered(1) - 1; }
  T operator--(int) noexcept { return fetchAndSubOrdered(1); }

  T operator+=(T v) noexcept { return fetchAndAddOrdered(v) + v; }
  T operator-=(T v) noexcept { return fetchAndSubOrdered(v) - v; }
  T operator&=(T v) noexcept { return fetchAndAndOrdered(v) & v; }
  T operator|=(T v) noexcept { return fetchAndOrOrdered(v) | v; }
  T operator^=(T v) noexcept { return fetchAndXorOrdered(v) ^ v; }

  QBasicAtomicInteger() = default;
  constexpr QBasicAtomicInteger(T value) noexcept : _q_value(value) {}
  QBasicAtomicInteger(const QBasicAtomicInteger &) = delete;
  QBasicAtomicInteger &operator=(const QBasicAtomicInteger &) = delete;
  QBasicAtomicInteger &operator=(const QBasicAtomicInteger &) volatile = delete;
};
typedef QBasicAtomicInteger<int> QBasicAtomicInt;

template <typename X> class QBasicAtomicPointer {
public:
  typedef X *Type;
  typedef QAtomicOps<Type> Ops;
  typedef typename Ops::Type AtomicType;

  AtomicType _q_value;

  __attribute__((__deprecated__("Use loadRelaxed"))) Type
  load() const noexcept {
    return loadRelaxed();
  }
  __attribute__((__deprecated__("Use storeRelaxed"))) void
  store(Type newValue) noexcept {
    storeRelaxed(newValue);
  }

  Type loadRelaxed() const noexcept { return Ops::loadRelaxed(_q_value); }
  void storeRelaxed(Type newValue) noexcept {
    Ops::storeRelaxed(_q_value, newValue);
  }

  operator Type() const noexcept { return loadAcquire(); }
  Type operator=(Type newValue) noexcept {
    storeRelease(newValue);
    return newValue;
  }

  Type loadAcquire() const noexcept { return Ops::loadAcquire(_q_value); }
  void storeRelease(Type newValue) noexcept {
    Ops::storeRelease(_q_value, newValue);
  }

  static constexpr bool isTestAndSetNative() noexcept {
    return Ops::isTestAndSetNative();
  }
  static constexpr bool isTestAndSetWaitFree() noexcept {
    return Ops::isTestAndSetWaitFree();
  }

  bool testAndSetRelaxed(Type expectedValue, Type newValue) noexcept {
    return Ops::testAndSetRelaxed(_q_value, expectedValue, newValue);
  }
  bool testAndSetAcquire(Type expectedValue, Type newValue) noexcept {
    return Ops::testAndSetAcquire(_q_value, expectedValue, newValue);
  }
  bool testAndSetRelease(Type expectedValue, Type newValue) noexcept {
    return Ops::testAndSetRelease(_q_value, expectedValue, newValue);
  }
  bool testAndSetOrdered(Type expectedValue, Type newValue) noexcept {
    return Ops::testAndSetOrdered(_q_value, expectedValue, newValue);
  }

  bool testAndSetRelaxed(Type expectedValue, Type newValue,
                         Type &currentValue) noexcept {
    return Ops::testAndSetRelaxed(_q_value, expectedValue, newValue,
                                  &currentValue);
  }
  bool testAndSetAcquire(Type expectedValue, Type newValue,
                         Type &currentValue) noexcept {
    return Ops::testAndSetAcquire(_q_value, expectedValue, newValue,
                                  &currentValue);
  }
  bool testAndSetRelease(Type expectedValue, Type newValue,
                         Type &currentValue) noexcept {
    return Ops::testAndSetRelease(_q_value, expectedValue, newValue,
                                  &currentValue);
  }
  bool testAndSetOrdered(Type expectedValue, Type newValue,
                         Type &currentValue) noexcept {
    return Ops::testAndSetOrdered(_q_value, expectedValue, newValue,
                                  &currentValue);
  }

  static constexpr bool isFetchAndStoreNative() noexcept {
    return Ops::isFetchAndStoreNative();
  }
  static constexpr bool isFetchAndStoreWaitFree() noexcept {
    return Ops::isFetchAndStoreWaitFree();
  }

  Type fetchAndStoreRelaxed(Type newValue) noexcept {
    return Ops::fetchAndStoreRelaxed(_q_value, newValue);
  }
  Type fetchAndStoreAcquire(Type newValue) noexcept {
    return Ops::fetchAndStoreAcquire(_q_value, newValue);
  }
  Type fetchAndStoreRelease(Type newValue) noexcept {
    return Ops::fetchAndStoreRelease(_q_value, newValue);
  }
  Type fetchAndStoreOrdered(Type newValue) noexcept {
    return Ops::fetchAndStoreOrdered(_q_value, newValue);
  }

  static constexpr bool isFetchAndAddNative() noexcept {
    return Ops::isFetchAndAddNative();
  }
  static constexpr bool isFetchAndAddWaitFree() noexcept {
    return Ops::isFetchAndAddWaitFree();
  }

  Type fetchAndAddRelaxed(qptrdiff valueToAdd) noexcept {
    return Ops::fetchAndAddRelaxed(_q_value, valueToAdd);
  }
  Type fetchAndAddAcquire(qptrdiff valueToAdd) noexcept {
    return Ops::fetchAndAddAcquire(_q_value, valueToAdd);
  }
  Type fetchAndAddRelease(qptrdiff valueToAdd) noexcept {
    return Ops::fetchAndAddRelease(_q_value, valueToAdd);
  }
  Type fetchAndAddOrdered(qptrdiff valueToAdd) noexcept {
    return Ops::fetchAndAddOrdered(_q_value, valueToAdd);
  }

  Type fetchAndSubRelaxed(qptrdiff valueToAdd) noexcept {
    return Ops::fetchAndSubRelaxed(_q_value, valueToAdd);
  }
  Type fetchAndSubAcquire(qptrdiff valueToAdd) noexcept {
    return Ops::fetchAndSubAcquire(_q_value, valueToAdd);
  }
  Type fetchAndSubRelease(qptrdiff valueToAdd) noexcept {
    return Ops::fetchAndSubRelease(_q_value, valueToAdd);
  }
  Type fetchAndSubOrdered(qptrdiff valueToAdd) noexcept {
    return Ops::fetchAndSubOrdered(_q_value, valueToAdd);
  }

  Type operator++() noexcept { return fetchAndAddOrdered(1) + 1; }
  Type operator++(int) noexcept { return fetchAndAddOrdered(1); }
  Type operator--() noexcept { return fetchAndSubOrdered(1) - 1; }
  Type operator--(int) noexcept { return fetchAndSubOrdered(1); }
  Type operator+=(qptrdiff valueToAdd) noexcept {
    return fetchAndAddOrdered(valueToAdd) + valueToAdd;
  }
  Type operator-=(qptrdiff valueToSub) noexcept {
    return fetchAndSubOrdered(valueToSub) - valueToSub;
  }

  QBasicAtomicPointer() = default;
  constexpr QBasicAtomicPointer(Type value) noexcept : _q_value(value) {}
  QBasicAtomicPointer(const QBasicAtomicPointer &) = delete;
  QBasicAtomicPointer &operator=(const QBasicAtomicPointer &) = delete;
  QBasicAtomicPointer &operator=(const QBasicAtomicPointer &) volatile = delete;
};

#pragma clang diagnostic pop
# 47 "/usr/local/include/QtCore/qatomic.h" 2

#pragma clang diagnostic push

template <typename T> class QAtomicInteger : public QBasicAtomicInteger<T> {
public:
  constexpr QAtomicInteger(T value = 0) noexcept
      : QBasicAtomicInteger<T>(value) {}

  inline QAtomicInteger(const QAtomicInteger &other) noexcept

      : QBasicAtomicInteger<T>()

  {
    this->storeRelease(other.loadAcquire());
  }

  inline QAtomicInteger &operator=(const QAtomicInteger &other) noexcept {
    this->storeRelease(other.loadAcquire());
    return *this;
  }
# 157 "/usr/local/include/QtCore/qatomic.h"
};

class QAtomicInt : public QAtomicInteger<int> {
public:
  constexpr

      QAtomicInt(int value = 0) noexcept
      : QAtomicInteger<int>(value) {}
};

template <typename T> class QAtomicPointer : public QBasicAtomicPointer<T> {
public:
  constexpr QAtomicPointer(T *value = nullptr) noexcept
      : QBasicAtomicPointer<T>(value) {}

  inline QAtomicPointer(const QAtomicPointer<T> &other) noexcept

      : QBasicAtomicPointer<T>()

  {
    this->storeRelease(other.loadAcquire());
  }

  inline QAtomicPointer<T> &operator=(const QAtomicPointer<T> &other) noexcept {
    this->storeRelease(other.loadAcquire());
    return *this;
  }
# 230 "/usr/local/include/QtCore/qatomic.h"
};

#pragma clang diagnostic pop
# 244 "/usr/local/include/QtCore/qatomic.h"
template <typename T> inline void qAtomicAssign(T *&d, T *x) {
  if (d == x)
    return;
  x->ref.ref();
  if (!d->ref.deref())
    delete d;
  d = x;
}
# 263 "/usr/local/include/QtCore/qatomic.h"
template <typename T> inline void qAtomicDetach(T *&d) {
  if (d->ref.loadRelaxed() == 1)
    return;
  T *x = d;
  d = new T(*d);
  if (!x->ref.deref())
    delete x;
}
# 1305 "/usr/local/include/QtCore/qglobal.h" 2
# 1 "/usr/local/include/QtCore/qglobalstatic.h" 1
# 40 "/usr/local/include/QtCore/qglobalstatic.h"
# 1 "/usr/local/include/QtCore/qglobal.h" 1
# 41 "/usr/local/include/QtCore/qglobalstatic.h" 2

# 1 "/usr/local/include/QtCore/qatomic.h" 1
# 41 "/usr/local/include/QtCore/qatomic.h"
# 1 "/usr/local/include/QtCore/qglobal.h" 1
# 42 "/usr/local/include/QtCore/qatomic.h" 2
# 46 "/usr/local/include/QtCore/qglobalstatic.h" 2

namespace QtGlobalStatic {
enum GuardValues {
  Destroyed = -2,
  Initialized = -1,
  Uninitialized = 0,
  Initializing = 1
};
}
# 100 "/usr/local/include/QtCore/qglobalstatic.h"
# 1 "/usr/local/include/QtCore/qmutex.h" 1
# 43 "/usr/local/include/QtCore/qmutex.h"
# 1 "/usr/local/include/QtCore/qglobal.h" 1
# 44 "/usr/local/include/QtCore/qmutex.h" 2
# 1 "/usr/local/include/QtCore/qatomic.h" 1
# 41 "/usr/local/include/QtCore/qatomic.h"
# 1 "/usr/local/include/QtCore/qglobal.h" 1
# 42 "/usr/local/include/QtCore/qatomic.h" 2
# 45 "/usr/local/include/QtCore/qmutex.h" 2

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/chrono" 1 3
# 826 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/chrono" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 827 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/chrono" 2 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ctime" 1 3
# 48 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ctime" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 49 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ctime" 2 3
# 53 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ctime" 3

namespace std {
inline namespace __1 {

using ::clock_t;
using ::size_t;
using ::time_t;
using ::tm;

using ::clock;
using ::difftime;
using ::mktime;
using ::time;

using ::asctime;
using ::ctime;
using ::gmtime;
using ::localtime;

using ::strftime;

} // namespace __1
} // namespace std
# 828 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/chrono" 2 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ratio" 1 3
# 80 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ratio" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 81 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ratio" 2 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/climits" 1 3
# 40 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/climits" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 41 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/climits" 2 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/limits.h" 1 3
# 40 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/limits.h" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 41 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/limits.h" 2 3
# 44 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/limits.h" 3
# 57 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/limits.h" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/12.0.0/include/limits.h" 1 3
# 21 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/12.0.0/include/limits.h" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/limits.h" 1 3 4
# 64 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/limits.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/machine/limits.h" 1 3 4

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/limits.h" 1 3 4
# 40 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/limits.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/_limits.h" 1 3 4
# 41 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/i386/limits.h" 2 3 4
# 7 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/machine/limits.h" 2 3 4
# 65 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/limits.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/syslimits.h" 1 3 4
# 66 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/limits.h" 2 3 4
# 22 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/12.0.0/include/limits.h" 2 3
# 58 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/limits.h" 2 3
# 42 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/climits" 2 3
# 45 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/climits" 3
# 83 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ratio" 2 3
# 87 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ratio" 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_macros" 1 3
# 91 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ratio" 2 3

namespace std {
inline namespace __1 {

template <intmax_t _Xp, intmax_t _Yp> struct __static_gcd {
  static const intmax_t value = __static_gcd<_Yp, _Xp % _Yp>::value;
};

template <intmax_t _Xp> struct __static_gcd<_Xp, 0> {
  static const intmax_t value = _Xp;
};

template <> struct __static_gcd<0, 0> { static const intmax_t value = 1; };

template <intmax_t _Xp, intmax_t _Yp> struct __static_lcm {
  static const intmax_t value = _Xp / __static_gcd<_Xp, _Yp>::value * _Yp;
};

template <intmax_t _Xp> struct __static_abs {
  static const intmax_t value = _Xp < 0 ? -_Xp : _Xp;
};

template <intmax_t _Xp> struct __static_sign {
  static const intmax_t value = _Xp == 0 ? 0 : (_Xp < 0 ? -1 : 1);
};

template <intmax_t _Xp, intmax_t _Yp, intmax_t = __static_sign<_Yp>::value>
class __ll_add;

template <intmax_t _Xp, intmax_t _Yp> class __ll_add<_Xp, _Yp, 1> {
  static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
  static const intmax_t max = -min;

  static_assert(_Xp <= max - _Yp, "overflow in __ll_add");

public:
  static const intmax_t value = _Xp + _Yp;
};

template <intmax_t _Xp, intmax_t _Yp> class __ll_add<_Xp, _Yp, 0> {
public:
  static const intmax_t value = _Xp;
};

template <intmax_t _Xp, intmax_t _Yp> class __ll_add<_Xp, _Yp, -1> {
  static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
  static const intmax_t max = -min;

  static_assert(min - _Yp <= _Xp, "overflow in __ll_add");

public:
  static const intmax_t value = _Xp + _Yp;
};

template <intmax_t _Xp, intmax_t _Yp, intmax_t = __static_sign<_Yp>::value>
class __ll_sub;

template <intmax_t _Xp, intmax_t _Yp> class __ll_sub<_Xp, _Yp, 1> {
  static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
  static const intmax_t max = -min;

  static_assert(min + _Yp <= _Xp, "overflow in __ll_sub");

public:
  static const intmax_t value = _Xp - _Yp;
};

template <intmax_t _Xp, intmax_t _Yp> class __ll_sub<_Xp, _Yp, 0> {
public:
  static const intmax_t value = _Xp;
};

template <intmax_t _Xp, intmax_t _Yp> class __ll_sub<_Xp, _Yp, -1> {
  static const intmax_t min = (1LL << (sizeof(intmax_t) * 8 - 1)) + 1;
  static const intmax_t max = -min;

  static_assert(_Xp <= max + _Yp, "overflow in __ll_sub");

public:
  static const intmax_t value = _Xp - _Yp;
};

template <intmax_t _Xp, intmax_t _Yp> class __ll_mul {
  static const intmax_t nan = (1LL << (sizeof(intmax_t) * 8 - 1));
  static const intmax_t min = nan + 1;
  static const intmax_t max = -min;
  static const intmax_t __a_x = __static_abs<_Xp>::value;
  static const intmax_t __a_y = __static_abs<_Yp>::value;

  static_assert(_Xp != nan && _Yp != nan && __a_x <= max / __a_y,
                "overflow in __ll_mul");

public:
  static const intmax_t value = _Xp * _Yp;
};

template <intmax_t _Yp> class __ll_mul<0, _Yp> {
public:
  static const intmax_t value = 0;
};

template <intmax_t _Xp> class __ll_mul<_Xp, 0> {
public:
  static const intmax_t value = 0;
};

template <> class __ll_mul<0, 0> {
public:
  static const intmax_t value = 0;
};

template <intmax_t _Xp, intmax_t _Yp> class __ll_div {
  static const intmax_t nan = (1LL << (sizeof(intmax_t) * 8 - 1));
  static const intmax_t min = nan + 1;
  static const intmax_t max = -min;

  static_assert(_Xp != nan && _Yp != nan && _Yp != 0, "overflow in __ll_div");

public:
  static const intmax_t value = _Xp / _Yp;
};

template <intmax_t _Num, intmax_t _Den = 1>
class __attribute__((__type_visibility__("default"))) ratio {
  static_assert(__static_abs<_Num>::value >= 0,
                "ratio numerator is out of range");
  static_assert(_Den != 0, "ratio divide by 0");
  static_assert(__static_abs<_Den>::value > 0,
                "ratio denominator is out of range");
  static constexpr const intmax_t __na = __static_abs<_Num>::value;
  static constexpr const intmax_t __da = __static_abs<_Den>::value;
  static constexpr const intmax_t __s =
      __static_sign<_Num>::value * __static_sign<_Den>::value;
  static constexpr const intmax_t __gcd = __static_gcd<__na, __da>::value;

public:
  static constexpr const intmax_t num = __s * __na / __gcd;
  static constexpr const intmax_t den = __da / __gcd;

  typedef ratio<num, den> type;
};

template <intmax_t _Num, intmax_t _Den>
constexpr const intmax_t ratio<_Num, _Den>::num;

template <intmax_t _Num, intmax_t _Den>
constexpr const intmax_t ratio<_Num, _Den>::den;

template <class _Tp> struct __is_ratio : false_type {};
template <intmax_t _Num, intmax_t _Den>
struct __is_ratio<ratio<_Num, _Den>> : true_type {};

typedef ratio<1LL, 1000000000000000000LL> atto;
typedef ratio<1LL, 1000000000000000LL> femto;
typedef ratio<1LL, 1000000000000LL> pico;
typedef ratio<1LL, 1000000000LL> nano;
typedef ratio<1LL, 1000000LL> micro;
typedef ratio<1LL, 1000LL> milli;
typedef ratio<1LL, 100LL> centi;
typedef ratio<1LL, 10LL> deci;
typedef ratio<10LL, 1LL> deca;
typedef ratio<100LL, 1LL> hecto;
typedef ratio<1000LL, 1LL> kilo;
typedef ratio<1000000LL, 1LL> mega;
typedef ratio<1000000000LL, 1LL> giga;
typedef ratio<1000000000000LL, 1LL> tera;
typedef ratio<1000000000000000LL, 1LL> peta;
typedef ratio<1000000000000000000LL, 1LL> exa;

template <class _R1, class _R2> struct __ratio_multiply {
private:
  static const intmax_t __gcd_n1_d2 = __static_gcd<_R1::num, _R2::den>::value;
  static const intmax_t __gcd_d1_n2 = __static_gcd<_R1::den, _R2::num>::value;

public:
  typedef typename ratio<
      __ll_mul<_R1::num / __gcd_n1_d2, _R2::num / __gcd_d1_n2>::value,
      __ll_mul<_R2::den / __gcd_n1_d2, _R1::den / __gcd_d1_n2>::value>::type
      type;
};

template <class _R1, class _R2>
using ratio_multiply = typename __ratio_multiply<_R1, _R2>::type;
# 317 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ratio" 3
template <class _R1, class _R2> struct __ratio_divide {
private:
  static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
  static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;

public:
  typedef typename ratio<
      __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
      __ll_mul<_R2::num / __gcd_n1_n2, _R1::den / __gcd_d1_d2>::value>::type
      type;
};

template <class _R1, class _R2>
using ratio_divide = typename __ratio_divide<_R1, _R2>::type;
# 344 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ratio" 3
template <class _R1, class _R2> struct __ratio_add {
private:
  static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
  static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;

public:
  typedef typename ratio_multiply<
      ratio<__gcd_n1_n2, _R1::den / __gcd_d1_d2>,
      ratio<__ll_add<
                __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
                __ll_mul<_R2::num / __gcd_n1_n2,
                         _R1::den / __gcd_d1_d2>::value>::value,
            _R2::den>>::type type;
};

template <class _R1, class _R2>
using ratio_add = typename __ratio_add<_R1, _R2>::type;
# 379 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ratio" 3
template <class _R1, class _R2> struct __ratio_subtract {
private:
  static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
  static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;

public:
  typedef typename ratio_multiply<
      ratio<__gcd_n1_n2, _R1::den / __gcd_d1_d2>,
      ratio<__ll_sub<
                __ll_mul<_R1::num / __gcd_n1_n2, _R2::den / __gcd_d1_d2>::value,
                __ll_mul<_R2::num / __gcd_n1_n2,
                         _R1::den / __gcd_d1_d2>::value>::value,
            _R2::den>>::type type;
};

template <class _R1, class _R2>
using ratio_subtract = typename __ratio_subtract<_R1, _R2>::type;
# 416 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ratio" 3
template <class _R1, class _R2>
struct __attribute__((__type_visibility__("default"))) ratio_equal
    : public integral_constant<bool, ((_R1::num == _R2::num &&
                                       _R1::den == _R2::den))> {};

template <class _R1, class _R2>
struct __attribute__((__type_visibility__("default"))) ratio_not_equal
    : public integral_constant<bool, ((!ratio_equal<_R1, _R2>::value))> {};

template <
    class _R1, class _R2, bool _Odd = false, intmax_t _Q1 = _R1::num / _R1::den,
    intmax_t _M1 = _R1::num % _R1::den, intmax_t _Q2 = _R2::num / _R2::den,
    intmax_t _M2 = _R2::num % _R2::den>
struct __ratio_less1 {
  static const bool value = _Odd ? _Q2 < _Q1 : _Q1 < _Q2;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, 0, _Qp, 0> {
  static const bool value = false;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M2>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, 0, _Qp, _M2> {
  static const bool value = !_Odd;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M1>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, _M1, _Qp, 0> {
  static const bool value = _Odd;
};

template <class _R1, class _R2, bool _Odd, intmax_t _Qp, intmax_t _M1,
          intmax_t _M2>
struct __ratio_less1<_R1, _R2, _Odd, _Qp, _M1, _Qp, _M2> {
  static const bool value =
      __ratio_less1<ratio<_R1::den, _M1>, ratio<_R2::den, _M2>, !_Odd>::value;
};

template <class _R1, class _R2, intmax_t _S1 = __static_sign<_R1::num>::value,
          intmax_t _S2 = __static_sign<_R2::num>::value>
struct __ratio_less {
  static const bool value = _S1 < _S2;
};

template <class _R1, class _R2> struct __ratio_less<_R1, _R2, 1LL, 1LL> {
  static const bool value = __ratio_less1<_R1, _R2>::value;
};

template <class _R1, class _R2> struct __ratio_less<_R1, _R2, -1LL, -1LL> {
  static const bool value = __ratio_less1<ratio<-_R2::num, _R2::den>,
                                          ratio<-_R1::num, _R1::den>>::value;
};

template <class _R1, class _R2>
struct __attribute__((__type_visibility__("default"))) ratio_less
    : public integral_constant<bool, ((__ratio_less<_R1, _R2>::value))> {};

template <class _R1, class _R2>
struct __attribute__((__type_visibility__("default"))) ratio_less_equal
    : public integral_constant<bool, ((!ratio_less<_R2, _R1>::value))> {};

template <class _R1, class _R2>
struct __attribute__((__type_visibility__("default"))) ratio_greater
    : public integral_constant<bool, ((ratio_less<_R2, _R1>::value))> {};

template <class _R1, class _R2>
struct __attribute__((__type_visibility__("default"))) ratio_greater_equal
    : public integral_constant<bool, ((!ratio_less<_R1, _R2>::value))> {};

template <class _R1, class _R2> struct __ratio_gcd {
  typedef ratio<__static_gcd<_R1::num, _R2::num>::value,
                __static_lcm<_R1::den, _R2::den>::value>
      type;
};
# 528 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ratio" 3
} // namespace __1
} // namespace std
# 830 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/chrono" 2 3
# 835 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/chrono" 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_macros" 1 3
# 839 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/chrono" 2 3

namespace std {
inline namespace __1 {
namespace __fs {
namespace filesystem {
struct _FilesystemClock;
}
} // namespace __fs
} // namespace __1
} // namespace std

namespace std {
inline namespace __1 {

namespace chrono {

template <class _Rep, class _Period = ratio<1>>
class __attribute__((__type_visibility__("default"))) duration;

template <class _Tp> struct __is_duration : false_type {};

template <class _Rep, class _Period>
struct __is_duration<duration<_Rep, _Period>> : true_type {};

template <class _Rep, class _Period>
struct __is_duration<const duration<_Rep, _Period>> : true_type {};

template <class _Rep, class _Period>
struct __is_duration<volatile duration<_Rep, _Period>> : true_type {};

template <class _Rep, class _Period>
struct __is_duration<const volatile duration<_Rep, _Period>> : true_type {};

} // namespace chrono

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
struct __attribute__((__type_visibility__("default")))
common_type<chrono::duration<_Rep1, _Period1>,
            chrono::duration<_Rep2, _Period2>> {
  typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
                           typename __ratio_gcd<_Period1, _Period2>::type>
      type;
};

namespace chrono {

template <class _FromDuration, class _ToDuration,
          class _Period =
              typename ratio_divide<typename _FromDuration::period,
                                    typename _ToDuration::period>::type,
          bool = _Period::num == 1, bool = _Period::den == 1>
struct __duration_cast;

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, true, true> {
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr _ToDuration
  operator()(const _FromDuration &__fd) const {
    return _ToDuration(static_cast<typename _ToDuration::rep>(__fd.count()));
  }
};

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, true, false> {
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr _ToDuration
  operator()(const _FromDuration &__fd) const {
    typedef
        typename common_type<typename _ToDuration::rep,
                             typename _FromDuration::rep, intmax_t>::type _Ct;
    return _ToDuration(static_cast<typename _ToDuration::rep>(
        static_cast<_Ct>(__fd.count()) / static_cast<_Ct>(_Period::den)));
  }
};

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, false, true> {
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr _ToDuration
  operator()(const _FromDuration &__fd) const {
    typedef
        typename common_type<typename _ToDuration::rep,
                             typename _FromDuration::rep, intmax_t>::type _Ct;
    return _ToDuration(static_cast<typename _ToDuration::rep>(
        static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num)));
  }
};

template <class _FromDuration, class _ToDuration, class _Period>
struct __duration_cast<_FromDuration, _ToDuration, _Period, false, false> {
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr _ToDuration
  operator()(const _FromDuration &__fd) const {
    typedef
        typename common_type<typename _ToDuration::rep,
                             typename _FromDuration::rep, intmax_t>::type _Ct;
    return _ToDuration(static_cast<typename _ToDuration::rep>(
        static_cast<_Ct>(__fd.count()) * static_cast<_Ct>(_Period::num) /
        static_cast<_Ct>(_Period::den)));
  }
};

template <class _ToDuration, class _Rep, class _Period>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr
    typename enable_if<__is_duration<_ToDuration>::value, _ToDuration>::type
    duration_cast(const duration<_Rep, _Period> &__fd) {
  return __duration_cast<duration<_Rep, _Period>, _ToDuration>()(__fd);
}

template <class _Rep>
struct __attribute__((__type_visibility__("default"))) treat_as_floating_point
    : is_floating_point<_Rep> {};

template <class _Rep>
struct __attribute__((__type_visibility__("default"))) duration_values {
public:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr _Rep
  zero() noexcept {
    return _Rep(0);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr _Rep
  max() noexcept {
    return numeric_limits<_Rep>::max();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr _Rep
  min() noexcept {
    return numeric_limits<_Rep>::lowest();
  }
};
# 1020 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/chrono" 3
template <class _Rep, class _Period>
class __attribute__((__type_visibility__("default"))) duration {
  static_assert(!__is_duration<_Rep>::value,
                "A duration representation can not be a duration");
  static_assert(__is_ratio<_Period>::value,
                "Second template parameter of duration must be a std::ratio");
  static_assert(_Period::num > 0, "duration period must be positive");

  template <class _R1, class _R2> struct __no_overflow {
  private:
    static const intmax_t __gcd_n1_n2 = __static_gcd<_R1::num, _R2::num>::value;
    static const intmax_t __gcd_d1_d2 = __static_gcd<_R1::den, _R2::den>::value;
    static const intmax_t __n1 = _R1::num / __gcd_n1_n2;
    static const intmax_t __d1 = _R1::den / __gcd_d1_d2;
    static const intmax_t __n2 = _R2::num / __gcd_n1_n2;
    static const intmax_t __d2 = _R2::den / __gcd_d1_d2;
    static const intmax_t max =
        -((intmax_t(1) << (sizeof(intmax_t) * 8 - 1)) + 1);

    template <intmax_t _Xp, intmax_t _Yp, bool __overflow> struct __mul {
      static const intmax_t value = _Xp * _Yp;
    };

    template <intmax_t _Xp, intmax_t _Yp> struct __mul<_Xp, _Yp, true> {
      static const intmax_t value = 1;
    };

  public:
    static const bool value = (__n1 <= max / __d2) && (__n2 <= max / __d1);
    typedef ratio<__mul<__n1, __d2, !value>::value,
                  __mul<__n2, __d1, !value>::value>
        type;
  };

public:
  typedef _Rep rep;
  typedef typename _Period::type period;

private:
  rep __rep_;

public:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr

      duration() = default;

  template <class _Rep2>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr explicit duration(
      const _Rep2 &__r,
      typename enable_if<is_convertible<_Rep2, rep>::value &&
                         (treat_as_floating_point<rep>::value ||
                          !treat_as_floating_point<_Rep2>::value)>::type * = 0)
      : __rep_(__r) {}

  template <class _Rep2, class _Period2>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr duration(
      const duration<_Rep2, _Period2> &__d,
      typename enable_if<__no_overflow<_Period2, period>::value &&
                         (treat_as_floating_point<rep>::value ||
                          (__no_overflow<_Period2, period>::type::den == 1 &&
                           !treat_as_floating_point<_Rep2>::value))>::type * =
          0)
      : __rep_(std::__1::chrono::duration_cast<duration>(__d).count()) {}

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr rep
  count() const {
    return __rep_;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr
      typename common_type<duration>::type
      operator+() const {
    return typename common_type<duration>::type(*this);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr
      typename common_type<duration>::type
      operator-() const {
    return typename common_type<duration>::type(-__rep_);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  duration &
  operator++() {
    ++__rep_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  duration
  operator++(int) {
    return duration(__rep_++);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  duration &
  operator--() {
    --__rep_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  duration
  operator--(int) {
    return duration(__rep_--);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  duration &
  operator+=(const duration &__d) {
    __rep_ += __d.count();
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  duration &
  operator-=(const duration &__d) {
    __rep_ -= __d.count();
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  duration &
  operator*=(const rep &rhs) {
    __rep_ *= rhs;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  duration &
  operator/=(const rep &rhs) {
    __rep_ /= rhs;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  duration &
  operator%=(const rep &rhs) {
    __rep_ %= rhs;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  duration &
  operator%=(const duration &rhs) {
    __rep_ %= rhs.count();
    return *this;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr duration
  zero() noexcept {
    return duration(duration_values<rep>::zero());
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr duration
  min() noexcept {
    return duration(duration_values<rep>::min());
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr duration
  max() noexcept {
    return duration(duration_values<rep>::max());
  }
};

typedef duration<long long, nano> nanoseconds;
typedef duration<long long, micro> microseconds;
typedef duration<long long, milli> milliseconds;
typedef duration<long long> seconds;
typedef duration<long, ratio<60>> minutes;
typedef duration<long, ratio<3600>> hours;
# 1137 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/chrono" 3
template <class _LhsDuration, class _RhsDuration> struct __duration_eq {
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr bool
  operator()(const _LhsDuration &__lhs, const _RhsDuration &__rhs) const {
    typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;
    return _Ct(__lhs).count() == _Ct(__rhs).count();
  }
};

template <class _LhsDuration> struct __duration_eq<_LhsDuration, _LhsDuration> {
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr bool
  operator()(const _LhsDuration &__lhs, const _LhsDuration &__rhs) const {
    return __lhs.count() == __rhs.count();
  }
};

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr bool
operator==(const duration<_Rep1, _Period1> &__lhs,
           const duration<_Rep2, _Period2> &__rhs) {
  return __duration_eq<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>()(
      __lhs, __rhs);
}

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr bool
operator!=(const duration<_Rep1, _Period1> &__lhs,
           const duration<_Rep2, _Period2> &__rhs) {
  return !(__lhs == __rhs);
}

template <class _LhsDuration, class _RhsDuration> struct __duration_lt {
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr bool
  operator()(const _LhsDuration &__lhs, const _RhsDuration &__rhs) const {
    typedef typename common_type<_LhsDuration, _RhsDuration>::type _Ct;
    return _Ct(__lhs).count() < _Ct(__rhs).count();
  }
};

template <class _LhsDuration> struct __duration_lt<_LhsDuration, _LhsDuration> {
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr bool
  operator()(const _LhsDuration &__lhs, const _LhsDuration &__rhs) const {
    return __lhs.count() < __rhs.count();
  }
};

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr bool
operator<(const duration<_Rep1, _Period1> &__lhs,
          const duration<_Rep2, _Period2> &__rhs) {
  return __duration_lt<duration<_Rep1, _Period1>, duration<_Rep2, _Period2>>()(
      __lhs, __rhs);
}

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr bool
operator>(const duration<_Rep1, _Period1> &__lhs,
          const duration<_Rep2, _Period2> &__rhs) {
  return __rhs < __lhs;
}

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr bool
operator<=(const duration<_Rep1, _Period1> &__lhs,
           const duration<_Rep2, _Period2> &__rhs) {
  return !(__rhs < __lhs);
}

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr bool
operator>=(const duration<_Rep1, _Period1> &__lhs,
           const duration<_Rep2, _Period2> &__rhs) {
  return !(__lhs < __rhs);
}

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr
    typename common_type<duration<_Rep1, _Period1>,
                         duration<_Rep2, _Period2>>::type
    operator+(const duration<_Rep1, _Period1> &__lhs,
              const duration<_Rep2, _Period2> &__rhs) {
  typedef typename common_type<duration<_Rep1, _Period1>,
                               duration<_Rep2, _Period2>>::type _Cd;
  return _Cd(_Cd(__lhs).count() + _Cd(__rhs).count());
}

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr
    typename common_type<duration<_Rep1, _Period1>,
                         duration<_Rep2, _Period2>>::type
    operator-(const duration<_Rep1, _Period1> &__lhs,
              const duration<_Rep2, _Period2> &__rhs) {
  typedef typename common_type<duration<_Rep1, _Period1>,
                               duration<_Rep2, _Period2>>::type _Cd;
  return _Cd(_Cd(__lhs).count() - _Cd(__rhs).count());
}

template <class _Rep1, class _Period, class _Rep2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr typename enable_if<
    is_convertible<_Rep2, typename common_type<_Rep1, _Rep2>::type>::value,
    duration<typename common_type<_Rep1, _Rep2>::type, _Period>>::type
operator*(const duration<_Rep1, _Period> &__d, const _Rep2 &__s) {
  typedef typename common_type<_Rep1, _Rep2>::type _Cr;
  typedef duration<_Cr, _Period> _Cd;
  return _Cd(_Cd(__d).count() * static_cast<_Cr>(__s));
}

template <class _Rep1, class _Period, class _Rep2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr typename enable_if<
    is_convertible<_Rep1, typename common_type<_Rep1, _Rep2>::type>::value,
    duration<typename common_type<_Rep1, _Rep2>::type, _Period>>::type
operator*(const _Rep1 &__s, const duration<_Rep2, _Period> &__d) {
  return __d * __s;
}

template <class _Rep1, class _Period, class _Rep2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr typename enable_if<
    !__is_duration<_Rep2>::value &&
        is_convertible<_Rep2, typename common_type<_Rep1, _Rep2>::type>::value,
    duration<typename common_type<_Rep1, _Rep2>::type, _Period>>::type
operator/(const duration<_Rep1, _Period> &__d, const _Rep2 &__s) {
  typedef typename common_type<_Rep1, _Rep2>::type _Cr;
  typedef duration<_Cr, _Period> _Cd;
  return _Cd(_Cd(__d).count() / static_cast<_Cr>(__s));
}

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr
    typename common_type<_Rep1, _Rep2>::type
    operator/(const duration<_Rep1, _Period1> &__lhs,
              const duration<_Rep2, _Period2> &__rhs) {
  typedef typename common_type<duration<_Rep1, _Period1>,
                               duration<_Rep2, _Period2>>::type _Ct;
  return _Ct(__lhs).count() / _Ct(__rhs).count();
}

template <class _Rep1, class _Period, class _Rep2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr typename enable_if<
    !__is_duration<_Rep2>::value &&
        is_convertible<_Rep2, typename common_type<_Rep1, _Rep2>::type>::value,
    duration<typename common_type<_Rep1, _Rep2>::type, _Period>>::type
operator%(const duration<_Rep1, _Period> &__d, const _Rep2 &__s) {
  typedef typename common_type<_Rep1, _Rep2>::type _Cr;
  typedef duration<_Cr, _Period> _Cd;
  return _Cd(_Cd(__d).count() % static_cast<_Cr>(__s));
}

template <class _Rep1, class _Period1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr
    typename common_type<duration<_Rep1, _Period1>,
                         duration<_Rep2, _Period2>>::type
    operator%(const duration<_Rep1, _Period1> &__lhs,
              const duration<_Rep2, _Period2> &__rhs) {
  typedef typename common_type<_Rep1, _Rep2>::type _Cr;
  typedef typename common_type<duration<_Rep1, _Period1>,
                               duration<_Rep2, _Period2>>::type _Cd;
  return _Cd(static_cast<_Cr>(_Cd(__lhs).count()) %
             static_cast<_Cr>(_Cd(__rhs).count()));
}

template <class _Clock, class _Duration = typename _Clock::duration>
class __attribute__((__type_visibility__("default"))) time_point {
  static_assert(__is_duration<_Duration>::value,
                "Second template parameter of time_point must be a "
                "std::chrono::duration");

public:
  typedef _Clock clock;
  typedef _Duration duration;
  typedef typename duration::rep rep;
  typedef typename duration::period period;

private:
  duration __d_;

public:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr time_point()
      : __d_(duration::zero()) {}
  __attribute__((__visibility__("hidden"))) __attribute__((
      internal_linkage)) constexpr explicit time_point(const duration &__d)
      : __d_(__d) {}

  template <class _Duration2>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr time_point(
      const time_point<clock, _Duration2> &t,
      typename enable_if<is_convertible<_Duration2, duration>::value>::type * =
          0)
      : __d_(t.time_since_epoch()) {}

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr duration
  time_since_epoch() const {
    return __d_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  time_point &
  operator+=(const duration &__d) {
    __d_ += __d;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  time_point &
  operator-=(const duration &__d) {
    __d_ -= __d;
    return *this;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr time_point
  min() noexcept {
    return time_point(duration::min());
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static constexpr time_point
  max() noexcept {
    return time_point(duration::max());
  }
};

} // namespace chrono

template <class _Clock, class _Duration1, class _Duration2>
struct __attribute__((__type_visibility__("default")))
common_type<chrono::time_point<_Clock, _Duration1>,
            chrono::time_point<_Clock, _Duration2>> {
  typedef chrono::time_point<_Clock,
                             typename common_type<_Duration1, _Duration2>::type>
      type;
};

namespace chrono {

template <class _ToDuration, class _Clock, class _Duration>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr time_point<_Clock, _ToDuration>
time_point_cast(const time_point<_Clock, _Duration> &__t) {
  return time_point<_Clock, _ToDuration>(
      std::__1::chrono::duration_cast<_ToDuration>(__t.time_since_epoch()));
}
# 1467 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/chrono" 3
template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr bool
operator==(const time_point<_Clock, _Duration1> &__lhs,
           const time_point<_Clock, _Duration2> &__rhs) {
  return __lhs.time_since_epoch() == __rhs.time_since_epoch();
}

template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr bool
operator!=(const time_point<_Clock, _Duration1> &__lhs,
           const time_point<_Clock, _Duration2> &__rhs) {
  return !(__lhs == __rhs);
}

template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr bool
operator<(const time_point<_Clock, _Duration1> &__lhs,
          const time_point<_Clock, _Duration2> &__rhs) {
  return __lhs.time_since_epoch() < __rhs.time_since_epoch();
}

template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr bool
operator>(const time_point<_Clock, _Duration1> &__lhs,
          const time_point<_Clock, _Duration2> &__rhs) {
  return __rhs < __lhs;
}

template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr bool
operator<=(const time_point<_Clock, _Duration1> &__lhs,
           const time_point<_Clock, _Duration2> &__rhs) {
  return !(__rhs < __lhs);
}

template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr bool
operator>=(const time_point<_Clock, _Duration1> &__lhs,
           const time_point<_Clock, _Duration2> &__rhs) {
  return !(__lhs < __rhs);
}

template <class _Clock, class _Duration1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr time_point<
    _Clock, typename common_type<_Duration1, duration<_Rep2, _Period2>>::type>
operator+(const time_point<_Clock, _Duration1> &__lhs,
          const duration<_Rep2, _Period2> &__rhs) {
  typedef time_point<
      _Clock, typename common_type<_Duration1, duration<_Rep2, _Period2>>::type>
      _Tr;
  return _Tr(__lhs.time_since_epoch() + __rhs);
}

template <class _Rep1, class _Period1, class _Clock, class _Duration2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr time_point<
    _Clock, typename common_type<duration<_Rep1, _Period1>, _Duration2>::type>
operator+(const duration<_Rep1, _Period1> &__lhs,
          const time_point<_Clock, _Duration2> &__rhs) {
  return __rhs + __lhs;
}

template <class _Clock, class _Duration1, class _Rep2, class _Period2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr time_point<
    _Clock, typename common_type<_Duration1, duration<_Rep2, _Period2>>::type>
operator-(const time_point<_Clock, _Duration1> &__lhs,
          const duration<_Rep2, _Period2> &__rhs) {
  typedef time_point<
      _Clock, typename common_type<_Duration1, duration<_Rep2, _Period2>>::type>
      _Ret;
  return _Ret(__lhs.time_since_epoch() - __rhs);
}

template <class _Clock, class _Duration1, class _Duration2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr
    typename common_type<_Duration1, _Duration2>::type
    operator-(const time_point<_Clock, _Duration1> &__lhs,
              const time_point<_Clock, _Duration2> &__rhs) {
  return __lhs.time_since_epoch() - __rhs.time_since_epoch();
}

class __attribute__((__visibility__("default"))) system_clock {
public:
  typedef microseconds duration;
  typedef duration::rep rep;
  typedef duration::period period;
  typedef chrono::time_point<system_clock> time_point;
  static constexpr const bool is_steady = false;

  static time_point now() noexcept;
  static time_t to_time_t(const time_point &__t) noexcept;
  static time_point from_time_t(time_t __t) noexcept;
};

class __attribute__((__visibility__("default"))) steady_clock {
public:
  typedef nanoseconds duration;
  typedef duration::rep rep;
  typedef duration::period period;
  typedef chrono::time_point<steady_clock, duration> time_point;
  static constexpr const bool is_steady = true;

  static time_point now() noexcept;
};

typedef steady_clock high_resolution_clock;
# 2834 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/chrono" 3
} // namespace chrono

inline namespace literals {
inline namespace chrono_literals {

constexpr chrono::hours operator""h(unsigned long long __h) {
  return chrono::hours(static_cast<chrono::hours::rep>(__h));
}

constexpr chrono::duration<long double, ratio<3600, 1>>
operator""h(long double __h) {
  return chrono::duration<long double, ratio<3600, 1>>(__h);
}

constexpr chrono::minutes operator""min(unsigned long long __m) {
  return chrono::minutes(static_cast<chrono::minutes::rep>(__m));
}

constexpr chrono::duration<long double, ratio<60, 1>>
operator""min(long double __m) {
  return chrono::duration<long double, ratio<60, 1>>(__m);
}

constexpr chrono::seconds operator""s(unsigned long long __s) {
  return chrono::seconds(static_cast<chrono::seconds::rep>(__s));
}

constexpr chrono::duration<long double> operator""s(long double __s) {
  return chrono::duration<long double>(__s);
}

constexpr chrono::milliseconds operator""ms(unsigned long long __ms) {
  return chrono::milliseconds(static_cast<chrono::milliseconds::rep>(__ms));
}

constexpr chrono::duration<long double, milli> operator""ms(long double __ms) {
  return chrono::duration<long double, milli>(__ms);
}

constexpr chrono::microseconds operator""us(unsigned long long __us) {
  return chrono::microseconds(static_cast<chrono::microseconds::rep>(__us));
}

constexpr chrono::duration<long double, micro> operator""us(long double __us) {
  return chrono::duration<long double, micro>(__us);
}

constexpr chrono::nanoseconds operator""ns(unsigned long long __ns) {
  return chrono::nanoseconds(static_cast<chrono::nanoseconds::rep>(__ns));
}

constexpr chrono::duration<long double, nano> operator""ns(long double __ns) {
  return chrono::duration<long double, nano>(__ns);
}
# 2919 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/chrono" 3
} // namespace chrono_literals
} // namespace literals

namespace chrono {
using namespace literals::chrono_literals;
}

} // namespace __1
} // namespace std

namespace std {
inline namespace __1 {
namespace __fs {
namespace filesystem {
struct _FilesystemClock {

  typedef __int128_t rep;
  typedef nano period;

  typedef chrono::duration<rep, period> duration;
  typedef chrono::time_point<_FilesystemClock> time_point;

  __attribute__((
      __visibility__("default"))) static constexpr const bool is_steady = false;

  __attribute__((availability(macosx, strict, introduced = 10.15)))
  __attribute__((availability(ios, strict, introduced = 13.0)))
  __attribute__((availability(tvos, strict, introduced = 13.0)))
  __attribute__((availability(watchos, strict, introduced = 6.0)))
  __attribute__((__visibility__("default"))) static time_point
  now() noexcept;

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static time_t
  to_time_t(const time_point &__t) noexcept {
    typedef chrono::duration<rep> __secs;
    return time_t(
        chrono::duration_cast<__secs>(__t.time_since_epoch()).count());
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static time_point
  from_time_t(time_t __t) noexcept {
    typedef chrono::duration<rep> __secs;
    return time_point(__secs(__t));
  }
};
} // namespace filesystem
} // namespace __fs
} // namespace __1
} // namespace std
# 49 "/usr/local/include/QtCore/qmutex.h" 2

class tst_QMutex;
# 65 "/usr/local/include/QtCore/qmutex.h"
class QMutex;
class QRecursiveMutex;
class QMutexData;

class __attribute__((visibility("default"))) QBasicMutex {
public:
  constexpr QBasicMutex() : d_ptr(nullptr) {}

  inline void lock() {
    if (!fastTryLock())
      lockInternal();
  }

  inline void unlock() noexcept {
    ((d_ptr.loadRelaxed())
         ? static_cast<void>(0)
         : qt_assert("d_ptr.loadRelaxed()",
                     "/usr/local/include/QtCore/qmutex.h", 86));
    if (!fastTryUnlock())
      unlockInternal();
  }

  bool tryLock() noexcept { return fastTryLock(); }

  bool try_lock() noexcept { return tryLock(); }

  bool isRecursive() noexcept;
  bool isRecursive() const noexcept;

private:
  inline bool fastTryLock() noexcept {
    return d_ptr.testAndSetAcquire(nullptr, dummyLocked());
  }
  inline bool fastTryUnlock() noexcept {
    return d_ptr.testAndSetRelease(dummyLocked(), nullptr);
  }
  inline bool fastTryLock(QMutexData *&current) noexcept {
    return d_ptr.testAndSetAcquire(nullptr, dummyLocked(), current);
  }
  inline bool fastTryUnlock(QMutexData *&current) noexcept {
    return d_ptr.testAndSetRelease(dummyLocked(), nullptr, current);
  }

  void lockInternal();
  bool lockInternal(int timeout);
  void unlockInternal() noexcept;

  QBasicAtomicPointer<QMutexData> d_ptr;
  static inline QMutexData *dummyLocked() {
    return reinterpret_cast<QMutexData *>(quintptr(1));
  }

  friend class QMutex;
  friend class QRecursiveMutex;
  friend class QMutexData;
};

class __attribute__((visibility("default"))) QMutex : public QBasicMutex {
public:
  constexpr QMutex() = default;

  enum RecursionMode { NonRecursive, Recursive };
  explicit QMutex(RecursionMode mode);
  ~QMutex();

  void lock();
  bool tryLock(int timeout = 0);

  void unlock() noexcept;

  bool try_lock() { return tryLock(); }

  template <class Rep, class Period>
  bool try_lock_for(std::chrono::duration<Rep, Period> duration) {
    return tryLock(convertToMilliseconds(duration));
  }

  template <class Clock, class Duration>
  bool try_lock_until(std::chrono::time_point<Clock, Duration> timePoint) {

    return try_lock_for(timePoint - Clock::now());
  }

  bool isRecursive() const noexcept { return QBasicMutex::isRecursive(); }

private:
  QMutex(const QMutex &) = delete;
  QMutex &operator=(const QMutex &) = delete;
  friend class QMutexLocker;
  friend class QRecursiveMutex;
  friend class ::tst_QMutex;

  template <class Rep, class Period>
  static int
  convertToMilliseconds(std::chrono::duration<Rep, Period> duration) {

    if (duration <= duration.zero())
      return 0;

    std::chrono::milliseconds wait =
        std::chrono::duration_cast<std::chrono::milliseconds>(duration);
    if (wait < duration)
      wait += std::chrono::milliseconds(1);
    ((wait >= duration) ? static_cast<void>(0)
                        : qt_assert("wait >= duration",
                                    "/usr/local/include/QtCore/qmutex.h", 195));
    const auto ms = wait.count();
    const auto maxInt = (std::numeric_limits<int>::max)();

    return ms < maxInt ? int(ms) : maxInt;
  }
};

class QRecursiveMutex : private QMutex {

  friend class QMutexLocker;

public:
  __attribute__((visibility("default"))) QRecursiveMutex();
  __attribute__((visibility("default"))) ~QRecursiveMutex();

  using QMutex::lock;
  using QMutex::try_lock;
  using QMutex::tryLock;
  using QMutex::unlock;

  using QMutex::try_lock_for;
  using QMutex::try_lock_until;
};

class __attribute__((visibility("default"))) QMutexLocker {
public:
  inline explicit QMutexLocker(QBasicMutex *m) {
    (((reinterpret_cast<quintptr>(m) & quintptr(1u)) == quintptr(0))
         ? static_cast<void>(0)
         : qt_assert_x("QMutexLocker", "QMutex pointer is misaligned",
                       "/usr/local/include/QtCore/qmutex.h", 229));

    val = quintptr(m);
    if (__builtin_expect(!!(m), true)) {

      static_cast<QMutex *>(m)->lock();
      val |= 1;
    }
  }
  explicit QMutexLocker(QRecursiveMutex *m)
      : QMutexLocker{static_cast<QBasicMutex *>(m)} {}

  inline ~QMutexLocker() { unlock(); }

  inline void unlock() noexcept {
    if ((val & quintptr(1u)) == quintptr(1u)) {
      val &= ~quintptr(1u);
      mutex()->unlock();
    }
  }

  inline void relock() {
    if (val) {
      if ((val & quintptr(1u)) == quintptr(0u)) {
        mutex()->lock();
        val |= quintptr(1u);
      }
    }
  }

  inline QMutex *mutex() const {
    return reinterpret_cast<QMutex *>(val & ~quintptr(1u));
  }

private:
  QMutexLocker(const QMutexLocker &) = delete;
  QMutexLocker &operator=(const QMutexLocker &) = delete;

  quintptr val;
};
# 101 "/usr/local/include/QtCore/qglobalstatic.h" 2
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/mutex" 1 3
# 189 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/mutex" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 190 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/mutex" 2 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__mutex_base" 1 3
# 13 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__mutex_base" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 14 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__mutex_base" 2 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/system_error" 1 3
# 145 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/system_error" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__errc" 1 3
# 103 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__errc" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 104 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__errc" 2 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cerrno" 1 3
# 25 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cerrno" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 26 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cerrno" 2 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/errno.h" 1 3
# 25 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/errno.h" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 26 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/errno.h" 2 3
# 29 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/errno.h" 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/errno.h" 1 3 4
# 23 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/errno.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/errno.h" 1 3 4
# 79 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/errno.h" 3 4
extern "C" {
extern int *__error(void);
}
# 24 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/errno.h" 2 3 4
# 32 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/errno.h" 2 3
# 27 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cerrno" 2 3
# 30 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cerrno" 3
# 105 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__errc" 2 3
# 108 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__errc" 3

namespace std {
inline namespace __1 {

enum class __attribute__((__type_visibility__("default"))) errc {
  address_family_not_supported = 47,
  address_in_use = 48,
  address_not_available = 49,
  already_connected = 56,
  argument_list_too_long = 7,
  argument_out_of_domain = 33,
  bad_address = 14,
  bad_file_descriptor = 9,
  bad_message = 94,
  broken_pipe = 32,
  connection_aborted = 53,
  connection_already_in_progress = 37,
  connection_refused = 61,
  connection_reset = 54,
  cross_device_link = 18,
  destination_address_required = 39,
  device_or_resource_busy = 16,
  directory_not_empty = 66,
  executable_format_error = 8,
  file_exists = 17,
  file_too_large = 27,
  filename_too_long = 63,
  function_not_supported = 78,
  host_unreachable = 65,
  identifier_removed = 90,
  illegal_byte_sequence = 92,
  inappropriate_io_control_operation = 25,
  interrupted = 4,
  invalid_argument = 22,
  invalid_seek = 29,
  io_error = 5,
  is_a_directory = 21,
  message_size = 40,
  network_down = 50,
  network_reset = 52,
  network_unreachable = 51,
  no_buffer_space = 55,
  no_child_process = 10,
  no_link = 97,
  no_lock_available = 77,

  no_message_available = 96,

  no_message = 91,
  no_protocol_option = 42,
  no_space_on_device = 28,

  no_stream_resources = 98,

  no_such_device_or_address = 6,
  no_such_device = 19,
  no_such_file_or_directory = 2,
  no_such_process = 3,
  not_a_directory = 20,
  not_a_socket = 38,

  not_a_stream = 99,

  not_connected = 57,
  not_enough_memory = 12,
  not_supported = 45,
  operation_canceled = 89,
  operation_in_progress = 36,
  operation_not_permitted = 1,
  operation_not_supported = 102,
  operation_would_block = 35,
  owner_dead = 105,
  permission_denied = 13,
  protocol_error = 100,
  protocol_not_supported = 43,
  read_only_file_system = 30,
  resource_deadlock_would_occur = 11,
  resource_unavailable_try_again = 35,
  result_out_of_range = 34,
  state_not_recoverable = 104,

  stream_timeout = 101,

  text_file_busy = 26,
  timed_out = 60,
  too_many_files_open_in_system = 23,
  too_many_files_open = 24,
  too_many_links = 31,
  too_many_symbolic_link_levels = 62,
  value_too_large = 84,
  wrong_protocol_type = 41
};

}
} // namespace std
# 146 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/system_error" 2 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 1 3
# 503 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 504 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 2 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string_view" 1 3
# 174 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string_view" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 175 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string_view" 2 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__string" 1 3
# 56 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__string" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 57 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__string" 2 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdio" 1 3
# 98 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdio" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 99 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdio" 2 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/stdio.h" 1 3
# 100 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdio" 2 3
# 103 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdio" 3

namespace std {
inline namespace __1 {

using ::FILE;
using ::fpos_t;
using ::size_t;

using ::clearerr;
using ::fclose;
using ::feof;
using ::ferror;
using ::fflush;
using ::fgetc;
using ::fgetpos;
using ::fgets;
using ::fprintf;
using ::fputc;
using ::fputs;
using ::fread;
using ::fscanf;
using ::fseek;
using ::fsetpos;
using ::ftell;
using ::fwrite;
using ::getc;
using ::perror;
using ::putc;
using ::rewind;
using ::setbuf;
using ::setvbuf;
using ::snprintf;
using ::sprintf;
using ::sscanf;
using ::ungetc;
using ::vfprintf;
using ::vfscanf;
using ::vsnprintf;
using ::vsprintf;
using ::vsscanf;

using ::fopen;
using ::freopen;
using ::remove;
using ::rename;
using ::tmpfile;
using ::tmpnam;

using ::getchar;

using ::scanf;
using ::vscanf;

using ::printf;
using ::putchar;
using ::puts;
using ::vprintf;
# 181 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdio" 3
} // namespace __1
} // namespace std
# 59 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__string" 2 3
# 65 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__string" 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_macros" 1 3
# 69 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__string" 2 3

namespace std {
inline namespace __1 {

template <class _CharT>
struct __attribute__((__type_visibility__("default"))) char_traits {
  typedef _CharT char_type;
  typedef int int_type;
  typedef streamoff off_type;
  typedef streampos pos_type;
  typedef mbstate_t state_type;

  static inline void assign(char_type &__c1, const char_type &__c2) noexcept {
    __c1 = __c2;
  }
  static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept {
    return __c1 == __c2;
  }
  static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept {
    return __c1 < __c2;
  }

  static int compare(const char_type *__s1, const char_type *__s2, size_t __n);
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static size_t
  length(const char_type *__s);
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static const char_type *
  find(const char_type *__s, size_t __n, const char_type &__a);
  static char_type *move(char_type *__s1, const char_type *__s2, size_t __n);
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static char_type *
  copy(char_type *__s1, const char_type *__s2, size_t __n);
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static char_type *
  assign(char_type *__s, size_t __n, char_type __a);

  static inline constexpr int_type not_eof(int_type __c) noexcept {
    return eq_int_type(__c, eof()) ? ~eof() : __c;
  }
  static inline constexpr char_type to_char_type(int_type __c) noexcept {
    return char_type(__c);
  }
  static inline constexpr int_type to_int_type(char_type __c) noexcept {
    return int_type(__c);
  }
  static inline constexpr bool eq_int_type(int_type __c1,
                                           int_type __c2) noexcept {
    return __c1 == __c2;
  }
  static inline constexpr int_type eof() noexcept { return int_type((-1)); }
};

template <class _CharT>
int char_traits<_CharT>::compare(const char_type *__s1, const char_type *__s2,
                                 size_t __n) {
  for (; __n; --__n, ++__s1, ++__s2) {
    if (lt(*__s1, *__s2))
      return -1;
    if (lt(*__s2, *__s1))
      return 1;
  }
  return 0;
}

template <class _CharT>
inline size_t char_traits<_CharT>::length(const char_type *__s) {
  size_t __len = 0;
  for (; !eq(*__s, char_type(0)); ++__s)
    ++__len;
  return __len;
}

template <class _CharT>
inline const _CharT *char_traits<_CharT>::find(const char_type *__s, size_t __n,
                                               const char_type &__a) {
  for (; __n; --__n) {
    if (eq(*__s, __a))
      return __s;
    ++__s;
  }
  return 0;
}

template <class _CharT>
_CharT *char_traits<_CharT>::move(char_type *__s1, const char_type *__s2,
                                  size_t __n) {
  if (__n == 0)
    return __s1;
  char_type *__r = __s1;
  if (__s1 < __s2) {
    for (; __n; --__n, ++__s1, ++__s2)
      assign(*__s1, *__s2);
  } else if (__s2 < __s1) {
    __s1 += __n;
    __s2 += __n;
    for (; __n; --__n)
      assign(*--__s1, *--__s2);
  }
  return __r;
}

template <class _CharT>
inline _CharT *char_traits<_CharT>::copy(char_type *__s1, const char_type *__s2,
                                         size_t __n) {
  ((void)0);
  char_type *__r = __s1;
  for (; __n; --__n, ++__s1, ++__s2)
    assign(*__s1, *__s2);
  return __r;
}

template <class _CharT>
inline _CharT *char_traits<_CharT>::assign(char_type *__s, size_t __n,
                                           char_type __a) {
  char_type *__r = __s;
  for (; __n; --__n, ++__s)
    assign(*__s, __a);
  return __r;
}

template <class _CharT>
static inline _CharT *__move_constexpr(_CharT *__s1, const _CharT *__s2,
                                       size_t __n) noexcept {
  if (__n == 0)
    return __s1;
  if (__s1 < __s2) {
    std::__1::copy(__s2, __s2 + __n, __s1);
  } else if (__s2 < __s1) {
    std::__1::copy_backward(__s2, __s2 + __n, __s1 + __n);
  }
  return __s1;
}

template <class _CharT>
static inline _CharT *__copy_constexpr(_CharT *__s1, const _CharT *__s2,
                                       size_t __n) noexcept {
  std::__1::copy_n(__s2, __n, __s1);
  return __s1;
}

template <class _CharT>
static inline _CharT *__assign_constexpr(_CharT *__s, size_t __n,
                                         _CharT __a) noexcept {
  std::__1::fill_n(__s, __n, __a);
  return __s;
}

template <>
struct __attribute__((__type_visibility__("default"))) char_traits<char> {
  typedef char char_type;
  typedef int int_type;
  typedef streamoff off_type;
  typedef streampos pos_type;
  typedef mbstate_t state_type;

  static inline void assign(char_type &__c1, const char_type &__c2) noexcept {
    __c1 = __c2;
  }
  static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept {
    return __c1 == __c2;
  }
  static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept {
    return (unsigned char)__c1 < (unsigned char)__c2;
  }

  static int compare(const char_type *__s1, const char_type *__s2,
                     size_t __n) noexcept;
  static inline size_t length(const char_type *__s) noexcept {
    return __builtin_strlen(__s);
  }
  static const char_type *find(const char_type *__s, size_t __n,
                               const char_type &__a) noexcept;
  static inline char_type *move(char_type *__s1, const char_type *__s2,
                                size_t __n) noexcept {
    return __libcpp_is_constant_evaluated() ? __move_constexpr(__s1, __s2, __n)
           : __n == 0                       ? __s1
                      : (char_type *)memmove(__s1, __s2, __n);
  }
  static inline char_type *copy(char_type *__s1, const char_type *__s2,
                                size_t __n) noexcept {
    ((void)0);
    return __libcpp_is_constant_evaluated() ? __copy_constexpr(__s1, __s2, __n)
           : __n == 0                       ? __s1
                      : (char_type *)memcpy(__s1, __s2, __n);
  }
  static inline char_type *assign(char_type *__s, size_t __n,
                                  char_type __a) noexcept {
    return __libcpp_is_constant_evaluated() ? __assign_constexpr(__s, __n, __a)
           : __n == 0                       ? __s
                      : (char_type *)memset(__s, to_int_type(__a), __n);
  }

  static inline constexpr int_type not_eof(int_type __c) noexcept {
    return eq_int_type(__c, eof()) ? ~eof() : __c;
  }
  static inline constexpr char_type to_char_type(int_type __c) noexcept {
    return char_type(__c);
  }
  static inline constexpr int_type to_int_type(char_type __c) noexcept {
    return int_type((unsigned char)__c);
  }
  static inline constexpr bool eq_int_type(int_type __c1,
                                           int_type __c2) noexcept {
    return __c1 == __c2;
  }
  static inline constexpr int_type eof() noexcept { return int_type((-1)); }
};

inline int char_traits<char>::compare(const char_type *__s1,
                                      const char_type *__s2,
                                      size_t __n) noexcept {
  if (__n == 0)
    return 0;

  return __builtin_memcmp(__s1, __s2, __n);
# 311 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__string" 3
}

inline const char *char_traits<char>::find(const char_type *__s, size_t __n,
                                           const char_type &__a) noexcept {
  if (__n == 0)
    return nullptr;

  return __builtin_char_memchr(__s, to_int_type(__a), __n);
# 332 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__string" 3
}

template <>
struct __attribute__((__type_visibility__("default"))) char_traits<wchar_t> {
  typedef wchar_t char_type;
  typedef wint_t int_type;
  typedef streamoff off_type;
  typedef streampos pos_type;
  typedef mbstate_t state_type;

  static inline void assign(char_type &__c1, const char_type &__c2) noexcept {
    __c1 = __c2;
  }
  static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept {
    return __c1 == __c2;
  }
  static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept {
    return __c1 < __c2;
  }

  static int compare(const char_type *__s1, const char_type *__s2,
                     size_t __n) noexcept;
  static size_t length(const char_type *__s) noexcept;
  static const char_type *find(const char_type *__s, size_t __n,
                               const char_type &__a) noexcept;
  static inline char_type *move(char_type *__s1, const char_type *__s2,
                                size_t __n) noexcept {
    return __libcpp_is_constant_evaluated() ? __move_constexpr(__s1, __s2, __n)
           : __n == 0                       ? __s1
                                            : wmemmove(__s1, __s2, __n);
  }
  static inline char_type *copy(char_type *__s1, const char_type *__s2,
                                size_t __n) noexcept {
    ((void)0);
    return __libcpp_is_constant_evaluated() ? __copy_constexpr(__s1, __s2, __n)
           : __n == 0                       ? __s1
                                            : wmemcpy(__s1, __s2, __n);
  }
  static inline char_type *assign(char_type *__s, size_t __n,
                                  char_type __a) noexcept {
    return __libcpp_is_constant_evaluated() ? __assign_constexpr(__s, __n, __a)
           : __n == 0                       ? __s
                                            : wmemset(__s, __a, __n);
  }
  static inline constexpr int_type not_eof(int_type __c) noexcept {
    return eq_int_type(__c, eof()) ? ~eof() : __c;
  }
  static inline constexpr char_type to_char_type(int_type __c) noexcept {
    return char_type(__c);
  }
  static inline constexpr int_type to_int_type(char_type __c) noexcept {
    return int_type(__c);
  }
  static inline constexpr bool eq_int_type(int_type __c1,
                                           int_type __c2) noexcept {
    return __c1 == __c2;
  }
  static inline constexpr int_type eof() noexcept {
    return int_type(((__darwin_wint_t)-1));
  }
};

inline int char_traits<wchar_t>::compare(const char_type *__s1,
                                         const char_type *__s2,
                                         size_t __n) noexcept {
  if (__n == 0)
    return 0;

  return __builtin_wmemcmp(__s1, __s2, __n);
# 413 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__string" 3
}

template <class _Traits>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr inline size_t
__char_traits_length_checked(const typename _Traits::char_type *__s) noexcept {

  return _Traits::length(__s);
}

inline size_t char_traits<wchar_t>::length(const char_type *__s) noexcept {

  return __builtin_wcslen(__s);
# 441 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__string" 3
}

inline const wchar_t *
char_traits<wchar_t>::find(const char_type *__s, size_t __n,
                           const char_type &__a) noexcept {
  if (__n == 0)
    return nullptr;

  return __builtin_wmemchr(__s, __a, __n);
# 462 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__string" 3
}
# 576 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__string" 3
template <>
struct __attribute__((__type_visibility__("default"))) char_traits<char16_t> {
  typedef char16_t char_type;
  typedef uint_least16_t int_type;
  typedef streamoff off_type;
  typedef u16streampos pos_type;
  typedef mbstate_t state_type;

  static inline void assign(char_type &__c1, const char_type &__c2) noexcept {
    __c1 = __c2;
  }
  static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept {
    return __c1 == __c2;
  }
  static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept {
    return __c1 < __c2;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static int
  compare(const char_type *__s1, const char_type *__s2, size_t __n) noexcept;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static size_t
  length(const char_type *__s) noexcept;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static const char_type *
  find(const char_type *__s, size_t __n, const char_type &__a) noexcept;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static char_type *
  move(char_type *__s1, const char_type *__s2, size_t __n) noexcept;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static char_type *
  copy(char_type *__s1, const char_type *__s2, size_t __n) noexcept;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static char_type *
  assign(char_type *__s, size_t __n, char_type __a) noexcept;

  static inline constexpr int_type not_eof(int_type __c) noexcept {
    return eq_int_type(__c, eof()) ? ~eof() : __c;
  }
  static inline constexpr char_type to_char_type(int_type __c) noexcept {
    return char_type(__c);
  }
  static inline constexpr int_type to_int_type(char_type __c) noexcept {
    return int_type(__c);
  }
  static inline constexpr bool eq_int_type(int_type __c1,
                                           int_type __c2) noexcept {
    return __c1 == __c2;
  }
  static inline constexpr int_type eof() noexcept { return int_type(0xFFFF); }
};

inline int char_traits<char16_t>::compare(const char_type *__s1,
                                          const char_type *__s2,
                                          size_t __n) noexcept {
  for (; __n; --__n, ++__s1, ++__s2) {
    if (lt(*__s1, *__s2))
      return -1;
    if (lt(*__s2, *__s1))
      return 1;
  }
  return 0;
}

inline size_t char_traits<char16_t>::length(const char_type *__s) noexcept {
  size_t __len = 0;
  for (; !eq(*__s, char_type(0)); ++__s)
    ++__len;
  return __len;
}

inline const char16_t *
char_traits<char16_t>::find(const char_type *__s, size_t __n,
                            const char_type &__a) noexcept {
  for (; __n; --__n) {
    if (eq(*__s, __a))
      return __s;
    ++__s;
  }
  return 0;
}

inline char16_t *char_traits<char16_t>::move(char_type *__s1,
                                             const char_type *__s2,
                                             size_t __n) noexcept {
  if (__n == 0)
    return __s1;
  char_type *__r = __s1;
  if (__s1 < __s2) {
    for (; __n; --__n, ++__s1, ++__s2)
      assign(*__s1, *__s2);
  } else if (__s2 < __s1) {
    __s1 += __n;
    __s2 += __n;
    for (; __n; --__n)
      assign(*--__s1, *--__s2);
  }
  return __r;
}

inline char16_t *char_traits<char16_t>::copy(char_type *__s1,
                                             const char_type *__s2,
                                             size_t __n) noexcept {
  ((void)0);
  char_type *__r = __s1;
  for (; __n; --__n, ++__s1, ++__s2)
    assign(*__s1, *__s2);
  return __r;
}

inline char16_t *char_traits<char16_t>::assign(char_type *__s, size_t __n,
                                               char_type __a) noexcept {
  char_type *__r = __s;
  for (; __n; --__n, ++__s)
    assign(*__s, __a);
  return __r;
}

template <>
struct __attribute__((__type_visibility__("default"))) char_traits<char32_t> {
  typedef char32_t char_type;
  typedef uint_least32_t int_type;
  typedef streamoff off_type;
  typedef u32streampos pos_type;
  typedef mbstate_t state_type;

  static inline void assign(char_type &__c1, const char_type &__c2) noexcept {
    __c1 = __c2;
  }
  static inline constexpr bool eq(char_type __c1, char_type __c2) noexcept {
    return __c1 == __c2;
  }
  static inline constexpr bool lt(char_type __c1, char_type __c2) noexcept {
    return __c1 < __c2;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static int
  compare(const char_type *__s1, const char_type *__s2, size_t __n) noexcept;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static size_t
  length(const char_type *__s) noexcept;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static const char_type *
  find(const char_type *__s, size_t __n, const char_type &__a) noexcept;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static char_type *
  move(char_type *__s1, const char_type *__s2, size_t __n) noexcept;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static char_type *
  copy(char_type *__s1, const char_type *__s2, size_t __n) noexcept;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static char_type *
  assign(char_type *__s, size_t __n, char_type __a) noexcept;

  static inline constexpr int_type not_eof(int_type __c) noexcept {
    return eq_int_type(__c, eof()) ? ~eof() : __c;
  }
  static inline constexpr char_type to_char_type(int_type __c) noexcept {
    return char_type(__c);
  }
  static inline constexpr int_type to_int_type(char_type __c) noexcept {
    return int_type(__c);
  }
  static inline constexpr bool eq_int_type(int_type __c1,
                                           int_type __c2) noexcept {
    return __c1 == __c2;
  }
  static inline constexpr int_type eof() noexcept {
    return int_type(0xFFFFFFFF);
  }
};

inline int char_traits<char32_t>::compare(const char_type *__s1,
                                          const char_type *__s2,
                                          size_t __n) noexcept {
  for (; __n; --__n, ++__s1, ++__s2) {
    if (lt(*__s1, *__s2))
      return -1;
    if (lt(*__s2, *__s1))
      return 1;
  }
  return 0;
}

inline size_t char_traits<char32_t>::length(const char_type *__s) noexcept {
  size_t __len = 0;
  for (; !eq(*__s, char_type(0)); ++__s)
    ++__len;
  return __len;
}

inline const char32_t *
char_traits<char32_t>::find(const char_type *__s, size_t __n,
                            const char_type &__a) noexcept {
  for (; __n; --__n) {
    if (eq(*__s, __a))
      return __s;
    ++__s;
  }
  return 0;
}

inline char32_t *char_traits<char32_t>::move(char_type *__s1,
                                             const char_type *__s2,
                                             size_t __n) noexcept {
  if (__n == 0)
    return __s1;
  char_type *__r = __s1;
  if (__s1 < __s2) {
    for (; __n; --__n, ++__s1, ++__s2)
      assign(*__s1, *__s2);
  } else if (__s2 < __s1) {
    __s1 += __n;
    __s2 += __n;
    for (; __n; --__n)
      assign(*--__s1, *--__s2);
  }
  return __r;
}

inline char32_t *char_traits<char32_t>::copy(char_type *__s1,
                                             const char_type *__s2,
                                             size_t __n) noexcept {
  ((void)0);
  char_type *__r = __s1;
  for (; __n; --__n, ++__s1, ++__s2)
    assign(*__s1, *__s2);
  return __r;
}

inline char32_t *char_traits<char32_t>::assign(char_type *__s, size_t __n,
                                               char_type __a) noexcept {
  char_type *__r = __s;
  for (; __n; --__n, ++__s)
    assign(*__s, __a);
  return __r;
}

template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
__str_find(const _CharT *__p, _SizeT __sz, _CharT __c, _SizeT __pos) noexcept {
  if (__pos >= __sz)
    return __npos;
  const _CharT *__r = _Traits::find(__p + __pos, __sz - __pos, __c);
  if (__r == 0)
    return __npos;
  return static_cast<_SizeT>(__r - __p);
}

template <class _CharT, class _Traits>
inline constexpr const _CharT *
__search_substring(const _CharT *__first1, const _CharT *__last1,
                   const _CharT *__first2, const _CharT *__last2) {

  const ptrdiff_t __len2 = __last2 - __first2;
  if (__len2 == 0)
    return __first1;

  ptrdiff_t __len1 = __last1 - __first1;
  if (__len1 < __len2)
    return __last1;

  _CharT __f2 = *__first2;
  while (true) {
    __len1 = __last1 - __first1;

    if (__len1 < __len2)
      return __last1;

    __first1 = _Traits::find(__first1, __len1 - __len2 + 1, __f2);
    if (__first1 == 0)
      return __last1;

    if (_Traits::compare(__first1, __first2, __len2) == 0)
      return __first1;

    ++__first1;
  }
}

template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
__str_find(const _CharT *__p, _SizeT __sz, const _CharT *__s, _SizeT __pos,
           _SizeT __n) noexcept {
  if (__pos > __sz)
    return __npos;

  if (__n == 0)
    return __pos;

  const _CharT *__r = __search_substring<_CharT, _Traits>(
      __p + __pos, __p + __sz, __s, __s + __n);

  if (__r == __p + __sz)
    return __npos;
  return static_cast<_SizeT>(__r - __p);
}

template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
__str_rfind(const _CharT *__p, _SizeT __sz, _CharT __c, _SizeT __pos) noexcept {
  if (__sz < 1)
    return __npos;
  if (__pos < __sz)
    ++__pos;
  else
    __pos = __sz;
  for (const _CharT *__ps = __p + __pos; __ps != __p;) {
    if (_Traits::eq(*--__ps, __c))
      return static_cast<_SizeT>(__ps - __p);
  }
  return __npos;
}

template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
__str_rfind(const _CharT *__p, _SizeT __sz, const _CharT *__s, _SizeT __pos,
            _SizeT __n) noexcept {
  __pos = std::__1::min(__pos, __sz);
  if (__n < __sz - __pos)
    __pos += __n;
  else
    __pos = __sz;
  const _CharT *__r = std::__1::__find_end(
      __p, __p + __pos, __s, __s + __n, _Traits::eq,
      random_access_iterator_tag(), random_access_iterator_tag());
  if (__n > 0 && __r == __p + __pos)
    return __npos;
  return static_cast<_SizeT>(__r - __p);
}

template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
__str_find_first_of(const _CharT *__p, _SizeT __sz, const _CharT *__s,
                    _SizeT __pos, _SizeT __n) noexcept {
  if (__pos >= __sz || __n == 0)
    return __npos;
  const _CharT *__r = std::__1::__find_first_of_ce(__p + __pos, __p + __sz, __s,
                                                   __s + __n, _Traits::eq);
  if (__r == __p + __sz)
    return __npos;
  return static_cast<_SizeT>(__r - __p);
}

template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
__str_find_last_of(const _CharT *__p, _SizeT __sz, const _CharT *__s,
                   _SizeT __pos, _SizeT __n) noexcept {
  if (__n != 0) {
    if (__pos < __sz)
      ++__pos;
    else
      __pos = __sz;
    for (const _CharT *__ps = __p + __pos; __ps != __p;) {
      const _CharT *__r = _Traits::find(__s, __n, *--__ps);
      if (__r)
        return static_cast<_SizeT>(__ps - __p);
    }
  }
  return __npos;
}

template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
__str_find_first_not_of(const _CharT *__p, _SizeT __sz, const _CharT *__s,
                        _SizeT __pos, _SizeT __n) noexcept {
  if (__pos < __sz) {
    const _CharT *__pe = __p + __sz;
    for (const _CharT *__ps = __p + __pos; __ps != __pe; ++__ps)
      if (_Traits::find(__s, __n, *__ps) == 0)
        return static_cast<_SizeT>(__ps - __p);
  }
  return __npos;
}

template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
__str_find_first_not_of(const _CharT *__p, _SizeT __sz, _CharT __c,
                        _SizeT __pos) noexcept {
  if (__pos < __sz) {
    const _CharT *__pe = __p + __sz;
    for (const _CharT *__ps = __p + __pos; __ps != __pe; ++__ps)
      if (!_Traits::eq(*__ps, __c))
        return static_cast<_SizeT>(__ps - __p);
  }
  return __npos;
}

template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
__str_find_last_not_of(const _CharT *__p, _SizeT __sz, const _CharT *__s,
                       _SizeT __pos, _SizeT __n) noexcept {
  if (__pos < __sz)
    ++__pos;
  else
    __pos = __sz;
  for (const _CharT *__ps = __p + __pos; __ps != __p;)
    if (_Traits::find(__s, __n, *--__ps) == 0)
      return static_cast<_SizeT>(__ps - __p);
  return __npos;
}

template <class _CharT, class _SizeT, class _Traits, _SizeT __npos>
inline _SizeT constexpr __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
__str_find_last_not_of(const _CharT *__p, _SizeT __sz, _CharT __c,
                       _SizeT __pos) noexcept {
  if (__pos < __sz)
    ++__pos;
  else
    __pos = __sz;
  for (const _CharT *__ps = __p + __pos; __ps != __p;)
    if (!_Traits::eq(*--__ps, __c))
      return static_cast<_SizeT>(__ps - __p);
  return __npos;
}

template <class _Ptr>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) size_t
__do_string_hash(_Ptr __p, _Ptr __e) {
  typedef typename iterator_traits<_Ptr>::value_type value_type;
  return __murmur2_or_cityhash<size_t>()(__p, (__e - __p) * sizeof(value_type));
}

template <class _CharT, class _Iter, class _Traits = char_traits<_CharT>>
struct __quoted_output_proxy {
  _Iter __first;
  _Iter __last;
  _CharT __delim;
  _CharT __escape;

  __quoted_output_proxy(_Iter __f, _Iter __l, _CharT __d, _CharT __e)
      : __first(__f), __last(__l), __delim(__d), __escape(__e) {}
};

} // namespace __1
} // namespace std
# 176 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string_view" 2 3
# 186 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string_view" 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_macros" 1 3
# 190 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string_view" 2 3

namespace std {
inline namespace __1 {

template <class _CharT, class _Traits = char_traits<_CharT>>
class __attribute__((__type_visibility__("default"))) basic_string_view {
public:
  typedef _Traits traits_type;
  typedef _CharT value_type;
  typedef _CharT *pointer;
  typedef const _CharT *const_pointer;
  typedef _CharT &reference;
  typedef const _CharT &const_reference;
  typedef const_pointer const_iterator;
  typedef const_iterator iterator;
  typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;
  typedef const_reverse_iterator reverse_iterator;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;
  static constexpr const size_type npos = -1;

  static_assert((!is_array<value_type>::value),
                "Character type of basic_string_view must not be an array");
  static_assert((is_standard_layout<value_type>::value),
                "Character type of basic_string_view must be standard-layout");
  static_assert((is_trivial<value_type>::value),
                "Character type of basic_string_view must be trivial");
  static_assert((is_same<_CharT, typename traits_type::char_type>::value),
                "traits_type::char_type must be the same type as CharT");

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) basic_string_view() noexcept
      : __data(nullptr), __size(0) {}

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage))
  basic_string_view(const basic_string_view &) noexcept = default;

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) basic_string_view &
  operator=(const basic_string_view &) noexcept = default;

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage))
  basic_string_view(const _CharT *__s, size_type __len) noexcept
      : __data(__s), __size(__len) {

    ((void)0);
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) basic_string_view(const _CharT *__s)
      : __data(__s), __size(std::__char_traits_length_checked<_Traits>(__s)) {}

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) const_iterator
  begin() const noexcept {
    return cbegin();
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) const_iterator
  end() const noexcept {
    return cend();
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) const_iterator
  cbegin() const noexcept {
    return __data;
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) const_iterator
  cend() const noexcept {
    return __data + __size;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reverse_iterator
  rbegin() const noexcept {
    return const_reverse_iterator(cend());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reverse_iterator
  rend() const noexcept {
    return const_reverse_iterator(cbegin());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reverse_iterator
  crbegin() const noexcept {
    return const_reverse_iterator(cend());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reverse_iterator
  crend() const noexcept {
    return const_reverse_iterator(cbegin());
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) size_type
  size() const noexcept {
    return __size;
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) size_type
  length() const noexcept {
    return __size;
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) size_type
  max_size() const noexcept {
    return numeric_limits<size_type>::max();
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr bool
  empty() const noexcept {
    return __size == 0;
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) const_reference
  operator[](size_type __pos) const noexcept {
    return __data[__pos];
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) const_reference
  at(size_type __pos) const {
    return __pos >= size()
               ? (__throw_out_of_range("string_view::at"), __data[0])
               : __data[__pos];
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) const_reference
  front() const noexcept {
    return ((void)0), __data[0];
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) const_reference
  back() const noexcept {
    return ((void)0), __data[__size - 1];
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) const_pointer
  data() const noexcept {
    return __data;
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  remove_prefix(size_type __n) noexcept {
    ((void)0);
    __data += __n;
    __size -= __n;
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  remove_suffix(size_type __n) noexcept {
    ((void)0);
    __size -= __n;
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  swap(basic_string_view &__other) noexcept {
    const value_type *__p = __data;
    __data = __other.__data;
    __other.__data = __p;

    size_type __sz = __size;
    __size = __other.__size;
    __other.__size = __sz;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  copy(_CharT *__s, size_type __n, size_type __pos = 0) const {
    if (__pos > size())
      __throw_out_of_range("string_view::copy");
    size_type __rlen = std::__1::min(__n, size() - __pos);
    _Traits::copy(__s, data() + __pos, __rlen);
    return __rlen;
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) basic_string_view
  substr(size_type __pos = 0, size_type __n = npos) const {
    return __pos > size()
               ? (__throw_out_of_range("string_view::substr"),
                  basic_string_view())
               : basic_string_view(data() + __pos,
                                   std::__1::min(__n, size() - __pos));
  }

  constexpr int compare(basic_string_view __sv) const noexcept {
    size_type __rlen = std::__1::min(size(), __sv.size());
    int __retval = _Traits::compare(data(), __sv.data(), __rlen);
    if (__retval == 0)
      __retval = size() == __sv.size() ? 0 : (size() < __sv.size() ? -1 : 1);
    return __retval;
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) int
  compare(size_type __pos1, size_type __n1, basic_string_view __sv) const {
    return substr(__pos1, __n1).compare(__sv);
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) int
  compare(size_type __pos1, size_type __n1, basic_string_view __sv,
          size_type __pos2, size_type __n2) const {
    return substr(__pos1, __n1).compare(__sv.substr(__pos2, __n2));
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) int
  compare(const _CharT *__s) const noexcept {
    return compare(basic_string_view(__s));
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) int
  compare(size_type __pos1, size_type __n1, const _CharT *__s) const {
    return substr(__pos1, __n1).compare(basic_string_view(__s));
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) int
  compare(size_type __pos1, size_type __n1, const _CharT *__s,
          size_type __n2) const {
    return substr(__pos1, __n1).compare(basic_string_view(__s, __n2));
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) size_type
  find(basic_string_view __s, size_type __pos = 0) const noexcept {
    ((void)0);
    return __str_find<value_type, size_type, traits_type, npos>(
        data(), size(), __s.data(), __pos, __s.size());
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) size_type
  find(_CharT __c, size_type __pos = 0) const noexcept {
    return __str_find<value_type, size_type, traits_type, npos>(data(), size(),
                                                                __c, __pos);
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) size_type
  find(const _CharT *__s, size_type __pos, size_type __n) const {
    ((void)0);
    return __str_find<value_type, size_type, traits_type, npos>(
        data(), size(), __s, __pos, __n);
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) size_type
  find(const _CharT *__s, size_type __pos = 0) const {
    ((void)0);
    return __str_find<value_type, size_type, traits_type, npos>(
        data(), size(), __s, __pos, traits_type::length(__s));
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) size_type
  rfind(basic_string_view __s, size_type __pos = npos) const noexcept {
    ((void)0);
    return __str_rfind<value_type, size_type, traits_type, npos>(
        data(), size(), __s.data(), __pos, __s.size());
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) size_type
  rfind(_CharT __c, size_type __pos = npos) const noexcept {
    return __str_rfind<value_type, size_type, traits_type, npos>(data(), size(),
                                                                 __c, __pos);
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) size_type
  rfind(const _CharT *__s, size_type __pos, size_type __n) const {
    ((void)0);
    return __str_rfind<value_type, size_type, traits_type, npos>(
        data(), size(), __s, __pos, __n);
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) size_type
  rfind(const _CharT *__s, size_type __pos = npos) const {
    ((void)0);
    return __str_rfind<value_type, size_type, traits_type, npos>(
        data(), size(), __s, __pos, traits_type::length(__s));
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) size_type
  find_first_of(basic_string_view __s, size_type __pos = 0) const noexcept {
    ((void)0);
    return __str_find_first_of<value_type, size_type, traits_type, npos>(
        data(), size(), __s.data(), __pos, __s.size());
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) size_type
  find_first_of(_CharT __c, size_type __pos = 0) const noexcept {
    return find(__c, __pos);
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) size_type
  find_first_of(const _CharT *__s, size_type __pos, size_type __n) const {
    ((void)0);
    return __str_find_first_of<value_type, size_type, traits_type, npos>(
        data(), size(), __s, __pos, __n);
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) size_type
  find_first_of(const _CharT *__s, size_type __pos = 0) const {
    ((void)0);
    return __str_find_first_of<value_type, size_type, traits_type, npos>(
        data(), size(), __s, __pos, traits_type::length(__s));
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) size_type
  find_last_of(basic_string_view __s, size_type __pos = npos) const noexcept {
    ((void)0);
    return __str_find_last_of<value_type, size_type, traits_type, npos>(
        data(), size(), __s.data(), __pos, __s.size());
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) size_type
  find_last_of(_CharT __c, size_type __pos = npos) const noexcept {
    return rfind(__c, __pos);
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) size_type
  find_last_of(const _CharT *__s, size_type __pos, size_type __n) const {
    ((void)0);
    return __str_find_last_of<value_type, size_type, traits_type, npos>(
        data(), size(), __s, __pos, __n);
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) size_type
  find_last_of(const _CharT *__s, size_type __pos = npos) const {
    ((void)0);
    return __str_find_last_of<value_type, size_type, traits_type, npos>(
        data(), size(), __s, __pos, traits_type::length(__s));
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) size_type
  find_first_not_of(basic_string_view __s, size_type __pos = 0) const noexcept {
    ((void)0);
    return __str_find_first_not_of<value_type, size_type, traits_type, npos>(
        data(), size(), __s.data(), __pos, __s.size());
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) size_type
  find_first_not_of(_CharT __c, size_type __pos = 0) const noexcept {
    return __str_find_first_not_of<value_type, size_type, traits_type, npos>(
        data(), size(), __c, __pos);
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) size_type
  find_first_not_of(const _CharT *__s, size_type __pos, size_type __n) const {
    ((void)0);
    return __str_find_first_not_of<value_type, size_type, traits_type, npos>(
        data(), size(), __s, __pos, __n);
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) size_type
  find_first_not_of(const _CharT *__s, size_type __pos = 0) const {
    ((void)0);
    return __str_find_first_not_of<value_type, size_type, traits_type, npos>(
        data(), size(), __s, __pos, traits_type::length(__s));
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) size_type
  find_last_not_of(basic_string_view __s,
                   size_type __pos = npos) const noexcept {
    ((void)0);
    return __str_find_last_not_of<value_type, size_type, traits_type, npos>(
        data(), size(), __s.data(), __pos, __s.size());
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) size_type
  find_last_not_of(_CharT __c, size_type __pos = npos) const noexcept {
    return __str_find_last_not_of<value_type, size_type, traits_type, npos>(
        data(), size(), __c, __pos);
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) size_type
  find_last_not_of(const _CharT *__s, size_type __pos, size_type __n) const {
    ((void)0);
    return __str_find_last_not_of<value_type, size_type, traits_type, npos>(
        data(), size(), __s, __pos, __n);
  }

  constexpr __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) size_type
  find_last_not_of(const _CharT *__s, size_type __pos = npos) const {
    ((void)0);
    return __str_find_last_not_of<value_type, size_type, traits_type, npos>(
        data(), size(), __s, __pos, traits_type::length(__s));
  }
# 604 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string_view" 3
private:
  const value_type *__data;
  size_type __size;
};

template <class _CharT, class _Traits>
constexpr __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator==(basic_string_view<_CharT, _Traits> __lhs,
           basic_string_view<_CharT, _Traits> __rhs) noexcept {
  if (__lhs.size() != __rhs.size())
    return false;
  return __lhs.compare(__rhs) == 0;
}

template <class _CharT, class _Traits>
constexpr __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator==(basic_string_view<_CharT, _Traits> __lhs,
           typename common_type<basic_string_view<_CharT, _Traits>>::type
               __rhs) noexcept {
  if (__lhs.size() != __rhs.size())
    return false;
  return __lhs.compare(__rhs) == 0;
}

template <class _CharT, class _Traits>
constexpr __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator==(typename common_type<basic_string_view<_CharT, _Traits>>::type __lhs,
           basic_string_view<_CharT, _Traits> __rhs) noexcept {
  if (__lhs.size() != __rhs.size())
    return false;
  return __lhs.compare(__rhs) == 0;
}

template <class _CharT, class _Traits>
constexpr __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator!=(basic_string_view<_CharT, _Traits> __lhs,
           basic_string_view<_CharT, _Traits> __rhs) noexcept {
  if (__lhs.size() != __rhs.size())
    return true;
  return __lhs.compare(__rhs) != 0;
}

template <class _CharT, class _Traits>
constexpr __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator!=(basic_string_view<_CharT, _Traits> __lhs,
           typename common_type<basic_string_view<_CharT, _Traits>>::type
               __rhs) noexcept {
  if (__lhs.size() != __rhs.size())
    return true;
  return __lhs.compare(__rhs) != 0;
}

template <class _CharT, class _Traits>
constexpr __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator!=(typename common_type<basic_string_view<_CharT, _Traits>>::type __lhs,
           basic_string_view<_CharT, _Traits> __rhs) noexcept {
  if (__lhs.size() != __rhs.size())
    return true;
  return __lhs.compare(__rhs) != 0;
}

template <class _CharT, class _Traits>
constexpr __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator<(basic_string_view<_CharT, _Traits> __lhs,
          basic_string_view<_CharT, _Traits> __rhs) noexcept {
  return __lhs.compare(__rhs) < 0;
}

template <class _CharT, class _Traits>
constexpr __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator<(basic_string_view<_CharT, _Traits> __lhs,
          typename common_type<basic_string_view<_CharT, _Traits>>::type
              __rhs) noexcept {
  return __lhs.compare(__rhs) < 0;
}

template <class _CharT, class _Traits>
constexpr __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator<(typename common_type<basic_string_view<_CharT, _Traits>>::type __lhs,
          basic_string_view<_CharT, _Traits> __rhs) noexcept {
  return __lhs.compare(__rhs) < 0;
}

template <class _CharT, class _Traits>
constexpr __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator>(basic_string_view<_CharT, _Traits> __lhs,
          basic_string_view<_CharT, _Traits> __rhs) noexcept {
  return __lhs.compare(__rhs) > 0;
}

template <class _CharT, class _Traits>
constexpr __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator>(basic_string_view<_CharT, _Traits> __lhs,
          typename common_type<basic_string_view<_CharT, _Traits>>::type
              __rhs) noexcept {
  return __lhs.compare(__rhs) > 0;
}

template <class _CharT, class _Traits>
constexpr __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator>(typename common_type<basic_string_view<_CharT, _Traits>>::type __lhs,
          basic_string_view<_CharT, _Traits> __rhs) noexcept {
  return __lhs.compare(__rhs) > 0;
}

template <class _CharT, class _Traits>
constexpr __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator<=(basic_string_view<_CharT, _Traits> __lhs,
           basic_string_view<_CharT, _Traits> __rhs) noexcept {
  return __lhs.compare(__rhs) <= 0;
}

template <class _CharT, class _Traits>
constexpr __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator<=(basic_string_view<_CharT, _Traits> __lhs,
           typename common_type<basic_string_view<_CharT, _Traits>>::type
               __rhs) noexcept {
  return __lhs.compare(__rhs) <= 0;
}

template <class _CharT, class _Traits>
constexpr __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator<=(typename common_type<basic_string_view<_CharT, _Traits>>::type __lhs,
           basic_string_view<_CharT, _Traits> __rhs) noexcept {
  return __lhs.compare(__rhs) <= 0;
}

template <class _CharT, class _Traits>
constexpr __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator>=(basic_string_view<_CharT, _Traits> __lhs,
           basic_string_view<_CharT, _Traits> __rhs) noexcept {
  return __lhs.compare(__rhs) >= 0;
}

template <class _CharT, class _Traits>
constexpr __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator>=(basic_string_view<_CharT, _Traits> __lhs,
           typename common_type<basic_string_view<_CharT, _Traits>>::type
               __rhs) noexcept {
  return __lhs.compare(__rhs) >= 0;
}

template <class _CharT, class _Traits>
constexpr __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator>=(typename common_type<basic_string_view<_CharT, _Traits>>::type __lhs,
           basic_string_view<_CharT, _Traits> __rhs) noexcept {
  return __lhs.compare(__rhs) >= 0;
}

template <class _CharT, class _Traits>
basic_ostream<_CharT, _Traits> &
operator<<(basic_ostream<_CharT, _Traits> &__os,
           basic_string_view<_CharT, _Traits> __str);

typedef basic_string_view<char> string_view;

typedef basic_string_view<char16_t> u16string_view;
typedef basic_string_view<char32_t> u32string_view;
typedef basic_string_view<wchar_t> wstring_view;

template <class _CharT>
struct __attribute__((__type_visibility__("default")))
hash<basic_string_view<_CharT, char_traits<_CharT>>>
    : public unary_function<basic_string_view<_CharT, char_traits<_CharT>>,
                            size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_t
  operator()(const basic_string_view<_CharT, char_traits<_CharT>> __val)
      const noexcept {
    return __do_string_hash(__val.data(), __val.data() + __val.size());
  }
};

inline namespace literals {
inline namespace string_view_literals {
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr basic_string_view<char>
operator"" sv(const char *__str, size_t __len) noexcept {
  return basic_string_view<char>(__str, __len);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr basic_string_view<wchar_t>
operator"" sv(const wchar_t *__str, size_t __len) noexcept {
  return basic_string_view<wchar_t>(__str, __len);
}
# 822 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string_view" 3
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr basic_string_view<char16_t>
operator"" sv(const char16_t *__str, size_t __len) noexcept {
  return basic_string_view<char16_t>(__str, __len);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr basic_string_view<char32_t>
operator"" sv(const char32_t *__str, size_t __len) noexcept {
  return basic_string_view<char32_t>(__str, __len);
}
} // namespace string_view_literals
} // namespace literals

} // namespace __1
} // namespace std
# 505 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 2 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cwchar" 1 3
# 105 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cwchar" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 106 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cwchar" 2 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cwctype" 1 3
# 52 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cwctype" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 53 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cwctype" 2 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cctype" 1 3
# 37 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cctype" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 38 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cctype" 2 3
# 42 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cctype" 3

namespace std {
inline namespace __1 {
# 103 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cctype" 3
using ::isalnum;
using ::isalpha;
using ::isblank;
using ::iscntrl;
using ::isdigit;
using ::isgraph;
using ::islower;
using ::isprint;
using ::ispunct;
using ::isspace;
using ::isupper;
using ::isxdigit;
using ::tolower;
using ::toupper;

} // namespace __1
} // namespace std
# 54 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cwctype" 2 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/wctype.h" 1 3
# 47 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/wctype.h" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 48 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/wctype.h" 2 3
# 51 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/wctype.h" 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/wctype.h" 1 3 4
# 36 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/wctype.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_types/_wctrans_t.h" 1 3 4
# 32 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/_types/_wctrans_t.h" 3 4
typedef __darwin_wctrans_t wctrans_t;
# 37 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/wctype.h" 2 3 4
# 49 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/wctype.h" 3 4
inline int iswblank(wint_t _wc) { return (__istype(_wc, 0x00020000L)); }

inline int iswascii(wint_t _wc) { return ((_wc & ~0x7F) == 0); }

inline int iswhexnumber(wint_t _wc) { return (__istype(_wc, 0x00010000L)); }

inline int iswideogram(wint_t _wc) { return (__istype(_wc, 0x00080000L)); }

inline int iswnumber(wint_t _wc) { return (__istype(_wc, 0x00000400L)); }

inline int iswphonogram(wint_t _wc) { return (__istype(_wc, 0x00200000L)); }

inline int iswrune(wint_t _wc) { return (__istype(_wc, 0xFFFFFFF0L)); }

inline int iswspecial(wint_t _wc) { return (__istype(_wc, 0x00100000L)); }
# 117 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/wctype.h" 3 4
extern "C" {

wint_t nextwctype(wint_t, wctype_t);

wint_t towctrans(wint_t, wctrans_t);
wctrans_t wctrans(const char *);
}
# 54 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/wctype.h" 2 3
# 55 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cwctype" 2 3
# 58 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cwctype" 3

namespace std {
inline namespace __1 {

using ::iswalnum;
using ::iswalpha;
using ::iswblank;
using ::iswcntrl;
using ::iswctype;
using ::iswdigit;
using ::iswgraph;
using ::iswlower;
using ::iswprint;
using ::iswpunct;
using ::iswspace;
using ::iswupper;
using ::iswxdigit;
using ::towctrans;
using ::towlower;
using ::towupper;
using ::wctrans;
using ::wctrans_t;
using ::wctype;
using ::wctype_t;
using ::wint_t;

} // namespace __1
} // namespace std
# 107 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cwchar" 2 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/wchar.h" 1 3
# 108 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cwchar" 2 3
# 111 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cwchar" 3

namespace std {
inline namespace __1 {

using ::fgetwc;
using ::fgetws;
using ::FILE;
using ::fputwc;
using ::fputws;
using ::fwide;
using ::fwprintf;
using ::fwscanf;
using ::getwc;
using ::mbstate_t;
using ::putwc;
using ::size_t;
using ::swprintf;
using ::swscanf;
using ::tm;
using ::ungetwc;
using ::vfwprintf;
using ::vfwscanf;
using ::vswprintf;
using ::vswscanf;
using ::wcstod;
using ::wcstof;
using ::wcstol;
using ::wcstold;
using ::wint_t;

using ::wcstoll;

using ::wcstoul;

using ::wcstoull;

using ::btowc;
using ::mbrlen;
using ::mbrtowc;
using ::mbsinit;
using ::mbsrtowcs;
using ::wcrtomb;
using ::wcscat;
using ::wcschr;
using ::wcscmp;
using ::wcscoll;
using ::wcscpy;
using ::wcscspn;
using ::wcsftime;
using ::wcslen;
using ::wcsncat;
using ::wcsncmp;
using ::wcsncpy;
using ::wcspbrk;
using ::wcsrchr;
using ::wcsrtombs;
using ::wcsspn;
using ::wcsstr;
using ::wcstok;
using ::wcsxfrm;
using ::wctob;
using ::wmemchr;
using ::wmemcmp;
using ::wmemcpy;
using ::wmemmove;
using ::wmemset;

using ::getwchar;
using ::vwscanf;
using ::wscanf;

using ::putwchar;
using ::vwprintf;
using ::wprintf;
# 244 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cwchar" 3
} // namespace __1
} // namespace std
# 509 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 2 3
# 526 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_macros" 1 3
# 530 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 2 3

namespace std {
inline namespace __1 {

template <class _StateT>
class __attribute__((__type_visibility__("default"))) fpos {
private:
  _StateT __st_;
  streamoff __off_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  fpos(streamoff __off = streamoff())
      : __st_(), __off_(__off) {}

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  operator streamoff() const {
    return __off_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  _StateT
  state() const {
    return __st_;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  state(_StateT __st) {
    __st_ = __st;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  fpos &
  operator+=(streamoff __off) {
    __off_ += __off;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  fpos
  operator+(streamoff __off) const {
    fpos __t(*this);
    __t += __off;
    return __t;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  fpos &
  operator-=(streamoff __off) {
    __off_ -= __off;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  fpos
  operator-(streamoff __off) const {
    fpos __t(*this);
    __t -= __off;
    return __t;
  }
};

template <class _StateT>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) streamoff
operator-(const fpos<_StateT> &__x, const fpos<_StateT> &__y) {
  return streamoff(__x) - streamoff(__y);
}

template <class _StateT>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator==(const fpos<_StateT> &__x, const fpos<_StateT> &__y) {
  return streamoff(__x) == streamoff(__y);
}

template <class _StateT>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator!=(const fpos<_StateT> &__x, const fpos<_StateT> &__y) {
  return streamoff(__x) != streamoff(__y);
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator> &__x,
          const basic_string<_CharT, _Traits, _Allocator> &__y);

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT *__x,
          const basic_string<_CharT, _Traits, _Allocator> &__y);

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __x, const basic_string<_CharT, _Traits, _Allocator> &__y);

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator> &__x,
          const _CharT *__y);

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator> &__x, _CharT __y);

extern template __attribute__((__visibility__("default"))) string operator+
    <char, char_traits<char>, allocator<char>>(char const *, string const &);

template <bool>
class __attribute__((__type_visibility__("default"))) __basic_string_common {
protected:
  [[noreturn]] void __throw_length_error() const;
  [[noreturn]] void __throw_out_of_range() const;
};

template <bool __b>
void __basic_string_common<__b>::__throw_length_error() const {
  std::__1::__throw_length_error("basic_string");
}

template <bool __b>
void __basic_string_common<__b>::__throw_out_of_range() const {
  std::__1::__throw_out_of_range("basic_string");
}

extern template class __attribute__((__visibility__("default")))
__basic_string_common<true>;
# 628 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3
template <class _Iter, bool = __is_cpp17_forward_iterator<_Iter>::value>
struct __libcpp_string_gets_noexcept_iterator_impl
    : public integral_constant<
          bool, ((noexcept(++(declval<_Iter &>())) &&
                  is_nothrow_assignable<_Iter &, _Iter>::value &&noexcept(
                      declval<_Iter>() ==
                      declval<_Iter>()) &&noexcept(*declval<_Iter>())))> {};

template <class _Iter>
struct __libcpp_string_gets_noexcept_iterator_impl<_Iter, false>
    : public false_type {};

template <class _Iter>
struct __libcpp_string_gets_noexcept_iterator
    : public integral_constant<
          bool, (__libcpp_is_trivial_iterator<_Iter>::value ||
                 __libcpp_string_gets_noexcept_iterator_impl<_Iter>::value)> {};

template <class _CharT, class _Traits, class _Tp>
struct __can_be_converted_to_string_view
    : public integral_constant<
          bool, ((is_convertible<const _Tp &,
                                 basic_string_view<_CharT, _Traits>>::value &&
                  !is_convertible<const _Tp &, const _CharT *>::value))> {};
# 665 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3
template <class _CharT, class _Traits, class _Allocator>
class __attribute__((__type_visibility__("default"))) basic_string
    : private __basic_string_common<true> {
public:
  typedef basic_string __self;
  typedef basic_string_view<_CharT, _Traits> __self_view;
  typedef _Traits traits_type;
  typedef _CharT value_type;
  typedef _Allocator allocator_type;
  typedef allocator_traits<allocator_type> __alloc_traits;
  typedef typename __alloc_traits::size_type size_type;
  typedef typename __alloc_traits::difference_type difference_type;
  typedef value_type &reference;
  typedef const value_type &const_reference;
  typedef typename __alloc_traits::pointer pointer;
  typedef typename __alloc_traits::const_pointer const_pointer;

  static_assert((!is_array<value_type>::value),
                "Character type of basic_string must not be an array");
  static_assert((is_standard_layout<value_type>::value),
                "Character type of basic_string must be standard-layout");
  static_assert((is_trivial<value_type>::value),
                "Character type of basic_string must be trivial");
  static_assert((is_same<_CharT, typename traits_type::char_type>::value),
                "traits_type::char_type must be the same type as CharT");
  static_assert(
      (is_same<typename allocator_type::value_type, value_type>::value),
      "Allocator::value_type must be same type as value_type");

  typedef __wrap_iter<pointer> iterator;
  typedef __wrap_iter<const_pointer> const_iterator;

  typedef std::__1::reverse_iterator<iterator> reverse_iterator;
  typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

private:
# 735 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3
  struct __long {
    size_type __cap_;
    size_type __size_;
    pointer __data_;
  };

  static const size_type __short_mask = 0x01;
  static const size_type __long_mask = 0x1ul;

  enum {
    __min_cap = (sizeof(__long) - 1) / sizeof(value_type) > 2
                    ? (sizeof(__long) - 1) / sizeof(value_type)
                    : 2
  };

  struct __short {
    union {
      unsigned char __size_;
      value_type __lx;
    };
    value_type __data_[__min_cap];
  };

  union __ulx {
    __long __lx;
    __short __lxx;
  };

  enum { __n_words = sizeof(__ulx) / sizeof(size_type) };

  struct __raw {
    size_type __words[__n_words];
  };

  struct __rep {
    union {
      __long __l;
      __short __s;
      __raw __r;
    };
  };

  __compressed_pair<__rep, allocator_type> __r_;

public:
  static const size_type npos = -1;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  basic_string() noexcept(
      is_nothrow_default_constructible<allocator_type>::value);

  __attribute__((__visibility__("hidden"))) __attribute__((
      internal_linkage)) explicit basic_string(const allocator_type &__a)

      noexcept(is_nothrow_copy_constructible<allocator_type>::value);

  basic_string(const basic_string &__str);
  basic_string(const basic_string &__str, const allocator_type &__a);

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  basic_string(basic_string &&__str)

      noexcept(is_nothrow_move_constructible<allocator_type>::value);

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  basic_string(basic_string &&__str, const allocator_type &__a);

  template <class = typename enable_if<__is_allocator<_Allocator>::value,
                                       nullptr_t>::type>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  basic_string(const _CharT *__s)
      : __r_(__default_init_tag(), __default_init_tag()) {
    ((void)0);
    __init(__s, traits_type::length(__s));
  }

  template <class = typename enable_if<__is_allocator<_Allocator>::value,
                                       nullptr_t>::type>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  basic_string(const _CharT *__s, const _Allocator &__a);

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  basic_string(const _CharT *__s, size_type __n);
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  basic_string(const _CharT *__s, size_type __n, const _Allocator &__a);
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  basic_string(size_type __n, _CharT __c);

  template <class = typename enable_if<__is_allocator<_Allocator>::value,
                                       nullptr_t>::type>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  basic_string(size_type __n, _CharT __c, const _Allocator &__a);

  basic_string(const basic_string &__str, size_type __pos, size_type __n,
               const _Allocator &__a = _Allocator());
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  basic_string(const basic_string &__str, size_type __pos,
               const _Allocator &__a = _Allocator());

  template <class _Tp,
            class = typename enable_if<
                __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
                void>::type>
  inline __attribute__((__visibility__("hidden")))
  basic_string(const _Tp &__t, size_type __pos, size_type __n,
               const allocator_type &__a = allocator_type());

  template <class _Tp,
            class = typename enable_if<
                __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
                void>::type>
  inline __attribute__((__visibility__("hidden"))) explicit basic_string(
      const _Tp &__t);

  template <class _Tp,
            class = typename enable_if<
                __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
                void>::type>
  inline __attribute__((__visibility__("hidden"))) explicit basic_string(
      const _Tp &__t, const allocator_type &__a);

  template <class _InputIterator,
            class = typename enable_if<
                __is_cpp17_input_iterator<_InputIterator>::value>::type>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  basic_string(_InputIterator __first, _InputIterator __last);
  template <class _InputIterator,
            class = typename enable_if<
                __is_cpp17_input_iterator<_InputIterator>::value>::type>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  basic_string(_InputIterator __first, _InputIterator __last,
               const allocator_type &__a);

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  basic_string(initializer_list<_CharT> __il);
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  basic_string(initializer_list<_CharT> __il, const _Allocator &__a);

  inline ~basic_string();

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  operator __self_view() const noexcept {
    return __self_view(data(), size());
  }

  basic_string &operator=(const basic_string &__str);

  template <class _Tp,
            class = typename enable_if<
                __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
                void>::type>
  basic_string &operator=(const _Tp &__t) {
    __self_view __sv = __t;
    return assign(__sv);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  basic_string &
  operator=(basic_string &&__str) noexcept(
      (__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  basic_string &
  operator=(initializer_list<value_type> __il) {
    return assign(__il.begin(), __il.size());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  basic_string &
  operator=(const value_type *__s) {
    return assign(__s);
  }
  basic_string &operator=(value_type __c);
# 907 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  begin() noexcept {
    return iterator(__get_pointer());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_iterator
  begin() const noexcept {
    return const_iterator(__get_pointer());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  end() noexcept {
    return iterator(__get_pointer() + size());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_iterator
  end() const noexcept {
    return const_iterator(__get_pointer() + size());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reverse_iterator
  rbegin() noexcept {
    return reverse_iterator(end());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reverse_iterator
  rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reverse_iterator
  rend() noexcept {
    return reverse_iterator(begin());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reverse_iterator
  rend() const noexcept {
    return const_reverse_iterator(begin());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_iterator
  cbegin() const noexcept {
    return begin();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_iterator
  cend() const noexcept {
    return end();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reverse_iterator
  crbegin() const noexcept {
    return rbegin();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reverse_iterator
  crend() const noexcept {
    return rend();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  size() const noexcept {
    return __is_long() ? __get_long_size() : __get_short_size();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  length() const noexcept {
    return size();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  max_size() const noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  capacity() const noexcept {
    return (__is_long() ? __get_long_cap()
                        : static_cast<size_type>(__min_cap)) -
           1;
  }

  void resize(size_type __n, value_type __c);
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  resize(size_type __n) {
    resize(__n, value_type());
  }

  void reserve(size_type __res_arg);
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __resize_default_init(size_type __n);

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  reserve() noexcept {
    reserve(0);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  shrink_to_fit() noexcept {
    reserve();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  clear() noexcept;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  empty() const noexcept {
    return size() == 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reference
  operator[](size_type __pos) const noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reference
  operator[](size_type __pos) noexcept;

  const_reference at(size_type __n) const;
  reference at(size_type __n);

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  basic_string &
  operator+=(const basic_string &__str) {
    return append(__str);
  }

  template <class _Tp>
  inline __attribute__((__visibility__("hidden"))) typename enable_if<
      __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
      basic_string &>::type
  operator+=(const _Tp &__t) {
    __self_view __sv = __t;
    return append(__sv);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  basic_string &
  operator+=(const value_type *__s) {
    return append(__s);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  basic_string &
  operator+=(value_type __c) {
    push_back(__c);
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  basic_string &
  operator+=(initializer_list<value_type> __il) {
    return append(__il);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  basic_string &
  append(const basic_string &__str);

  template <class _Tp>
  inline __attribute__((__visibility__("hidden"))) typename enable_if<
      __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
      basic_string &>::type
  append(const _Tp &__t) {
    __self_view __sv = __t;
    return append(__sv.data(), __sv.size());
  }
  basic_string &append(const basic_string &__str, size_type __pos,
                       size_type __n = npos);

  template <class _Tp>
  inline __attribute__((__visibility__("hidden"))) typename enable_if<
      __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
      basic_string &>::type
  append(const _Tp &__t, size_type __pos, size_type __n = npos);
  basic_string &append(const value_type *__s, size_type __n);
  basic_string &append(const value_type *__s);
  basic_string &append(size_type __n, value_type __c);

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __append_default_init(size_type __n);

  template <class _ForwardIterator>
  inline __attribute__((__visibility__("hidden")))
  basic_string &__append_forward_unsafe(_ForwardIterator, _ForwardIterator);
  template <class _InputIterator>
  inline __attribute__((__visibility__("hidden"))) typename enable_if<
      __is_exactly_cpp17_input_iterator<_InputIterator>::value ||
          !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,
      basic_string &>::type __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage))
  append(_InputIterator __first, _InputIterator __last) {
    const basic_string __temp(__first, __last, __alloc());
    append(__temp.data(), __temp.size());
    return *this;
  }
  template <class _ForwardIterator>
  inline __attribute__((__visibility__("hidden"))) typename enable_if<
      __is_cpp17_forward_iterator<_ForwardIterator>::value &&
          __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,
      basic_string &>::type __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage))
  append(_ForwardIterator __first, _ForwardIterator __last) {
    return __append_forward_unsafe(__first, __last);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  basic_string &
  append(initializer_list<value_type> __il) {
    return append(__il.begin(), __il.size());
  }

  void push_back(value_type __c);
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  pop_back();
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reference
  front() noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reference
  front() const noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reference
  back() noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reference
  back() const noexcept;

  template <class _Tp>
  inline __attribute__((__visibility__("hidden"))) typename enable_if<
      __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
      basic_string &>::type
  assign(const _Tp &__t) {
    __self_view __sv = __t;
    return assign(__sv.data(), __sv.size());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  basic_string &
  assign(const basic_string &__str) {
    return *this = __str;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  basic_string &
  assign(basic_string &&__str) noexcept(
      (__noexcept_move_assign_container<_Allocator, __alloc_traits>::value)) {
    *this = std::__1::move(__str);
    return *this;
  }

  basic_string &assign(const basic_string &__str, size_type __pos,
                       size_type __n = npos);
  template <class _Tp>
  inline __attribute__((__visibility__("hidden"))) typename enable_if<
      __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
      basic_string &>::type
  assign(const _Tp &__t, size_type __pos, size_type __n = npos);
  basic_string &assign(const value_type *__s, size_type __n);
  basic_string &assign(const value_type *__s);
  basic_string &assign(size_type __n, value_type __c);
  template <class _InputIterator>
  inline __attribute__((__visibility__("hidden"))) typename enable_if<
      __is_exactly_cpp17_input_iterator<_InputIterator>::value ||
          !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,
      basic_string &>::type
  assign(_InputIterator __first, _InputIterator __last);
  template <class _ForwardIterator>
  inline __attribute__((__visibility__("hidden"))) typename enable_if<
      __is_cpp17_forward_iterator<_ForwardIterator>::value &&
          __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,
      basic_string &>::type
  assign(_ForwardIterator __first, _ForwardIterator __last);

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  basic_string &
  assign(initializer_list<value_type> __il) {
    return assign(__il.begin(), __il.size());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  basic_string &
  insert(size_type __pos1, const basic_string &__str);

  template <class _Tp>
  inline __attribute__((__visibility__("hidden"))) typename enable_if<
      __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
      basic_string &>::type
  insert(size_type __pos1, const _Tp &__t) {
    __self_view __sv = __t;
    return insert(__pos1, __sv.data(), __sv.size());
  }

  template <class _Tp>
  inline __attribute__((__visibility__("hidden"))) typename enable_if<
      __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
      basic_string &>::type
  insert(size_type __pos1, const _Tp &__t, size_type __pos2,
         size_type __n = npos);
  basic_string &insert(size_type __pos1, const basic_string &__str,
                       size_type __pos2, size_type __n = npos);
  basic_string &insert(size_type __pos, const value_type *__s, size_type __n);
  basic_string &insert(size_type __pos, const value_type *__s);
  basic_string &insert(size_type __pos, size_type __n, value_type __c);
  iterator insert(const_iterator __pos, value_type __c);
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  insert(const_iterator __pos, size_type __n, value_type __c);
  template <class _InputIterator>
  inline __attribute__((__visibility__("hidden"))) typename enable_if<
      __is_exactly_cpp17_input_iterator<_InputIterator>::value ||
          !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,
      iterator>::type
  insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);
  template <class _ForwardIterator>
  inline __attribute__((__visibility__("hidden"))) typename enable_if<
      __is_cpp17_forward_iterator<_ForwardIterator>::value &&
          __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,
      iterator>::type
  insert(const_iterator __pos, _ForwardIterator __first,
         _ForwardIterator __last);

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  insert(const_iterator __pos, initializer_list<value_type> __il) {
    return insert(__pos, __il.begin(), __il.end());
  }

  basic_string &erase(size_type __pos = 0, size_type __n = npos);
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  erase(const_iterator __pos);
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  erase(const_iterator __first, const_iterator __last);

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  basic_string &
  replace(size_type __pos1, size_type __n1, const basic_string &__str);

  template <class _Tp>
  inline __attribute__((__visibility__("hidden"))) typename enable_if<
      __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
      basic_string &>::type
  replace(size_type __pos1, size_type __n1, const _Tp &__t) {
    __self_view __sv = __t;
    return replace(__pos1, __n1, __sv.data(), __sv.size());
  }
  basic_string &replace(size_type __pos1, size_type __n1,
                        const basic_string &__str, size_type __pos2,
                        size_type __n2 = npos);
  template <class _Tp>
  inline __attribute__((__visibility__("hidden"))) typename enable_if<
      __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
      basic_string &>::type
  replace(size_type __pos1, size_type __n1, const _Tp &__t, size_type __pos2,
          size_type __n2 = npos);
  basic_string &replace(size_type __pos, size_type __n1, const value_type *__s,
                        size_type __n2);
  basic_string &replace(size_type __pos, size_type __n1, const value_type *__s);
  basic_string &replace(size_type __pos, size_type __n1, size_type __n2,
                        value_type __c);
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  basic_string &
  replace(const_iterator __i1, const_iterator __i2, const basic_string &__str);

  template <class _Tp>
  inline __attribute__((__visibility__("hidden"))) typename enable_if<
      __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
      basic_string &>::type
  replace(const_iterator __i1, const_iterator __i2, const _Tp &__t) {
    __self_view __sv = __t;
    return replace(__i1 - begin(), __i2 - __i1, __sv);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  basic_string &
  replace(const_iterator __i1, const_iterator __i2, const value_type *__s,
          size_type __n);
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  basic_string &
  replace(const_iterator __i1, const_iterator __i2, const value_type *__s);
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  basic_string &
  replace(const_iterator __i1, const_iterator __i2, size_type __n,
          value_type __c);
  template <class _InputIterator>
  inline __attribute__((__visibility__("hidden")))
  typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value,
                     basic_string &>::type
  replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1,
          _InputIterator __j2);

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  basic_string &
  replace(const_iterator __i1, const_iterator __i2,
          initializer_list<value_type> __il) {
    return replace(__i1, __i2, __il.begin(), __il.end());
  }

  size_type copy(value_type *__s, size_type __n, size_type __pos = 0) const;
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  basic_string
  substr(size_type __pos = 0, size_type __n = npos) const;

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  swap(basic_string &__str)

      noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const value_type *
  c_str() const noexcept {
    return data();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const value_type *
  data() const noexcept {
    return std::__1::__to_address(__get_pointer());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  allocator_type
  get_allocator() const noexcept {
    return __alloc();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  find(const basic_string &__str, size_type __pos = 0) const noexcept;

  template <class _Tp>
  inline __attribute__((__visibility__("hidden"))) typename enable_if<
      __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
      size_type>::type
  find(const _Tp &__t, size_type __pos = 0) const;
  size_type find(const value_type *__s, size_type __pos,
                 size_type __n) const noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  find(const value_type *__s, size_type __pos = 0) const noexcept;
  size_type find(value_type __c, size_type __pos = 0) const noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  rfind(const basic_string &__str, size_type __pos = npos) const noexcept;

  template <class _Tp>
  inline __attribute__((__visibility__("hidden"))) typename enable_if<
      __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
      size_type>::type
  rfind(const _Tp &__t, size_type __pos = npos) const;
  size_type rfind(const value_type *__s, size_type __pos,
                  size_type __n) const noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  rfind(const value_type *__s, size_type __pos = npos) const noexcept;
  size_type rfind(value_type __c, size_type __pos = npos) const noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  find_first_of(const basic_string &__str, size_type __pos = 0) const noexcept;

  template <class _Tp>
  inline __attribute__((__visibility__("hidden"))) typename enable_if<
      __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
      size_type>::type
  find_first_of(const _Tp &__t, size_type __pos = 0) const;
  size_type find_first_of(const value_type *__s, size_type __pos,
                          size_type __n) const noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  find_first_of(const value_type *__s, size_type __pos = 0) const noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  find_first_of(value_type __c, size_type __pos = 0) const noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  find_last_of(const basic_string &__str,
               size_type __pos = npos) const noexcept;

  template <class _Tp>
  inline __attribute__((__visibility__("hidden"))) typename enable_if<
      __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
      size_type>::type
  find_last_of(const _Tp &__t, size_type __pos = npos) const;
  size_type find_last_of(const value_type *__s, size_type __pos,
                         size_type __n) const noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  find_last_of(const value_type *__s, size_type __pos = npos) const noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  find_last_of(value_type __c, size_type __pos = npos) const noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  find_first_not_of(const basic_string &__str,
                    size_type __pos = 0) const noexcept;

  template <class _Tp>
  inline __attribute__((__visibility__("hidden"))) typename enable_if<
      __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
      size_type>::type
  find_first_not_of(const _Tp &__t, size_type __pos = 0) const;
  size_type find_first_not_of(const value_type *__s, size_type __pos,
                              size_type __n) const noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  find_first_not_of(const value_type *__s, size_type __pos = 0) const noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  find_first_not_of(value_type __c, size_type __pos = 0) const noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  find_last_not_of(const basic_string &__str,
                   size_type __pos = npos) const noexcept;

  template <class _Tp>
  inline __attribute__((__visibility__("hidden"))) typename enable_if<
      __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
      size_type>::type
  find_last_not_of(const _Tp &__t, size_type __pos = npos) const;
  size_type find_last_not_of(const value_type *__s, size_type __pos,
                             size_type __n) const noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  find_last_not_of(const value_type *__s,
                   size_type __pos = npos) const noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  find_last_not_of(value_type __c, size_type __pos = npos) const noexcept;

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) int
  compare(const basic_string &__str) const noexcept;

  template <class _Tp>
  inline __attribute__((__visibility__("hidden"))) typename enable_if<
      __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int>::type
  compare(const _Tp &__t) const;

  template <class _Tp>
  inline __attribute__((__visibility__("hidden"))) typename enable_if<
      __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int>::type
  compare(size_type __pos1, size_type __n1, const _Tp &__t) const;

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) int
  compare(size_type __pos1, size_type __n1, const basic_string &__str) const;
  int compare(size_type __pos1, size_type __n1, const basic_string &__str,
              size_type __pos2, size_type __n2 = npos) const;

  template <class _Tp>
  inline __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) typename enable_if<
      __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int>::type
  compare(size_type __pos1, size_type __n1, const _Tp &__t, size_type __pos2,
          size_type __n2 = npos) const;
  int compare(const value_type *__s) const noexcept;
  int compare(size_type __pos1, size_type __n1, const value_type *__s) const;
  int compare(size_type __pos1, size_type __n1, const value_type *__s,
              size_type __n2) const;
# 1414 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  __invariants() const;

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __clear_and_shrink() noexcept;

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  __is_long() const noexcept {
    return bool(__r_.first().__s.__size_ & __short_mask);
  }
# 1431 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3
private:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  allocator_type &
  __alloc() noexcept {
    return __r_.second();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const allocator_type &
  __alloc() const noexcept {
    return __r_.second();
  }
# 1459 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __set_short_size(size_type __s) noexcept

  {
    __r_.first().__s.__size_ = (unsigned char)(__s << 1);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  __get_short_size() const noexcept

  {
    return __r_.first().__s.__size_ >> 1;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __set_long_size(size_type __s) noexcept {
    __r_.first().__l.__size_ = __s;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  __get_long_size() const noexcept {
    return __r_.first().__l.__size_;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __set_size(size_type __s) noexcept {
    if (__is_long())
      __set_long_size(__s);
    else
      __set_short_size(__s);
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __set_long_cap(size_type __s) noexcept {
    __r_.first().__l.__cap_ = __long_mask | __s;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  __get_long_cap() const noexcept {
    return __r_.first().__l.__cap_ & size_type(~__long_mask);
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __set_long_pointer(pointer __p) noexcept {
    __r_.first().__l.__data_ = __p;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pointer
  __get_long_pointer() noexcept {
    return __r_.first().__l.__data_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_pointer
  __get_long_pointer() const noexcept {
    return __r_.first().__l.__data_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pointer
  __get_short_pointer() noexcept {
    return pointer_traits<pointer>::pointer_to(__r_.first().__s.__data_[0]);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_pointer
  __get_short_pointer() const noexcept {
    return pointer_traits<const_pointer>::pointer_to(
        __r_.first().__s.__data_[0]);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pointer
  __get_pointer() noexcept {
    return __is_long() ? __get_long_pointer() : __get_short_pointer();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_pointer
  __get_pointer() const noexcept {
    return __is_long() ? __get_long_pointer() : __get_short_pointer();
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __zero() noexcept {
    size_type(&__a)[__n_words] = __r_.first().__r.__words;
    for (unsigned __i = 0; __i < __n_words; ++__i)
      __a[__i] = 0;
  }

  template <size_type __a>
  static __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) size_type
  __align_it(size_type __s) noexcept {
    return (__s + (__a - 1)) & ~(__a - 1);
  }
  enum { __alignment = 16 };
  static __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) size_type
  __recommend(size_type __s) noexcept {
    if (__s < __min_cap)
      return static_cast<size_type>(__min_cap) - 1;
    size_type __guess = __align_it < sizeof(value_type) < __alignment
                            ? __alignment / sizeof(value_type)
                            : 1 > (__s + 1) - 1;
    if (__guess == __min_cap)
      ++__guess;
    return __guess;
  }

  inline void __init(const value_type *__s, size_type __sz,
                     size_type __reserve);
  inline void __init(const value_type *__s, size_type __sz);
  inline void __init(size_type __n, value_type __c);

  template <class _InputIterator>
  inline typename enable_if<
      __is_exactly_cpp17_input_iterator<_InputIterator>::value, void>::type
  __init(_InputIterator __first, _InputIterator __last);

  template <class _ForwardIterator>
  inline
      typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value,
                         void>::type
      __init(_ForwardIterator __first, _ForwardIterator __last);

  void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,
                 size_type __n_copy, size_type __n_del, size_type __n_add = 0);
  void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap,
                             size_type __old_sz, size_type __n_copy,
                             size_type __n_del, size_type __n_add,
                             const value_type *__p_new_stuff);

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __erase_to_end(size_type __pos);

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __copy_assign_alloc(const basic_string &__str) {
    __copy_assign_alloc(
        __str,
        integral_constant<
            bool,
            __alloc_traits::propagate_on_container_copy_assignment::value>());
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __copy_assign_alloc(const basic_string &__str, true_type) {
    if (__alloc() == __str.__alloc())
      __alloc() = __str.__alloc();
    else {
      if (!__str.__is_long()) {
        __clear_and_shrink();
        __alloc() = __str.__alloc();
      } else {
        allocator_type __a = __str.__alloc();
        pointer __p = __alloc_traits::allocate(__a, __str.__get_long_cap());
        __clear_and_shrink();
        __alloc() = std::__1::move(__a);
        __set_long_pointer(__p);
        __set_long_cap(__str.__get_long_cap());
        __set_long_size(__str.size());
      }
    }
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __copy_assign_alloc(const basic_string &, false_type) noexcept {}

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __move_assign(basic_string &__str,
                false_type) noexcept(__alloc_traits::is_always_equal::value);
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __move_assign(basic_string &__str, true_type)

      noexcept(is_nothrow_move_assignable<allocator_type>::value);

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __move_assign_alloc(basic_string &__str) noexcept(
      !__alloc_traits::propagate_on_container_move_assignment::value ||
      is_nothrow_move_assignable<allocator_type>::value)

  {
    __move_assign_alloc(
        __str,
        integral_constant<
            bool,
            __alloc_traits::propagate_on_container_move_assignment::value>());
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __move_assign_alloc(basic_string &__c, true_type) noexcept(
      is_nothrow_move_assignable<allocator_type>::value) {
    __alloc() = std::__1::move(__c.__alloc());
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __move_assign_alloc(basic_string &, false_type) noexcept {}

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __invalidate_all_iterators();
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void __invalidate_iterators_past(size_type);

  friend basic_string operator+<>(const basic_string &, const basic_string &);
  friend basic_string operator+<>(const value_type *, const basic_string &);
  friend basic_string operator+<>(value_type, const basic_string &);
  friend basic_string operator+<>(const basic_string &, const value_type *);
  friend basic_string operator+<>(const basic_string &, value_type);
};
# 1680 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3
template <class _CharT, class _Traits, class _Allocator>
inline void
basic_string<_CharT, _Traits, _Allocator>::__invalidate_all_iterators() {}

template <class _CharT, class _Traits, class _Allocator>
inline void
basic_string<_CharT, _Traits, _Allocator>::__invalidate_iterators_past(size_type

) {
# 1718 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3
}

template <class _CharT, class _Traits, class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>::basic_string() noexcept(
    is_nothrow_default_constructible<allocator_type>::value)
    : __r_(__default_init_tag(), __default_init_tag()) {

  __zero();
}

template <class _CharT, class _Traits, class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>::basic_string(
    const allocator_type &__a)

    noexcept(is_nothrow_copy_constructible<allocator_type>::value)

    : __r_(__default_init_tag(), __a) {

  __zero();
}

template <class _CharT, class _Traits, class _Allocator>
void basic_string<_CharT, _Traits, _Allocator>::__init(const value_type *__s,
                                                       size_type __sz,
                                                       size_type __reserve) {
  if (__reserve > max_size())
    this->__throw_length_error();
  pointer __p;
  if (__reserve < __min_cap) {
    __set_short_size(__sz);
    __p = __get_short_pointer();
  } else {
    size_type __cap = __recommend(__reserve);
    __p = __alloc_traits::allocate(__alloc(), __cap + 1);
    __set_long_pointer(__p);
    __set_long_cap(__cap + 1);
    __set_long_size(__sz);
  }
  traits_type::copy(std::__1::__to_address(__p), __s, __sz);
  traits_type::assign(__p[__sz], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
void basic_string<_CharT, _Traits, _Allocator>::__init(const value_type *__s,
                                                       size_type __sz) {
  if (__sz > max_size())
    this->__throw_length_error();
  pointer __p;
  if (__sz < __min_cap) {
    __set_short_size(__sz);
    __p = __get_short_pointer();
  } else {
    size_type __cap = __recommend(__sz);
    __p = __alloc_traits::allocate(__alloc(), __cap + 1);
    __set_long_pointer(__p);
    __set_long_cap(__cap + 1);
    __set_long_size(__sz);
  }
  traits_type::copy(std::__1::__to_address(__p), __s, __sz);
  traits_type::assign(__p[__sz], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
template <class>
basic_string<_CharT, _Traits, _Allocator>::basic_string(const _CharT *__s,
                                                        const _Allocator &__a)
    : __r_(__default_init_tag(), __a) {
  ((void)0);
  __init(__s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>::basic_string(
    const _CharT *__s, size_type __n)
    : __r_(__default_init_tag(), __default_init_tag()) {
  ((void)0);
  __init(__s, __n);
}

template <class _CharT, class _Traits, class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>::basic_string(
    const _CharT *__s, size_type __n, const _Allocator &__a)
    : __r_(__default_init_tag(), __a) {
  ((void)0);
  __init(__s, __n);
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::basic_string(
    const basic_string &__str)
    : __r_(__default_init_tag(),
           __alloc_traits::select_on_container_copy_construction(
               __str.__alloc())) {
  if (!__str.__is_long())
    __r_.first().__r = __str.__r_.first().__r;
  else
    __init(std::__1::__to_address(__str.__get_long_pointer()),
           __str.__get_long_size());
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::basic_string(
    const basic_string &__str, const allocator_type &__a)
    : __r_(__default_init_tag(), __a) {
  if (!__str.__is_long())
    __r_.first().__r = __str.__r_.first().__r;
  else
    __init(std::__1::__to_address(__str.__get_long_pointer()),
           __str.__get_long_size());
}

template <class _CharT, class _Traits, class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>::basic_string(
    basic_string &&__str)

    noexcept(is_nothrow_move_constructible<allocator_type>::value)

    : __r_(std::__1::move(__str.__r_)) {
  __str.__zero();
}

template <class _CharT, class _Traits, class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>::basic_string(
    basic_string &&__str, const allocator_type &__a)
    : __r_(__default_init_tag(), __a) {
  if (__str.__is_long() && __a != __str.__alloc())
    __init(std::__1::__to_address(__str.__get_long_pointer()),
           __str.__get_long_size());
  else {
    __r_.first().__r = __str.__r_.first().__r;
    __str.__zero();
  }
}

template <class _CharT, class _Traits, class _Allocator>
void basic_string<_CharT, _Traits, _Allocator>::__init(size_type __n,
                                                       value_type __c) {
  if (__n > max_size())
    this->__throw_length_error();
  pointer __p;
  if (__n < __min_cap) {
    __set_short_size(__n);
    __p = __get_short_pointer();
  } else {
    size_type __cap = __recommend(__n);
    __p = __alloc_traits::allocate(__alloc(), __cap + 1);
    __set_long_pointer(__p);
    __set_long_cap(__cap + 1);
    __set_long_size(__n);
  }
  traits_type::assign(std::__1::__to_address(__p), __n, __c);
  traits_type::assign(__p[__n], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n,
                                                               _CharT __c)
    : __r_(__default_init_tag(), __default_init_tag()) {
  __init(__n, __c);
}

template <class _CharT, class _Traits, class _Allocator>
template <class>
basic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n,
                                                        _CharT __c,
                                                        const _Allocator &__a)
    : __r_(__default_init_tag(), __a) {
  __init(__n, __c);
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::basic_string(
    const basic_string &__str, size_type __pos, size_type __n,
    const _Allocator &__a)
    : __r_(__default_init_tag(), __a) {
  size_type __str_sz = __str.size();
  if (__pos > __str_sz)
    this->__throw_out_of_range();
  __init(__str.data() + __pos, std::__1::min(__n, __str_sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>::basic_string(
    const basic_string &__str, size_type __pos, const _Allocator &__a)
    : __r_(__default_init_tag(), __a) {
  size_type __str_sz = __str.size();
  if (__pos > __str_sz)
    this->__throw_out_of_range();
  __init(__str.data() + __pos, __str_sz - __pos);
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp, class>
basic_string<_CharT, _Traits, _Allocator>::basic_string(
    const _Tp &__t, size_type __pos, size_type __n, const allocator_type &__a)
    : __r_(__default_init_tag(), __a) {
  __self_view __sv0 = __t;
  __self_view __sv = __sv0.substr(__pos, __n);
  __init(__sv.data(), __sv.size());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp, class>
basic_string<_CharT, _Traits, _Allocator>::basic_string(const _Tp &__t)
    : __r_(__default_init_tag(), __default_init_tag()) {
  __self_view __sv = __t;
  __init(__sv.data(), __sv.size());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp, class>
basic_string<_CharT, _Traits, _Allocator>::basic_string(const _Tp &__t,
                                                        const _Allocator &__a)
    : __r_(__default_init_tag(), __a) {
  __self_view __sv = __t;
  __init(__sv.data(), __sv.size());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator>
typename enable_if<__is_exactly_cpp17_input_iterator<_InputIterator>::value,
                   void>::type
basic_string<_CharT, _Traits, _Allocator>::__init(_InputIterator __first,
                                                  _InputIterator __last) {
  __zero();

  try {

    for (; __first != __last; ++__first)
      push_back(*__first);

  } catch (...) {
    if (__is_long())
      __alloc_traits::deallocate(__alloc(), __get_long_pointer(),
                                 __get_long_cap());
    throw;
  }
}

template <class _CharT, class _Traits, class _Allocator>
template <class _ForwardIterator>
typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value,
                   void>::type
basic_string<_CharT, _Traits, _Allocator>::__init(_ForwardIterator __first,
                                                  _ForwardIterator __last) {
  size_type __sz = static_cast<size_type>(std::__1::distance(__first, __last));
  if (__sz > max_size())
    this->__throw_length_error();
  pointer __p;
  if (__sz < __min_cap) {
    __set_short_size(__sz);
    __p = __get_short_pointer();
  } else {
    size_type __cap = __recommend(__sz);
    __p = __alloc_traits::allocate(__alloc(), __cap + 1);
    __set_long_pointer(__p);
    __set_long_cap(__cap + 1);
    __set_long_size(__sz);
  }
  for (; __first != __last; ++__first, (void)++__p)
    traits_type::assign(*__p, *__first);
  traits_type::assign(*__p, value_type());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator, class>
inline basic_string<_CharT, _Traits, _Allocator>::basic_string(
    _InputIterator __first, _InputIterator __last)
    : __r_(__default_init_tag(), __default_init_tag()) {
  __init(__first, __last);
}

template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator, class>
inline basic_string<_CharT, _Traits, _Allocator>::basic_string(
    _InputIterator __first, _InputIterator __last, const allocator_type &__a)
    : __r_(__default_init_tag(), __a) {
  __init(__first, __last);
}

template <class _CharT, class _Traits, class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>::basic_string(
    initializer_list<_CharT> __il)
    : __r_(__default_init_tag(), __default_init_tag()) {
  __init(__il.begin(), __il.end());
}

template <class _CharT, class _Traits, class _Allocator>
inline

    basic_string<_CharT, _Traits, _Allocator>::basic_string(
        initializer_list<_CharT> __il, const _Allocator &__a)
    : __r_(__default_init_tag(), __a) {
  __init(__il.begin(), __il.end());
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::~basic_string() {

  if (__is_long())
    __alloc_traits::deallocate(__alloc(), __get_long_pointer(),
                               __get_long_cap());
}

template <class _CharT, class _Traits, class _Allocator>
void basic_string<_CharT, _Traits, _Allocator>::__grow_by_and_replace(
    size_type __old_cap, size_type __delta_cap, size_type __old_sz,
    size_type __n_copy, size_type __n_del, size_type __n_add,
    const value_type *__p_new_stuff) {
  size_type __ms = max_size();
  if (__delta_cap > __ms - __old_cap - 1)
    this->__throw_length_error();
  pointer __old_p = __get_pointer();
  size_type __cap =
      __old_cap < __ms / 2 - __alignment
          ? __recommend(std::__1::max(__old_cap + __delta_cap, 2 * __old_cap))
          : __ms - 1;
  pointer __p = __alloc_traits::allocate(__alloc(), __cap + 1);
  __invalidate_all_iterators();
  if (__n_copy != 0)
    traits_type::copy(std::__1::__to_address(__p),
                      std::__1::__to_address(__old_p), __n_copy);
  if (__n_add != 0)
    traits_type::copy(std::__1::__to_address(__p) + __n_copy, __p_new_stuff,
                      __n_add);
  size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;
  if (__sec_cp_sz != 0)
    traits_type::copy(std::__1::__to_address(__p) + __n_copy + __n_add,
                      std::__1::__to_address(__old_p) + __n_copy + __n_del,
                      __sec_cp_sz);
  if (__old_cap + 1 != __min_cap)
    __alloc_traits::deallocate(__alloc(), __old_p, __old_cap + 1);
  __set_long_pointer(__p);
  __set_long_cap(__cap + 1);
  __old_sz = __n_copy + __n_add + __sec_cp_sz;
  __set_long_size(__old_sz);
  traits_type::assign(__p[__old_sz], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
void basic_string<_CharT, _Traits, _Allocator>::__grow_by(
    size_type __old_cap, size_type __delta_cap, size_type __old_sz,
    size_type __n_copy, size_type __n_del, size_type __n_add) {
  size_type __ms = max_size();
  if (__delta_cap > __ms - __old_cap)
    this->__throw_length_error();
  pointer __old_p = __get_pointer();
  size_type __cap =
      __old_cap < __ms / 2 - __alignment
          ? __recommend(std::__1::max(__old_cap + __delta_cap, 2 * __old_cap))
          : __ms - 1;
  pointer __p = __alloc_traits::allocate(__alloc(), __cap + 1);
  __invalidate_all_iterators();
  if (__n_copy != 0)
    traits_type::copy(std::__1::__to_address(__p),
                      std::__1::__to_address(__old_p), __n_copy);
  size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;
  if (__sec_cp_sz != 0)
    traits_type::copy(std::__1::__to_address(__p) + __n_copy + __n_add,
                      std::__1::__to_address(__old_p) + __n_copy + __n_del,
                      __sec_cp_sz);
  if (__old_cap + 1 != __min_cap)
    __alloc_traits::deallocate(__alloc(), __old_p, __old_cap + 1);
  __set_long_pointer(__p);
  __set_long_cap(__cap + 1);
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::assign(const value_type *__s,
                                                  size_type __n) {
  ((void)0);
  size_type __cap = capacity();
  if (__cap >= __n) {
    value_type *__p = std::__1::__to_address(__get_pointer());
    traits_type::move(__p, __s, __n);
    traits_type::assign(__p[__n], value_type());
    __set_size(__n);
    __invalidate_iterators_past(__n);
  } else {
    size_type __sz = size();
    __grow_by_and_replace(__cap, __n - __cap, __sz, 0, __sz, __n, __s);
  }
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::assign(size_type __n,
                                                  value_type __c) {
  size_type __cap = capacity();
  if (__cap < __n) {
    size_type __sz = size();
    __grow_by(__cap, __n - __cap, __sz, 0, __sz);
  } else
    __invalidate_iterators_past(__n);
  value_type *__p = std::__1::__to_address(__get_pointer());
  traits_type::assign(__p, __n, __c);
  traits_type::assign(__p[__n], value_type());
  __set_size(__n);
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::operator=(value_type __c) {
  pointer __p;
  if (__is_long()) {
    __p = __get_long_pointer();
    __set_long_size(1);
  } else {
    __p = __get_short_pointer();
    __set_short_size(1);
  }
  traits_type::assign(*__p, __c);
  traits_type::assign(*++__p, value_type());
  __invalidate_iterators_past(1);
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::operator=(
    const basic_string &__str) {
  if (this != &__str) {
    __copy_assign_alloc(__str);
    return assign(__str.data(), __str.size());
  }
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
inline void basic_string<_CharT, _Traits, _Allocator>::__move_assign(
    basic_string &__str,
    false_type) noexcept(__alloc_traits::is_always_equal::value) {
  if (__alloc() != __str.__alloc())
    assign(__str);
  else
    __move_assign(__str, true_type());
}

template <class _CharT, class _Traits, class _Allocator>
inline void
basic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string &__str,
                                                         true_type)

    noexcept(is_nothrow_move_assignable<allocator_type>::value)

{
  if (__is_long()) {
    __alloc_traits::deallocate(__alloc(), __get_long_pointer(),
                               __get_long_cap());

    if (!is_nothrow_move_assignable<allocator_type>::value) {
      __set_short_size(0);
      traits_type::assign(__get_short_pointer()[0], value_type());
    }
  }
  __move_assign_alloc(__str);
  __r_.first() = __str.__r_.first();
  __str.__set_short_size(0);
  traits_type::assign(__str.__get_short_pointer()[0], value_type());
}

template <class _CharT, class _Traits, class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::
operator=(basic_string &&__str) noexcept(
    (__noexcept_move_assign_container<_Allocator, __alloc_traits>::value)) {
  __move_assign(
      __str,
      integral_constant<
          bool,
          __alloc_traits::propagate_on_container_move_assignment::value>());
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator>
typename enable_if<
    __is_exactly_cpp17_input_iterator<_InputIterator>::value ||
        !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,
    basic_string<_CharT, _Traits, _Allocator> &>::type
basic_string<_CharT, _Traits, _Allocator>::assign(_InputIterator __first,
                                                  _InputIterator __last) {
  const basic_string __temp(__first, __last, __alloc());
  assign(__temp.data(), __temp.size());
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template <class _ForwardIterator>
typename enable_if<
    __is_cpp17_forward_iterator<_ForwardIterator>::value &&
        __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,
    basic_string<_CharT, _Traits, _Allocator> &>::type
basic_string<_CharT, _Traits, _Allocator>::assign(_ForwardIterator __first,
                                                  _ForwardIterator __last) {
  size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
  size_type __cap = capacity();
  if (__cap < __n) {
    size_type __sz = size();
    __grow_by(__cap, __n - __cap, __sz, 0, __sz);
  } else
    __invalidate_iterators_past(__n);
  pointer __p = __get_pointer();
  for (; __first != __last; ++__first, ++__p)
    traits_type::assign(*__p, *__first);
  traits_type::assign(*__p, value_type());
  __set_size(__n);
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::assign(const basic_string &__str,
                                                  size_type __pos,
                                                  size_type __n) {
  size_type __sz = __str.size();
  if (__pos > __sz)
    this->__throw_out_of_range();
  return assign(__str.data() + __pos, std::__1::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
typename enable_if<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    basic_string<_CharT, _Traits, _Allocator> &>::type
basic_string<_CharT, _Traits, _Allocator>::assign(const _Tp &__t,
                                                  size_type __pos,
                                                  size_type __n) {
  __self_view __sv = __t;
  size_type __sz = __sv.size();
  if (__pos > __sz)
    this->__throw_out_of_range();
  return assign(__sv.data() + __pos, std::__1::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::assign(const value_type *__s) {
  ((void)0);
  return assign(__s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::append(const value_type *__s,
                                                  size_type __n) {
  ((void)0);
  size_type __cap = capacity();
  size_type __sz = size();
  if (__cap - __sz >= __n) {
    if (__n) {
      value_type *__p = std::__1::__to_address(__get_pointer());
      traits_type::copy(__p + __sz, __s, __n);
      __sz += __n;
      __set_size(__sz);
      traits_type::assign(__p[__sz], value_type());
    }
  } else
    __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __sz, 0, __n, __s);
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::append(size_type __n,
                                                  value_type __c) {
  if (__n) {
    size_type __cap = capacity();
    size_type __sz = size();
    if (__cap - __sz < __n)
      __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);
    pointer __p = __get_pointer();
    traits_type::assign(std::__1::__to_address(__p) + __sz, __n, __c);
    __sz += __n;
    __set_size(__sz);
    traits_type::assign(__p[__sz], value_type());
  }
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
inline void basic_string<_CharT, _Traits, _Allocator>::__append_default_init(
    size_type __n) {
  if (__n) {
    size_type __cap = capacity();
    size_type __sz = size();
    if (__cap - __sz < __n)
      __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);
    pointer __p = __get_pointer();
    __sz += __n;
    __set_size(__sz);
    traits_type::assign(__p[__sz], value_type());
  }
}

template <class _CharT, class _Traits, class _Allocator>
void basic_string<_CharT, _Traits, _Allocator>::push_back(value_type __c) {
  bool __is_short = !__is_long();
  size_type __cap;
  size_type __sz;
  if (__is_short) {
    __cap = __min_cap - 1;
    __sz = __get_short_size();
  } else {
    __cap = __get_long_cap() - 1;
    __sz = __get_long_size();
  }
  if (__sz == __cap) {
    __grow_by(__cap, 1, __sz, __sz, 0);
    __is_short = !__is_long();
  }
  pointer __p;
  if (__is_short) {
    __p = __get_short_pointer() + __sz;
    __set_short_size(__sz + 1);
  } else {
    __p = __get_long_pointer() + __sz;
    __set_long_size(__sz + 1);
  }
  traits_type::assign(*__p, __c);
  traits_type::assign(*++__p, value_type());
}

template <class _Tp>
bool __ptr_in_range(const _Tp *__p, const _Tp *__first, const _Tp *__last) {
  return __first <= __p && __p < __last;
}

template <class _Tp1, class _Tp2>
bool __ptr_in_range(const _Tp1 *, const _Tp2 *, const _Tp2 *) {
  return false;
}

template <class _CharT, class _Traits, class _Allocator>
template <class _ForwardIterator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::__append_forward_unsafe(
    _ForwardIterator __first, _ForwardIterator __last) {
  static_assert(__is_cpp17_forward_iterator<_ForwardIterator>::value,
                "function requires a ForwardIterator");
  size_type __sz = size();
  size_type __cap = capacity();
  size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
  if (__n) {
    typedef typename iterator_traits<_ForwardIterator>::reference _CharRef;
    _CharRef __tmp_ref = *__first;
    if (__ptr_in_range(std::__1::addressof(__tmp_ref), data(),
                       data() + size())) {
      const basic_string __temp(__first, __last, __alloc());
      append(__temp.data(), __temp.size());
    } else {
      if (__cap - __sz < __n)
        __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);
      pointer __p = __get_pointer() + __sz;
      for (; __first != __last; ++__p, ++__first)
        traits_type::assign(*__p, *__first);
      traits_type::assign(*__p, value_type());
      __set_size(__sz + __n);
    }
  }
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::append(const basic_string &__str) {
  return append(__str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::append(const basic_string &__str,
                                                  size_type __pos,
                                                  size_type __n) {
  size_type __sz = __str.size();
  if (__pos > __sz)
    this->__throw_out_of_range();
  return append(__str.data() + __pos, std::__1::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
typename enable_if<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    basic_string<_CharT, _Traits, _Allocator> &>::type
basic_string<_CharT, _Traits, _Allocator>::append(const _Tp &__t,
                                                  size_type __pos,
                                                  size_type __n) {
  __self_view __sv = __t;
  size_type __sz = __sv.size();
  if (__pos > __sz)
    this->__throw_out_of_range();
  return append(__sv.data() + __pos, std::__1::min(__n, __sz - __pos));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::append(const value_type *__s) {
  ((void)0);
  return append(__s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos,
                                                  const value_type *__s,
                                                  size_type __n) {
  ((void)0);
  size_type __sz = size();
  if (__pos > __sz)
    this->__throw_out_of_range();
  size_type __cap = capacity();
  if (__cap - __sz >= __n) {
    if (__n) {
      value_type *__p = std::__1::__to_address(__get_pointer());
      size_type __n_move = __sz - __pos;
      if (__n_move != 0) {
        if (__p + __pos <= __s && __s < __p + __sz)
          __s += __n;
        traits_type::move(__p + __pos + __n, __p + __pos, __n_move);
      }
      traits_type::move(__p + __pos, __s, __n);
      __sz += __n;
      __set_size(__sz);
      traits_type::assign(__p[__sz], value_type());
    }
  } else
    __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos,
                                                  size_type __n,
                                                  value_type __c) {
  size_type __sz = size();
  if (__pos > __sz)
    this->__throw_out_of_range();
  if (__n) {
    size_type __cap = capacity();
    value_type *__p;
    if (__cap - __sz >= __n) {
      __p = std::__1::__to_address(__get_pointer());
      size_type __n_move = __sz - __pos;
      if (__n_move != 0)
        traits_type::move(__p + __pos + __n, __p + __pos, __n_move);
    } else {
      __grow_by(__cap, __sz + __n - __cap, __sz, __pos, 0, __n);
      __p = std::__1::__to_address(__get_long_pointer());
    }
    traits_type::assign(__p + __pos, __n, __c);
    __sz += __n;
    __set_size(__sz);
    traits_type::assign(__p[__sz], value_type());
  }
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator>
typename enable_if<
    __is_exactly_cpp17_input_iterator<_InputIterator>::value ||
        !__libcpp_string_gets_noexcept_iterator<_InputIterator>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::iterator>::type
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos,
                                                  _InputIterator __first,
                                                  _InputIterator __last) {

  const basic_string __temp(__first, __last, __alloc());
  return insert(__pos, __temp.data(), __temp.data() + __temp.size());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _ForwardIterator>
typename enable_if<
    __is_cpp17_forward_iterator<_ForwardIterator>::value &&
        __libcpp_string_gets_noexcept_iterator<_ForwardIterator>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::iterator>::type
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos,
                                                  _ForwardIterator __first,
                                                  _ForwardIterator __last) {

  size_type __ip = static_cast<size_type>(__pos - begin());
  size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
  if (__n) {
    typedef typename iterator_traits<_ForwardIterator>::reference _CharRef;
    _CharRef __tmp_char = *__first;
    if (__ptr_in_range(std::__1::addressof(__tmp_char), data(),
                       data() + size())) {
      const basic_string __temp(__first, __last, __alloc());
      return insert(__pos, __temp.data(), __temp.data() + __temp.size());
    }

    size_type __sz = size();
    size_type __cap = capacity();
    value_type *__p;
    if (__cap - __sz >= __n) {
      __p = std::__1::__to_address(__get_pointer());
      size_type __n_move = __sz - __ip;
      if (__n_move != 0)
        traits_type::move(__p + __ip + __n, __p + __ip, __n_move);
    } else {
      __grow_by(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);
      __p = std::__1::__to_address(__get_long_pointer());
    }
    __sz += __n;
    __set_size(__sz);
    traits_type::assign(__p[__sz], value_type());
    for (__p += __ip; __first != __last; ++__p, ++__first)
      traits_type::assign(*__p, *__first);
  }
  return begin() + __ip;
}

template <class _CharT, class _Traits, class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1,
                                                  const basic_string &__str) {
  return insert(__pos1, __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1,
                                                  const basic_string &__str,
                                                  size_type __pos2,
                                                  size_type __n) {
  size_type __str_sz = __str.size();
  if (__pos2 > __str_sz)
    this->__throw_out_of_range();
  return insert(__pos1, __str.data() + __pos2,
                std::__1::min(__n, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
typename enable_if<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    basic_string<_CharT, _Traits, _Allocator> &>::type
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1,
                                                  const _Tp &__t,
                                                  size_type __pos2,
                                                  size_type __n) {
  __self_view __sv = __t;
  size_type __str_sz = __sv.size();
  if (__pos2 > __str_sz)
    this->__throw_out_of_range();
  return insert(__pos1, __sv.data() + __pos2,
                std::__1::min(__n, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos,
                                                  const value_type *__s) {
  ((void)0);
  return insert(__pos, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos,
                                                  value_type __c) {
  size_type __ip = static_cast<size_type>(__pos - begin());
  size_type __sz = size();
  size_type __cap = capacity();
  value_type *__p;
  if (__cap == __sz) {
    __grow_by(__cap, 1, __sz, __ip, 0, 1);
    __p = std::__1::__to_address(__get_long_pointer());
  } else {
    __p = std::__1::__to_address(__get_pointer());
    size_type __n_move = __sz - __ip;
    if (__n_move != 0)
      traits_type::move(__p + __ip + 1, __p + __ip, __n_move);
  }
  traits_type::assign(__p[__ip], __c);
  traits_type::assign(__p[++__sz], value_type());
  __set_size(__sz);
  return begin() + static_cast<difference_type>(__ip);
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos,
                                                  size_type __n,
                                                  value_type __c) {

  difference_type __p = __pos - begin();
  insert(static_cast<size_type>(__p), __n, __c);
  return begin() + __p;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos,
                                                   size_type __n1,
                                                   const value_type *__s,
                                                   size_type __n2)
    __attribute__((__no_sanitize__("unsigned-integer-overflow"))) {
  ((void)0);
  size_type __sz = size();
  if (__pos > __sz)
    this->__throw_out_of_range();
  __n1 = std::__1::min(__n1, __sz - __pos);
  size_type __cap = capacity();
  if (__cap - __sz + __n1 >= __n2) {
    value_type *__p = std::__1::__to_address(__get_pointer());
    if (__n1 != __n2) {
      size_type __n_move = __sz - __pos - __n1;
      if (__n_move != 0) {
        if (__n1 > __n2) {
          traits_type::move(__p + __pos, __s, __n2);
          traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
          goto __finish;
        }
        if (__p + __pos < __s && __s < __p + __sz) {
          if (__p + __pos + __n1 <= __s)
            __s += __n2 - __n1;
          else {
            traits_type::move(__p + __pos, __s, __n1);
            __pos += __n1;
            __s += __n2;
            __n2 -= __n1;
            __n1 = 0;
          }
        }
        traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
      }
    }
    traits_type::move(__p + __pos, __s, __n2);
  __finish:

    __sz += __n2 - __n1;
    __set_size(__sz);
    __invalidate_iterators_past(__sz);
    traits_type::assign(__p[__sz], value_type());
  } else
    __grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1,
                          __n2, __s);
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos,
                                                   size_type __n1,
                                                   size_type __n2,
                                                   value_type __c)
    __attribute__((__no_sanitize__("unsigned-integer-overflow"))) {
  size_type __sz = size();
  if (__pos > __sz)
    this->__throw_out_of_range();
  __n1 = std::__1::min(__n1, __sz - __pos);
  size_type __cap = capacity();
  value_type *__p;
  if (__cap - __sz + __n1 >= __n2) {
    __p = std::__1::__to_address(__get_pointer());
    if (__n1 != __n2) {
      size_type __n_move = __sz - __pos - __n1;
      if (__n_move != 0)
        traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);
    }
  } else {
    __grow_by(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2);
    __p = std::__1::__to_address(__get_long_pointer());
  }
  traits_type::assign(__p + __pos, __n2, __c);
  __sz += __n2 - __n1;
  __set_size(__sz);
  __invalidate_iterators_past(__sz);
  traits_type::assign(__p[__sz], value_type());
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator>
typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value,
                   basic_string<_CharT, _Traits, _Allocator> &>::type
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1,
                                                   const_iterator __i2,
                                                   _InputIterator __j1,
                                                   _InputIterator __j2) {
  const basic_string __temp(__j1, __j2, __alloc());
  return this->replace(__i1, __i2, __temp);
}

template <class _CharT, class _Traits, class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1,
                                                   size_type __n1,
                                                   const basic_string &__str) {
  return replace(__pos1, __n1, __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1,
                                                   size_type __n1,
                                                   const basic_string &__str,
                                                   size_type __pos2,
                                                   size_type __n2) {
  size_type __str_sz = __str.size();
  if (__pos2 > __str_sz)
    this->__throw_out_of_range();
  return replace(__pos1, __n1, __str.data() + __pos2,
                 std::__1::min(__n2, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
typename enable_if<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    basic_string<_CharT, _Traits, _Allocator> &>::type
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1,
                                                   size_type __n1,
                                                   const _Tp &__t,
                                                   size_type __pos2,
                                                   size_type __n2) {
  __self_view __sv = __t;
  size_type __str_sz = __sv.size();
  if (__pos2 > __str_sz)
    this->__throw_out_of_range();
  return replace(__pos1, __n1, __sv.data() + __pos2,
                 std::__1::min(__n2, __str_sz - __pos2));
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos,
                                                   size_type __n1,
                                                   const value_type *__s) {
  ((void)0);
  return replace(__pos, __n1, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1,
                                                   const_iterator __i2,
                                                   const basic_string &__str) {
  return replace(static_cast<size_type>(__i1 - begin()),
                 static_cast<size_type>(__i2 - __i1), __str.data(),
                 __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1,
                                                   const_iterator __i2,
                                                   const value_type *__s,
                                                   size_type __n) {
  return replace(static_cast<size_type>(__i1 - begin()),
                 static_cast<size_type>(__i2 - __i1), __s, __n);
}

template <class _CharT, class _Traits, class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1,
                                                   const_iterator __i2,
                                                   const value_type *__s) {
  return replace(static_cast<size_type>(__i1 - begin()),
                 static_cast<size_type>(__i2 - __i1), __s);
}

template <class _CharT, class _Traits, class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1,
                                                   const_iterator __i2,
                                                   size_type __n,
                                                   value_type __c) {
  return replace(static_cast<size_type>(__i1 - begin()),
                 static_cast<size_type>(__i2 - __i1), __n, __c);
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator> &
basic_string<_CharT, _Traits, _Allocator>::erase(size_type __pos,
                                                 size_type __n) {
  size_type __sz = size();
  if (__pos > __sz)
    this->__throw_out_of_range();
  if (__n) {
    value_type *__p = std::__1::__to_address(__get_pointer());
    __n = std::__1::min(__n, __sz - __pos);
    size_type __n_move = __sz - __pos - __n;
    if (__n_move != 0)
      traits_type::move(__p + __pos, __p + __pos + __n, __n_move);
    __sz -= __n;
    __set_size(__sz);
    __invalidate_iterators_past(__sz);
    traits_type::assign(__p[__sz], value_type());
  }
  return *this;
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __pos) {

  ((void)0);

  iterator __b = begin();
  size_type __r = static_cast<size_type>(__pos - __b);
  erase(__r, 1);
  return __b + static_cast<difference_type>(__r);
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __first,
                                                 const_iterator __last) {

  ((void)0);
  iterator __b = begin();
  size_type __r = static_cast<size_type>(__first - __b);
  erase(__r, static_cast<size_type>(__last - __first));
  return __b + static_cast<difference_type>(__r);
}

template <class _CharT, class _Traits, class _Allocator>
inline void basic_string<_CharT, _Traits, _Allocator>::pop_back() {
  ((void)0);
  size_type __sz;
  if (__is_long()) {
    __sz = __get_long_size() - 1;
    __set_long_size(__sz);
    traits_type::assign(*(__get_long_pointer() + __sz), value_type());
  } else {
    __sz = __get_short_size() - 1;
    __set_short_size(__sz);
    traits_type::assign(*(__get_short_pointer() + __sz), value_type());
  }
  __invalidate_iterators_past(__sz);
}

template <class _CharT, class _Traits, class _Allocator>
inline void basic_string<_CharT, _Traits, _Allocator>::clear() noexcept {
  __invalidate_all_iterators();
  if (__is_long()) {
    traits_type::assign(*__get_long_pointer(), value_type());
    __set_long_size(0);
  } else {
    traits_type::assign(*__get_short_pointer(), value_type());
    __set_short_size(0);
  }
}

template <class _CharT, class _Traits, class _Allocator>
inline void
basic_string<_CharT, _Traits, _Allocator>::__erase_to_end(size_type __pos) {
  if (__is_long()) {
    traits_type::assign(*(__get_long_pointer() + __pos), value_type());
    __set_long_size(__pos);
  } else {
    traits_type::assign(*(__get_short_pointer() + __pos), value_type());
    __set_short_size(__pos);
  }
  __invalidate_iterators_past(__pos);
}

template <class _CharT, class _Traits, class _Allocator>
void basic_string<_CharT, _Traits, _Allocator>::resize(size_type __n,
                                                       value_type __c) {
  size_type __sz = size();
  if (__n > __sz)
    append(__n - __sz, __c);
  else
    __erase_to_end(__n);
}

template <class _CharT, class _Traits, class _Allocator>
inline void basic_string<_CharT, _Traits, _Allocator>::__resize_default_init(
    size_type __n) {
  size_type __sz = size();
  if (__n > __sz) {
    __append_default_init(__n - __sz);
  } else
    __erase_to_end(__n);
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::max_size() const noexcept {
  size_type __m = __alloc_traits::max_size(__alloc());

  return __m - __alignment;
}

template <class _CharT, class _Traits, class _Allocator>
void basic_string<_CharT, _Traits, _Allocator>::reserve(size_type __res_arg) {
  if (__res_arg > max_size())
    this->__throw_length_error();
  size_type __cap = capacity();
  size_type __sz = size();
  __res_arg = std::__1::max(__res_arg, __sz);
  __res_arg = __recommend(__res_arg);
  if (__res_arg != __cap) {
    pointer __new_data, __p;
    bool __was_long, __now_long;
    if (__res_arg == __min_cap - 1) {
      __was_long = true;
      __now_long = false;
      __new_data = __get_short_pointer();
      __p = __get_long_pointer();
    } else {
      if (__res_arg > __cap)
        __new_data = __alloc_traits::allocate(__alloc(), __res_arg + 1);
      else {

        try {

          __new_data = __alloc_traits::allocate(__alloc(), __res_arg + 1);

        } catch (...) {
          return;
        }
      }
      __now_long = true;
      __was_long = __is_long();
      __p = __get_pointer();
    }
    traits_type::copy(std::__1::__to_address(__new_data),
                      std::__1::__to_address(__p), size() + 1);
    if (__was_long)
      __alloc_traits::deallocate(__alloc(), __p, __cap + 1);
    if (__now_long) {
      __set_long_cap(__res_arg + 1);
      __set_long_size(__sz);
      __set_long_pointer(__new_data);
    } else
      __set_short_size(__sz);
    __invalidate_all_iterators();
  }
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::operator[](
    size_type __pos) const noexcept {
  ((void)0);
  return *(data() + __pos);
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::operator[](
    size_type __pos) noexcept {
  ((void)0);
  return *(__get_pointer() + __pos);
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::at(size_type __n) const {
  if (__n >= size())
    this->__throw_out_of_range();
  return (*this)[__n];
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::at(size_type __n) {
  if (__n >= size())
    this->__throw_out_of_range();
  return (*this)[__n];
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::front() noexcept {
  ((void)0);
  return *__get_pointer();
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::front() const noexcept {
  ((void)0);
  return *data();
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::back() noexcept {
  ((void)0);
  return *(__get_pointer() + size() - 1);
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::back() const noexcept {
  ((void)0);
  return *(data() + size() - 1);
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::copy(value_type *__s, size_type __n,
                                                size_type __pos) const {
  size_type __sz = size();
  if (__pos > __sz)
    this->__throw_out_of_range();
  size_type __rlen = std::__1::min(__n, __sz - __pos);
  traits_type::copy(__s, data() + __pos, __rlen);
  return __rlen;
}

template <class _CharT, class _Traits, class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>
basic_string<_CharT, _Traits, _Allocator>::substr(size_type __pos,
                                                  size_type __n) const {
  return basic_string(*this, __pos, __n, __alloc());
}

template <class _CharT, class _Traits, class _Allocator>
inline void basic_string<_CharT, _Traits, _Allocator>::swap(basic_string &__str)

    noexcept

{

  ((void)0);

  std::__1::swap(__r_.first(), __str.__r_.first());
  __swap_allocator(__alloc(), __str.__alloc());
}

template <class _Traits>
struct __attribute__((__visibility__("hidden"))) __traits_eq {
  typedef typename _Traits::char_type char_type;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator()(const char_type &__x, const char_type &__y) noexcept {
    return _Traits::eq(__x, __y);
  }
};

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(const value_type *__s,
                                                size_type __pos,
                                                size_type __n) const noexcept {
  ((void)0);
  return __str_find<value_type, size_type, traits_type, npos>(data(), size(),
                                                              __s, __pos, __n);
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(
    const basic_string &__str, size_type __pos) const noexcept {
  return __str_find<value_type, size_type, traits_type, npos>(
      data(), size(), __str.data(), __pos, __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
typename enable_if<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::size_type>::type
basic_string<_CharT, _Traits, _Allocator>::find(const _Tp &__t,
                                                size_type __pos) const {
  __self_view __sv = __t;
  return __str_find<value_type, size_type, traits_type, npos>(
      data(), size(), __sv.data(), __pos, __sv.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(
    const value_type *__s, size_type __pos) const noexcept {
  ((void)0);
  return __str_find<value_type, size_type, traits_type, npos>(
      data(), size(), __s, __pos, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find(
    value_type __c, size_type __pos) const noexcept {
  return __str_find<value_type, size_type, traits_type, npos>(data(), size(),
                                                              __c, __pos);
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(const value_type *__s,
                                                 size_type __pos,
                                                 size_type __n) const noexcept {
  ((void)0);
  return __str_rfind<value_type, size_type, traits_type, npos>(data(), size(),
                                                               __s, __pos, __n);
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(
    const basic_string &__str, size_type __pos) const noexcept {
  return __str_rfind<value_type, size_type, traits_type, npos>(
      data(), size(), __str.data(), __pos, __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
typename enable_if<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::size_type>::type
basic_string<_CharT, _Traits, _Allocator>::rfind(const _Tp &__t,
                                                 size_type __pos) const {
  __self_view __sv = __t;
  return __str_rfind<value_type, size_type, traits_type, npos>(
      data(), size(), __sv.data(), __pos, __sv.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(
    const value_type *__s, size_type __pos) const noexcept {
  ((void)0);
  return __str_rfind<value_type, size_type, traits_type, npos>(
      data(), size(), __s, __pos, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::rfind(
    value_type __c, size_type __pos) const noexcept {
  return __str_rfind<value_type, size_type, traits_type, npos>(data(), size(),
                                                               __c, __pos);
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(
    const value_type *__s, size_type __pos, size_type __n) const noexcept {
  ((void)0);
  return __str_find_first_of<value_type, size_type, traits_type, npos>(
      data(), size(), __s, __pos, __n);
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(
    const basic_string &__str, size_type __pos) const noexcept {
  return __str_find_first_of<value_type, size_type, traits_type, npos>(
      data(), size(), __str.data(), __pos, __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
typename enable_if<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::size_type>::type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(
    const _Tp &__t, size_type __pos) const {
  __self_view __sv = __t;
  return __str_find_first_of<value_type, size_type, traits_type, npos>(
      data(), size(), __sv.data(), __pos, __sv.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(
    const value_type *__s, size_type __pos) const noexcept {
  ((void)0);
  return __str_find_first_of<value_type, size_type, traits_type, npos>(
      data(), size(), __s, __pos, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_of(
    value_type __c, size_type __pos) const noexcept {
  return find(__c, __pos);
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(
    const value_type *__s, size_type __pos, size_type __n) const noexcept {
  ((void)0);
  return __str_find_last_of<value_type, size_type, traits_type, npos>(
      data(), size(), __s, __pos, __n);
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(
    const basic_string &__str, size_type __pos) const noexcept {
  return __str_find_last_of<value_type, size_type, traits_type, npos>(
      data(), size(), __str.data(), __pos, __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
typename enable_if<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::size_type>::type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(const _Tp &__t,
                                                        size_type __pos) const {
  __self_view __sv = __t;
  return __str_find_last_of<value_type, size_type, traits_type, npos>(
      data(), size(), __sv.data(), __pos, __sv.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(
    const value_type *__s, size_type __pos) const noexcept {
  ((void)0);
  return __str_find_last_of<value_type, size_type, traits_type, npos>(
      data(), size(), __s, __pos, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_of(
    value_type __c, size_type __pos) const noexcept {
  return rfind(__c, __pos);
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(
    const value_type *__s, size_type __pos, size_type __n) const noexcept {
  ((void)0);
  return __str_find_first_not_of<value_type, size_type, traits_type, npos>(
      data(), size(), __s, __pos, __n);
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(
    const basic_string &__str, size_type __pos) const noexcept {
  return __str_find_first_not_of<value_type, size_type, traits_type, npos>(
      data(), size(), __str.data(), __pos, __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
typename enable_if<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::size_type>::type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(
    const _Tp &__t, size_type __pos) const {
  __self_view __sv = __t;
  return __str_find_first_not_of<value_type, size_type, traits_type, npos>(
      data(), size(), __sv.data(), __pos, __sv.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(
    const value_type *__s, size_type __pos) const noexcept {
  ((void)0);
  return __str_find_first_not_of<value_type, size_type, traits_type, npos>(
      data(), size(), __s, __pos, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_first_not_of(
    value_type __c, size_type __pos) const noexcept {
  return __str_find_first_not_of<value_type, size_type, traits_type, npos>(
      data(), size(), __c, __pos);
}

template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(
    const value_type *__s, size_type __pos, size_type __n) const noexcept {
  ((void)0);
  return __str_find_last_not_of<value_type, size_type, traits_type, npos>(
      data(), size(), __s, __pos, __n);
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(
    const basic_string &__str, size_type __pos) const noexcept {
  return __str_find_last_not_of<value_type, size_type, traits_type, npos>(
      data(), size(), __str.data(), __pos, __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
typename enable_if<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value,
    typename basic_string<_CharT, _Traits, _Allocator>::size_type>::type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(
    const _Tp &__t, size_type __pos) const {
  __self_view __sv = __t;
  return __str_find_last_not_of<value_type, size_type, traits_type, npos>(
      data(), size(), __sv.data(), __pos, __sv.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(
    const value_type *__s, size_type __pos) const noexcept {
  ((void)0);
  return __str_find_last_not_of<value_type, size_type, traits_type, npos>(
      data(), size(), __s, __pos, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::find_last_not_of(
    value_type __c, size_type __pos) const noexcept {
  return __str_find_last_not_of<value_type, size_type, traits_type, npos>(
      data(), size(), __c, __pos);
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
typename enable_if<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int>::type
basic_string<_CharT, _Traits, _Allocator>::compare(const _Tp &__t) const {
  __self_view __sv = __t;
  size_t __lhs_sz = size();
  size_t __rhs_sz = __sv.size();
  int __result = traits_type::compare(data(), __sv.data(),
                                      std::__1::min(__lhs_sz, __rhs_sz));
  if (__result != 0)
    return __result;
  if (__lhs_sz < __rhs_sz)
    return -1;
  if (__lhs_sz > __rhs_sz)
    return 1;
  return 0;
}

template <class _CharT, class _Traits, class _Allocator>
inline int basic_string<_CharT, _Traits, _Allocator>::compare(
    const basic_string &__str) const noexcept {
  return compare(__self_view(__str));
}

template <class _CharT, class _Traits, class _Allocator>
int basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                       size_type __n1,
                                                       const value_type *__s,
                                                       size_type __n2) const {
  ((void)0);
  size_type __sz = size();
  if (__pos1 > __sz || __n2 == npos)
    this->__throw_out_of_range();
  size_type __rlen = std::__1::min(__n1, __sz - __pos1);
  int __r =
      traits_type::compare(data() + __pos1, __s, std::__1::min(__rlen, __n2));
  if (__r == 0) {
    if (__rlen < __n2)
      __r = -1;
    else if (__rlen > __n2)
      __r = 1;
  }
  return __r;
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
typename enable_if<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int>::type
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const _Tp &__t) const {
  __self_view __sv = __t;
  return compare(__pos1, __n1, __sv.data(), __sv.size());
}

template <class _CharT, class _Traits, class _Allocator>
inline int basic_string<_CharT, _Traits, _Allocator>::compare(
    size_type __pos1, size_type __n1, const basic_string &__str) const {
  return compare(__pos1, __n1, __str.data(), __str.size());
}

template <class _CharT, class _Traits, class _Allocator>
template <class _Tp>
typename enable_if<
    __can_be_converted_to_string_view<_CharT, _Traits, _Tp>::value, int>::type
basic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,
                                                   size_type __n1,
                                                   const _Tp &__t,
                                                   size_type __pos2,
                                                   size_type __n2) const {
  __self_view __sv = __t;
  return __self_view(*this)
      .substr(__pos1, __n1)
      .compare(__sv.substr(__pos2, __n2));
}

template <class _CharT, class _Traits, class _Allocator>
int basic_string<_CharT, _Traits, _Allocator>::compare(
    size_type __pos1, size_type __n1, const basic_string &__str,
    size_type __pos2, size_type __n2) const {
  return compare(__pos1, __n1, __self_view(__str), __pos2, __n2);
}

template <class _CharT, class _Traits, class _Allocator>
int basic_string<_CharT, _Traits, _Allocator>::compare(
    const value_type *__s) const noexcept {
  ((void)0);
  return compare(0, npos, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
int basic_string<_CharT, _Traits, _Allocator>::compare(
    size_type __pos1, size_type __n1, const value_type *__s) const {
  ((void)0);
  return compare(__pos1, __n1, __s, traits_type::length(__s));
}

template <class _CharT, class _Traits, class _Allocator>
inline bool basic_string<_CharT, _Traits, _Allocator>::__invariants() const {
  if (size() > capacity())
    return false;
  if (capacity() < __min_cap - 1)
    return false;
  if (data() == 0)
    return false;
  if (data()[size()] != value_type(0))
    return false;
  return true;
}

template <class _CharT, class _Traits, class _Allocator>
inline void
basic_string<_CharT, _Traits, _Allocator>::__clear_and_shrink() noexcept {
  clear();
  if (__is_long()) {
    __alloc_traits::deallocate(__alloc(), __get_long_pointer(), capacity() + 1);
    __set_long_cap(0);
    __set_short_size(0);
  }
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator==(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
           const basic_string<_CharT, _Traits, _Allocator> &__rhs) noexcept {
  size_t __lhs_sz = __lhs.size();
  return __lhs_sz == __rhs.size() &&
         _Traits::compare(__lhs.data(), __rhs.data(), __lhs_sz) == 0;
}

template <class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator==(
    const basic_string<char, char_traits<char>, _Allocator> &__lhs,
    const basic_string<char, char_traits<char>, _Allocator> &__rhs) noexcept {
  size_t __lhs_sz = __lhs.size();
  if (__lhs_sz != __rhs.size())
    return false;
  const char *__lp = __lhs.data();
  const char *__rp = __rhs.data();
  if (__lhs.__is_long())
    return char_traits<char>::compare(__lp, __rp, __lhs_sz) == 0;
  for (; __lhs_sz != 0; --__lhs_sz, ++__lp, ++__rp)
    if (*__lp != *__rp)
      return false;
  return true;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator==(const _CharT *__lhs,
           const basic_string<_CharT, _Traits, _Allocator> &__rhs) noexcept {
  typedef basic_string<_CharT, _Traits, _Allocator> _String;
  ((void)0);
  size_t __lhs_len = _Traits::length(__lhs);
  if (__lhs_len != __rhs.size())
    return false;
  return __rhs.compare(0, _String::npos, __lhs, __lhs_len) == 0;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator==(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
           const _CharT *__rhs) noexcept {
  typedef basic_string<_CharT, _Traits, _Allocator> _String;
  ((void)0);
  size_t __rhs_len = _Traits::length(__rhs);
  if (__rhs_len != __lhs.size())
    return false;
  return __lhs.compare(0, _String::npos, __rhs, __rhs_len) == 0;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator!=(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
           const basic_string<_CharT, _Traits, _Allocator> &__rhs) noexcept {
  return !(__lhs == __rhs);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator!=(const _CharT *__lhs,
           const basic_string<_CharT, _Traits, _Allocator> &__rhs) noexcept {
  return !(__lhs == __rhs);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator!=(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
           const _CharT *__rhs) noexcept {
  return !(__lhs == __rhs);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator<(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
          const basic_string<_CharT, _Traits, _Allocator> &__rhs) noexcept {
  return __lhs.compare(__rhs) < 0;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator<(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
          const _CharT *__rhs) noexcept {
  return __lhs.compare(__rhs) < 0;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator<(const _CharT *__lhs,
          const basic_string<_CharT, _Traits, _Allocator> &__rhs) noexcept {
  return __rhs.compare(__lhs) > 0;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator>(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
          const basic_string<_CharT, _Traits, _Allocator> &__rhs) noexcept {
  return __rhs < __lhs;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator>(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
          const _CharT *__rhs) noexcept {
  return __rhs < __lhs;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator>(const _CharT *__lhs,
          const basic_string<_CharT, _Traits, _Allocator> &__rhs) noexcept {
  return __rhs < __lhs;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator<=(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
           const basic_string<_CharT, _Traits, _Allocator> &__rhs) noexcept {
  return !(__rhs < __lhs);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator<=(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
           const _CharT *__rhs) noexcept {
  return !(__rhs < __lhs);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator<=(const _CharT *__lhs,
           const basic_string<_CharT, _Traits, _Allocator> &__rhs) noexcept {
  return !(__rhs < __lhs);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator>=(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
           const basic_string<_CharT, _Traits, _Allocator> &__rhs) noexcept {
  return !(__lhs < __rhs);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator>=(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
           const _CharT *__rhs) noexcept {
  return !(__lhs < __rhs);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator>=(const _CharT *__lhs,
           const basic_string<_CharT, _Traits, _Allocator> &__rhs) noexcept {
  return !(__lhs < __rhs);
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
          const basic_string<_CharT, _Traits, _Allocator> &__rhs) {
  basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
  typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz =
      __lhs.size();
  typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz =
      __rhs.size();
  __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);
  __r.append(__rhs.data(), __rhs_sz);
  return __r;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT *__lhs,
          const basic_string<_CharT, _Traits, _Allocator> &__rhs) {
  basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());
  typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz =
      _Traits::length(__lhs);
  typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz =
      __rhs.size();
  __r.__init(__lhs, __lhs_sz, __lhs_sz + __rhs_sz);
  __r.append(__rhs.data(), __rhs_sz);
  return __r;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __lhs,
          const basic_string<_CharT, _Traits, _Allocator> &__rhs) {
  basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());
  typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz =
      __rhs.size();
  __r.__init(&__lhs, 1, 1 + __rhs_sz);
  __r.append(__rhs.data(), __rhs_sz);
  return __r;
}

template <class _CharT, class _Traits, class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
          const _CharT *__rhs) {
  basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
  typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz =
      __lhs.size();
  typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz =
      _Traits::length(__rhs);
  __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);
  __r.append(__rhs, __rhs_sz);
  return __r;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
          _CharT __rhs) {
  basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());
  typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz =
      __lhs.size();
  __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + 1);
  __r.push_back(__rhs);
  return __r;
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) basic_string<_CharT, _Traits, _Allocator>
operator+(basic_string<_CharT, _Traits, _Allocator> &&__lhs,
          const basic_string<_CharT, _Traits, _Allocator> &__rhs) {
  return std::__1::move(__lhs.append(__rhs));
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) basic_string<_CharT, _Traits, _Allocator>
operator+(const basic_string<_CharT, _Traits, _Allocator> &__lhs,
          basic_string<_CharT, _Traits, _Allocator> &&__rhs) {
  return std::__1::move(__rhs.insert(0, __lhs));
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) basic_string<_CharT, _Traits, _Allocator>
operator+(basic_string<_CharT, _Traits, _Allocator> &&__lhs,
          basic_string<_CharT, _Traits, _Allocator> &&__rhs) {
  return std::__1::move(__lhs.append(__rhs));
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) basic_string<_CharT, _Traits, _Allocator>
operator+(const _CharT *__lhs,
          basic_string<_CharT, _Traits, _Allocator> &&__rhs) {
  return std::__1::move(__rhs.insert(0, __lhs));
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) basic_string<_CharT, _Traits, _Allocator>
operator+(_CharT __lhs, basic_string<_CharT, _Traits, _Allocator> &&__rhs) {
  __rhs.insert(__rhs.begin(), __lhs);
  return std::__1::move(__rhs);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) basic_string<_CharT, _Traits, _Allocator>
operator+(basic_string<_CharT, _Traits, _Allocator> &&__lhs,
          const _CharT *__rhs) {
  return std::__1::move(__lhs.append(__rhs));
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) basic_string<_CharT, _Traits, _Allocator>
operator+(basic_string<_CharT, _Traits, _Allocator> &&__lhs, _CharT __rhs) {
  __lhs.push_back(__rhs);
  return std::__1::move(__lhs);
}

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
swap(basic_string<_CharT, _Traits, _Allocator> &__lhs,
     basic_string<_CharT, _Traits, _Allocator>
         &__rhs) noexcept(noexcept(__lhs.swap(__rhs))) {
  __lhs.swap(__rhs);
}

typedef basic_string<char16_t> u16string;
typedef basic_string<char32_t> u32string;

__attribute__((__visibility__("default"))) int
stoi(const string &__str, size_t *__idx = 0, int __base = 10);
__attribute__((__visibility__("default"))) long
stol(const string &__str, size_t *__idx = 0, int __base = 10);
__attribute__((__visibility__("default"))) unsigned long
stoul(const string &__str, size_t *__idx = 0, int __base = 10);
__attribute__((__visibility__("default"))) long long
stoll(const string &__str, size_t *__idx = 0, int __base = 10);
__attribute__((__visibility__("default"))) unsigned long long
stoull(const string &__str, size_t *__idx = 0, int __base = 10);

__attribute__((__visibility__("default"))) float stof(const string &__str,
                                                      size_t *__idx = 0);
__attribute__((__visibility__("default"))) double stod(const string &__str,
                                                       size_t *__idx = 0);
__attribute__((__visibility__("default"))) long double
stold(const string &__str, size_t *__idx = 0);

__attribute__((__visibility__("default"))) string to_string(int __val);
__attribute__((__visibility__("default"))) string to_string(unsigned __val);
__attribute__((__visibility__("default"))) string to_string(long __val);
__attribute__((__visibility__("default"))) string
to_string(unsigned long __val);
__attribute__((__visibility__("default"))) string to_string(long long __val);
__attribute__((__visibility__("default"))) string
to_string(unsigned long long __val);
__attribute__((__visibility__("default"))) string to_string(float __val);
__attribute__((__visibility__("default"))) string to_string(double __val);
__attribute__((__visibility__("default"))) string to_string(long double __val);

__attribute__((__visibility__("default"))) int
stoi(const wstring &__str, size_t *__idx = 0, int __base = 10);
__attribute__((__visibility__("default"))) long
stol(const wstring &__str, size_t *__idx = 0, int __base = 10);
__attribute__((__visibility__("default"))) unsigned long
stoul(const wstring &__str, size_t *__idx = 0, int __base = 10);
__attribute__((__visibility__("default"))) long long
stoll(const wstring &__str, size_t *__idx = 0, int __base = 10);
__attribute__((__visibility__("default"))) unsigned long long
stoull(const wstring &__str, size_t *__idx = 0, int __base = 10);

__attribute__((__visibility__("default"))) float stof(const wstring &__str,
                                                      size_t *__idx = 0);
__attribute__((__visibility__("default"))) double stod(const wstring &__str,
                                                       size_t *__idx = 0);
__attribute__((__visibility__("default"))) long double
stold(const wstring &__str, size_t *__idx = 0);

__attribute__((__visibility__("default"))) wstring to_wstring(int __val);
__attribute__((__visibility__("default"))) wstring to_wstring(unsigned __val);
__attribute__((__visibility__("default"))) wstring to_wstring(long __val);
__attribute__((__visibility__("default"))) wstring
to_wstring(unsigned long __val);
__attribute__((__visibility__("default"))) wstring to_wstring(long long __val);
__attribute__((__visibility__("default"))) wstring
to_wstring(unsigned long long __val);
__attribute__((__visibility__("default"))) wstring to_wstring(float __val);
__attribute__((__visibility__("default"))) wstring to_wstring(double __val);
__attribute__((__visibility__("default"))) wstring
to_wstring(long double __val);

template <class _CharT, class _Traits, class _Allocator>
const typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::npos;

template <class _CharT, class _Allocator>
struct __attribute__((__type_visibility__("default")))
hash<basic_string<_CharT, char_traits<_CharT>, _Allocator>>
    : public unary_function<
          basic_string<_CharT, char_traits<_CharT>, _Allocator>, size_t> {
  size_t operator()(const basic_string<_CharT, char_traits<_CharT>, _Allocator>
                        &__val) const noexcept {
    return __do_string_hash(__val.data(), __val.data() + __val.size());
  }
};

template <class _CharT, class _Traits, class _Allocator>
basic_ostream<_CharT, _Traits> &
operator<<(basic_ostream<_CharT, _Traits> &__os,
           const basic_string<_CharT, _Traits, _Allocator> &__str);

template <class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits> &
operator>>(basic_istream<_CharT, _Traits> &__is,
           basic_string<_CharT, _Traits, _Allocator> &__str);

template <class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits> &
getline(basic_istream<_CharT, _Traits> &__is,
        basic_string<_CharT, _Traits, _Allocator> &__str, _CharT __dlm);

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) basic_istream<_CharT, _Traits> &
getline(basic_istream<_CharT, _Traits> &__is,
        basic_string<_CharT, _Traits, _Allocator> &__str);

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) basic_istream<_CharT, _Traits> &
getline(basic_istream<_CharT, _Traits> &&__is,
        basic_string<_CharT, _Traits, _Allocator> &__str, _CharT __dlm);

template <class _CharT, class _Traits, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) basic_istream<_CharT, _Traits> &
getline(basic_istream<_CharT, _Traits> &&__is,
        basic_string<_CharT, _Traits, _Allocator> &__str);
# 4333 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3
extern template class __attribute__((__visibility__("default")))
basic_string<char>;
extern template class __attribute__((__visibility__("default")))
basic_string<wchar_t>;

inline namespace literals {
inline namespace string_literals {
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) basic_string<char>
operator"" s(const char *__str, size_t __len) {
  return basic_string<char>(__str, __len);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) basic_string<wchar_t>
operator"" s(const wchar_t *__str, size_t __len) {
  return basic_string<wchar_t>(__str, __len);
}
# 4362 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string" 3
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) basic_string<char16_t>
operator"" s(const char16_t *__str, size_t __len) {
  return basic_string<char16_t>(__str, __len);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) basic_string<char32_t>
operator"" s(const char32_t *__str, size_t __len) {
  return basic_string<char32_t>(__str, __len);
}
} // namespace string_literals
} // namespace literals

} // namespace __1
} // namespace std
# 150 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/system_error" 2 3
# 153 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/system_error" 3

namespace std {
inline namespace __1 {

template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_error_code_enum
    : public false_type {};
# 170 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/system_error" 3
template <class _Tp>
struct __attribute__((__type_visibility__("default"))) is_error_condition_enum
    : public false_type {};

template <>
struct __attribute__((__type_visibility__("default")))
is_error_condition_enum<errc> : true_type {};

class __attribute__((__visibility__("default"))) error_condition;
class __attribute__((__visibility__("default"))) error_code;

class __attribute__((__visibility__("hidden"))) __do_message;

class __attribute__((__visibility__("default"))) error_category {
public:
  virtual ~error_category() noexcept;

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr error_category() noexcept =
      default;

private:
  error_category(const error_category &);
  error_category &operator=(const error_category &);

public:
  virtual const char *name() const noexcept = 0;
  virtual error_condition default_error_condition(int __ev) const noexcept;
  virtual bool equivalent(int __code,
                          const error_condition &__condition) const noexcept;
  virtual bool equivalent(const error_code &__code,
                          int __condition) const noexcept;
  virtual string message(int __ev) const = 0;

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator==(const error_category &__rhs) const noexcept {
    return this == &__rhs;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator!=(const error_category &__rhs) const noexcept {
    return !(*this == __rhs);
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator<(const error_category &__rhs) const noexcept {
    return this < &__rhs;
  }

  friend class __attribute__((__visibility__("hidden"))) __do_message;
};

class __attribute__((__visibility__("hidden"))) __do_message
    : public error_category {
public:
  virtual string message(int ev) const;
};

__attribute__((__visibility__("default"))) const error_category &
generic_category() noexcept;
__attribute__((__visibility__("default"))) const error_category &
system_category() noexcept;

class __attribute__((__visibility__("default"))) error_condition {
  int __val_;
  const error_category *__cat_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  error_condition() noexcept
      : __val_(0), __cat_(&generic_category()) {}

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  error_condition(int __val, const error_category &__cat) noexcept
      : __val_(__val), __cat_(&__cat) {}

  template <class _Ep>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  error_condition(_Ep __e,
                  typename enable_if<is_error_condition_enum<_Ep>::value>::type
                      * = 0) noexcept {
    *this = make_error_condition(__e);
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  assign(int __val, const error_category &__cat) noexcept {
    __val_ = __val;
    __cat_ = &__cat;
  }

  template <class _Ep>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename enable_if<is_error_condition_enum<_Ep>::value,
                     error_condition &>::type
  operator=(_Ep __e) noexcept {
    *this = make_error_condition(__e);
    return *this;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  clear() noexcept {
    __val_ = 0;
    __cat_ = &generic_category();
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) int
  value() const noexcept {
    return __val_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const error_category &
  category() const noexcept {
    return *__cat_;
  }
  string message() const;

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit
  operator bool() const noexcept {
    return __val_ != 0;
  }
};

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) error_condition
make_error_condition(errc __e) noexcept {
  return error_condition(static_cast<int>(__e), generic_category());
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator<(const error_condition &__x, const error_condition &__y) noexcept {
  return __x.category() < __y.category() ||
         (__x.category() == __y.category() && __x.value() < __y.value());
}

class __attribute__((__visibility__("default"))) error_code {
  int __val_;
  const error_category *__cat_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  error_code() noexcept
      : __val_(0), __cat_(&system_category()) {}

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  error_code(int __val, const error_category &__cat) noexcept
      : __val_(__val), __cat_(&__cat) {}

  template <class _Ep>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  error_code(
      _Ep __e,
      typename enable_if<is_error_code_enum<_Ep>::value>::type * = 0) noexcept {
    *this = make_error_code(__e);
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  assign(int __val, const error_category &__cat) noexcept {
    __val_ = __val;
    __cat_ = &__cat;
  }

  template <class _Ep>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename enable_if<is_error_code_enum<_Ep>::value, error_code &>::type
  operator=(_Ep __e) noexcept {
    *this = make_error_code(__e);
    return *this;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  clear() noexcept {
    __val_ = 0;
    __cat_ = &system_category();
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) int
  value() const noexcept {
    return __val_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const error_category &
  category() const noexcept {
    return *__cat_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  error_condition
  default_error_condition() const noexcept {
    return __cat_->default_error_condition(__val_);
  }

  string message() const;

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit
  operator bool() const noexcept {
    return __val_ != 0;
  }
};

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) error_code
make_error_code(errc __e) noexcept {
  return error_code(static_cast<int>(__e), generic_category());
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator<(const error_code &__x, const error_code &__y) noexcept {
  return __x.category() < __y.category() ||
         (__x.category() == __y.category() && __x.value() < __y.value());
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator==(const error_code &__x, const error_code &__y) noexcept {
  return __x.category() == __y.category() && __x.value() == __y.value();
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator==(const error_code &__x, const error_condition &__y) noexcept {
  return __x.category().equivalent(__x.value(), __y) ||
         __y.category().equivalent(__x, __y.value());
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator==(const error_condition &__x, const error_code &__y) noexcept {
  return __y == __x;
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator==(const error_condition &__x, const error_condition &__y) noexcept {
  return __x.category() == __y.category() && __x.value() == __y.value();
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator!=(const error_code &__x, const error_code &__y) noexcept {
  return !(__x == __y);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator!=(const error_code &__x, const error_condition &__y) noexcept {
  return !(__x == __y);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator!=(const error_condition &__x, const error_code &__y) noexcept {
  return !(__x == __y);
}

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator!=(const error_condition &__x, const error_condition &__y) noexcept {
  return !(__x == __y);
}

template <>
struct __attribute__((__type_visibility__("default")))
hash<error_code> : public unary_function<error_code, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_t
  operator()(const error_code &__ec) const noexcept {
    return static_cast<size_t>(__ec.value());
  }
};

template <>
struct __attribute__((__type_visibility__("default")))
hash<error_condition> : public unary_function<error_condition, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_t
  operator()(const error_condition &__ec) const noexcept {
    return static_cast<size_t>(__ec.value());
  }
};

class __attribute__((__visibility__("default"))) system_error
    : public runtime_error {
  error_code __ec_;

public:
  system_error(error_code __ec, const string &__what_arg);
  system_error(error_code __ec, const char *__what_arg);
  system_error(error_code __ec);
  system_error(int __ev, const error_category &__ecat,
               const string &__what_arg);
  system_error(int __ev, const error_category &__ecat, const char *__what_arg);
  system_error(int __ev, const error_category &__ecat);
  ~system_error() noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const error_code &
  code() const noexcept {
    return __ec_;
  }

private:
  static string __init(const error_code &, string);
};

[[noreturn]] __attribute__((__visibility__("default"))) void
__throw_system_error(int ev, const char *what_arg);

} // namespace __1
} // namespace std
# 16 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__mutex_base" 2 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__threading_support" 1 3
# 13 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__threading_support" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 14 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__threading_support" 2 3
# 20 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__threading_support" 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pthread.h" 1 3 4
# 57 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pthread.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pthread/pthread_impl.h" 1 3 4
# 33 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pthread/pthread_impl.h" 3 4
#pragma clang assume_nonnull begin
#pragma clang assume_nonnull end
# 58 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pthread.h" 2 3 4

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pthread/sched.h" 1 3 4
# 30 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pthread/sched.h" 3 4
extern "C" {

struct sched_param {
  int sched_priority;
  char __opaque[4];
};

extern int sched_yield(void);
extern int sched_get_priority_min(int);
extern int sched_get_priority_max(int);
}
# 60 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pthread.h" 2 3 4

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_cond_t.h" 1 3 4
# 31 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_cond_t.h" 3 4
typedef __darwin_pthread_cond_t pthread_cond_t;
# 64 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_condattr_t.h" 1 3 4
# 31 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_condattr_t.h" 3 4
typedef __darwin_pthread_condattr_t pthread_condattr_t;
# 65 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_key_t.h" 1 3 4
# 31 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_key_t.h" 3 4
typedef __darwin_pthread_key_t pthread_key_t;
# 66 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_mutex_t.h" 1 3 4
# 31 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_mutex_t.h" 3 4
typedef __darwin_pthread_mutex_t pthread_mutex_t;
# 67 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_mutexattr_t.h" 1 3 4
# 31 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_mutexattr_t.h" 3 4
typedef __darwin_pthread_mutexattr_t pthread_mutexattr_t;
# 68 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_once_t.h" 1 3 4
# 31 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_once_t.h" 3 4
typedef __darwin_pthread_once_t pthread_once_t;
# 69 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_rwlock_t.h" 1 3 4
# 31 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_rwlock_t.h" 3 4
typedef __darwin_pthread_rwlock_t pthread_rwlock_t;
# 70 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_rwlockattr_t.h" 1 3 4
# 31 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_rwlockattr_t.h" 3 4
typedef __darwin_pthread_rwlockattr_t pthread_rwlockattr_t;
# 71 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_t.h" 1 3 4
# 31 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_pthread/_pthread_t.h" 3 4
typedef __darwin_pthread_t pthread_t;
# 72 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pthread.h" 2 3 4

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pthread/qos.h" 1 3 4
# 34 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pthread/qos.h" 3 4
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/qos.h" 1 3 4
# 130 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/qos.h" 3 4
typedef enum : unsigned int {
  QOS_CLASS_USER_INTERACTIVE
  __attribute__((availability(macos, introduced = 10.10)))
  __attribute__((availability(ios, introduced = 8.0))) = 0x21,
  QOS_CLASS_USER_INITIATED
  __attribute__((availability(macos, introduced = 10.10)))
  __attribute__((availability(ios, introduced = 8.0))) = 0x19,
  QOS_CLASS_DEFAULT __attribute__((availability(macos, introduced = 10.10)))
  __attribute__((availability(ios, introduced = 8.0))) = 0x15,
  QOS_CLASS_UTILITY __attribute__((availability(macos, introduced = 10.10)))
  __attribute__((availability(ios, introduced = 8.0))) = 0x11,
  QOS_CLASS_BACKGROUND __attribute__((availability(macos, introduced = 10.10)))
  __attribute__((availability(ios, introduced = 8.0))) = 0x09,
  QOS_CLASS_UNSPECIFIED __attribute__((availability(macos, introduced = 10.10)))
  __attribute__((availability(ios, introduced = 8.0))) = 0x00,
} qos_class_t;
# 159 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/qos.h" 3 4
extern "C" {
# 170 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/qos.h" 3 4
__attribute__((availability(macos, introduced = 10.10)))
__attribute__((availability(ios, introduced = 8.0))) qos_class_t
qos_class_self(void);
# 192 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/qos.h" 3 4
__attribute__((availability(macos, introduced = 10.10)))
__attribute__((availability(ios, introduced = 8.0))) qos_class_t
qos_class_main(void);
}
# 35 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pthread/qos.h" 2 3 4

#pragma clang assume_nonnull begin

extern "C" {
# 81 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pthread/qos.h" 3 4
__attribute__((availability(macos, introduced = 10.10)))
__attribute__((availability(ios, introduced = 8.0))) int
pthread_attr_set_qos_class_np(pthread_attr_t *__attr, qos_class_t __qos_class,
                              int __relative_priority);
# 112 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pthread/qos.h" 3 4
__attribute__((availability(macos, introduced = 10.10)))
__attribute__((availability(ios, introduced = 8.0))) int
pthread_attr_get_qos_class_np(pthread_attr_t *__attr,
                              qos_class_t *_Nullable __qos_class,
                              int *_Nullable __relative_priority);
# 153 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pthread/qos.h" 3 4
__attribute__((availability(macos, introduced = 10.10)))
__attribute__((availability(ios, introduced = 8.0))) int
pthread_set_qos_class_self_np(qos_class_t __qos_class, int __relative_priority);
# 184 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pthread/qos.h" 3 4
__attribute__((availability(macos, introduced = 10.10)))
__attribute__((availability(ios, introduced = 8.0))) int
pthread_get_qos_class_np(pthread_t __pthread,
                         qos_class_t *_Nullable __qos_class,
                         int *_Nullable __relative_priority);
# 211 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pthread/qos.h" 3 4
typedef struct pthread_override_s *pthread_override_t;
# 263 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pthread/qos.h" 3 4
__attribute__((availability(macos, introduced = 10.10)))
__attribute__((availability(ios, introduced = 8.0))) pthread_override_t
pthread_override_qos_class_start_np(pthread_t __pthread,
                                    qos_class_t __qos_class,
                                    int __relative_priority);
# 291 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pthread/qos.h" 3 4
__attribute__((availability(macos, introduced = 10.10)))
__attribute__((availability(ios, introduced = 8.0))) int
pthread_override_qos_class_end_np(pthread_override_t __override);
}
#pragma clang assume_nonnull end
# 74 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pthread.h" 2 3 4

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_mach_port_t.h" 1 3 4
# 50 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_mach_port_t.h" 3 4
typedef __darwin_mach_port_t mach_port_t;
# 78 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pthread.h" 2 3 4
# 106 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pthread.h" 3 4
#pragma clang assume_nonnull begin

extern "C" {
# 221 "/Applications/apps/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/pthread.h" 3 4
__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_atfork(void (*_Nullable)(void), void (*_Nullable)(void),
               void (*_Nullable)(void));

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_attr_destroy(pthread_attr_t *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_attr_getdetachstate(const pthread_attr_t *, int *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_attr_getguardsize(const pthread_attr_t *, size_t *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_attr_getinheritsched(const pthread_attr_t *, int *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_attr_getschedparam(const pthread_attr_t *, struct sched_param *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_attr_getschedpolicy(const pthread_attr_t *, int *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_attr_getscope(const pthread_attr_t *, int *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_attr_getstack(const pthread_attr_t *, void *_Nullable *_Nonnull,
                      size_t *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_attr_getstackaddr(const pthread_attr_t *, void *_Nullable *_Nonnull);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_attr_getstacksize(const pthread_attr_t *, size_t *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_attr_init(pthread_attr_t *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_attr_setdetachstate(pthread_attr_t *, int);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_attr_setguardsize(pthread_attr_t *, size_t);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_attr_setinheritsched(pthread_attr_t *, int);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_attr_setschedparam(pthread_attr_t *, const struct sched_param *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_attr_setschedpolicy(pthread_attr_t *, int);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_attr_setscope(pthread_attr_t *, int);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_attr_setstack(pthread_attr_t *, void *, size_t);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_attr_setstackaddr(pthread_attr_t *, void *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_attr_setstacksize(pthread_attr_t *, size_t);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
    pthread_cancel(pthread_t) __asm("_"
                                    "pthread_cancel");

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_cond_broadcast(pthread_cond_t *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_cond_destroy(pthread_cond_t *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_cond_init(pthread_cond_t *, const pthread_condattr_t *_Nullable) __asm(
    "_"
    "pthread_cond_init");

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_cond_signal(pthread_cond_t *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_cond_timedwait(
    pthread_cond_t *, pthread_mutex_t *,
    const struct timespec *_Nullable) __asm("_"
                                            "pthread_cond_timedwait");

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_cond_wait(pthread_cond_t *,
                  pthread_mutex_t *) __asm("_"
                                           "pthread_cond_wait");

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_condattr_destroy(pthread_condattr_t *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_condattr_init(pthread_condattr_t *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_condattr_getpshared(const pthread_condattr_t *, int *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_condattr_setpshared(pthread_condattr_t *, int);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))

int pthread_create(pthread_t _Nullable * _Nonnull ,
  const pthread_attr_t * _Nullable ,
  void * _Nullable (* _Nonnull)(void * _Nullable),
  void * _Nullable );

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
    pthread_detach(pthread_t);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
    pthread_equal(pthread_t _Nullable, pthread_t _Nullable);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) void
pthread_exit(void *_Nullable) __attribute__((__noreturn__));

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_getconcurrency(void);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_getschedparam(pthread_t, int *_Nullable, struct sched_param *_Nullable);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(
    ios, introduced = 2.0))) void *_Nullable pthread_getspecific(pthread_key_t);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_join(pthread_t, void *_Nullable *_Nullable) __asm("_"
                                                          "pthread_join");

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_key_create(pthread_key_t *, void (*_Nullable)(void *));

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
    pthread_key_delete(pthread_key_t);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_mutex_destroy(pthread_mutex_t *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_mutex_getprioceiling(const pthread_mutex_t *, int *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_mutex_init(pthread_mutex_t *, const pthread_mutexattr_t *_Nullable);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_mutex_lock(pthread_mutex_t *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_mutex_setprioceiling(pthread_mutex_t *, int, int *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_mutex_trylock(pthread_mutex_t *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_mutex_unlock(pthread_mutex_t *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_mutexattr_destroy(pthread_mutexattr_t *) __asm(
    "_"
    "pthread_mutexattr_destroy");

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *, int *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_mutexattr_getprotocol(const pthread_mutexattr_t *, int *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_mutexattr_getpshared(const pthread_mutexattr_t *, int *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_mutexattr_gettype(const pthread_mutexattr_t *, int *);

__attribute__((availability(macos, introduced = 10.13.4)))
__attribute__((availability(ios, introduced = 11.3)))
__attribute__((availability(watchos, introduced = 4.3)))
__attribute__((availability(tvos, introduced = 11.3))) int
pthread_mutexattr_getpolicy_np(const pthread_mutexattr_t *, int *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_mutexattr_init(pthread_mutexattr_t *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_mutexattr_setpshared(pthread_mutexattr_t *, int);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_mutexattr_settype(pthread_mutexattr_t *, int);

__attribute__((availability(macos, introduced = 10.7)))
__attribute__((availability(ios, introduced = 5.0))) int
pthread_mutexattr_setpolicy_np(pthread_mutexattr_t *, int);

__attribute__((availability(
    swift, unavailable, message = "Use lazily initialized globals instead")))
__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_once(pthread_once_t *, void (*_Nonnull)(void));

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_rwlock_destroy(pthread_rwlock_t *) __asm("_"
                                                 "pthread_rwlock_destroy");

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_rwlock_init(
    pthread_rwlock_t *,
    const pthread_rwlockattr_t *_Nullable) __asm("_"
                                                 "pthread_rwlock_init");

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_rwlock_rdlock(pthread_rwlock_t *) __asm("_"
                                                "pthread_rwlock_rdlock");

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_rwlock_tryrdlock(pthread_rwlock_t *) __asm("_"
                                                   "pthread_rwlock_tryrdlock");

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_rwlock_trywrlock(pthread_rwlock_t *) __asm("_"
                                                   "pthread_rwlock_trywrlock");

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_rwlock_wrlock(pthread_rwlock_t *) __asm("_"
                                                "pthread_rwlock_wrlock");

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_rwlock_unlock(pthread_rwlock_t *) __asm("_"
                                                "pthread_rwlock_unlock");

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_rwlockattr_destroy(pthread_rwlockattr_t *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *, int *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_rwlockattr_init(pthread_rwlockattr_t *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) pthread_t
pthread_self(void);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_setcancelstate(int, int *_Nullable) __asm("_"
                                                  "pthread_setcancelstate");

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_setcanceltype(int, int *_Nullable) __asm("_"
                                                 "pthread_setcanceltype");

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_setconcurrency(int);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_setschedparam(pthread_t, int, const struct sched_param *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_setspecific(pthread_key_t, const void *_Nullable);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) void
pthread_testcancel(void) __asm("_"
                               "pthread_testcancel");

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_is_threaded_np(void);

__attribute__((availability(macos, introduced = 10.6)))
__attribute__((availability(ios, introduced = 3.2))) int
pthread_threadid_np(pthread_t _Nullable, __uint64_t *_Nullable);

__attribute__((availability(macos, introduced = 10.6)))
__attribute__((availability(ios, introduced = 3.2))) int
pthread_getname_np(pthread_t, char *, size_t);

__attribute__((availability(macos, introduced = 10.6)))
__attribute__((availability(ios, introduced = 3.2))) int
pthread_setname_np(const char *);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_main_np(void);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0)))
mach_port_t pthread_mach_thread_np(pthread_t);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0)))
size_t pthread_get_stacksize_np(pthread_t);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) void *
    pthread_get_stackaddr_np(pthread_t);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_cond_signal_thread_np(pthread_cond_t *, pthread_t _Nullable);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_cond_timedwait_relative_np(pthread_cond_t *, pthread_mutex_t *,
                                   const struct timespec *_Nullable);

__attribute__((availability(macos,introduced=10.4))) __attribute__((availability(ios,introduced=2.0)))

int pthread_create_suspended_np(
  pthread_t _Nullable * _Nonnull, const pthread_attr_t * _Nullable,
  void * _Nullable (* _Nonnull)(void * _Nullable), void * _Nullable);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_kill(pthread_t, int);

__attribute__((availability(macos, introduced = 10.5)))
__attribute__((availability(ios, introduced = 2.0))) _Nullable pthread_t
    pthread_from_mach_thread_np(mach_port_t);

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) int
pthread_sigmask(int, const sigset_t *_Nullable,
                sigset_t *_Nullable) __asm("_"
                                           "pthread_sigmask");

__attribute__((availability(macos, introduced = 10.4)))
__attribute__((availability(ios, introduced = 2.0))) void
pthread_yield_np(void);
}
#pragma clang assume_nonnull end
# 28 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__threading_support" 2 3
# 45 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__threading_support" 3
typedef ::timespec __libcpp_timespec_t;

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_macros" 1 3
# 50 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__threading_support" 2 3

namespace std {
inline namespace __1 {

typedef pthread_mutex_t __libcpp_mutex_t;

typedef pthread_mutex_t __libcpp_recursive_mutex_t;

typedef pthread_cond_t __libcpp_condvar_t;

typedef pthread_once_t __libcpp_exec_once_flag;

typedef pthread_t __libcpp_thread_id;

typedef pthread_t __libcpp_thread_t;

typedef pthread_key_t __libcpp_tls_key;
# 119 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__threading_support" 3
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) int
__libcpp_recursive_mutex_init(__libcpp_recursive_mutex_t *__m);

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) int
__libcpp_recursive_mutex_lock(__libcpp_recursive_mutex_t *__m);

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
__libcpp_recursive_mutex_trylock(__libcpp_recursive_mutex_t *__m);

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) int
__libcpp_recursive_mutex_unlock(__libcpp_recursive_mutex_t *__m);

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) int
__libcpp_recursive_mutex_destroy(__libcpp_recursive_mutex_t *__m);

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) int
__libcpp_mutex_lock(__libcpp_mutex_t *__m);

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
__libcpp_mutex_trylock(__libcpp_mutex_t *__m);

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) int
__libcpp_mutex_unlock(__libcpp_mutex_t *__m);

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) int
__libcpp_mutex_destroy(__libcpp_mutex_t *__m);

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) int
__libcpp_condvar_signal(__libcpp_condvar_t *__cv);

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) int
__libcpp_condvar_broadcast(__libcpp_condvar_t *__cv);

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) int
__libcpp_condvar_wait(__libcpp_condvar_t *__cv, __libcpp_mutex_t *__m);

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) int
__libcpp_condvar_timedwait(__libcpp_condvar_t *__cv, __libcpp_mutex_t *__m,
                           __libcpp_timespec_t *__ts);

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) int
__libcpp_condvar_destroy(__libcpp_condvar_t *__cv);

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) int
__libcpp_execute_once(__libcpp_exec_once_flag *flag, void (*init_routine)());

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
__libcpp_thread_id_equal(__libcpp_thread_id t1, __libcpp_thread_id t2);

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
__libcpp_thread_id_less(__libcpp_thread_id t1, __libcpp_thread_id t2);

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
__libcpp_thread_isnull(const __libcpp_thread_t *__t);

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) int
__libcpp_thread_create(__libcpp_thread_t *__t, void *(*__func)(void *),
                       void *__arg);

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) __libcpp_thread_id
__libcpp_thread_get_current_id();

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) __libcpp_thread_id
__libcpp_thread_get_id(const __libcpp_thread_t *__t);

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) int
__libcpp_thread_join(__libcpp_thread_t *__t);

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) int
__libcpp_thread_detach(__libcpp_thread_t *__t);

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
__libcpp_thread_yield();

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
__libcpp_thread_sleep_for(const chrono::nanoseconds &__ns);

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) int
__libcpp_tls_create(__libcpp_tls_key *__key, void (*__at_exit)(void *));

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void *
__libcpp_tls_get(__libcpp_tls_key __key);

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) int
__libcpp_tls_set(__libcpp_tls_key __key, void *__p);

int __libcpp_recursive_mutex_init(__libcpp_recursive_mutex_t *__m) {
  pthread_mutexattr_t attr;
  int __ec = pthread_mutexattr_init(&attr);
  if (__ec)
    return __ec;
  __ec = pthread_mutexattr_settype(&attr, 2);
  if (__ec) {
    pthread_mutexattr_destroy(&attr);
    return __ec;
  }
  __ec = pthread_mutex_init(__m, &attr);
  if (__ec) {
    pthread_mutexattr_destroy(&attr);
    return __ec;
  }
  __ec = pthread_mutexattr_destroy(&attr);
  if (__ec) {
    pthread_mutex_destroy(__m);
    return __ec;
  }
  return 0;
}

int __libcpp_recursive_mutex_lock(__libcpp_recursive_mutex_t *__m) {
  return pthread_mutex_lock(__m);
}

bool __libcpp_recursive_mutex_trylock(__libcpp_recursive_mutex_t *__m) {
  return pthread_mutex_trylock(__m) == 0;
}

int __libcpp_recursive_mutex_unlock(__libcpp_mutex_t *__m) {
  return pthread_mutex_unlock(__m);
}

int __libcpp_recursive_mutex_destroy(__libcpp_recursive_mutex_t *__m) {
  return pthread_mutex_destroy(__m);
}

int __libcpp_mutex_lock(__libcpp_mutex_t *__m) {
  return pthread_mutex_lock(__m);
}

bool __libcpp_mutex_trylock(__libcpp_mutex_t *__m) {
  return pthread_mutex_trylock(__m) == 0;
}

int __libcpp_mutex_unlock(__libcpp_mutex_t *__m) {
  return pthread_mutex_unlock(__m);
}

int __libcpp_mutex_destroy(__libcpp_mutex_t *__m) {
  return pthread_mutex_destroy(__m);
}

int __libcpp_condvar_signal(__libcpp_condvar_t *__cv) {
  return pthread_cond_signal(__cv);
}

int __libcpp_condvar_broadcast(__libcpp_condvar_t *__cv) {
  return pthread_cond_broadcast(__cv);
}

int __libcpp_condvar_wait(__libcpp_condvar_t *__cv, __libcpp_mutex_t *__m) {
  return pthread_cond_wait(__cv, __m);
}

int __libcpp_condvar_timedwait(__libcpp_condvar_t *__cv, __libcpp_mutex_t *__m,
                               __libcpp_timespec_t *__ts) {
  return pthread_cond_timedwait(__cv, __m, __ts);
}

int __libcpp_condvar_destroy(__libcpp_condvar_t *__cv) {
  return pthread_cond_destroy(__cv);
}

int __libcpp_execute_once(__libcpp_exec_once_flag *flag,
                          void (*init_routine)()) {
  return pthread_once(flag, init_routine);
}

bool __libcpp_thread_id_equal(__libcpp_thread_id t1, __libcpp_thread_id t2) {
  return pthread_equal(t1, t2) != 0;
}

bool __libcpp_thread_id_less(__libcpp_thread_id t1, __libcpp_thread_id t2) {
  return t1 < t2;
}

bool __libcpp_thread_isnull(const __libcpp_thread_t *__t) { return *__t == 0; }

int __libcpp_thread_create(__libcpp_thread_t *__t, void *(*__func)(void *),
                           void *__arg) {
  return pthread_create(__t, 0, __func, __arg);
}

__libcpp_thread_id __libcpp_thread_get_current_id() { return pthread_self(); }

__libcpp_thread_id __libcpp_thread_get_id(const __libcpp_thread_t *__t) {
  return *__t;
}

int __libcpp_thread_join(__libcpp_thread_t *__t) {
  return pthread_join(*__t, 0);
}

int __libcpp_thread_detach(__libcpp_thread_t *__t) {
  return pthread_detach(*__t);
}

void __libcpp_thread_yield() { sched_yield(); }

void __libcpp_thread_sleep_for(const chrono::nanoseconds &__ns) {
  using namespace chrono;
  seconds __s = duration_cast<seconds>(__ns);
  __libcpp_timespec_t __ts;
  typedef decltype(__ts.tv_sec) ts_sec;
  constexpr ts_sec __ts_sec_max = numeric_limits<ts_sec>::max();

  if (__s.count() < __ts_sec_max) {
    __ts.tv_sec = static_cast<ts_sec>(__s.count());
    __ts.tv_nsec = static_cast<decltype(__ts.tv_nsec)>((__ns - __s).count());
  } else {
    __ts.tv_sec = __ts_sec_max;
    __ts.tv_nsec = 999999999;
  }

  while (nanosleep(&__ts, &__ts) == -1 && (*__error()) == 4)
    ;
}

int __libcpp_tls_create(__libcpp_tls_key *__key, void (*__at_exit)(void *)) {
  return pthread_key_create(__key, __at_exit);
}

void *__libcpp_tls_get(__libcpp_tls_key __key) {
  return pthread_getspecific(__key);
}

int __libcpp_tls_set(__libcpp_tls_key __key, void *__p) {
  return pthread_setspecific(__key, __p);
}

class __attribute__((__visibility__("default"))) thread;
class __attribute__((__visibility__("default"))) __thread_id;

namespace this_thread {

__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
__thread_id
get_id() noexcept;

}

template <> struct hash<__thread_id>;

class __attribute__((__type_visibility__("default"))) __thread_id {

  __libcpp_thread_id __id_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __thread_id() noexcept
      : __id_(0) {}

  friend __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator==(__thread_id __x, __thread_id __y) noexcept {
    if (__x.__id_ == 0)
      return __y.__id_ == 0;
    if (__y.__id_ == 0)
      return false;
    return __libcpp_thread_id_equal(__x.__id_, __y.__id_);
  }
  friend __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator!=(__thread_id __x, __thread_id __y) noexcept {
    return !(__x == __y);
  }
  friend __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator<(__thread_id __x, __thread_id __y) noexcept {
    if (__x.__id_ == 0)
      return __y.__id_ != 0;
    if (__y.__id_ == 0)
      return false;
    return __libcpp_thread_id_less(__x.__id_, __y.__id_);
  }
  friend __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator<=(__thread_id __x, __thread_id __y) noexcept {
    return !(__y < __x);
  }
  friend __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator>(__thread_id __x, __thread_id __y) noexcept {
    return __y < __x;
  }
  friend __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator>=(__thread_id __x, __thread_id __y) noexcept {
    return !(__x < __y);
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __reset() {
    __id_ = 0;
  }

  template <class _CharT, class _Traits>
  friend __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) basic_ostream<_CharT, _Traits> &
  operator<<(basic_ostream<_CharT, _Traits> &__os, __thread_id __id);

private:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __thread_id(__libcpp_thread_id __id)
      : __id_(__id) {}

  friend __thread_id this_thread::get_id() noexcept;
  friend class __attribute__((__visibility__("default"))) thread;
  friend struct __attribute__((__type_visibility__("default")))
  hash<__thread_id>;
};

namespace this_thread {

inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) __thread_id
get_id() noexcept {
  return __libcpp_thread_get_current_id();
}

} // namespace this_thread

} // namespace __1
} // namespace std
# 17 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__mutex_base" 2 3
# 22 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__mutex_base" 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_macros" 1 3
# 26 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__mutex_base" 2 3

namespace std {
inline namespace __1 {

class __attribute__((__visibility__("default"))) mutex {
  __libcpp_mutex_t __m_ = {0x32AAABA7, {0}};

public:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr mutex() = default;

  mutex(const mutex &) = delete;
  mutex &operator=(const mutex &) = delete;

  ~mutex() noexcept;

  void lock();
  bool try_lock() noexcept;
  void unlock() noexcept;

  typedef __libcpp_mutex_t *native_handle_type;
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  native_handle_type
  native_handle() {
    return &__m_;
  }
};

static_assert(is_nothrow_default_constructible<mutex>::value,
              "the default constructor for std::mutex must be nothrow");

struct __attribute__((__visibility__("default"))) defer_lock_t {
  explicit defer_lock_t() = default;
};
struct __attribute__((__visibility__("default"))) try_to_lock_t {
  explicit try_to_lock_t() = default;
};
struct __attribute__((__visibility__("default"))) adopt_lock_t {
  explicit adopt_lock_t() = default;
};
# 72 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__mutex_base" 3
constexpr defer_lock_t defer_lock = defer_lock_t();
constexpr try_to_lock_t try_to_lock = try_to_lock_t();
constexpr adopt_lock_t adopt_lock = adopt_lock_t();

template <class _Mutex>
class __attribute__((__type_visibility__("default"))) lock_guard {
public:
  typedef _Mutex mutex_type;

private:
  mutex_type &__m_;

public:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit lock_guard(mutex_type &__m)
      : __m_(__m) {
    __m_.lock();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  lock_guard(mutex_type &__m, adopt_lock_t)
      : __m_(__m) {}
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) ~lock_guard() {
    __m_.unlock();
  }

private:
  lock_guard(lock_guard const &) = delete;
  lock_guard &operator=(lock_guard const &) = delete;
};

template <class _Mutex>
class __attribute__((__type_visibility__("default"))) unique_lock {
public:
  typedef _Mutex mutex_type;

private:
  mutex_type *__m_;
  bool __owns_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  unique_lock() noexcept
      : __m_(nullptr), __owns_(false) {}
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit unique_lock(mutex_type &__m)
      : __m_(std::__1::addressof(__m)), __owns_(true) {
    __m_->lock();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  unique_lock(mutex_type &__m, defer_lock_t) noexcept
      : __m_(std::__1::addressof(__m)), __owns_(false) {}
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  unique_lock(mutex_type &__m, try_to_lock_t)
      : __m_(std::__1::addressof(__m)), __owns_(__m.try_lock()) {}
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  unique_lock(mutex_type &__m, adopt_lock_t)
      : __m_(std::__1::addressof(__m)), __owns_(true) {}
  template <class _Clock, class _Duration>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  unique_lock(mutex_type &__m, const chrono::time_point<_Clock, _Duration> &__t)
      : __m_(std::__1::addressof(__m)), __owns_(__m.try_lock_until(__t)) {}
  template <class _Rep, class _Period>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  unique_lock(mutex_type &__m, const chrono::duration<_Rep, _Period> &__d)
      : __m_(std::__1::addressof(__m)), __owns_(__m.try_lock_for(__d)) {}
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) ~unique_lock() {
    if (__owns_)
      __m_->unlock();
  }

private:
  unique_lock(unique_lock const &);
  unique_lock &operator=(unique_lock const &);

public:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  unique_lock(unique_lock &&__u) noexcept
      : __m_(__u.__m_), __owns_(__u.__owns_) {
    __u.__m_ = nullptr;
    __u.__owns_ = false;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  unique_lock &
  operator=(unique_lock &&__u) noexcept {
    if (__owns_)
      __m_->unlock();
    __m_ = __u.__m_;
    __owns_ = __u.__owns_;
    __u.__m_ = nullptr;
    __u.__owns_ = false;
    return *this;
  }

  void lock();
  bool try_lock();

  template <class _Rep, class _Period>
  bool try_lock_for(const chrono::duration<_Rep, _Period> &__d);
  template <class _Clock, class _Duration>
  bool try_lock_until(const chrono::time_point<_Clock, _Duration> &__t);

  void unlock();

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  swap(unique_lock &__u) noexcept {
    std::__1::swap(__m_, __u.__m_);
    std::__1::swap(__owns_, __u.__owns_);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  mutex_type *
  release() noexcept {
    mutex_type *__m = __m_;
    __m_ = nullptr;
    __owns_ = false;
    return __m;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  owns_lock() const noexcept {
    return __owns_;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit
  operator bool() const noexcept {
    return __owns_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  mutex_type *
  mutex() const noexcept {
    return __m_;
  }
};

template <class _Mutex> void unique_lock<_Mutex>::lock() {
  if (__m_ == nullptr)
    __throw_system_error(1, "unique_lock::lock: references null mutex");
  if (__owns_)
    __throw_system_error(11, "unique_lock::lock: already locked");
  __m_->lock();
  __owns_ = true;
}

template <class _Mutex> bool unique_lock<_Mutex>::try_lock() {
  if (__m_ == nullptr)
    __throw_system_error(1, "unique_lock::try_lock: references null mutex");
  if (__owns_)
    __throw_system_error(11, "unique_lock::try_lock: already locked");
  __owns_ = __m_->try_lock();
  return __owns_;
}

template <class _Mutex>
template <class _Rep, class _Period>
bool unique_lock<_Mutex>::try_lock_for(
    const chrono::duration<_Rep, _Period> &__d) {
  if (__m_ == nullptr)
    __throw_system_error(1, "unique_lock::try_lock_for: references null mutex");
  if (__owns_)
    __throw_system_error(11, "unique_lock::try_lock_for: already locked");
  __owns_ = __m_->try_lock_for(__d);
  return __owns_;
}

template <class _Mutex>
template <class _Clock, class _Duration>
bool unique_lock<_Mutex>::try_lock_until(
    const chrono::time_point<_Clock, _Duration> &__t) {
  if (__m_ == nullptr)
    __throw_system_error(1,
                         "unique_lock::try_lock_until: references null mutex");
  if (__owns_)
    __throw_system_error(11, "unique_lock::try_lock_until: already locked");
  __owns_ = __m_->try_lock_until(__t);
  return __owns_;
}

template <class _Mutex> void unique_lock<_Mutex>::unlock() {
  if (!__owns_)
    __throw_system_error(1, "unique_lock::unlock: not locked");
  __m_->unlock();
  __owns_ = false;
}

template <class _Mutex>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
swap(unique_lock<_Mutex> &__x, unique_lock<_Mutex> &__y) noexcept {
  __x.swap(__y);
}

enum class __attribute__((__type_visibility__("default"))) cv_status {
  no_timeout,
  timeout
};

class __attribute__((__visibility__("default"))) condition_variable {
  __libcpp_condvar_t __cv_ = {0x3CB0B1BB, {0}};

public:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr condition_variable() noexcept =
      default;

  ~condition_variable();

  condition_variable(const condition_variable &) = delete;
  condition_variable &operator=(const condition_variable &) = delete;

  void notify_one() noexcept;
  void notify_all() noexcept;

  void wait(unique_lock<mutex> &__lk) noexcept;
  template <class _Predicate>
  inline __attribute__((__visibility__("hidden"))) void
  wait(unique_lock<mutex> &__lk, _Predicate __pred);

  template <class _Clock, class _Duration>
  inline __attribute__((__visibility__("hidden"))) cv_status
  wait_until(unique_lock<mutex> &__lk,
             const chrono::time_point<_Clock, _Duration> &__t);

  template <class _Clock, class _Duration, class _Predicate>
  inline __attribute__((__visibility__("hidden"))) bool
  wait_until(unique_lock<mutex> &__lk,
             const chrono::time_point<_Clock, _Duration> &__t,
             _Predicate __pred);

  template <class _Rep, class _Period>
  inline __attribute__((__visibility__("hidden"))) cv_status
  wait_for(unique_lock<mutex> &__lk,
           const chrono::duration<_Rep, _Period> &__d);

  template <class _Rep, class _Period, class _Predicate>
  bool __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage))
  wait_for(unique_lock<mutex> &__lk, const chrono::duration<_Rep, _Period> &__d,
           _Predicate __pred);

  typedef __libcpp_condvar_t *native_handle_type;
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  native_handle_type
  native_handle() {
    return &__cv_;
  }

private:
  void __do_timed_wait(
      unique_lock<mutex> &__lk,
      chrono::time_point<chrono::system_clock, chrono::nanoseconds>) noexcept;

  template <class _Clock>
  void
  __do_timed_wait(unique_lock<mutex> &__lk,
                  chrono::time_point<_Clock, chrono::nanoseconds>) noexcept;
};

template <class _Rep, class _Period>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename enable_if<is_floating_point<_Rep>::value, chrono::nanoseconds>::type
__safe_nanosecond_cast(chrono::duration<_Rep, _Period> __d) {
  using namespace chrono;
  using __ratio = ratio_divide<_Period, nano>;
  using __ns_rep = nanoseconds::rep;
  _Rep __result_float = __d.count() * __ratio::num / __ratio::den;

  _Rep __result_max = numeric_limits<__ns_rep>::max();
  if (__result_float >= __result_max) {
    return nanoseconds::max();
  }

  _Rep __result_min = numeric_limits<__ns_rep>::min();
  if (__result_float <= __result_min) {
    return nanoseconds::min();
  }

  return nanoseconds(static_cast<__ns_rep>(__result_float));
}

template <class _Rep, class _Period>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename enable_if<!is_floating_point<_Rep>::value, chrono::nanoseconds>::type
__safe_nanosecond_cast(chrono::duration<_Rep, _Period> __d) {
  using namespace chrono;
  if (__d.count() == 0) {
    return nanoseconds(0);
  }

  using __ratio = ratio_divide<_Period, nano>;
  using __ns_rep = nanoseconds::rep;
  __ns_rep __result_max = std::numeric_limits<__ns_rep>::max();
  if (__d.count() > 0 && __d.count() > __result_max / __ratio::num) {
    return nanoseconds::max();
  }

  __ns_rep __result_min = std::numeric_limits<__ns_rep>::min();
  if (__d.count() < 0 && __d.count() < __result_min / __ratio::num) {
    return nanoseconds::min();
  }

  __ns_rep __result = __d.count() * __ratio::num / __ratio::den;
  if (__result == 0) {
    return nanoseconds(1);
  }

  return nanoseconds(__result);
}

template <class _Predicate>
void condition_variable::wait(unique_lock<mutex> &__lk, _Predicate __pred) {
  while (!__pred())
    wait(__lk);
}

template <class _Clock, class _Duration>
cv_status condition_variable::wait_until(
    unique_lock<mutex> &__lk,
    const chrono::time_point<_Clock, _Duration> &__t) {
  using namespace chrono;
  using __clock_tp_ns = time_point<_Clock, nanoseconds>;

  typename _Clock::time_point __now = _Clock::now();
  if (__t <= __now)
    return cv_status::timeout;

  __clock_tp_ns __t_ns =
      __clock_tp_ns(__safe_nanosecond_cast(__t.time_since_epoch()));

  __do_timed_wait(__lk, __t_ns);
  return _Clock::now() < __t ? cv_status::no_timeout : cv_status::timeout;
}

template <class _Clock, class _Duration, class _Predicate>
bool condition_variable::wait_until(
    unique_lock<mutex> &__lk, const chrono::time_point<_Clock, _Duration> &__t,
    _Predicate __pred) {
  while (!__pred()) {
    if (wait_until(__lk, __t) == cv_status::timeout)
      return __pred();
  }
  return true;
}

template <class _Rep, class _Period>
cv_status
condition_variable::wait_for(unique_lock<mutex> &__lk,
                             const chrono::duration<_Rep, _Period> &__d) {
  using namespace chrono;
  if (__d <= __d.zero())
    return cv_status::timeout;
  using __ns_rep = nanoseconds::rep;
  steady_clock::time_point __c_now = steady_clock::now();

  using __clock_tp_ns = time_point<system_clock, nanoseconds>;
  __ns_rep __now_count_ns =
      __safe_nanosecond_cast(system_clock::now().time_since_epoch()).count();

  __ns_rep __d_ns_count = __safe_nanosecond_cast(__d).count();

  if (__now_count_ns > numeric_limits<__ns_rep>::max() - __d_ns_count) {
    __do_timed_wait(__lk, __clock_tp_ns::max());
  } else {
    __do_timed_wait(__lk,
                    __clock_tp_ns(nanoseconds(__now_count_ns + __d_ns_count)));
  }

  return steady_clock::now() - __c_now < __d ? cv_status::no_timeout
                                             : cv_status::timeout;
}

template <class _Rep, class _Period, class _Predicate>
inline bool
condition_variable::wait_for(unique_lock<mutex> &__lk,
                             const chrono::duration<_Rep, _Period> &__d,
                             _Predicate __pred) {
  return wait_until(__lk, chrono::steady_clock::now() + __d,
                    std::__1::move(__pred));
}
# 517 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__mutex_base" 3
template <class _Clock>
inline void condition_variable::__do_timed_wait(
    unique_lock<mutex> &__lk,
    chrono::time_point<_Clock, chrono::nanoseconds> __tp) noexcept {
  wait_for(__lk, __tp - _Clock::now());
}

} // namespace __1
} // namespace std
# 191 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/mutex" 2 3
# 202 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/mutex" 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_macros" 1 3
# 206 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/mutex" 2 3

namespace std {
inline namespace __1 {

class __attribute__((__visibility__("default"))) recursive_mutex {
  __libcpp_recursive_mutex_t __m_;

public:
  recursive_mutex();
  ~recursive_mutex();

private:
  recursive_mutex(const recursive_mutex &);
  recursive_mutex &operator=(const recursive_mutex &);

public:
  void lock();
  bool try_lock() noexcept;
  void unlock() noexcept;

  typedef __libcpp_recursive_mutex_t *native_handle_type;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  native_handle_type
  native_handle() {
    return &__m_;
  }
};

class __attribute__((__visibility__("default"))) timed_mutex {
  mutex __m_;
  condition_variable __cv_;
  bool __locked_;

public:
  timed_mutex();
  ~timed_mutex();

private:
  timed_mutex(const timed_mutex &);
  timed_mutex &operator=(const timed_mutex &);

public:
  void lock();
  bool try_lock() noexcept;
  template <class _Rep, class _Period>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  try_lock_for(const chrono::duration<_Rep, _Period> &__d) {
    return try_lock_until(chrono::steady_clock::now() + __d);
  }
  template <class _Clock, class _Duration>
  inline __attribute__((__visibility__("hidden"))) bool
  try_lock_until(const chrono::time_point<_Clock, _Duration> &__t);
  void unlock() noexcept;
};

template <class _Clock, class _Duration>
bool timed_mutex::try_lock_until(
    const chrono::time_point<_Clock, _Duration> &__t) {
  using namespace chrono;
  unique_lock<mutex> __lk(__m_);
  bool no_timeout = _Clock::now() < __t;
  while (no_timeout && __locked_)
    no_timeout = __cv_.wait_until(__lk, __t) == cv_status::no_timeout;
  if (!__locked_) {
    __locked_ = true;
    return true;
  }
  return false;
}

class __attribute__((__visibility__("default"))) recursive_timed_mutex {
  mutex __m_;
  condition_variable __cv_;
  size_t __count_;
  __thread_id __id_;

public:
  recursive_timed_mutex();
  ~recursive_timed_mutex();

private:
  recursive_timed_mutex(const recursive_timed_mutex &);
  recursive_timed_mutex &operator=(const recursive_timed_mutex &);

public:
  void lock();
  bool try_lock() noexcept;
  template <class _Rep, class _Period>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  try_lock_for(const chrono::duration<_Rep, _Period> &__d) {
    return try_lock_until(chrono::steady_clock::now() + __d);
  }
  template <class _Clock, class _Duration>
  inline __attribute__((__visibility__("hidden"))) bool
  try_lock_until(const chrono::time_point<_Clock, _Duration> &__t);
  void unlock() noexcept;
};

template <class _Clock, class _Duration>
bool recursive_timed_mutex::try_lock_until(
    const chrono::time_point<_Clock, _Duration> &__t) {
  using namespace chrono;
  __thread_id __id = this_thread::get_id();
  unique_lock<mutex> lk(__m_);
  if (__id == __id_) {
    if (__count_ == numeric_limits<size_t>::max())
      return false;
    ++__count_;
    return true;
  }
  bool no_timeout = _Clock::now() < __t;
  while (no_timeout && __count_ != 0)
    no_timeout = __cv_.wait_until(lk, __t) == cv_status::no_timeout;
  if (__count_ == 0) {
    __count_ = 1;
    __id_ = __id;
    return true;
  }
  return false;
}

template <class _L0, class _L1> int try_lock(_L0 &__l0, _L1 &__l1) {
  unique_lock<_L0> __u0(__l0, try_to_lock);
  if (__u0.owns_lock()) {
    if (__l1.try_lock()) {
      __u0.release();
      return -1;
    } else
      return 1;
  }
  return 0;
}

template <class _L0, class _L1, class _L2, class... _L3>
int try_lock(_L0 &__l0, _L1 &__l1, _L2 &__l2, _L3 &...__l3) {
  int __r = 0;
  unique_lock<_L0> __u0(__l0, try_to_lock);
  if (__u0.owns_lock()) {
    __r = try_lock(__l1, __l2, __l3...);
    if (__r == -1)
      __u0.release();
    else
      ++__r;
  }
  return __r;
}

template <class _L0, class _L1> void lock(_L0 &__l0, _L1 &__l1) {
  while (true) {
    {
      unique_lock<_L0> __u0(__l0);
      if (__l1.try_lock()) {
        __u0.release();
        break;
      }
    }
    __libcpp_thread_yield();
    {
      unique_lock<_L1> __u1(__l1);
      if (__l0.try_lock()) {
        __u1.release();
        break;
      }
    }
    __libcpp_thread_yield();
  }
}

template <class _L0, class _L1, class _L2, class... _L3>
void __lock_first(int __i, _L0 &__l0, _L1 &__l1, _L2 &__l2, _L3 &...__l3) {
  while (true) {
    switch (__i) {
    case 0: {
      unique_lock<_L0> __u0(__l0);
      __i = try_lock(__l1, __l2, __l3...);
      if (__i == -1) {
        __u0.release();
        return;
      }
    }
      ++__i;
      __libcpp_thread_yield();
      break;
    case 1: {
      unique_lock<_L1> __u1(__l1);
      __i = try_lock(__l2, __l3..., __l0);
      if (__i == -1) {
        __u1.release();
        return;
      }
    }
      if (__i == sizeof...(_L3) + 1)
        __i = 0;
      else
        __i += 2;
      __libcpp_thread_yield();
      break;
    default:
      __lock_first(__i - 2, __l2, __l3..., __l0, __l1);
      return;
    }
  }
}

template <class _L0, class _L1, class _L2, class... _L3>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
lock(_L0 &__l0, _L1 &__l1, _L2 &__l2, _L3 &...__l3) {
  __lock_first(0, __l0, __l1, __l2, __l3...);
}

template <class _L0>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
__unlock(_L0 &__l0) {
  __l0.unlock();
}

template <class _L0, class _L1>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
__unlock(_L0 &__l0, _L1 &__l1) {
  __l0.unlock();
  __l1.unlock();
}

template <class _L0, class _L1, class _L2, class... _L3>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
__unlock(_L0 &__l0, _L1 &__l1, _L2 &__l2, _L3 &...__l3) {
  __l0.unlock();
  __l1.unlock();
  std::__1::__unlock(__l2, __l3...);
}
# 553 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/mutex" 3
struct __attribute__((__type_visibility__("default"))) once_flag;

template <class _Callable, class... _Args>
__attribute__((__visibility__("hidden"))) __attribute__((internal_linkage)) void
call_once(once_flag &, _Callable &&, _Args &&...);
# 573 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/mutex" 3
struct __attribute__((__type_visibility__("default"))) once_flag {
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr once_flag() noexcept
      : __state_(0) {}

  typedef unsigned long _State_type;

private:
  once_flag(const once_flag &);
  once_flag &operator=(const once_flag &);

  _State_type __state_;

  template <class _Callable, class... _Args>
  friend void call_once(once_flag &, _Callable &&, _Args &&...);
# 605 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/mutex" 3
};

template <class _Fp> class __call_once_param {
  _Fp &__f_;

public:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit __call_once_param(_Fp &__f)
      : __f_(__f) {}

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  operator()() {
    typedef
        typename __make_tuple_indices<tuple_size<_Fp>::value, 1>::type _Index;
    __execute(_Index());
  }

private:
  template <size_t... _Indices>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __execute(__tuple_indices<_Indices...>) {
    __invoke(std::__1::get<0>(std::__1::move(__f_)),
             std::__1::get<_Indices>(std::__1::move(__f_))...);
  }
};
# 652 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/mutex" 3
template <class _Fp>
void __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
__call_once_proxy(void *__vp) {
  __call_once_param<_Fp> *__p = static_cast<__call_once_param<_Fp> *>(__vp);
  (*__p)();
}

__attribute__((__visibility__("default"))) void
__call_once(volatile once_flag::_State_type &, void *, void (*)(void *));

template <class _Callable, class... _Args>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
call_once(once_flag &__flag, _Callable &&__func, _Args &&...__args) {
  if (__libcpp_acquire_load(&__flag.__state_) != ~once_flag::_State_type(0)) {
    typedef tuple<_Callable &&, _Args &&...> _Gp;
    _Gp __f(std::__1::forward<_Callable>(__func),
            std::__1::forward<_Args>(__args)...);
    __call_once_param<_Gp> __p(__f);
    __call_once(__flag.__state_, &__p, &__call_once_proxy<_Gp>);
  }
}
# 707 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/mutex" 3
} // namespace __1
} // namespace std
# 102 "/usr/local/include/QtCore/qglobalstatic.h" 2
# 128 "/usr/local/include/QtCore/qglobalstatic.h"
template <typename T, T *(&innerFunction)(), QBasicAtomicInt &guard>
struct QGlobalStatic {
  typedef T Type;

  bool isDestroyed() const {
    return guard.loadRelaxed() <= QtGlobalStatic::Destroyed;
  }
  bool exists() const {
    return guard.loadRelaxed() == QtGlobalStatic::Initialized;
  }
  operator Type *() {
    if (isDestroyed())
      return nullptr;
    return innerFunction();
  }
  Type *operator()() {
    if (isDestroyed())
      return nullptr;
    return innerFunction();
  }
  Type *operator->() {
    ((!isDestroyed())
         ? static_cast<void>(0)
         : qt_assert_x("Q_GLOBAL_STATIC",
                       "The global static was used after being destroyed",
                       "/usr/local/include/QtCore/qglobalstatic.h", 139));
    return innerFunction();
  }
  Type &operator*() {
    ((!isDestroyed())
         ? static_cast<void>(0)
         : qt_assert_x("Q_GLOBAL_STATIC",
                       "The global static was used after being destroyed",
                       "/usr/local/include/QtCore/qglobalstatic.h", 144));
    return *innerFunction();
  }
};
# 1306 "/usr/local/include/QtCore/qglobal.h" 2
# 1 "/usr/local/include/QtCore/qnumeric.h" 1
# 43 "/usr/local/include/QtCore/qnumeric.h"
# 1 "/usr/local/include/QtCore/qglobal.h" 1
# 44 "/usr/local/include/QtCore/qnumeric.h" 2

__attribute__((visibility("default"))) __attribute__((const)) bool
qIsInf(double d);
__attribute__((visibility("default"))) __attribute__((const)) bool
qIsNaN(double d);
__attribute__((visibility("default"))) __attribute__((const)) bool
qIsFinite(double d);
__attribute__((visibility("default"))) __attribute__((const)) int
qFpClassify(double val);
__attribute__((visibility("default"))) __attribute__((const)) bool
qIsInf(float f);
__attribute__((visibility("default"))) __attribute__((const)) bool
qIsNaN(float f);
__attribute__((visibility("default"))) __attribute__((const)) bool
qIsFinite(float f);
__attribute__((visibility("default"))) __attribute__((const)) int
qFpClassify(float val);

__attribute__((visibility("default"))) __attribute__((const)) double qSNaN();

__attribute__((visibility("default"))) __attribute__((const)) double qQNaN();
__attribute__((visibility("default"))) __attribute__((const)) double qInf();

__attribute__((visibility("default"))) quint32 qFloatDistance(float a, float b);
__attribute__((visibility("default"))) quint64 qFloatDistance(double a,
                                                              double b);
# 1307 "/usr/local/include/QtCore/qglobal.h" 2
# 1 "/usr/local/include/QtCore/qversiontagging.h" 1
# 41 "/usr/local/include/QtCore/qversiontagging.h"
# 1 "/usr/local/include/QtCore/qglobal.h" 1
# 42 "/usr/local/include/QtCore/qversiontagging.h" 2
# 1308 "/usr/local/include/QtCore/qglobal.h" 2
# 44 "/usr/local/include/QtCore/qnamespace.h" 2


struct QMetaObject;

const QMetaObject *qt_getQtMetaObject() noexcept;

namespace

    Qt {

enum GlobalColor {
  color0,
  color1,
  black,
  white,
  darkGray,
  gray,
  lightGray,
  red,
  green,
  blue,
  cyan,
  magenta,
  yellow,
  darkRed,
  darkGreen,
  darkBlue,
  darkCyan,
  darkMagenta,
  darkYellow,
  transparent
};

enum KeyboardModifier {
  NoModifier = 0x00000000,
  ShiftModifier = 0x02000000,
  ControlModifier = 0x04000000,
  AltModifier = 0x08000000,
  MetaModifier = 0x10000000,
  KeypadModifier = 0x20000000,
  GroupSwitchModifier = 0x40000000,

  KeyboardModifierMask = 0xfe000000
};
typedef QFlags<KeyboardModifier> KeyboardModifiers;
constexpr inline QFlags<KeyboardModifiers::enum_type>
operator|(KeyboardModifiers::enum_type f1,
          KeyboardModifiers::enum_type f2) noexcept {
  return QFlags<KeyboardModifiers::enum_type>(f1) | f2;
}
constexpr inline QFlags<KeyboardModifiers::enum_type>
operator|(KeyboardModifiers::enum_type f1,
          QFlags<KeyboardModifiers::enum_type> f2) noexcept {
  return f2 | f1;
}
constexpr inline QIncompatibleFlag operator|(KeyboardModifiers::enum_type f1,
                                             int f2) noexcept {
  return QIncompatibleFlag(int(f1) | f2);
}

enum Modifier {
  META = Qt::MetaModifier,
  SHIFT = Qt::ShiftModifier,
  CTRL = Qt::ControlModifier,
  ALT = Qt::AltModifier,
  MODIFIER_MASK = KeyboardModifierMask,
  UNICODE_ACCEL = 0x00000000
};

enum MouseButton {
  NoButton = 0x00000000,
  LeftButton = 0x00000001,
  RightButton = 0x00000002,
  MidButton = 0x00000004,
  MiddleButton = MidButton,
  BackButton = 0x00000008,
  XButton1 = BackButton,
  ExtraButton1 = XButton1,
  ForwardButton = 0x00000010,
  XButton2 = ForwardButton,
  ExtraButton2 = ForwardButton,
  TaskButton = 0x00000020,
  ExtraButton3 = TaskButton,
  ExtraButton4 = 0x00000040,
  ExtraButton5 = 0x00000080,
  ExtraButton6 = 0x00000100,
  ExtraButton7 = 0x00000200,
  ExtraButton8 = 0x00000400,
  ExtraButton9 = 0x00000800,
  ExtraButton10 = 0x00001000,
  ExtraButton11 = 0x00002000,
  ExtraButton12 = 0x00004000,
  ExtraButton13 = 0x00008000,
  ExtraButton14 = 0x00010000,
  ExtraButton15 = 0x00020000,
  ExtraButton16 = 0x00040000,
  ExtraButton17 = 0x00080000,
  ExtraButton18 = 0x00100000,
  ExtraButton19 = 0x00200000,
  ExtraButton20 = 0x00400000,
  ExtraButton21 = 0x00800000,
  ExtraButton22 = 0x01000000,
  ExtraButton23 = 0x02000000,
  ExtraButton24 = 0x04000000,
  AllButtons = 0x07ffffff,
  MaxMouseButton = ExtraButton24,

  MouseButtonMask = 0xffffffff
};
typedef QFlags<MouseButton> MouseButtons;
constexpr inline QFlags<MouseButtons::enum_type>
operator|(MouseButtons::enum_type f1, MouseButtons::enum_type f2) noexcept {
  return QFlags<MouseButtons::enum_type>(f1) | f2;
}
constexpr inline QFlags<MouseButtons::enum_type>
operator|(MouseButtons::enum_type f1,
          QFlags<MouseButtons::enum_type> f2) noexcept {
  return f2 | f1;
}
constexpr inline QIncompatibleFlag operator|(MouseButtons::enum_type f1,
                                             int f2) noexcept {
  return QIncompatibleFlag(int(f1) | f2);
}

enum Orientation { Horizontal = 0x1, Vertical = 0x2 };

typedef QFlags<Orientation> Orientations;
constexpr inline QFlags<Orientations::enum_type>
operator|(Orientations::enum_type f1, Orientations::enum_type f2) noexcept {
  return QFlags<Orientations::enum_type>(f1) | f2;
}
constexpr inline QFlags<Orientations::enum_type>
operator|(Orientations::enum_type f1,
          QFlags<Orientations::enum_type> f2) noexcept {
  return f2 | f1;
}
constexpr inline QIncompatibleFlag operator|(Orientations::enum_type f1,
                                             int f2) noexcept {
  return QIncompatibleFlag(int(f1) | f2);
}

enum FocusPolicy {
  NoFocus = 0,
  TabFocus = 0x1,
  ClickFocus = 0x2,
  StrongFocus = TabFocus | ClickFocus | 0x8,
  WheelFocus = StrongFocus | 0x4
};

enum TabFocusBehavior {
  NoTabFocus = 0x00,
  TabFocusTextControls = 0x01,
  TabFocusListControls = 0x02,
  TabFocusAllControls = 0xff
};

enum SortOrder { AscendingOrder, DescendingOrder };

enum SplitBehaviorFlags {
  KeepEmptyParts = 0,
  SkipEmptyParts = 0x1,
};
typedef QFlags<SplitBehaviorFlags> SplitBehavior;
constexpr inline QFlags<SplitBehavior::enum_type>
operator|(SplitBehavior::enum_type f1, SplitBehavior::enum_type f2) noexcept {
  return QFlags<SplitBehavior::enum_type>(f1) | f2;
}
constexpr inline QFlags<SplitBehavior::enum_type>
operator|(SplitBehavior::enum_type f1,
          QFlags<SplitBehavior::enum_type> f2) noexcept {
  return f2 | f1;
}
constexpr inline QIncompatibleFlag operator|(SplitBehavior::enum_type f1,
                                             int f2) noexcept {
  return QIncompatibleFlag(int(f1) | f2);
}

enum TileRule { StretchTile, RepeatTile, RoundTile };

enum AlignmentFlag {
  AlignLeft = 0x0001,
  AlignLeading = AlignLeft,
  AlignRight = 0x0002,
  AlignTrailing = AlignRight,
  AlignHCenter = 0x0004,
  AlignJustify = 0x0008,
  AlignAbsolute = 0x0010,
  AlignHorizontal_Mask =
      AlignLeft | AlignRight | AlignHCenter | AlignJustify | AlignAbsolute,

  AlignTop = 0x0020,
  AlignBottom = 0x0040,
  AlignVCenter = 0x0080,
  AlignBaseline = 0x0100,

  AlignVertical_Mask = AlignTop | AlignBottom | AlignVCenter | AlignBaseline,

  AlignCenter = AlignVCenter | AlignHCenter
};

typedef QFlags<AlignmentFlag> Alignment;
constexpr inline QFlags<Alignment::enum_type>
operator|(Alignment::enum_type f1, Alignment::enum_type f2) noexcept {
  return QFlags<Alignment::enum_type>(f1) | f2;
}
constexpr inline QFlags<Alignment::enum_type>
operator|(Alignment::enum_type f1, QFlags<Alignment::enum_type> f2) noexcept {
  return f2 | f1;
}
constexpr inline QIncompatibleFlag operator|(Alignment::enum_type f1,
                                             int f2) noexcept {
  return QIncompatibleFlag(int(f1) | f2);
}

enum TextFlag {
  TextSingleLine = 0x0100,
  TextDontClip = 0x0200,
  TextExpandTabs = 0x0400,
  TextShowMnemonic = 0x0800,
  TextWordWrap = 0x1000,
  TextWrapAnywhere = 0x2000,
  TextDontPrint = 0x4000,
  TextIncludeTrailingSpaces = 0x08000000,
  TextHideMnemonic = 0x8000,
  TextJustificationForced = 0x10000,
  TextForceLeftToRight = 0x20000,
  TextForceRightToLeft = 0x40000,

  TextLongestVariant = 0x80000

  ,
  TextBypassShaping = 0x100000

};

enum TextElideMode { ElideLeft, ElideRight, ElideMiddle, ElideNone };

enum WhiteSpaceMode {
  WhiteSpaceNormal,
  WhiteSpacePre,
  WhiteSpaceNoWrap,
  WhiteSpaceModeUndefined = -1
};

enum HitTestAccuracy { ExactHit, FuzzyHit };

enum WindowType {
  Widget = 0x00000000,
  Window = 0x00000001,
  Dialog = 0x00000002 | Window,
  Sheet = 0x00000004 | Window,
  Drawer = Sheet | Dialog,
  Popup = 0x00000008 | Window,
  Tool = Popup | Dialog,
  ToolTip = Popup | Sheet,
  SplashScreen = ToolTip | Dialog,
  Desktop = 0x00000010 | Window,
  SubWindow = 0x00000012,
  ForeignWindow = 0x00000020 | Window,
  CoverWindow = 0x00000040 | Window,

  WindowType_Mask = 0x000000ff,
  MSWindowsFixedSizeDialogHint = 0x00000100,
  MSWindowsOwnDC = 0x00000200,
  BypassWindowManagerHint = 0x00000400,
  X11BypassWindowManagerHint = BypassWindowManagerHint,
  FramelessWindowHint = 0x00000800,
  WindowTitleHint = 0x00001000,
  WindowSystemMenuHint = 0x00002000,
  WindowMinimizeButtonHint = 0x00004000,
  WindowMaximizeButtonHint = 0x00008000,
  WindowMinMaxButtonsHint = WindowMinimizeButtonHint | WindowMaximizeButtonHint,
  WindowContextHelpButtonHint = 0x00010000,
  WindowShadeButtonHint = 0x00020000,
  WindowStaysOnTopHint = 0x00040000,
  WindowTransparentForInput = 0x00080000,
  WindowOverridesSystemGestures = 0x00100000,
  WindowDoesNotAcceptFocus = 0x00200000,
  MaximizeUsingFullscreenGeometryHint = 0x00400000,

  CustomizeWindowHint = 0x02000000,
  WindowStaysOnBottomHint = 0x04000000,
  WindowCloseButtonHint = 0x08000000,
  MacWindowToolBarButtonHint = 0x10000000,
  BypassGraphicsProxyWidget = 0x20000000,
  NoDropShadowWindowHint = 0x40000000,
  WindowFullscreenButtonHint = 0x80000000
};

typedef QFlags<WindowType> WindowFlags;
constexpr inline QFlags<WindowFlags::enum_type>
operator|(WindowFlags::enum_type f1, WindowFlags::enum_type f2) noexcept {
  return QFlags<WindowFlags::enum_type>(f1) | f2;
}
constexpr inline QFlags<WindowFlags::enum_type>
operator|(WindowFlags::enum_type f1,
          QFlags<WindowFlags::enum_type> f2) noexcept {
  return f2 | f1;
}
constexpr inline QIncompatibleFlag operator|(WindowFlags::enum_type f1,
                                             int f2) noexcept {
  return QIncompatibleFlag(int(f1) | f2);
}

enum WindowState {
  WindowNoState = 0x00000000,
  WindowMinimized = 0x00000001,
  WindowMaximized = 0x00000002,
  WindowFullScreen = 0x00000004,
  WindowActive = 0x00000008
};

typedef QFlags<WindowState> WindowStates;
constexpr inline QFlags<WindowStates::enum_type>
operator|(WindowStates::enum_type f1, WindowStates::enum_type f2) noexcept {
  return QFlags<WindowStates::enum_type>(f1) | f2;
}
constexpr inline QFlags<WindowStates::enum_type>
operator|(WindowStates::enum_type f1,
          QFlags<WindowStates::enum_type> f2) noexcept {
  return f2 | f1;
}
constexpr inline QIncompatibleFlag operator|(WindowStates::enum_type f1,
                                             int f2) noexcept {
  return QIncompatibleFlag(int(f1) | f2);
}

enum ApplicationState {
  ApplicationSuspended = 0x00000000,
  ApplicationHidden = 0x00000001,
  ApplicationInactive = 0x00000002,
  ApplicationActive = 0x00000004
};

typedef QFlags<ApplicationState> ApplicationStates;

enum ScreenOrientation {
  PrimaryOrientation = 0x00000000,
  PortraitOrientation = 0x00000001,
  LandscapeOrientation = 0x00000002,
  InvertedPortraitOrientation = 0x00000004,
  InvertedLandscapeOrientation = 0x00000008
};

typedef QFlags<ScreenOrientation> ScreenOrientations;
constexpr inline QFlags<ScreenOrientations::enum_type>
operator|(ScreenOrientations::enum_type f1,
          ScreenOrientations::enum_type f2) noexcept {
  return QFlags<ScreenOrientations::enum_type>(f1) | f2;
}
constexpr inline QFlags<ScreenOrientations::enum_type>
operator|(ScreenOrientations::enum_type f1,
          QFlags<ScreenOrientations::enum_type> f2) noexcept {
  return f2 | f1;
}
constexpr inline QIncompatibleFlag operator|(ScreenOrientations::enum_type f1,
                                             int f2) noexcept {
  return QIncompatibleFlag(int(f1) | f2);
}

enum WidgetAttribute {
  WA_Disabled = 0,
  WA_UnderMouse = 1,
  WA_MouseTracking = 2,
  WA_ContentsPropagated = 3,
  WA_OpaquePaintEvent = 4,

  WA_NoBackground = WA_OpaquePaintEvent,

  WA_StaticContents = 5,
  WA_LaidOut = 7,
  WA_PaintOnScreen = 8,
  WA_NoSystemBackground = 9,
  WA_UpdatesDisabled = 10,
  WA_Mapped = 11,

  WA_MacNoClickThrough = 12,

  WA_InputMethodEnabled = 14,
  WA_WState_Visible = 15,
  WA_WState_Hidden = 16,

  WA_ForceDisabled = 32,
  WA_KeyCompression = 33,
  WA_PendingMoveEvent = 34,
  WA_PendingResizeEvent = 35,
  WA_SetPalette = 36,
  WA_SetFont = 37,
  WA_SetCursor = 38,
  WA_NoChildEventsFromChildren = 39,
  WA_WindowModified = 41,
  WA_Resized = 42,
  WA_Moved = 43,
  WA_PendingUpdate = 44,
  WA_InvalidSize = 45,

  WA_MacBrushedMetal = 46,
  WA_MacMetalStyle = 46,

  WA_CustomWhatsThis = 47,
  WA_LayoutOnEntireRect = 48,
  WA_OutsideWSRange = 49,
  WA_GrabbedShortcut = 50,
  WA_TransparentForMouseEvents = 51,
  WA_PaintUnclipped = 52,
  WA_SetWindowIcon = 53,
  WA_NoMouseReplay = 54,
  WA_DeleteOnClose = 55,
  WA_RightToLeft = 56,
  WA_SetLayoutDirection = 57,
  WA_NoChildEventsForParent = 58,
  WA_ForceUpdatesDisabled = 59,

  WA_WState_Created = 60,
  WA_WState_CompressKeys = 61,
  WA_WState_InPaintEvent = 62,
  WA_WState_Reparented = 63,
  WA_WState_ConfigPending = 64,
  WA_WState_Polished = 66,
  WA_WState_DND = 67,
  WA_WState_OwnSizePolicy = 68,
  WA_WState_ExplicitShowHide = 69,

  WA_ShowModal = 70,
  WA_MouseNoMask = 71,
  WA_GroupLeader = 72,
  WA_NoMousePropagation = 73,
  WA_Hover = 74,
  WA_InputMethodTransparent = 75,
  WA_QuitOnClose = 76,

  WA_KeyboardFocusChange = 77,

  WA_AcceptDrops = 78,
  WA_DropSiteRegistered = 79,
  WA_ForceAcceptDrops = WA_DropSiteRegistered,

  WA_WindowPropagation = 80,

  WA_NoX11EventCompression = 81,
  WA_TintedBackground = 82,
  WA_X11OpenGLOverlay = 83,
  WA_AlwaysShowToolTips = 84,
  WA_MacOpaqueSizeGrip = 85,
  WA_SetStyle = 86,

  WA_SetLocale = 87,
  WA_MacShowFocusRect = 88,

  WA_MacNormalSize = 89,
  WA_MacSmallSize = 90,
  WA_MacMiniSize = 91,

  WA_LayoutUsesWidgetRect = 92,
  WA_StyledBackground = 93,

  WA_MSWindowsUseDirect3D = 94,

  WA_CanHostQMdiSubWindowTitleBar = 95,

  WA_MacAlwaysShowToolWindow = 96,

  WA_StyleSheet = 97,

  WA_ShowWithoutActivating = 98,

  WA_X11BypassTransientForHint = 99,

  WA_NativeWindow = 100,
  WA_DontCreateNativeAncestors = 101,

  WA_MacVariableSize = 102,

  WA_DontShowOnScreen = 103,

  WA_X11NetWmWindowTypeDesktop = 104,
  WA_X11NetWmWindowTypeDock = 105,
  WA_X11NetWmWindowTypeToolBar = 106,
  WA_X11NetWmWindowTypeMenu = 107,
  WA_X11NetWmWindowTypeUtility = 108,
  WA_X11NetWmWindowTypeSplash = 109,
  WA_X11NetWmWindowTypeDialog = 110,
  WA_X11NetWmWindowTypeDropDownMenu = 111,
  WA_X11NetWmWindowTypePopupMenu = 112,
  WA_X11NetWmWindowTypeToolTip = 113,
  WA_X11NetWmWindowTypeNotification = 114,
  WA_X11NetWmWindowTypeCombo = 115,
  WA_X11NetWmWindowTypeDND = 116,

  WA_MacFrameworkScaled = 117,

  WA_SetWindowModality = 118,
  WA_WState_WindowOpacitySet = 119,
  WA_TranslucentBackground = 120,

  WA_AcceptTouchEvents = 121,
  WA_WState_AcceptedTouchBeginEvent = 122,
  WA_TouchPadAcceptSingleTouchEvents = 123,

  WA_X11DoNotAcceptFocus = 126,
  WA_MacNoShadow = 127,

  WA_AlwaysStackOnTop = 128,

  WA_TabletTracking = 129,

  WA_ContentsMarginsRespectsSafeArea = 130,

  WA_StyleSheetTarget = 131,

  WA_AttributeCount
};

enum ApplicationAttribute {
  AA_ImmediateWidgetCreation = 0,

  AA_MSWindowsUseDirect3DByDefault = 1,

  AA_DontShowIconsInMenus = 2,
  AA_NativeWindows = 3,
  AA_DontCreateNativeWidgetSiblings = 4,
  AA_PluginApplication = 5,

  AA_MacPluginApplication = AA_PluginApplication,

  AA_DontUseNativeMenuBar = 6,
  AA_MacDontSwapCtrlAndMeta = 7,
  AA_Use96Dpi = 8,
  AA_DisableNativeVirtualKeyboard = 9,

  AA_X11InitThreads = 10,

  AA_SynthesizeTouchForUnhandledMouseEvents = 11,
  AA_SynthesizeMouseForUnhandledTouchEvents = 12,
  AA_UseHighDpiPixmaps = 13,
  AA_ForceRasterWidgets = 14,
  AA_UseDesktopOpenGL = 15,
  AA_UseOpenGLES = 16,
  AA_UseSoftwareOpenGL = 17,
  AA_ShareOpenGLContexts = 18,
  AA_SetPalette = 19,
  AA_EnableHighDpiScaling = 20,
  AA_DisableHighDpiScaling = 21,
  AA_UseStyleSheetPropagationInWidgetStyles = 22,
  AA_DontUseNativeDialogs = 23,
  AA_SynthesizeMouseForUnhandledTabletEvents = 24,
  AA_CompressHighFrequencyEvents = 25,
  AA_DontCheckOpenGLContextThreadAffinity = 26,
  AA_DisableShaderDiskCache = 27,
  AA_DontShowShortcutsInContextMenus = 28,
  AA_CompressTabletEvents = 29,
  AA_DisableWindowContextHelpButton = 30,
  AA_DisableSessionManager = 31,

  AA_AttributeCount
};

enum ImageConversionFlag {
  ColorMode_Mask = 0x00000003,
  AutoColor = 0x00000000,
  ColorOnly = 0x00000003,
  MonoOnly = 0x00000002,

  AlphaDither_Mask = 0x0000000c,
  ThresholdAlphaDither = 0x00000000,
  OrderedAlphaDither = 0x00000004,
  DiffuseAlphaDither = 0x00000008,
  NoAlpha = 0x0000000c,

  Dither_Mask = 0x00000030,
  DiffuseDither = 0x00000000,
  OrderedDither = 0x00000010,
  ThresholdDither = 0x00000020,

  DitherMode_Mask = 0x000000c0,
  AutoDither = 0x00000000,
  PreferDither = 0x00000040,
  AvoidDither = 0x00000080,

  NoOpaqueDetection = 0x00000100,
  NoFormatConversion = 0x00000200
};
typedef QFlags<ImageConversionFlag> ImageConversionFlags;
constexpr inline QFlags<ImageConversionFlags::enum_type>
operator|(ImageConversionFlags::enum_type f1,
          ImageConversionFlags::enum_type f2) noexcept {
  return QFlags<ImageConversionFlags::enum_type>(f1) | f2;
}
constexpr inline QFlags<ImageConversionFlags::enum_type>
operator|(ImageConversionFlags::enum_type f1,
          QFlags<ImageConversionFlags::enum_type> f2) noexcept {
  return f2 | f1;
}
constexpr inline QIncompatibleFlag operator|(ImageConversionFlags::enum_type f1,
                                             int f2) noexcept {
  return QIncompatibleFlag(int(f1) | f2);
}

enum BGMode { TransparentMode, OpaqueMode };

enum Key {
  Key_Escape = 0x01000000,
  Key_Tab = 0x01000001,
  Key_Backtab = 0x01000002,
  Key_Backspace = 0x01000003,
  Key_Return = 0x01000004,
  Key_Enter = 0x01000005,
  Key_Insert = 0x01000006,
  Key_Delete = 0x01000007,
  Key_Pause = 0x01000008,
  Key_Print = 0x01000009,
  Key_SysReq = 0x0100000a,
  Key_Clear = 0x0100000b,
  Key_Home = 0x01000010,
  Key_End = 0x01000011,
  Key_Left = 0x01000012,
  Key_Up = 0x01000013,
  Key_Right = 0x01000014,
  Key_Down = 0x01000015,
  Key_PageUp = 0x01000016,
  Key_PageDown = 0x01000017,
  Key_Shift = 0x01000020,
  Key_Control = 0x01000021,
  Key_Meta = 0x01000022,
  Key_Alt = 0x01000023,
  Key_CapsLock = 0x01000024,
  Key_NumLock = 0x01000025,
  Key_ScrollLock = 0x01000026,
  Key_F1 = 0x01000030,
  Key_F2 = 0x01000031,
  Key_F3 = 0x01000032,
  Key_F4 = 0x01000033,
  Key_F5 = 0x01000034,
  Key_F6 = 0x01000035,
  Key_F7 = 0x01000036,
  Key_F8 = 0x01000037,
  Key_F9 = 0x01000038,
  Key_F10 = 0x01000039,
  Key_F11 = 0x0100003a,
  Key_F12 = 0x0100003b,
  Key_F13 = 0x0100003c,
  Key_F14 = 0x0100003d,
  Key_F15 = 0x0100003e,
  Key_F16 = 0x0100003f,
  Key_F17 = 0x01000040,
  Key_F18 = 0x01000041,
  Key_F19 = 0x01000042,
  Key_F20 = 0x01000043,
  Key_F21 = 0x01000044,
  Key_F22 = 0x01000045,
  Key_F23 = 0x01000046,
  Key_F24 = 0x01000047,
  Key_F25 = 0x01000048,
  Key_F26 = 0x01000049,
  Key_F27 = 0x0100004a,
  Key_F28 = 0x0100004b,
  Key_F29 = 0x0100004c,
  Key_F30 = 0x0100004d,
  Key_F31 = 0x0100004e,
  Key_F32 = 0x0100004f,
  Key_F33 = 0x01000050,
  Key_F34 = 0x01000051,
  Key_F35 = 0x01000052,
  Key_Super_L = 0x01000053,
  Key_Super_R = 0x01000054,
  Key_Menu = 0x01000055,
  Key_Hyper_L = 0x01000056,
  Key_Hyper_R = 0x01000057,
  Key_Help = 0x01000058,
  Key_Direction_L = 0x01000059,
  Key_Direction_R = 0x01000060,
  Key_Space = 0x20,
  Key_Any = Key_Space,
  Key_Exclam = 0x21,
  Key_QuoteDbl = 0x22,
  Key_NumberSign = 0x23,
  Key_Dollar = 0x24,
  Key_Percent = 0x25,
  Key_Ampersand = 0x26,
  Key_Apostrophe = 0x27,
  Key_ParenLeft = 0x28,
  Key_ParenRight = 0x29,
  Key_Asterisk = 0x2a,
  Key_Plus = 0x2b,
  Key_Comma = 0x2c,
  Key_Minus = 0x2d,
  Key_Period = 0x2e,
  Key_Slash = 0x2f,
  Key_0 = 0x30,
  Key_1 = 0x31,
  Key_2 = 0x32,
  Key_3 = 0x33,
  Key_4 = 0x34,
  Key_5 = 0x35,
  Key_6 = 0x36,
  Key_7 = 0x37,
  Key_8 = 0x38,
  Key_9 = 0x39,
  Key_Colon = 0x3a,
  Key_Semicolon = 0x3b,
  Key_Less = 0x3c,
  Key_Equal = 0x3d,
  Key_Greater = 0x3e,
  Key_Question = 0x3f,
  Key_At = 0x40,
  Key_A = 0x41,
  Key_B = 0x42,
  Key_C = 0x43,
  Key_D = 0x44,
  Key_E = 0x45,
  Key_F = 0x46,
  Key_G = 0x47,
  Key_H = 0x48,
  Key_I = 0x49,
  Key_J = 0x4a,
  Key_K = 0x4b,
  Key_L = 0x4c,
  Key_M = 0x4d,
  Key_N = 0x4e,
  Key_O = 0x4f,
  Key_P = 0x50,
  Key_Q = 0x51,
  Key_R = 0x52,
  Key_S = 0x53,
  Key_T = 0x54,
  Key_U = 0x55,
  Key_V = 0x56,
  Key_W = 0x57,
  Key_X = 0x58,
  Key_Y = 0x59,
  Key_Z = 0x5a,
  Key_BracketLeft = 0x5b,
  Key_Backslash = 0x5c,
  Key_BracketRight = 0x5d,
  Key_AsciiCircum = 0x5e,
  Key_Underscore = 0x5f,
  Key_QuoteLeft = 0x60,
  Key_BraceLeft = 0x7b,
  Key_Bar = 0x7c,
  Key_BraceRight = 0x7d,
  Key_AsciiTilde = 0x7e,

  Key_nobreakspace = 0x0a0,
  Key_exclamdown = 0x0a1,
  Key_cent = 0x0a2,
  Key_sterling = 0x0a3,
  Key_currency = 0x0a4,
  Key_yen = 0x0a5,
  Key_brokenbar = 0x0a6,
  Key_section = 0x0a7,
  Key_diaeresis = 0x0a8,
  Key_copyright = 0x0a9,
  Key_ordfeminine = 0x0aa,
  Key_guillemotleft = 0x0ab,
  Key_notsign = 0x0ac,
  Key_hyphen = 0x0ad,
  Key_registered = 0x0ae,
  Key_macron = 0x0af,
  Key_degree = 0x0b0,
  Key_plusminus = 0x0b1,
  Key_twosuperior = 0x0b2,
  Key_threesuperior = 0x0b3,
  Key_acute = 0x0b4,
  Key_mu = 0x0b5,
  Key_paragraph = 0x0b6,
  Key_periodcentered = 0x0b7,
  Key_cedilla = 0x0b8,
  Key_onesuperior = 0x0b9,
  Key_masculine = 0x0ba,
  Key_guillemotright = 0x0bb,
  Key_onequarter = 0x0bc,
  Key_onehalf = 0x0bd,
  Key_threequarters = 0x0be,
  Key_questiondown = 0x0bf,
  Key_Agrave = 0x0c0,
  Key_Aacute = 0x0c1,
  Key_Acircumflex = 0x0c2,
  Key_Atilde = 0x0c3,
  Key_Adiaeresis = 0x0c4,
  Key_Aring = 0x0c5,
  Key_AE = 0x0c6,
  Key_Ccedilla = 0x0c7,
  Key_Egrave = 0x0c8,
  Key_Eacute = 0x0c9,
  Key_Ecircumflex = 0x0ca,
  Key_Ediaeresis = 0x0cb,
  Key_Igrave = 0x0cc,
  Key_Iacute = 0x0cd,
  Key_Icircumflex = 0x0ce,
  Key_Idiaeresis = 0x0cf,
  Key_ETH = 0x0d0,
  Key_Ntilde = 0x0d1,
  Key_Ograve = 0x0d2,
  Key_Oacute = 0x0d3,
  Key_Ocircumflex = 0x0d4,
  Key_Otilde = 0x0d5,
  Key_Odiaeresis = 0x0d6,
  Key_multiply = 0x0d7,
  Key_Ooblique = 0x0d8,
  Key_Ugrave = 0x0d9,
  Key_Uacute = 0x0da,
  Key_Ucircumflex = 0x0db,
  Key_Udiaeresis = 0x0dc,
  Key_Yacute = 0x0dd,
  Key_THORN = 0x0de,
  Key_ssharp = 0x0df,
  Key_division = 0x0f7,
  Key_ydiaeresis = 0x0ff,

  Key_AltGr = 0x01001103,
  Key_Multi_key = 0x01001120,
  Key_Codeinput = 0x01001137,
  Key_SingleCandidate = 0x0100113c,
  Key_MultipleCandidate = 0x0100113d,
  Key_PreviousCandidate = 0x0100113e,

  Key_Mode_switch = 0x0100117e,

  Key_Kanji = 0x01001121,
  Key_Muhenkan = 0x01001122,

  Key_Henkan = 0x01001123,
  Key_Romaji = 0x01001124,
  Key_Hiragana = 0x01001125,
  Key_Katakana = 0x01001126,
  Key_Hiragana_Katakana = 0x01001127,
  Key_Zenkaku = 0x01001128,
  Key_Hankaku = 0x01001129,
  Key_Zenkaku_Hankaku = 0x0100112a,
  Key_Touroku = 0x0100112b,
  Key_Massyo = 0x0100112c,
  Key_Kana_Lock = 0x0100112d,
  Key_Kana_Shift = 0x0100112e,
  Key_Eisu_Shift = 0x0100112f,
  Key_Eisu_toggle = 0x01001130,
# 847 "/usr/local/include/QtCore/qnamespace.h"
  Key_Hangul = 0x01001131,
  Key_Hangul_Start = 0x01001132,
  Key_Hangul_End = 0x01001133,
  Key_Hangul_Hanja = 0x01001134,
  Key_Hangul_Jamo = 0x01001135,
  Key_Hangul_Romaja = 0x01001136,

  Key_Hangul_Jeonja = 0x01001138,
  Key_Hangul_Banja = 0x01001139,
  Key_Hangul_PreHanja = 0x0100113a,
  Key_Hangul_PostHanja = 0x0100113b,

  Key_Hangul_Special = 0x0100113f,

  Key_Dead_Grave = 0x01001250,
  Key_Dead_Acute = 0x01001251,
  Key_Dead_Circumflex = 0x01001252,
  Key_Dead_Tilde = 0x01001253,
  Key_Dead_Macron = 0x01001254,
  Key_Dead_Breve = 0x01001255,
  Key_Dead_Abovedot = 0x01001256,
  Key_Dead_Diaeresis = 0x01001257,
  Key_Dead_Abovering = 0x01001258,
  Key_Dead_Doubleacute = 0x01001259,
  Key_Dead_Caron = 0x0100125a,
  Key_Dead_Cedilla = 0x0100125b,
  Key_Dead_Ogonek = 0x0100125c,
  Key_Dead_Iota = 0x0100125d,
  Key_Dead_Voiced_Sound = 0x0100125e,
  Key_Dead_Semivoiced_Sound = 0x0100125f,
  Key_Dead_Belowdot = 0x01001260,
  Key_Dead_Hook = 0x01001261,
  Key_Dead_Horn = 0x01001262,
  Key_Dead_Stroke = 0x01001263,
  Key_Dead_Abovecomma = 0x01001264,
  Key_Dead_Abovereversedcomma = 0x01001265,
  Key_Dead_Doublegrave = 0x01001266,
  Key_Dead_Belowring = 0x01001267,
  Key_Dead_Belowmacron = 0x01001268,
  Key_Dead_Belowcircumflex = 0x01001269,
  Key_Dead_Belowtilde = 0x0100126a,
  Key_Dead_Belowbreve = 0x0100126b,
  Key_Dead_Belowdiaeresis = 0x0100126c,
  Key_Dead_Invertedbreve = 0x0100126d,
  Key_Dead_Belowcomma = 0x0100126e,
  Key_Dead_Currency = 0x0100126f,
  Key_Dead_a = 0x01001280,
  Key_Dead_A = 0x01001281,
  Key_Dead_e = 0x01001282,
  Key_Dead_E = 0x01001283,
  Key_Dead_i = 0x01001284,
  Key_Dead_I = 0x01001285,
  Key_Dead_o = 0x01001286,
  Key_Dead_O = 0x01001287,
  Key_Dead_u = 0x01001288,
  Key_Dead_U = 0x01001289,
  Key_Dead_Small_Schwa = 0x0100128a,
  Key_Dead_Capital_Schwa = 0x0100128b,
  Key_Dead_Greek = 0x0100128c,
  Key_Dead_Lowline = 0x01001290,
  Key_Dead_Aboveverticalline = 0x01001291,
  Key_Dead_Belowverticalline = 0x01001292,
  Key_Dead_Longsolidusoverlay = 0x01001293,

  Key_Back = 0x01000061,
  Key_Forward = 0x01000062,
  Key_Stop = 0x01000063,
  Key_Refresh = 0x01000064,
  Key_VolumeDown = 0x01000070,
  Key_VolumeMute = 0x01000071,
  Key_VolumeUp = 0x01000072,
  Key_BassBoost = 0x01000073,
  Key_BassUp = 0x01000074,
  Key_BassDown = 0x01000075,
  Key_TrebleUp = 0x01000076,
  Key_TrebleDown = 0x01000077,
  Key_MediaPlay = 0x01000080,
  Key_MediaStop = 0x01000081,
  Key_MediaPrevious = 0x01000082,
  Key_MediaNext = 0x01000083,
  Key_MediaRecord = 0x01000084,
  Key_MediaPause = 0x1000085,
  Key_MediaTogglePlayPause = 0x1000086,
  Key_HomePage = 0x01000090,
  Key_Favorites = 0x01000091,
  Key_Search = 0x01000092,
  Key_Standby = 0x01000093,
  Key_OpenUrl = 0x01000094,
  Key_LaunchMail = 0x010000a0,
  Key_LaunchMedia = 0x010000a1,
  Key_Launch0 = 0x010000a2,
  Key_Launch1 = 0x010000a3,
  Key_Launch2 = 0x010000a4,
  Key_Launch3 = 0x010000a5,
  Key_Launch4 = 0x010000a6,
  Key_Launch5 = 0x010000a7,
  Key_Launch6 = 0x010000a8,
  Key_Launch7 = 0x010000a9,
  Key_Launch8 = 0x010000aa,
  Key_Launch9 = 0x010000ab,
  Key_LaunchA = 0x010000ac,
  Key_LaunchB = 0x010000ad,
  Key_LaunchC = 0x010000ae,
  Key_LaunchD = 0x010000af,
  Key_LaunchE = 0x010000b0,
  Key_LaunchF = 0x010000b1,
  Key_MonBrightnessUp = 0x010000b2,
  Key_MonBrightnessDown = 0x010000b3,
  Key_KeyboardLightOnOff = 0x010000b4,
  Key_KeyboardBrightnessUp = 0x010000b5,
  Key_KeyboardBrightnessDown = 0x010000b6,
  Key_PowerOff = 0x010000b7,
  Key_WakeUp = 0x010000b8,
  Key_Eject = 0x010000b9,
  Key_ScreenSaver = 0x010000ba,
  Key_WWW = 0x010000bb,
  Key_Memo = 0x010000bc,
  Key_LightBulb = 0x010000bd,
  Key_Shop = 0x010000be,
  Key_History = 0x010000bf,
  Key_AddFavorite = 0x010000c0,
  Key_HotLinks = 0x010000c1,
  Key_BrightnessAdjust = 0x010000c2,
  Key_Finance = 0x010000c3,
  Key_Community = 0x010000c4,
  Key_AudioRewind = 0x010000c5,
  Key_BackForward = 0x010000c6,
  Key_ApplicationLeft = 0x010000c7,
  Key_ApplicationRight = 0x010000c8,
  Key_Book = 0x010000c9,
  Key_CD = 0x010000ca,
  Key_Calculator = 0x010000cb,
  Key_ToDoList = 0x010000cc,
  Key_ClearGrab = 0x010000cd,
  Key_Close = 0x010000ce,
  Key_Copy = 0x010000cf,
  Key_Cut = 0x010000d0,
  Key_Display = 0x010000d1,
  Key_DOS = 0x010000d2,
  Key_Documents = 0x010000d3,
  Key_Excel = 0x010000d4,
  Key_Explorer = 0x010000d5,
  Key_Game = 0x010000d6,
  Key_Go = 0x010000d7,
  Key_iTouch = 0x010000d8,
  Key_LogOff = 0x010000d9,
  Key_Market = 0x010000da,
  Key_Meeting = 0x010000db,
  Key_MenuKB = 0x010000dc,
  Key_MenuPB = 0x010000dd,
  Key_MySites = 0x010000de,
  Key_News = 0x010000df,
  Key_OfficeHome = 0x010000e0,
  Key_Option = 0x010000e1,
  Key_Paste = 0x010000e2,
  Key_Phone = 0x010000e3,
  Key_Calendar = 0x010000e4,
  Key_Reply = 0x010000e5,
  Key_Reload = 0x010000e6,
  Key_RotateWindows = 0x010000e7,
  Key_RotationPB = 0x010000e8,
  Key_RotationKB = 0x010000e9,
  Key_Save = 0x010000ea,
  Key_Send = 0x010000eb,
  Key_Spell = 0x010000ec,
  Key_SplitScreen = 0x010000ed,
  Key_Support = 0x010000ee,
  Key_TaskPane = 0x010000ef,
  Key_Terminal = 0x010000f0,
  Key_Tools = 0x010000f1,
  Key_Travel = 0x010000f2,
  Key_Video = 0x010000f3,
  Key_Word = 0x010000f4,
  Key_Xfer = 0x010000f5,
  Key_ZoomIn = 0x010000f6,
  Key_ZoomOut = 0x010000f7,
  Key_Away = 0x010000f8,
  Key_Messenger = 0x010000f9,
  Key_WebCam = 0x010000fa,
  Key_MailForward = 0x010000fb,
  Key_Pictures = 0x010000fc,
  Key_Music = 0x010000fd,
  Key_Battery = 0x010000fe,
  Key_Bluetooth = 0x010000ff,
  Key_WLAN = 0x01000100,
  Key_UWB = 0x01000101,
  Key_AudioForward = 0x01000102,
  Key_AudioRepeat = 0x01000103,
  Key_AudioRandomPlay = 0x01000104,
  Key_Subtitle = 0x01000105,
  Key_AudioCycleTrack = 0x01000106,
  Key_Time = 0x01000107,
  Key_Hibernate = 0x01000108,
  Key_View = 0x01000109,
  Key_TopMenu = 0x0100010a,
  Key_PowerDown = 0x0100010b,
  Key_Suspend = 0x0100010c,
  Key_ContrastAdjust = 0x0100010d,

  Key_LaunchG = 0x0100010e,
  Key_LaunchH = 0x0100010f,

  Key_TouchpadToggle = 0x01000110,
  Key_TouchpadOn = 0x01000111,
  Key_TouchpadOff = 0x01000112,

  Key_MicMute = 0x01000113,

  Key_Red = 0x01000114,
  Key_Green = 0x01000115,
  Key_Yellow = 0x01000116,
  Key_Blue = 0x01000117,

  Key_ChannelUp = 0x01000118,
  Key_ChannelDown = 0x01000119,

  Key_Guide = 0x0100011a,
  Key_Info = 0x0100011b,
  Key_Settings = 0x0100011c,

  Key_MicVolumeUp = 0x0100011d,
  Key_MicVolumeDown = 0x0100011e,

  Key_New = 0x01000120,
  Key_Open = 0x01000121,
  Key_Find = 0x01000122,
  Key_Undo = 0x01000123,
  Key_Redo = 0x01000124,

  Key_MediaLast = 0x0100ffff,

  Key_Select = 0x01010000,
  Key_Yes = 0x01010001,
  Key_No = 0x01010002,

  Key_Cancel = 0x01020001,
  Key_Printer = 0x01020002,
  Key_Execute = 0x01020003,
  Key_Sleep = 0x01020004,
  Key_Play = 0x01020005,
  Key_Zoom = 0x01020006,

  Key_Exit = 0x0102000a,

  Key_Context1 = 0x01100000,
  Key_Context2 = 0x01100001,
  Key_Context3 = 0x01100002,
  Key_Context4 = 0x01100003,
  Key_Call = 0x01100004,
  Key_Hangup = 0x01100005,
  Key_Flip = 0x01100006,
  Key_ToggleCallHangup = 0x01100007,
  Key_VoiceDial = 0x01100008,
  Key_LastNumberRedial = 0x01100009,

  Key_Camera = 0x01100020,
  Key_CameraFocus = 0x01100021,

  Key_unknown = 0x01ffffff
};

enum ArrowType { NoArrow, UpArrow, DownArrow, LeftArrow, RightArrow };

enum PenStyle {
  NoPen,
  SolidLine,
  DashLine,
  DotLine,
  DashDotLine,
  DashDotDotLine,
  CustomDashLine

  ,
  MPenStyle = 0x0f

};

enum PenCapStyle {
  FlatCap = 0x00,
  SquareCap = 0x10,
  RoundCap = 0x20,
  MPenCapStyle = 0x30
};

enum PenJoinStyle {
  MiterJoin = 0x00,
  BevelJoin = 0x40,
  RoundJoin = 0x80,
  SvgMiterJoin = 0x100,
  MPenJoinStyle = 0x1c0
};

enum BrushStyle {
  NoBrush,
  SolidPattern,
  Dense1Pattern,
  Dense2Pattern,
  Dense3Pattern,
  Dense4Pattern,
  Dense5Pattern,
  Dense6Pattern,
  Dense7Pattern,
  HorPattern,
  VerPattern,
  CrossPattern,
  BDiagPattern,
  FDiagPattern,
  DiagCrossPattern,
  LinearGradientPattern,
  RadialGradientPattern,
  ConicalGradientPattern,
  TexturePattern = 24
};

enum SizeMode { AbsoluteSize, RelativeSize };

enum UIEffect {
  UI_General,
  UI_AnimateMenu,
  UI_FadeMenu,
  UI_AnimateCombo,
  UI_AnimateTooltip,
  UI_FadeTooltip,
  UI_AnimateToolBox
};

enum CursorShape {
  ArrowCursor,
  UpArrowCursor,
  CrossCursor,
  WaitCursor,
  IBeamCursor,
  SizeVerCursor,
  SizeHorCursor,
  SizeBDiagCursor,
  SizeFDiagCursor,
  SizeAllCursor,
  BlankCursor,
  SplitVCursor,
  SplitHCursor,
  PointingHandCursor,
  ForbiddenCursor,
  WhatsThisCursor,
  BusyCursor,
  OpenHandCursor,
  ClosedHandCursor,
  DragCopyCursor,
  DragMoveCursor,
  DragLinkCursor,
  LastCursor = DragLinkCursor,
  BitmapCursor = 24,
  CustomCursor = 25
};

enum TextFormat { PlainText, RichText, AutoText, MarkdownText };

enum AspectRatioMode {
  IgnoreAspectRatio,
  KeepAspectRatio,
  KeepAspectRatioByExpanding
};

enum DockWidgetArea {
  LeftDockWidgetArea = 0x1,
  RightDockWidgetArea = 0x2,
  TopDockWidgetArea = 0x4,
  BottomDockWidgetArea = 0x8,

  DockWidgetArea_Mask = 0xf,
  AllDockWidgetAreas = DockWidgetArea_Mask,
  NoDockWidgetArea = 0
};
enum DockWidgetAreaSizes { NDockWidgetAreas = 4 };

typedef QFlags<DockWidgetArea> DockWidgetAreas;
constexpr inline QFlags<DockWidgetAreas::enum_type>
operator|(DockWidgetAreas::enum_type f1,
          DockWidgetAreas::enum_type f2) noexcept {
  return QFlags<DockWidgetAreas::enum_type>(f1) | f2;
}
constexpr inline QFlags<DockWidgetAreas::enum_type>
operator|(DockWidgetAreas::enum_type f1,
          QFlags<DockWidgetAreas::enum_type> f2) noexcept {
  return f2 | f1;
}
constexpr inline QIncompatibleFlag operator|(DockWidgetAreas::enum_type f1,
                                             int f2) noexcept {
  return QIncompatibleFlag(int(f1) | f2);
}

enum ToolBarArea {
  LeftToolBarArea = 0x1,
  RightToolBarArea = 0x2,
  TopToolBarArea = 0x4,
  BottomToolBarArea = 0x8,

  ToolBarArea_Mask = 0xf,
  AllToolBarAreas = ToolBarArea_Mask,
  NoToolBarArea = 0
};

enum ToolBarAreaSizes { NToolBarAreas = 4 };

typedef QFlags<ToolBarArea> ToolBarAreas;
constexpr inline QFlags<ToolBarAreas::enum_type>
operator|(ToolBarAreas::enum_type f1, ToolBarAreas::enum_type f2) noexcept {
  return QFlags<ToolBarAreas::enum_type>(f1) | f2;
}
constexpr inline QFlags<ToolBarAreas::enum_type>
operator|(ToolBarAreas::enum_type f1,
          QFlags<ToolBarAreas::enum_type> f2) noexcept {
  return f2 | f1;
}
constexpr inline QIncompatibleFlag operator|(ToolBarAreas::enum_type f1,
                                             int f2) noexcept {
  return QIncompatibleFlag(int(f1) | f2);
}

enum DateFormat {
  TextDate,
  ISODate,

  SystemLocaleDate,
  LocalDate = 2,
  LocaleDate,
  SystemLocaleShortDate,
  SystemLocaleLongDate,
  DefaultLocaleShortDate,
  DefaultLocaleLongDate,

  RFC2822Date = 8,
  ISODateWithMs
};

enum TimeSpec { LocalTime, UTC, OffsetFromUTC, TimeZone };

enum DayOfWeek {
  Monday = 1,
  Tuesday = 2,
  Wednesday = 3,
  Thursday = 4,
  Friday = 5,
  Saturday = 6,
  Sunday = 7
};

enum ScrollBarPolicy {
  ScrollBarAsNeeded,
  ScrollBarAlwaysOff,
  ScrollBarAlwaysOn
};

enum CaseSensitivity { CaseInsensitive, CaseSensitive };

enum Corner {
  TopLeftCorner = 0x00000,
  TopRightCorner = 0x00001,
  BottomLeftCorner = 0x00002,
  BottomRightCorner = 0x00003
};

enum Edge {
  TopEdge = 0x00001,
  LeftEdge = 0x00002,
  RightEdge = 0x00004,
  BottomEdge = 0x00008
};

typedef QFlags<Edge> Edges;
constexpr inline QFlags<Edges::enum_type>
operator|(Edges::enum_type f1, Edges::enum_type f2) noexcept {
  return QFlags<Edges::enum_type>(f1) | f2;
}
constexpr inline QFlags<Edges::enum_type>
operator|(Edges::enum_type f1, QFlags<Edges::enum_type> f2) noexcept {
  return f2 | f1;
}
constexpr inline QIncompatibleFlag operator|(Edges::enum_type f1,
                                             int f2) noexcept {
  return QIncompatibleFlag(int(f1) | f2);
}

enum ConnectionType {
  AutoConnection,
  DirectConnection,
  QueuedConnection,
  BlockingQueuedConnection,
  UniqueConnection = 0x80
};

enum ShortcutContext {
  WidgetShortcut,
  WindowShortcut,
  ApplicationShortcut,
  WidgetWithChildrenShortcut
};

enum FillRule { OddEvenFill, WindingFill };

enum MaskMode { MaskInColor, MaskOutColor };

enum ClipOperation { NoClip, ReplaceClip, IntersectClip };

enum ItemSelectionMode {
  ContainsItemShape = 0x0,
  IntersectsItemShape = 0x1,
  ContainsItemBoundingRect = 0x2,
  IntersectsItemBoundingRect = 0x3
};

enum ItemSelectionOperation { ReplaceSelection, AddToSelection };

enum TransformationMode { FastTransformation, SmoothTransformation };

enum Axis { XAxis, YAxis, ZAxis };

enum FocusReason {
  MouseFocusReason,
  TabFocusReason,
  BacktabFocusReason,
  ActiveWindowFocusReason,
  PopupFocusReason,
  ShortcutFocusReason,
  MenuBarFocusReason,
  OtherFocusReason,
  NoFocusReason
};

enum ContextMenuPolicy {
  NoContextMenu,
  DefaultContextMenu,
  ActionsContextMenu,
  CustomContextMenu,
  PreventContextMenu
};

enum InputMethodQuery {
  ImEnabled = 0x1,
  ImCursorRectangle = 0x2,

  ImMicroFocus = 0x2,

  ImFont = 0x4,
  ImCursorPosition = 0x8,
  ImSurroundingText = 0x10,
  ImCurrentSelection = 0x20,
  ImMaximumTextLength = 0x40,
  ImAnchorPosition = 0x80,
  ImHints = 0x100,
  ImPreferredLanguage = 0x200,

  ImAbsolutePosition = 0x400,
  ImTextBeforeCursor = 0x800,
  ImTextAfterCursor = 0x1000,
  ImEnterKeyType = 0x2000,
  ImAnchorRectangle = 0x4000,
  ImInputItemClipRectangle = 0x8000,

  ImPlatformData = 0x80000000,
  ImQueryInput = ImCursorRectangle | ImCursorPosition | ImSurroundingText |
                 ImCurrentSelection | ImAnchorRectangle | ImAnchorPosition,
  ImQueryAll = 0xffffffff
};
typedef QFlags<InputMethodQuery> InputMethodQueries;
constexpr inline QFlags<InputMethodQueries::enum_type>
operator|(InputMethodQueries::enum_type f1,
          InputMethodQueries::enum_type f2) noexcept {
  return QFlags<InputMethodQueries::enum_type>(f1) | f2;
}
constexpr inline QFlags<InputMethodQueries::enum_type>
operator|(InputMethodQueries::enum_type f1,
          QFlags<InputMethodQueries::enum_type> f2) noexcept {
  return f2 | f1;
}
constexpr inline QIncompatibleFlag operator|(InputMethodQueries::enum_type f1,
                                             int f2) noexcept {
  return QIncompatibleFlag(int(f1) | f2);
}

enum InputMethodHint {
  ImhNone = 0x0,

  ImhHiddenText = 0x1,
  ImhSensitiveData = 0x2,
  ImhNoAutoUppercase = 0x4,
  ImhPreferNumbers = 0x8,
  ImhPreferUppercase = 0x10,
  ImhPreferLowercase = 0x20,
  ImhNoPredictiveText = 0x40,

  ImhDate = 0x80,
  ImhTime = 0x100,

  ImhPreferLatin = 0x200,

  ImhMultiLine = 0x400,

  ImhNoEditMenu = 0x800,
  ImhNoTextHandles = 0x1000,

  ImhDigitsOnly = 0x10000,
  ImhFormattedNumbersOnly = 0x20000,
  ImhUppercaseOnly = 0x40000,
  ImhLowercaseOnly = 0x80000,
  ImhDialableCharactersOnly = 0x100000,
  ImhEmailCharactersOnly = 0x200000,
  ImhUrlCharactersOnly = 0x400000,
  ImhLatinOnly = 0x800000,

  ImhExclusiveInputMask = 0xffff0000
};
typedef QFlags<InputMethodHint> InputMethodHints;
constexpr inline QFlags<InputMethodHints::enum_type>
operator|(InputMethodHints::enum_type f1,
          InputMethodHints::enum_type f2) noexcept {
  return QFlags<InputMethodHints::enum_type>(f1) | f2;
}
constexpr inline QFlags<InputMethodHints::enum_type>
operator|(InputMethodHints::enum_type f1,
          QFlags<InputMethodHints::enum_type> f2) noexcept {
  return f2 | f1;
}
constexpr inline QIncompatibleFlag operator|(InputMethodHints::enum_type f1,
                                             int f2) noexcept {
  return QIncompatibleFlag(int(f1) | f2);
}

enum EnterKeyType {
  EnterKeyDefault,
  EnterKeyReturn,
  EnterKeyDone,
  EnterKeyGo,
  EnterKeySend,
  EnterKeySearch,
  EnterKeyNext,
  EnterKeyPrevious
};

enum ToolButtonStyle {
  ToolButtonIconOnly,
  ToolButtonTextOnly,
  ToolButtonTextBesideIcon,
  ToolButtonTextUnderIcon,
  ToolButtonFollowStyle
};

enum LayoutDirection { LeftToRight, RightToLeft, LayoutDirectionAuto };

enum AnchorPoint {
  AnchorLeft = 0,
  AnchorHorizontalCenter,
  AnchorRight,
  AnchorTop,
  AnchorVerticalCenter,
  AnchorBottom
};

enum FindChildOption {
  FindDirectChildrenOnly = 0x0,
  FindChildrenRecursively = 0x1
};
typedef QFlags<FindChildOption> FindChildOptions;

enum DropAction {
  CopyAction = 0x1,
  MoveAction = 0x2,
  LinkAction = 0x4,
  ActionMask = 0xff,
  TargetMoveAction = 0x8002,
  IgnoreAction = 0x0
};
typedef QFlags<DropAction> DropActions;
constexpr inline QFlags<DropActions::enum_type>
operator|(DropActions::enum_type f1, DropActions::enum_type f2) noexcept {
  return QFlags<DropActions::enum_type>(f1) | f2;
}
constexpr inline QFlags<DropActions::enum_type>
operator|(DropActions::enum_type f1,
          QFlags<DropActions::enum_type> f2) noexcept {
  return f2 | f1;
}
constexpr inline QIncompatibleFlag operator|(DropActions::enum_type f1,
                                             int f2) noexcept {
  return QIncompatibleFlag(int(f1) | f2);
}

enum CheckState { Unchecked, PartiallyChecked, Checked };

enum ItemDataRole {
  DisplayRole = 0,
  DecorationRole = 1,
  EditRole = 2,
  ToolTipRole = 3,
  StatusTipRole = 4,
  WhatsThisRole = 5,

  FontRole = 6,
  TextAlignmentRole = 7,
  BackgroundRole = 8,
  ForegroundRole = 9,

  BackgroundColorRole = BackgroundRole,
  TextColorRole = ForegroundRole,

  CheckStateRole = 10,

  AccessibleTextRole = 11,
  AccessibleDescriptionRole = 12,

  SizeHintRole = 13,
  InitialSortOrderRole = 14,

  DisplayPropertyRole = 27,
  DecorationPropertyRole = 28,
  ToolTipPropertyRole = 29,
  StatusTipPropertyRole = 30,
  WhatsThisPropertyRole = 31,

  UserRole = 0x0100
};

enum ItemFlag {
  NoItemFlags = 0,
  ItemIsSelectable = 1,
  ItemIsEditable = 2,
  ItemIsDragEnabled = 4,
  ItemIsDropEnabled = 8,
  ItemIsUserCheckable = 16,
  ItemIsEnabled = 32,
  ItemIsAutoTristate = 64,

  ItemIsTristate = ItemIsAutoTristate,

  ItemNeverHasChildren = 128,
  ItemIsUserTristate = 256
};
typedef QFlags<ItemFlag> ItemFlags;
constexpr inline QFlags<ItemFlags::enum_type>
operator|(ItemFlags::enum_type f1, ItemFlags::enum_type f2) noexcept {
  return QFlags<ItemFlags::enum_type>(f1) | f2;
}
constexpr inline QFlags<ItemFlags::enum_type>
operator|(ItemFlags::enum_type f1, QFlags<ItemFlags::enum_type> f2) noexcept {
  return f2 | f1;
}
constexpr inline QIncompatibleFlag operator|(ItemFlags::enum_type f1,
                                             int f2) noexcept {
  return QIncompatibleFlag(int(f1) | f2);
}

enum MatchFlag {
  MatchExactly = 0,
  MatchContains = 1,
  MatchStartsWith = 2,
  MatchEndsWith = 3,

  MatchRegExp = 4,

  MatchWildcard = 5,
  MatchFixedString = 8,
  MatchRegularExpression = 9,
  MatchCaseSensitive = 16,
  MatchWrap = 32,
  MatchRecursive = 64
};
typedef QFlags<MatchFlag> MatchFlags;
constexpr inline QFlags<MatchFlags::enum_type>
operator|(MatchFlags::enum_type f1, MatchFlags::enum_type f2) noexcept {
  return QFlags<MatchFlags::enum_type>(f1) | f2;
}
constexpr inline QFlags<MatchFlags::enum_type>
operator|(MatchFlags::enum_type f1, QFlags<MatchFlags::enum_type> f2) noexcept {
  return f2 | f1;
}
constexpr inline QIncompatibleFlag operator|(MatchFlags::enum_type f1,
                                             int f2) noexcept {
  return QIncompatibleFlag(int(f1) | f2);
}

typedef void *HANDLE;

enum WindowModality { NonModal, WindowModal, ApplicationModal };

enum TextInteractionFlag {
  NoTextInteraction = 0,
  TextSelectableByMouse = 1,
  TextSelectableByKeyboard = 2,
  LinksAccessibleByMouse = 4,
  LinksAccessibleByKeyboard = 8,
  TextEditable = 16,

  TextEditorInteraction =
      TextSelectableByMouse | TextSelectableByKeyboard | TextEditable,
  TextBrowserInteraction =
      TextSelectableByMouse | LinksAccessibleByMouse | LinksAccessibleByKeyboard
};
typedef QFlags<TextInteractionFlag> TextInteractionFlags;
constexpr inline QFlags<TextInteractionFlags::enum_type>
operator|(TextInteractionFlags::enum_type f1,
          TextInteractionFlags::enum_type f2) noexcept {
  return QFlags<TextInteractionFlags::enum_type>(f1) | f2;
}
constexpr inline QFlags<TextInteractionFlags::enum_type>
operator|(TextInteractionFlags::enum_type f1,
          QFlags<TextInteractionFlags::enum_type> f2) noexcept {
  return f2 | f1;
}
constexpr inline QIncompatibleFlag operator|(TextInteractionFlags::enum_type f1,
                                             int f2) noexcept {
  return QIncompatibleFlag(int(f1) | f2);
}

enum EventPriority {
  HighEventPriority = 1,
  NormalEventPriority = 0,
  LowEventPriority = -1
};

enum SizeHint {
  MinimumSize,
  PreferredSize,
  MaximumSize,
  MinimumDescent,
  NSizeHints
};

enum WindowFrameSection {
  NoSection,
  LeftSection,
  TopLeftSection,
  TopSection,
  TopRightSection,
  RightSection,
  BottomRightSection,
  BottomSection,
  BottomLeftSection,
  TitleBarArea
};

enum class Initialization { Uninitialized };
static constexpr __attribute__((__unused__)) Initialization Uninitialized =
    Initialization::Uninitialized;

enum CoordinateSystem { DeviceCoordinates, LogicalCoordinates };

enum TouchPointState {
  TouchPointPressed = 0x01,
  TouchPointMoved = 0x02,
  TouchPointStationary = 0x04,
  TouchPointReleased = 0x08
};
typedef QFlags<TouchPointState> TouchPointStates;
constexpr inline QFlags<TouchPointStates::enum_type>
operator|(TouchPointStates::enum_type f1,
          TouchPointStates::enum_type f2) noexcept {
  return QFlags<TouchPointStates::enum_type>(f1) | f2;
}
constexpr inline QFlags<TouchPointStates::enum_type>
operator|(TouchPointStates::enum_type f1,
          QFlags<TouchPointStates::enum_type> f2) noexcept {
  return f2 | f1;
}
constexpr inline QIncompatibleFlag operator|(TouchPointStates::enum_type f1,
                                             int f2) noexcept {
  return QIncompatibleFlag(int(f1) | f2);
}

enum GestureState {
  NoGesture,
  GestureStarted = 1,
  GestureUpdated = 2,
  GestureFinished = 3,
  GestureCanceled = 4
};

enum GestureType {
  TapGesture = 1,
  TapAndHoldGesture = 2,
  PanGesture = 3,
  PinchGesture = 4,
  SwipeGesture = 5,

  CustomGesture = 0x0100,

  LastGestureType = ~0u
};

enum GestureFlag {
  DontStartGestureOnChildren = 0x01,
  ReceivePartialGestures = 0x02,
  IgnoredGesturesPropagateToParent = 0x04
};
typedef QFlags<GestureFlag> GestureFlags;
constexpr inline QFlags<GestureFlags::enum_type>
operator|(GestureFlags::enum_type f1, GestureFlags::enum_type f2) noexcept {
  return QFlags<GestureFlags::enum_type>(f1) | f2;
}
constexpr inline QFlags<GestureFlags::enum_type>
operator|(GestureFlags::enum_type f1,
          QFlags<GestureFlags::enum_type> f2) noexcept {
  return f2 | f1;
}
constexpr inline QIncompatibleFlag operator|(GestureFlags::enum_type f1,
                                             int f2) noexcept {
  return QIncompatibleFlag(int(f1) | f2);
}

enum NativeGestureType {
  BeginNativeGesture,
  EndNativeGesture,
  PanNativeGesture,
  ZoomNativeGesture,
  SmartZoomNativeGesture,
  RotateNativeGesture,
  SwipeNativeGesture
};

enum NavigationMode {
  NavigationModeNone,
  NavigationModeKeypadTabOrder,
  NavigationModeKeypadDirectional,
  NavigationModeCursorAuto,
  NavigationModeCursorForceVisible
};

enum CursorMoveStyle { LogicalMoveStyle, VisualMoveStyle };

enum TimerType { PreciseTimer, CoarseTimer, VeryCoarseTimer };

enum ScrollPhase {
  NoScrollPhase = 0,
  ScrollBegin,
  ScrollUpdate,
  ScrollEnd,
  ScrollMomentum
};

enum MouseEventSource {
  MouseEventNotSynthesized,
  MouseEventSynthesizedBySystem,
  MouseEventSynthesizedByQt,
  MouseEventSynthesizedByApplication
};

enum MouseEventFlag {
  MouseEventCreatedDoubleClick = 0x01,
  MouseEventFlagMask = 0xFF
};
typedef QFlags<MouseEventFlag> MouseEventFlags;
constexpr inline QFlags<MouseEventFlags::enum_type>
operator|(MouseEventFlags::enum_type f1,
          MouseEventFlags::enum_type f2) noexcept {
  return QFlags<MouseEventFlags::enum_type>(f1) | f2;
}
constexpr inline QFlags<MouseEventFlags::enum_type>
operator|(MouseEventFlags::enum_type f1,
          QFlags<MouseEventFlags::enum_type> f2) noexcept {
  return f2 | f1;
}
constexpr inline QIncompatibleFlag operator|(MouseEventFlags::enum_type f1,
                                             int f2) noexcept {
  return QIncompatibleFlag(int(f1) | f2);
}

enum ChecksumType { ChecksumIso3309, ChecksumItuV41 };

enum class HighDpiScaleFactorRoundingPolicy {
  Unset,
  Round,
  Ceil,
  Floor,
  RoundPreferFloor,
  PassThrough
};

enum ReturnByValueConstant { ReturnByValue };

inline const QMetaObject *qt_getEnumMetaObject(ScrollBarPolicy) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(ScrollBarPolicy) noexcept {
  return "ScrollBarPolicy";
}
inline const QMetaObject *qt_getEnumMetaObject(FocusPolicy) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(FocusPolicy) noexcept {
  return "FocusPolicy";
}
inline const QMetaObject *qt_getEnumMetaObject(ContextMenuPolicy) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(ContextMenuPolicy) noexcept {
  return "ContextMenuPolicy";
}
inline const QMetaObject *qt_getEnumMetaObject(ArrowType) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(ArrowType) noexcept {
  return "ArrowType";
}
inline const QMetaObject *qt_getEnumMetaObject(ToolButtonStyle) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(ToolButtonStyle) noexcept {
  return "ToolButtonStyle";
}
inline const QMetaObject *qt_getEnumMetaObject(PenStyle) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(PenStyle) noexcept {
  return "PenStyle";
}
inline const QMetaObject *qt_getEnumMetaObject(PenCapStyle) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(PenCapStyle) noexcept {
  return "PenCapStyle";
}
inline const QMetaObject *qt_getEnumMetaObject(PenJoinStyle) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(PenJoinStyle) noexcept {
  return "PenJoinStyle";
}
inline const QMetaObject *qt_getEnumMetaObject(BrushStyle) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(BrushStyle) noexcept {
  return "BrushStyle";
}
inline const QMetaObject *qt_getEnumMetaObject(FillRule) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(FillRule) noexcept {
  return "FillRule";
}
inline const QMetaObject *qt_getEnumMetaObject(MaskMode) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(MaskMode) noexcept {
  return "MaskMode";
}
inline const QMetaObject *qt_getEnumMetaObject(BGMode) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(BGMode) noexcept {
  return "BGMode";
}
inline const QMetaObject *qt_getEnumMetaObject(ClipOperation) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(ClipOperation) noexcept {
  return "ClipOperation";
}
inline const QMetaObject *qt_getEnumMetaObject(SizeMode) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(SizeMode) noexcept {
  return "SizeMode";
}
inline const QMetaObject *qt_getEnumMetaObject(Axis) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(Axis) noexcept { return "Axis"; }
inline const QMetaObject *qt_getEnumMetaObject(Corner) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(Corner) noexcept {
  return "Corner";
}
inline const QMetaObject *qt_getEnumMetaObject(Edge) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(Edge) noexcept { return "Edge"; }
inline const QMetaObject *qt_getEnumMetaObject(LayoutDirection) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(LayoutDirection) noexcept {
  return "LayoutDirection";
}
inline const QMetaObject *qt_getEnumMetaObject(SizeHint) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(SizeHint) noexcept {
  return "SizeHint";
}
inline const QMetaObject *qt_getEnumMetaObject(Orientation) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(Orientation) noexcept {
  return "Orientation";
}
inline const QMetaObject *qt_getEnumMetaObject(DropAction) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(DropAction) noexcept {
  return "DropAction";
}
inline const QMetaObject *qt_getEnumMetaObject(Alignment) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(Alignment) noexcept {
  return "Alignment";
}
inline const QMetaObject *qt_getEnumMetaObject(TextFlag) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(TextFlag) noexcept {
  return "TextFlag";
}
inline const QMetaObject *qt_getEnumMetaObject(Orientations) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(Orientations) noexcept {
  return "Orientations";
}
inline const QMetaObject *qt_getEnumMetaObject(SplitBehavior) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(SplitBehavior) noexcept {
  return "SplitBehavior";
}
inline const QMetaObject *qt_getEnumMetaObject(DropActions) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(DropActions) noexcept {
  return "DropActions";
}
inline const QMetaObject *qt_getEnumMetaObject(Edges) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(Edges) noexcept { return "Edges"; }
inline const QMetaObject *qt_getEnumMetaObject(DockWidgetAreas) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(DockWidgetAreas) noexcept {
  return "DockWidgetAreas";
}
inline const QMetaObject *qt_getEnumMetaObject(ToolBarAreas) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(ToolBarAreas) noexcept {
  return "ToolBarAreas";
}
inline const QMetaObject *qt_getEnumMetaObject(DockWidgetArea) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(DockWidgetArea) noexcept {
  return "DockWidgetArea";
}
inline const QMetaObject *qt_getEnumMetaObject(ToolBarArea) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(ToolBarArea) noexcept {
  return "ToolBarArea";
}
inline const QMetaObject *qt_getEnumMetaObject(TextFormat) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(TextFormat) noexcept {
  return "TextFormat";
}
inline const QMetaObject *qt_getEnumMetaObject(TextElideMode) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(TextElideMode) noexcept {
  return "TextElideMode";
}
inline const QMetaObject *qt_getEnumMetaObject(DateFormat) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(DateFormat) noexcept {
  return "DateFormat";
}
inline const QMetaObject *qt_getEnumMetaObject(TimeSpec) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(TimeSpec) noexcept {
  return "TimeSpec";
}
inline const QMetaObject *qt_getEnumMetaObject(DayOfWeek) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(DayOfWeek) noexcept {
  return "DayOfWeek";
}
inline const QMetaObject *qt_getEnumMetaObject(CursorShape) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(CursorShape) noexcept {
  return "CursorShape";
}
inline const QMetaObject *qt_getEnumMetaObject(GlobalColor) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(GlobalColor) noexcept {
  return "GlobalColor";
}
inline const QMetaObject *qt_getEnumMetaObject(AspectRatioMode) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(AspectRatioMode) noexcept {
  return "AspectRatioMode";
}
inline const QMetaObject *qt_getEnumMetaObject(TransformationMode) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(TransformationMode) noexcept {
  return "TransformationMode";
}
inline const QMetaObject *qt_getEnumMetaObject(ImageConversionFlags) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(ImageConversionFlags) noexcept {
  return "ImageConversionFlags";
}
inline const QMetaObject *qt_getEnumMetaObject(Key) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(Key) noexcept { return "Key"; }
inline const QMetaObject *qt_getEnumMetaObject(ShortcutContext) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(ShortcutContext) noexcept {
  return "ShortcutContext";
}
inline const QMetaObject *qt_getEnumMetaObject(TextInteractionFlag) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(TextInteractionFlag) noexcept {
  return "TextInteractionFlag";
}
inline const QMetaObject *qt_getEnumMetaObject(TextInteractionFlags) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(TextInteractionFlags) noexcept {
  return "TextInteractionFlags";
}
inline const QMetaObject *qt_getEnumMetaObject(ItemSelectionMode) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(ItemSelectionMode) noexcept {
  return "ItemSelectionMode";
}
inline const QMetaObject *
qt_getEnumMetaObject(ItemSelectionOperation) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(ItemSelectionOperation) noexcept {
  return "ItemSelectionOperation";
}
inline const QMetaObject *qt_getEnumMetaObject(ItemFlags) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(ItemFlags) noexcept {
  return "ItemFlags";
}
inline const QMetaObject *qt_getEnumMetaObject(CheckState) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(CheckState) noexcept {
  return "CheckState";
}
inline const QMetaObject *qt_getEnumMetaObject(ItemDataRole) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(ItemDataRole) noexcept {
  return "ItemDataRole";
}
inline const QMetaObject *qt_getEnumMetaObject(SortOrder) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(SortOrder) noexcept {
  return "SortOrder";
}
inline const QMetaObject *qt_getEnumMetaObject(CaseSensitivity) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(CaseSensitivity) noexcept {
  return "CaseSensitivity";
}
inline const QMetaObject *qt_getEnumMetaObject(MatchFlags) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(MatchFlags) noexcept {
  return "MatchFlags";
}
inline const QMetaObject *qt_getEnumMetaObject(KeyboardModifiers) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(KeyboardModifiers) noexcept {
  return "KeyboardModifiers";
}
inline const QMetaObject *qt_getEnumMetaObject(MouseButtons) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(MouseButtons) noexcept {
  return "MouseButtons";
}
inline const QMetaObject *qt_getEnumMetaObject(WindowType) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(WindowType) noexcept {
  return "WindowType";
}
inline const QMetaObject *qt_getEnumMetaObject(WindowState) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(WindowState) noexcept {
  return "WindowState";
}
inline const QMetaObject *qt_getEnumMetaObject(WindowModality) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(WindowModality) noexcept {
  return "WindowModality";
}
inline const QMetaObject *qt_getEnumMetaObject(WidgetAttribute) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(WidgetAttribute) noexcept {
  return "WidgetAttribute";
}
inline const QMetaObject *qt_getEnumMetaObject(ApplicationAttribute) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(ApplicationAttribute) noexcept {
  return "ApplicationAttribute";
}
inline const QMetaObject *qt_getEnumMetaObject(WindowFlags) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(WindowFlags) noexcept {
  return "WindowFlags";
}
inline const QMetaObject *qt_getEnumMetaObject(WindowStates) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(WindowStates) noexcept {
  return "WindowStates";
}
inline const QMetaObject *qt_getEnumMetaObject(FocusReason) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(FocusReason) noexcept {
  return "FocusReason";
}
inline const QMetaObject *qt_getEnumMetaObject(InputMethodHint) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(InputMethodHint) noexcept {
  return "InputMethodHint";
}
inline const QMetaObject *qt_getEnumMetaObject(InputMethodQuery) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(InputMethodQuery) noexcept {
  return "InputMethodQuery";
}
inline const QMetaObject *qt_getEnumMetaObject(InputMethodHints) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(InputMethodHints) noexcept {
  return "InputMethodHints";
}
inline const QMetaObject *qt_getEnumMetaObject(EnterKeyType) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(EnterKeyType) noexcept {
  return "EnterKeyType";
}
inline const QMetaObject *qt_getEnumMetaObject(InputMethodQueries) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(InputMethodQueries) noexcept {
  return "InputMethodQueries";
}
inline const QMetaObject *qt_getEnumMetaObject(TouchPointStates) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(TouchPointStates) noexcept {
  return "TouchPointStates";
}
inline const QMetaObject *qt_getEnumMetaObject(ScreenOrientation) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(ScreenOrientation) noexcept {
  return "ScreenOrientation";
}
inline const QMetaObject *qt_getEnumMetaObject(ScreenOrientations) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(ScreenOrientations) noexcept {
  return "ScreenOrientations";
}
inline const QMetaObject *qt_getEnumMetaObject(ConnectionType) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(ConnectionType) noexcept {
  return "ConnectionType";
}
inline const QMetaObject *qt_getEnumMetaObject(ApplicationState) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(ApplicationState) noexcept {
  return "ApplicationState";
}

inline const QMetaObject *qt_getEnumMetaObject(GestureState) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(GestureState) noexcept {
  return "GestureState";
}
inline const QMetaObject *qt_getEnumMetaObject(GestureType) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(GestureType) noexcept {
  return "GestureType";
}
inline const QMetaObject *qt_getEnumMetaObject(NativeGestureType) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(NativeGestureType) noexcept {
  return "NativeGestureType";
}

inline const QMetaObject *qt_getEnumMetaObject(CursorMoveStyle) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(CursorMoveStyle) noexcept {
  return "CursorMoveStyle";
}
inline const QMetaObject *qt_getEnumMetaObject(TimerType) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(TimerType) noexcept {
  return "TimerType";
}
inline const QMetaObject *qt_getEnumMetaObject(ScrollPhase) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(ScrollPhase) noexcept {
  return "ScrollPhase";
}
inline const QMetaObject *qt_getEnumMetaObject(MouseEventSource) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(MouseEventSource) noexcept {
  return "MouseEventSource";
}
inline const QMetaObject *qt_getEnumMetaObject(MouseEventFlag) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(MouseEventFlag) noexcept {
  return "MouseEventFlag";
}
inline const QMetaObject *qt_getEnumMetaObject(ChecksumType) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(ChecksumType) noexcept {
  return "ChecksumType";
}
inline const QMetaObject *
qt_getEnumMetaObject(HighDpiScaleFactorRoundingPolicy) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *
qt_getEnumName(HighDpiScaleFactorRoundingPolicy) noexcept {
  return "HighDpiScaleFactorRoundingPolicy";
}
inline const QMetaObject *qt_getEnumMetaObject(TabFocusBehavior) noexcept {
  return qt_getQtMetaObject();
}
inline constexpr const char *qt_getEnumName(TabFocusBehavior) noexcept {
  return "TabFocusBehavior";
}

} // namespace Qt

typedef bool (*qInternalCallback)(void **);

class __attribute__((visibility("default"))) QInternal {
public:
  enum PaintDeviceFlags {
    UnknownDevice = 0x00,
    Widget = 0x01,
    Pixmap = 0x02,
    Image = 0x03,
    Printer = 0x04,
    Picture = 0x05,
    Pbuffer = 0x06,
    FramebufferObject = 0x07,
    CustomRaster = 0x08,
    MacQuartz = 0x09,
    PaintBuffer = 0x0a,
    OpenGL = 0x0b
  };
  enum RelayoutType { RelayoutNormal, RelayoutDragging, RelayoutDropped };

  enum DockPosition { LeftDock, RightDock, TopDock, BottomDock, DockCount };

  enum Callback { EventNotifyCallback, LastCallback };
  static bool registerCallback(Callback, qInternalCallback);
  static bool unregisterCallback(Callback, qInternalCallback);
  static bool activateCallbacks(Callback, void **);
};
# 49 "/usr/local/include/QtCore/qobjectdefs.h" 2

# 1 "/usr/local/include/QtCore/qobjectdefs_impl.h" 1
# 52 "/usr/local/include/QtCore/qobjectdefs_impl.h"
class QObject;

namespace QtPrivate {
template <typename T> struct RemoveRef { typedef T Type; };
template <typename T> struct RemoveRef<T &> { typedef T Type; };
template <typename T> struct RemoveConstRef { typedef T Type; };
template <typename T> struct RemoveConstRef<const T &> { typedef T Type; };
# 67 "/usr/local/include/QtCore/qobjectdefs_impl.h"
template <typename...> struct List {};
template <typename Head, typename... Tail> struct List<Head, Tail...> {
  typedef Head Car;
  typedef List<Tail...> Cdr;
};
template <typename, typename> struct List_Append;
template <typename... L1, typename... L2>
struct List_Append<List<L1...>, List<L2...>> {
  typedef List<L1..., L2...> Value;
};
template <typename L, int N> struct List_Left {
  typedef typename List_Append<
      List<typename L::Car>,
      typename List_Left<typename L::Cdr, N - 1>::Value>::Value Value;
};
template <typename L> struct List_Left<L, 0> { typedef List<> Value; };

template <typename L, int N> struct List_Select {
  typedef typename List_Select<typename L::Cdr, N - 1>::Value Value;
};
template <typename L> struct List_Select<L, 0> {
  typedef typename L::Car Value;
};

template <typename T> struct ApplyReturnValue {
  void *data;
  explicit ApplyReturnValue(void *data_) : data(data_) {}
};
template <typename T, typename U>
void operator,(T &&value, const ApplyReturnValue<U> &container) {
  if (container.data)
    *reinterpret_cast<U *>(container.data) = std::forward<T>(value);
}
template <typename T> void operator,(T, const ApplyReturnValue<void> &) {}
# 115 "/usr/local/include/QtCore/qobjectdefs_impl.h"
template <class T> using InvokeGenSeq = typename T::Type;

template <int...> struct IndexesList { using Type = IndexesList; };

template <int N, class S1, class S2> struct ConcatSeqImpl;

template <int N, int... I1, int... I2>
struct ConcatSeqImpl<N, IndexesList<I1...>, IndexesList<I2...>>
    : IndexesList<I1..., (N + I2)...> {};

template <int N, class S1, class S2>
using ConcatSeq = InvokeGenSeq<ConcatSeqImpl<N, S1, S2>>;

template <int N> struct GenSeq;
template <int N> using makeIndexSequence = InvokeGenSeq<GenSeq<N>>;

template <int N>
struct GenSeq
    : ConcatSeq<N / 2, makeIndexSequence<N / 2>, makeIndexSequence<N - N / 2>> {
};

template <> struct GenSeq<0> : IndexesList<> {};
template <> struct GenSeq<1> : IndexesList<0> {};

template <int N> struct Indexes { using Value = makeIndexSequence<N>; };

template <typename Func> struct FunctionPointer {
  enum { ArgumentCount = -1, IsPointerToMemberFunction = false };
};

template <typename, typename, typename, typename> struct FunctorCall;
template <int... II, typename... SignalArgs, typename R, typename Function>
struct FunctorCall<IndexesList<II...>, List<SignalArgs...>, R, Function> {
  static void call(Function &f, void **arg) {
    f((*reinterpret_cast<typename RemoveRef<SignalArgs>::Type *>(
        arg[II + 1]))...),
        ApplyReturnValue<R>(arg[0]);
  }
};
template <int... II, typename... SignalArgs, typename R, typename... SlotArgs,
          typename SlotRet, class Obj>
struct FunctorCall<IndexesList<II...>, List<SignalArgs...>, R,
                   SlotRet (Obj::*)(SlotArgs...)> {
  static void call(SlotRet (Obj::*f)(SlotArgs...), Obj *o, void **arg) {
    (o->*f)((*reinterpret_cast<typename RemoveRef<SignalArgs>::Type *>(
        arg[II + 1]))...),
        ApplyReturnValue<R>(arg[0]);
  }
};
template <int... II, typename... SignalArgs, typename R, typename... SlotArgs,
          typename SlotRet, class Obj>
struct FunctorCall<IndexesList<II...>, List<SignalArgs...>, R,
                   SlotRet (Obj::*)(SlotArgs...) const> {
  static void call(SlotRet (Obj::*f)(SlotArgs...) const, Obj *o, void **arg) {
    (o->*f)((*reinterpret_cast<typename RemoveRef<SignalArgs>::Type *>(
        arg[II + 1]))...),
        ApplyReturnValue<R>(arg[0]);
  }
};
# 176 "/usr/local/include/QtCore/qobjectdefs_impl.h"
template <class Obj, typename Ret, typename... Args>
struct FunctionPointer<Ret (Obj::*)(Args...)> {
  typedef Obj Object;
  typedef List<Args...> Arguments;
  typedef Ret ReturnType;
  typedef Ret (Obj::*Function)(Args...);
  enum { ArgumentCount = sizeof...(Args), IsPointerToMemberFunction = true };
  template <typename SignalArgs, typename R>
  static void call(Function f, Obj *o, void **arg) {
    FunctorCall<typename Indexes<ArgumentCount>::Value, SignalArgs, R,
                Function>::call(f, o, arg);
  }
};
template <class Obj, typename Ret, typename... Args>
struct FunctionPointer<Ret (Obj::*)(Args...) const> {
  typedef Obj Object;
  typedef List<Args...> Arguments;
  typedef Ret ReturnType;
  typedef Ret (Obj::*Function)(Args...) const;
  enum { ArgumentCount = sizeof...(Args), IsPointerToMemberFunction = true };
  template <typename SignalArgs, typename R>
  static void call(Function f, Obj *o, void **arg) {
    FunctorCall<typename Indexes<ArgumentCount>::Value, SignalArgs, R,
                Function>::call(f, o, arg);
  }
};

template <typename Ret, typename... Args>
struct FunctionPointer<Ret (*)(Args...)> {
  typedef List<Args...> Arguments;
  typedef Ret ReturnType;
  typedef Ret (*Function)(Args...);
  enum { ArgumentCount = sizeof...(Args), IsPointerToMemberFunction = false };
  template <typename SignalArgs, typename R>
  static void call(Function f, void *, void **arg) {
    FunctorCall<typename Indexes<ArgumentCount>::Value, SignalArgs, R,
                Function>::call(f, arg);
  }
};
# 252 "/usr/local/include/QtCore/qobjectdefs_impl.h"
template <typename Function, int N> struct Functor {
  template <typename SignalArgs, typename R>
  static void call(Function &f, void *, void **arg) {
    FunctorCall<typename Indexes<N>::Value, SignalArgs, R, Function>::call(f,
                                                                           arg);
  }
};

template <typename E, typename Enable = void>
struct IsEnumUnderlyingTypeSigned : std::false_type {};

template <typename E>
struct IsEnumUnderlyingTypeSigned<
    E, typename std::enable_if<std::is_enum<E>::value>::type>
    : std::integral_constant<
          bool, std::is_signed<typename std::underlying_type<E>::type>::value> {
};

template <typename From, typename To, typename Enable = void>
struct AreArgumentsNarrowedBase : std::false_type {};

template <typename T>
using is_bool = std::is_same<bool, typename std::decay<T>::type>;

template <typename From, typename To>
struct AreArgumentsNarrowedBase<
    From, To, typename std::enable_if<sizeof(From) && sizeof(To)>::type>
    : std::integral_constant<
          bool,
          (std::is_floating_point<From>::value &&
           std::is_integral<To>::value) ||
              (std::is_floating_point<From>::value &&
               std::is_floating_point<To>::value &&
               sizeof(From) > sizeof(To)) ||
              ((std::is_pointer<From>::value ||
                std::is_member_pointer<From>::value) &&
               QtPrivate::is_bool<To>::value) ||
              ((std::is_integral<From>::value || std::is_enum<From>::value) &&
               std::is_floating_point<To>::value) ||
              (std::is_integral<From>::value && std::is_integral<To>::value &&
               (sizeof(From) > sizeof(To) ||
                (std::is_signed<From>::value
                     ? !std::is_signed<To>::value
                     : (std::is_signed<To>::value &&
                        sizeof(From) == sizeof(To))))) ||
              (std::is_enum<From>::value && std::is_integral<To>::value &&
               (sizeof(From) > sizeof(To) ||
                (IsEnumUnderlyingTypeSigned<From>::value
                     ? !std::is_signed<To>::value
                     : (std::is_signed<To>::value &&
                        sizeof(From) == sizeof(To)))))> {};

template <typename A1, typename A2> struct AreArgumentsCompatible {
  static int test(const typename RemoveRef<A2>::Type &);
  static char test(...);
  static const typename RemoveRef<A1>::Type &dummy();
  enum { value = sizeof(test(dummy())) == sizeof(int) };
};
template <typename A1, typename A2> struct AreArgumentsCompatible<A1, A2 &> {
  enum { value = false };
};
template <typename A> struct AreArgumentsCompatible<A &, A &> {
  enum { value = true };
};

template <typename A> struct AreArgumentsCompatible<void, A> {
  enum { value = true };
};
template <typename A> struct AreArgumentsCompatible<A, void> {
  enum { value = true };
};
template <> struct AreArgumentsCompatible<void, void> {
  enum { value = true };
};

template <typename List1, typename List2> struct CheckCompatibleArguments {
  enum { value = false };
};
template <> struct CheckCompatibleArguments<List<>, List<>> {
  enum { value = true };
};
template <typename List1> struct CheckCompatibleArguments<List1, List<>> {
  enum { value = true };
};
template <typename Arg1, typename Arg2, typename... Tail1, typename... Tail2>
struct CheckCompatibleArguments<List<Arg1, Tail1...>, List<Arg2, Tail2...>> {
  enum {
    value =
        AreArgumentsCompatible<typename RemoveConstRef<Arg1>::Type,
                               typename RemoveConstRef<Arg2>::Type>::value &&
        CheckCompatibleArguments<List<Tail1...>, List<Tail2...>>::value
  };
};

template <typename Functor, typename ArgList>
struct ComputeFunctorArgumentCount;

template <typename Functor, typename ArgList, bool Done>
struct ComputeFunctorArgumentCountHelper {
  enum { Value = -1 };
};
template <typename Functor, typename First, typename... ArgList>
struct ComputeFunctorArgumentCountHelper<Functor, List<First, ArgList...>,
                                         false>
    : ComputeFunctorArgumentCount<
          Functor, typename List_Left<List<First, ArgList...>,
                                      sizeof...(ArgList)>::Value> {};

template <typename Functor, typename... ArgList>
struct ComputeFunctorArgumentCount<Functor, List<ArgList...>> {
  template <typename D> static D dummy();
  template <typename F>
  static auto test(F f)
      -> decltype(((f.operator()((dummy<ArgList>())...)), int()));
  static char test(...);
  enum {
    Ok = sizeof(test(dummy<Functor>())) == sizeof(int),
    Value =
        Ok ? int(sizeof...(ArgList))
           : int(ComputeFunctorArgumentCountHelper<Functor, List<ArgList...>,
                                                   Ok>::Value)
  };
};

template <typename Functor, typename ArgList> struct FunctorReturnType;
template <typename Functor, typename... ArgList>
struct FunctorReturnType<Functor, List<ArgList...>> {
  template <typename D> static D dummy();
  typedef decltype(dummy<Functor>().operator()((dummy<ArgList>())...)) Value;
};

class QSlotObjectBase {
  QAtomicInt m_ref;

  typedef void (*ImplFn)(int which, QSlotObjectBase *this_, QObject *receiver,
                         void **args, bool *ret);
  const ImplFn m_impl;

protected:
  enum Operation {
    Destroy,
    Call,
    Compare,

    NumOperations
  };

public:
  explicit QSlotObjectBase(ImplFn fn) : m_ref(1), m_impl(fn) {}

  inline int ref() noexcept { return m_ref.ref(); }
  inline void destroyIfLastRef() noexcept {
    if (!m_ref.deref())
      m_impl(Destroy, this, nullptr, nullptr, nullptr);
  }

  inline bool compare(void **a) {
    bool ret = false;
    m_impl(Compare, this, nullptr, a, &ret);
    return ret;
  }
  inline void call(QObject *r, void **a) { m_impl(Call, this, r, a, nullptr); }

protected:
  ~QSlotObjectBase() {}

private:
  QSlotObjectBase(const QSlotObjectBase &) = delete;
  QSlotObjectBase &operator=(const QSlotObjectBase &) = delete;
  QSlotObjectBase(QSlotObjectBase &&) = delete;
  QSlotObjectBase &operator=(QSlotObjectBase &&) = delete;
};

template <typename Func, typename Args, typename R>
class QSlotObject : public QSlotObjectBase {
  typedef QtPrivate::FunctionPointer<Func> FuncType;
  Func function;
  static void impl(int which, QSlotObjectBase *this_, QObject *r, void **a,
                   bool *ret) {
    switch (which) {
    case Destroy:
      delete static_cast<QSlotObject *>(this_);
      break;
    case Call:
      FuncType::template call<Args, R>(
          static_cast<QSlotObject *>(this_)->function,
          static_cast<typename FuncType::Object *>(r), a);
      break;
    case Compare:
      *ret = *reinterpret_cast<Func *>(a) ==
             static_cast<QSlotObject *>(this_)->function;
      break;
    case NumOperations:;
    }
  }

public:
  explicit QSlotObject(Func f) : QSlotObjectBase(&impl), function(f) {}
};

template <typename Func, int N, typename Args, typename R>
class QFunctorSlotObject : public QSlotObjectBase {
  typedef QtPrivate::Functor<Func, N> FuncType;
  Func function;
  static void impl(int which, QSlotObjectBase *this_, QObject *r, void **a,
                   bool *ret) {
    switch (which) {
    case Destroy:
      delete static_cast<QFunctorSlotObject *>(this_);
      break;
    case Call:
      FuncType::template call<Args, R>(
          static_cast<QFunctorSlotObject *>(this_)->function, r, a);
      break;
    case Compare:
    case NumOperations:
      (void)ret;
      ;
    }
  }

public:
  explicit QFunctorSlotObject(Func f)
      : QSlotObjectBase(&impl), function(std::move(f)) {}
};

template <typename Func>
using QSlotObjectWithNoArgs =
    QSlotObject<Func, QtPrivate::List<>,
                typename QtPrivate::FunctionPointer<Func>::ReturnType>;

template <typename Func, typename R>
using QFunctorSlotObjectWithNoArgs =
    QFunctorSlotObject<Func, 0, QtPrivate::List<>, R>;

template <typename Func>
using QFunctorSlotObjectWithNoArgsImplicitReturn = QFunctorSlotObjectWithNoArgs<
    Func, typename QtPrivate::FunctionPointer<Func>::ReturnType>;
} // namespace QtPrivate
# 51 "/usr/local/include/QtCore/qobjectdefs.h" 2

class QByteArray;
struct QArrayData;
typedef QArrayData QByteArrayData;

class QString;
# 256 "/usr/local/include/QtCore/qobjectdefs.h"
__attribute__((visibility("default"))) const char *
qFlagLocation(const char *method);
# 282 "/usr/local/include/QtCore/qobjectdefs.h"
class QObject;
class QMetaMethod;
class QMetaEnum;
class QMetaProperty;
class QMetaClassInfo;

class __attribute__((visibility("default"))) QGenericArgument {
public:
  inline QGenericArgument(const char *aName = nullptr,
                          const void *aData = nullptr)
      : _data(aData), _name(aName) {}
  inline void *data() const { return const_cast<void *>(_data); }
  inline const char *name() const { return _name; }

private:
  const void *_data;
  const char *_name;
};

class __attribute__((visibility("default"))) QGenericReturnArgument
    : public QGenericArgument {
public:
  inline QGenericReturnArgument(const char *aName = nullptr,
                                void *aData = nullptr)
      : QGenericArgument(aName, aData) {}
};

template <class T> class QArgument : public QGenericArgument {
public:
  inline QArgument(const char *aName, const T &aData)
      : QGenericArgument(aName, static_cast<const void *>(&aData)) {}
};
template <class T> class QArgument<T &> : public QGenericArgument {
public:
  inline QArgument(const char *aName, T &aData)
      : QGenericArgument(aName, static_cast<const void *>(&aData)) {}
};

template <typename T> class QReturnArgument : public QGenericReturnArgument {
public:
  inline QReturnArgument(const char *aName, T &aData)
      : QGenericReturnArgument(aName, static_cast<void *>(&aData)) {}
};

struct QMetaObject {
  class Connection;
  const char *className() const;
  const QMetaObject *superClass() const;

  bool inherits(const QMetaObject *metaObject) const noexcept;
  QObject *cast(QObject *obj) const;
  const QObject *cast(const QObject *obj) const;

  QString tr(const char *s, const char *c, int n = -1) const;

  int methodOffset() const;
  int enumeratorOffset() const;
  int propertyOffset() const;
  int classInfoOffset() const;

  int constructorCount() const;
  int methodCount() const;
  int enumeratorCount() const;
  int propertyCount() const;
  int classInfoCount() const;

  int indexOfConstructor(const char *constructor) const;
  int indexOfMethod(const char *method) const;
  int indexOfSignal(const char *signal) const;
  int indexOfSlot(const char *slot) const;
  int indexOfEnumerator(const char *name) const;
  int indexOfProperty(const char *name) const;
  int indexOfClassInfo(const char *name) const;

  QMetaMethod constructor(int index) const;
  QMetaMethod method(int index) const;
  QMetaEnum enumerator(int index) const;
  QMetaProperty property(int index) const;
  QMetaClassInfo classInfo(int index) const;
  QMetaProperty userProperty() const;

  static bool checkConnectArgs(const char *signal, const char *method);
  static bool checkConnectArgs(const QMetaMethod &signal,
                               const QMetaMethod &method);
  static QByteArray normalizedSignature(const char *method);
  static QByteArray normalizedType(const char *type);

  static Connection connect(const QObject *sender, int signal_index,
                            const QObject *receiver, int method_index,
                            int type = 0, int *types = nullptr);

  static bool disconnect(const QObject *sender, int signal_index,
                         const QObject *receiver, int method_index);
  static bool disconnectOne(const QObject *sender, int signal_index,
                            const QObject *receiver, int method_index);

  static void connectSlotsByName(QObject *o);

  static void activate(QObject *sender, int signal_index, void **argv);
  static void activate(QObject *sender, const QMetaObject *,
                       int local_signal_index, void **argv);
  static void activate(QObject *sender, int signal_offset,
                       int local_signal_index, void **argv);

  static bool invokeMethod(QObject *obj, const char *member, Qt::ConnectionType,
                           QGenericReturnArgument ret,
                           QGenericArgument val0 = QGenericArgument(nullptr),
                           QGenericArgument val1 = QGenericArgument(),
                           QGenericArgument val2 = QGenericArgument(),
                           QGenericArgument val3 = QGenericArgument(),
                           QGenericArgument val4 = QGenericArgument(),
                           QGenericArgument val5 = QGenericArgument(),
                           QGenericArgument val6 = QGenericArgument(),
                           QGenericArgument val7 = QGenericArgument(),
                           QGenericArgument val8 = QGenericArgument(),
                           QGenericArgument val9 = QGenericArgument());

  static inline bool
  invokeMethod(QObject *obj, const char *member, QGenericReturnArgument ret,
               QGenericArgument val0 = QGenericArgument(nullptr),
               QGenericArgument val1 = QGenericArgument(),
               QGenericArgument val2 = QGenericArgument(),
               QGenericArgument val3 = QGenericArgument(),
               QGenericArgument val4 = QGenericArgument(),
               QGenericArgument val5 = QGenericArgument(),
               QGenericArgument val6 = QGenericArgument(),
               QGenericArgument val7 = QGenericArgument(),
               QGenericArgument val8 = QGenericArgument(),
               QGenericArgument val9 = QGenericArgument()) {
    return invokeMethod(obj, member, Qt::AutoConnection, ret, val0, val1, val2,
                        val3, val4, val5, val6, val7, val8, val9);
  }

  static inline bool
  invokeMethod(QObject *obj, const char *member, Qt::ConnectionType type,
               QGenericArgument val0 = QGenericArgument(nullptr),
               QGenericArgument val1 = QGenericArgument(),
               QGenericArgument val2 = QGenericArgument(),
               QGenericArgument val3 = QGenericArgument(),
               QGenericArgument val4 = QGenericArgument(),
               QGenericArgument val5 = QGenericArgument(),
               QGenericArgument val6 = QGenericArgument(),
               QGenericArgument val7 = QGenericArgument(),
               QGenericArgument val8 = QGenericArgument(),
               QGenericArgument val9 = QGenericArgument()) {
    return invokeMethod(obj, member, type, QGenericReturnArgument(), val0, val1,
                        val2, val3, val4, val5, val6, val7, val8, val9);
  }

  static inline bool
  invokeMethod(QObject *obj, const char *member,
               QGenericArgument val0 = QGenericArgument(nullptr),
               QGenericArgument val1 = QGenericArgument(),
               QGenericArgument val2 = QGenericArgument(),
               QGenericArgument val3 = QGenericArgument(),
               QGenericArgument val4 = QGenericArgument(),
               QGenericArgument val5 = QGenericArgument(),
               QGenericArgument val6 = QGenericArgument(),
               QGenericArgument val7 = QGenericArgument(),
               QGenericArgument val8 = QGenericArgument(),
               QGenericArgument val9 = QGenericArgument()) {
    return invokeMethod(obj, member, Qt::AutoConnection,
                        QGenericReturnArgument(), val0, val1, val2, val3, val4,
                        val5, val6, val7, val8, val9);
  }
# 472 "/usr/local/include/QtCore/qobjectdefs.h"
  template <typename Func>
  static typename std::enable_if<
      QtPrivate::FunctionPointer<Func>::IsPointerToMemberFunction &&
          !std::is_convertible<Func, const char *>::value &&
          QtPrivate::FunctionPointer<Func>::ArgumentCount == 0,
      bool>::type
  invokeMethod(
      typename QtPrivate::FunctionPointer<Func>::Object *object, Func function,
      Qt::ConnectionType type = Qt::AutoConnection,
      typename QtPrivate::FunctionPointer<Func>::ReturnType *ret = nullptr) {
    return invokeMethodImpl(
        object, new QtPrivate::QSlotObjectWithNoArgs<Func>(function), type,
        ret);
  }

  template <typename Func>
  static typename std::enable_if<
      QtPrivate::FunctionPointer<Func>::IsPointerToMemberFunction &&
          !std::is_convertible<Func, const char *>::value &&
          QtPrivate::FunctionPointer<Func>::ArgumentCount == 0,
      bool>::type
  invokeMethod(typename QtPrivate::FunctionPointer<Func>::Object *object,
               Func function,
               typename QtPrivate::FunctionPointer<Func>::ReturnType *ret) {
    return invokeMethodImpl(
        object, new QtPrivate::QSlotObjectWithNoArgs<Func>(function),
        Qt::AutoConnection, ret);
  }

  template <typename Func>
  static typename std::enable_if<
      !QtPrivate::FunctionPointer<Func>::IsPointerToMemberFunction &&
          !std::is_convertible<Func, const char *>::value &&
          QtPrivate::FunctionPointer<Func>::ArgumentCount == 0,
      bool>::type
  invokeMethod(
      QObject *context, Func function,
      Qt::ConnectionType type = Qt::AutoConnection,
      typename QtPrivate::FunctionPointer<Func>::ReturnType *ret = nullptr) {
    return invokeMethodImpl(
        context,
        new QtPrivate::QFunctorSlotObjectWithNoArgsImplicitReturn<Func>(
            function),
        type, ret);
  }

  template <typename Func>
  static typename std::enable_if<
      !QtPrivate::FunctionPointer<Func>::IsPointerToMemberFunction &&
          !std::is_convertible<Func, const char *>::value &&
          QtPrivate::FunctionPointer<Func>::ArgumentCount == 0,
      bool>::type
  invokeMethod(QObject *context, Func function,
               typename QtPrivate::FunctionPointer<Func>::ReturnType *ret) {
    return invokeMethodImpl(
        context,
        new QtPrivate::QFunctorSlotObjectWithNoArgsImplicitReturn<Func>(
            function),
        Qt::AutoConnection, ret);
  }

  template <typename Func>
  static typename std::enable_if<
      !QtPrivate::FunctionPointer<Func>::IsPointerToMemberFunction &&
          QtPrivate::FunctionPointer<Func>::ArgumentCount == -1 &&
          !std::is_convertible<Func, const char *>::value,
      bool>::type
  invokeMethod(QObject *context, Func function,
               Qt::ConnectionType type = Qt::AutoConnection,
               decltype(function()) *ret = nullptr) {
    return invokeMethodImpl(
        context,
        new QtPrivate::QFunctorSlotObjectWithNoArgs<Func, decltype(function())>(
            std::move(function)),
        type, ret);
  }

  template <typename Func>
  static typename std::enable_if<
      !QtPrivate::FunctionPointer<Func>::IsPointerToMemberFunction &&
          QtPrivate::FunctionPointer<Func>::ArgumentCount == -1 &&
          !std::is_convertible<Func, const char *>::value,
      bool>::type
  invokeMethod(QObject *context, Func function, decltype(function()) *ret) {
    return invokeMethodImpl(
        context,
        new QtPrivate::QFunctorSlotObjectWithNoArgs<Func, decltype(function())>(
            std::move(function)),
        Qt::AutoConnection, ret);
  }

  QObject *newInstance(QGenericArgument val0 = QGenericArgument(nullptr),
                       QGenericArgument val1 = QGenericArgument(),
                       QGenericArgument val2 = QGenericArgument(),
                       QGenericArgument val3 = QGenericArgument(),
                       QGenericArgument val4 = QGenericArgument(),
                       QGenericArgument val5 = QGenericArgument(),
                       QGenericArgument val6 = QGenericArgument(),
                       QGenericArgument val7 = QGenericArgument(),
                       QGenericArgument val8 = QGenericArgument(),
                       QGenericArgument val9 = QGenericArgument()) const;

  enum Call {
    InvokeMetaMethod,
    ReadProperty,
    WriteProperty,
    ResetProperty,
    QueryPropertyDesignable,
    QueryPropertyScriptable,
    QueryPropertyStored,
    QueryPropertyEditable,
    QueryPropertyUser,
    CreateInstance,
    IndexOfMethod,
    RegisterPropertyMetaType,
    RegisterMethodArgumentMetaType
  };

  int static_metacall(Call, int, void **) const;
  static int metacall(QObject *, Call, int, void **);

  template <const QMetaObject &MO>
  static constexpr const QMetaObject *staticMetaObject() {
    return &MO;
  }

  struct SuperData {
    const QMetaObject *direct;
    SuperData() = default;
    constexpr SuperData(std::nullptr_t) : direct(nullptr) {}
    constexpr SuperData(const QMetaObject *mo) : direct(mo) {}

    constexpr const QMetaObject *operator->() const {
      return operator const QMetaObject *();
    }
# 597 "/usr/local/include/QtCore/qobjectdefs.h"
    constexpr operator const QMetaObject *() const { return direct; }
    template <const QMetaObject &MO> static constexpr SuperData link() {
      return SuperData(QMetaObject::staticMetaObject<MO>());
    }
  };

  struct {
    SuperData superdata;
    const QByteArrayData *stringdata;
    const uint *data;
    typedef void (*StaticMetacallFunction)(QObject *, QMetaObject::Call, int,
                                           void **);
    StaticMetacallFunction static_metacall;
    const SuperData *relatedMetaObjects;
    void *extradata;
  } d;

private:
  static bool invokeMethodImpl(QObject *object,
                               QtPrivate::QSlotObjectBase *slot,
                               Qt::ConnectionType type, void *ret);
  friend class QTimer;
};

class __attribute__((visibility("default"))) QMetaObject::Connection {
  void *d_ptr;
  explicit Connection(void *data) : d_ptr(data) {}
  friend class QObject;
  friend class QObjectPrivate;
  friend struct QMetaObject;
  bool isConnected_helper() const;

public:
  ~Connection();
  Connection();
  Connection(const Connection &other);
  Connection &operator=(const Connection &other);

  typedef void *Connection::*RestrictedBool;
  operator RestrictedBool() const {
    return d_ptr && isConnected_helper() ? &Connection::d_ptr : nullptr;
  }

  Connection(Connection &&o) noexcept : d_ptr(o.d_ptr) { o.d_ptr = nullptr; }
  Connection &operator=(Connection &&other) noexcept {
    qSwap(d_ptr, other.d_ptr);
    return *this;
  }
};

inline const QMetaObject *QMetaObject::superClass() const {
  return d.superdata;
}

namespace QtPrivate {

template <typename Object> struct HasQ_OBJECT_Macro {
  template <typename T>
  static char test(int (T::*)(QMetaObject::Call, int, void **));
  static int test(int (Object::*)(QMetaObject::Call, int, void **));
  enum { Value = sizeof(test(&Object::qt_metacall)) == sizeof(int) };
};
} // namespace QtPrivate
# 28 "./verdigris/wobjectdefs.h" 2
# 1 "/usr/local/include/QtCore/qmetatype.h" 1
# 46 "/usr/local/include/QtCore/qmetatype.h"
# 1 "/usr/local/include/QtCore/qatomic.h" 1
# 47 "/usr/local/include/QtCore/qmetatype.h" 2
# 1 "/usr/local/include/QtCore/qbytearray.h" 1
# 44 "/usr/local/include/QtCore/qbytearray.h"
# 1 "/usr/local/include/QtCore/qrefcount.h" 1
# 43 "/usr/local/include/QtCore/qrefcount.h"
# 1 "/usr/local/include/QtCore/qatomic.h" 1
# 44 "/usr/local/include/QtCore/qrefcount.h" 2

namespace QtPrivate {

class RefCount {
public:
  inline bool ref() noexcept {
    int count = atomic.loadRelaxed();

    if (count == 0)
      return false;

    if (count != -1)
      atomic.ref();
    return true;
  }

  inline bool deref() noexcept {
    int count = atomic.loadRelaxed();

    if (count == 0)
      return false;

    if (count == -1)
      return true;
    return atomic.deref();
  }

  bool setSharable(bool sharable) noexcept {
    ((!isShared()) ? static_cast<void>(0)
                   : qt_assert("!isShared()",
                               "/usr/local/include/QtCore/qrefcount.h", 79));
    if (sharable)
      return atomic.testAndSetRelaxed(0, 1);
    else
      return atomic.testAndSetRelaxed(1, 0);
  }

  bool isSharable() const noexcept { return atomic.loadRelaxed() != 0; }

  bool isStatic() const noexcept { return atomic.loadRelaxed() == -1; }

  bool isShared() const noexcept {
    int count = atomic.loadRelaxed();
    return (count != 1) && (count != 0);
  }

  void initializeOwned() noexcept { atomic.storeRelaxed(1); }
  void initializeUnsharable() noexcept { atomic.storeRelaxed(0); }

  QBasicAtomicInt atomic;
};

} // namespace QtPrivate
# 45 "/usr/local/include/QtCore/qbytearray.h" 2

# 1 "/usr/local/include/QtCore/qarraydata.h" 1
# 48 "/usr/local/include/QtCore/qarraydata.h"
struct __attribute__((visibility("default"))) QArrayData {
  QtPrivate::RefCount ref;
  int size;
  uint alloc : 31;
  uint capacityReserved : 1;

  qptrdiff offset;

  void *data() {
    ((size == 0 || offset < 0 || size_t(offset) >= sizeof(QArrayData))
         ? static_cast<void>(0)
         : qt_assert("size == 0 || offset < 0 || size_t(offset) >= "
                     "sizeof(QArrayData)",
                     "/usr/local/include/QtCore/qarraydata.h", 60));

    return reinterpret_cast<char *>(this) + offset;
  }

  const void *data() const {
    ((size == 0 || offset < 0 || size_t(offset) >= sizeof(QArrayData))
         ? static_cast<void>(0)
         : qt_assert("size == 0 || offset < 0 || size_t(offset) >= "
                     "sizeof(QArrayData)",
                     "/usr/local/include/QtCore/qarraydata.h", 67));

    return reinterpret_cast<const char *>(this) + offset;
  }

  bool isMutable() const { return alloc != 0; }

  enum AllocationOption {
    CapacityReserved = 0x1,

    Unsharable = 0x2,

    RawData = 0x4,
    Grow = 0x8,

    Default = 0
  };

  typedef QFlags<AllocationOption> AllocationOptions;

  size_t detachCapacity(size_t newSize) const {
    if (capacityReserved && newSize < alloc)
      return alloc;
    return newSize;
  }

  AllocationOptions detachFlags() const {
    AllocationOptions result;
    if (capacityReserved)
      result |= CapacityReserved;
    return result;
  }

  AllocationOptions cloneFlags() const {
    AllocationOptions result;
    if (capacityReserved)
      result |= CapacityReserved;
    return result;
  }

  __attribute__((__warn_unused_result__)) static QArrayData *
  allocate(size_t objectSize, size_t alignment, size_t capacity,
           AllocationOptions options = Default) noexcept;
  __attribute__((__warn_unused_result__)) static QArrayData *
  reallocateUnaligned(QArrayData *data, size_t objectSize, size_t newCapacity,
                      AllocationOptions newOptions = Default) noexcept;
  static void deallocate(QArrayData *data, size_t objectSize,
                         size_t alignment) noexcept;

  static const QArrayData shared_null[2];
  static QArrayData *sharedNull() noexcept {
    return const_cast<QArrayData *>(shared_null);
  }
};

constexpr inline QFlags<QArrayData::AllocationOptions::enum_type>
operator|(QArrayData::AllocationOptions::enum_type f1,
          QArrayData::AllocationOptions::enum_type f2) noexcept {
  return QFlags<QArrayData::AllocationOptions::enum_type>(f1) | f2;
}
constexpr inline QFlags<QArrayData::AllocationOptions::enum_type>
operator|(QArrayData::AllocationOptions::enum_type f1,
          QFlags<QArrayData::AllocationOptions::enum_type> f2) noexcept {
  return f2 | f1;
}
constexpr inline QIncompatibleFlag
operator|(QArrayData::AllocationOptions::enum_type f1, int f2) noexcept {
  return QIncompatibleFlag(int(f1) | f2);
}

template <class T> struct QTypedArrayData : QArrayData {
# 204 "/usr/local/include/QtCore/qarraydata.h"
  typedef T *iterator;
  typedef const T *const_iterator;

  T *data() { return static_cast<T *>(QArrayData::data()); }
  const T *data() const { return static_cast<const T *>(QArrayData::data()); }

  iterator begin(iterator = iterator()) { return data(); }
  iterator end(iterator = iterator()) { return data() + size; }
  const_iterator begin(const_iterator = const_iterator()) const {
    return data();
  }
  const_iterator end(const_iterator = const_iterator()) const {
    return data() + size;
  }
  const_iterator constBegin(const_iterator = const_iterator()) const {
    return data();
  }
  const_iterator constEnd(const_iterator = const_iterator()) const {
    return data() + size;
  }

  class AlignmentDummy {
    QArrayData header;
    T data;
  };

  __attribute__((__warn_unused_result__)) static QTypedArrayData *
  allocate(size_t capacity, AllocationOptions options = Default) {
    static_assert(bool(sizeof(QTypedArrayData) == sizeof(QArrayData)),
                  "sizeof(QTypedArrayData) == sizeof(QArrayData)");
    return static_cast<QTypedArrayData *>(QArrayData::allocate(
        sizeof(T), alignof(AlignmentDummy), capacity, options));
  }

  static QTypedArrayData *
  reallocateUnaligned(QTypedArrayData *data, size_t capacity,
                      AllocationOptions options = Default) {
    static_assert(bool(sizeof(QTypedArrayData) == sizeof(QArrayData)),
                  "sizeof(QTypedArrayData) == sizeof(QArrayData)");
    return static_cast<QTypedArrayData *>(
        QArrayData::reallocateUnaligned(data, sizeof(T), capacity, options));
  }

  static void deallocate(QArrayData *data) {
    static_assert(bool(sizeof(QTypedArrayData) == sizeof(QArrayData)),
                  "sizeof(QTypedArrayData) == sizeof(QArrayData)");
    QArrayData::deallocate(data, sizeof(T), alignof(AlignmentDummy));
  }

  static QTypedArrayData *fromRawData(const T *data, size_t n,
                                      AllocationOptions options = Default) {
    static_assert(bool(sizeof(QTypedArrayData) == sizeof(QArrayData)),
                  "sizeof(QTypedArrayData) == sizeof(QArrayData)");
    QTypedArrayData *result = allocate(0, options | RawData);
    if (result) {
      ((!result->ref.isShared())
           ? static_cast<void>(0)
           : qt_assert("!result->ref.isShared()",
                       "/usr/local/include/QtCore/qarraydata.h", 248));

      result->offset = reinterpret_cast<const char *>(data) -
                       reinterpret_cast<const char *>(result);
      result->size = int(n);
    }
    return result;
  }

  static QTypedArrayData *sharedNull() noexcept {
    static_assert(bool(sizeof(QTypedArrayData) == sizeof(QArrayData)),
                  "sizeof(QTypedArrayData) == sizeof(QArrayData)");
    return static_cast<QTypedArrayData *>(QArrayData::sharedNull());
  }

  static QTypedArrayData *sharedEmpty() {
    static_assert(bool(sizeof(QTypedArrayData) == sizeof(QArrayData)),
                  "sizeof(QTypedArrayData) == sizeof(QArrayData)");
    return allocate(0);
  }

  static QTypedArrayData *unsharableEmpty() {
    static_assert(bool(sizeof(QTypedArrayData) == sizeof(QArrayData)),
                  "sizeof(QTypedArrayData) == sizeof(QArrayData)");
    return allocate(0, Unsharable);
  }
};

template <class T, size_t N> struct QStaticArrayData {
  QArrayData header;
  T data[N];
};

template <class T> struct QArrayDataPointerRef { QTypedArrayData<T> *ptr; };
# 347 "/usr/local/include/QtCore/qarraydata.h"
namespace QtPrivate {
struct __attribute__((visibility("default"))) QContainerImplHelper {
  enum CutResult { Null, Empty, Full, Subset };
  static CutResult mid(int originalLength, int *position, int *length);
};
} // namespace QtPrivate
# 47 "/usr/local/include/QtCore/qbytearray.h" 2

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/stdlib.h" 1 3
# 49 "/usr/local/include/QtCore/qbytearray.h" 2
# 60 "/usr/local/include/QtCore/qbytearray.h"
typedef const struct __CFData *CFDataRef;
typedef struct objc_object NSData;
# 71 "/usr/local/include/QtCore/qbytearray.h"
__attribute__((visibility("default"))) char *qstrdup(const char *);

inline uint qstrlen(const char *str) { return str ? uint(strlen(str)) : 0; }

inline uint qstrnlen(const char *str, uint maxlen) {
  uint length = 0;
  if (str) {
    while (length < maxlen && *str++)
      length++;
  }
  return length;
}

__attribute__((visibility("default"))) char *qstrcpy(char *dst,
                                                     const char *src);
__attribute__((visibility("default"))) char *
qstrncpy(char *dst, const char *src, uint len);

__attribute__((visibility("default"))) int qstrcmp(const char *str1,
                                                   const char *str2);
__attribute__((visibility("default"))) int qstrcmp(const QByteArray &str1,
                                                   const QByteArray &str2);
__attribute__((visibility("default"))) int qstrcmp(const QByteArray &str1,
                                                   const char *str2);
static inline int qstrcmp(const char *str1, const QByteArray &str2) {
  return -qstrcmp(str2, str1);
}

inline int qstrncmp(const char *str1, const char *str2, uint len) {
  return (str1 && str2) ? strncmp(str1, str2, len)
                        : (str1 ? 1 : (str2 ? -1 : 0));
}
__attribute__((visibility("default"))) int qstricmp(const char *, const char *);
__attribute__((visibility("default"))) int qstrnicmp(const char *, const char *,
                                                     uint len);
__attribute__((visibility("default"))) int
qstrnicmp(const char *, qsizetype, const char *, qsizetype = -1);

__attribute__((visibility("default"))) int
qvsnprintf(char *str, size_t n, const char *fmt, va_list ap);
__attribute__((visibility("default"))) int qsnprintf(char *str, size_t n,
                                                     const char *fmt, ...);

__attribute__((visibility("default"))) quint16 qChecksum(const char *s,
                                                         uint len);
__attribute__((visibility("default"))) quint16
qChecksum(const char *s, uint len, Qt::ChecksumType standard);

class QByteRef;
class QString;
class QDataStream;
template <typename T> class QList;

typedef QArrayData QByteArrayData;

template <int N> struct QStaticByteArrayData {
  QByteArrayData ba;
  char data[N + 1];

  QByteArrayData *data_ptr() const {
    ((ba.ref.isStatic())
         ? static_cast<void>(0)
         : qt_assert("ba.ref.isStatic()",
                     "/usr/local/include/QtCore/qbytearray.h", 126));
    return const_cast<QByteArrayData *>(&ba);
  }
};

struct QByteArrayDataPtr {
  QByteArrayData *ptr;
};
# 156 "/usr/local/include/QtCore/qbytearray.h"
class __attribute__((visibility("default"))) QByteArray {
private:
  typedef QTypedArrayData<char> Data;

public:
  enum Base64Option {
    Base64Encoding = 0,
    Base64UrlEncoding = 1,

    KeepTrailingEquals = 0,
    OmitTrailingEquals = 2,

    IgnoreBase64DecodingErrors = 0,
    AbortOnBase64DecodingErrors = 4,
  };
  typedef QFlags<Base64Option> Base64Options;

  enum class Base64DecodingStatus {
    Ok,
    IllegalInputLength,
    IllegalCharacter,
    IllegalPadding,
  };

  inline QByteArray() noexcept;
  QByteArray(const char *, int size = -1);
  QByteArray(int size, char c);
  QByteArray(int size, Qt::Initialization);
  inline QByteArray(const QByteArray &) noexcept;
  inline ~QByteArray();

  QByteArray &operator=(const QByteArray &) noexcept;
  QByteArray &operator=(const char *str);
  inline QByteArray(QByteArray &&other) noexcept : d(other.d) {
    other.d = Data::sharedNull();
  }
  inline QByteArray &operator=(QByteArray &&other) noexcept {
    qSwap(d, other.d);
    return *this;
  }

  inline void swap(QByteArray &other) noexcept { qSwap(d, other.d); }

  inline int size() const;
  inline bool isEmpty() const;
  void resize(int size);

  QByteArray &fill(char c, int size = -1);

  inline int capacity() const;
  inline void reserve(int size);
  inline void squeeze();

  inline operator const char *() const;
  inline operator const void *() const;

  inline char *data();
  inline const char *data() const;
  inline const char *constData() const;
  inline void detach();
  inline bool isDetached() const;
  inline bool isSharedWith(const QByteArray &other) const {
    return d == other.d;
  }
  void clear();

  inline char at(int i) const;
  inline char operator[](int i) const;
  inline char operator[](uint i) const;
  __attribute__((__warn_unused_result__)) inline QByteRef operator[](int i);
  __attribute__((__warn_unused_result__)) inline QByteRef operator[](uint i);
  __attribute__((__warn_unused_result__)) char front() const { return at(0); }
  __attribute__((__warn_unused_result__)) inline QByteRef front();
  __attribute__((__warn_unused_result__)) char back() const {
    return at(size() - 1);
  }
  __attribute__((__warn_unused_result__)) inline QByteRef back();

  int indexOf(char c, int from = 0) const;
  int indexOf(const char *c, int from = 0) const;
  int indexOf(const QByteArray &a, int from = 0) const;
  int lastIndexOf(char c, int from = -1) const;
  int lastIndexOf(const char *c, int from = -1) const;
  int lastIndexOf(const QByteArray &a, int from = -1) const;

  inline bool contains(char c) const;
  inline bool contains(const char *a) const;
  inline bool contains(const QByteArray &a) const;
  int count(char c) const;
  int count(const char *a) const;
  int count(const QByteArray &a) const;

  inline int compare(const char *c,
                     Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept;
  inline int compare(const QByteArray &a,
                     Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept;

  __attribute__((__warn_unused_result__)) QByteArray left(int len) const;
  __attribute__((__warn_unused_result__)) QByteArray right(int len) const;
  __attribute__((__warn_unused_result__)) QByteArray mid(int index,
                                                         int len = -1) const;
  __attribute__((__warn_unused_result__)) QByteArray chopped(int len) const {
    ((len >= 0) ? static_cast<void>(0)
                : qt_assert("len >= 0",
                            "/usr/local/include/QtCore/qbytearray.h", 250));
    ((len <= size())
         ? static_cast<void>(0)
         : qt_assert("len <= size()", "/usr/local/include/QtCore/qbytearray.h",
                     250));
    return left(size() - len);
  }

  bool startsWith(const QByteArray &a) const;
  bool startsWith(char c) const;
  bool startsWith(const char *c) const;

  bool endsWith(const QByteArray &a) const;
  bool endsWith(char c) const;
  bool endsWith(const char *c) const;

  bool isUpper() const;
  bool isLower() const;

  void truncate(int pos);
  void chop(int n);
# 274 "/usr/local/include/QtCore/qbytearray.h"
  __attribute__((__warn_unused_result__)) QByteArray toLower() const & {
    return toLower_helper(*this);
  }
  __attribute__((__warn_unused_result__)) QByteArray toLower() && {
    return toLower_helper(*this);
  }
  __attribute__((__warn_unused_result__)) QByteArray toUpper() const & {
    return toUpper_helper(*this);
  }
  __attribute__((__warn_unused_result__)) QByteArray toUpper() && {
    return toUpper_helper(*this);
  }
  __attribute__((__warn_unused_result__)) QByteArray trimmed() const & {
    return trimmed_helper(*this);
  }
  __attribute__((__warn_unused_result__)) QByteArray trimmed() && {
    return trimmed_helper(*this);
  }
  __attribute__((__warn_unused_result__)) QByteArray simplified() const & {
    return simplified_helper(*this);
  }
  __attribute__((__warn_unused_result__)) QByteArray simplified() && {
    return simplified_helper(*this);
  }
# 300 "/usr/local/include/QtCore/qbytearray.h"
  __attribute__((__warn_unused_result__)) QByteArray
  leftJustified(int width, char fill = ' ', bool truncate = false) const;
  __attribute__((__warn_unused_result__)) QByteArray
  rightJustified(int width, char fill = ' ', bool truncate = false) const;

  QByteArray &prepend(char c);
  inline QByteArray &prepend(int count, char c);
  QByteArray &prepend(const char *s);
  QByteArray &prepend(const char *s, int len);
  QByteArray &prepend(const QByteArray &a);
  QByteArray &append(char c);
  inline QByteArray &append(int count, char c);
  QByteArray &append(const char *s);
  QByteArray &append(const char *s, int len);
  QByteArray &append(const QByteArray &a);
  QByteArray &insert(int i, char c);
  QByteArray &insert(int i, int count, char c);
  QByteArray &insert(int i, const char *s);
  QByteArray &insert(int i, const char *s, int len);
  QByteArray &insert(int i, const QByteArray &a);
  QByteArray &remove(int index, int len);
  QByteArray &replace(int index, int len, const char *s);
  QByteArray &replace(int index, int len, const char *s, int alen);
  QByteArray &replace(int index, int len, const QByteArray &s);
  inline QByteArray &replace(char before, const char *after);
  QByteArray &replace(char before, const QByteArray &after);
  inline QByteArray &replace(const char *before, const char *after);
  QByteArray &replace(const char *before, int bsize, const char *after,
                      int asize);
  QByteArray &replace(const QByteArray &before, const QByteArray &after);
  inline QByteArray &replace(const QByteArray &before, const char *after);
  QByteArray &replace(const char *before, const QByteArray &after);
  QByteArray &replace(char before, char after);
  inline QByteArray &operator+=(char c);
  inline QByteArray &operator+=(const char *s);
  inline QByteArray &operator+=(const QByteArray &a);

  QList<QByteArray> split(char sep) const;

  __attribute__((__warn_unused_result__)) QByteArray repeated(int times) const;

  QByteArray &append(const QString &s);
  QByteArray &insert(int i, const QString &s);
  QByteArray &replace(const QString &before, const char *after);
  QByteArray &replace(char c, const QString &after);
  QByteArray &replace(const QString &before, const QByteArray &after);

  QByteArray &operator+=(const QString &s);
  int indexOf(const QString &s, int from = 0) const;
  int lastIndexOf(const QString &s, int from = -1) const;

  inline bool operator==(const QString &s2) const;
  inline bool operator!=(const QString &s2) const;
  inline bool operator<(const QString &s2) const;
  inline bool operator>(const QString &s2) const;
  inline bool operator<=(const QString &s2) const;
  inline bool operator>=(const QString &s2) const;

  short toShort(bool *ok = nullptr, int base = 10) const;
  ushort toUShort(bool *ok = nullptr, int base = 10) const;
  int toInt(bool *ok = nullptr, int base = 10) const;
  uint toUInt(bool *ok = nullptr, int base = 10) const;
  long toLong(bool *ok = nullptr, int base = 10) const;
  ulong toULong(bool *ok = nullptr, int base = 10) const;
  qlonglong toLongLong(bool *ok = nullptr, int base = 10) const;
  qulonglong toULongLong(bool *ok = nullptr, int base = 10) const;
  float toFloat(bool *ok = nullptr) const;
  double toDouble(bool *ok = nullptr) const;
  QByteArray toBase64(Base64Options options) const;
  QByteArray toBase64() const;
  QByteArray toHex() const;
  QByteArray toHex(char separator) const;
  QByteArray toPercentEncoding(const QByteArray &exclude = QByteArray(),
                               const QByteArray &include = QByteArray(),
                               char percent = '%') const;

  inline QByteArray &setNum(short, int base = 10);
  inline QByteArray &setNum(ushort, int base = 10);
  inline QByteArray &setNum(int, int base = 10);
  inline QByteArray &setNum(uint, int base = 10);
  QByteArray &setNum(qlonglong, int base = 10);
  QByteArray &setNum(qulonglong, int base = 10);
  inline QByteArray &setNum(float, char f = 'g', int prec = 6);
  QByteArray &setNum(double, char f = 'g', int prec = 6);
  QByteArray &setRawData(const char *a, uint n);

  __attribute__((__warn_unused_result__)) static QByteArray
  number(int, int base = 10);
  __attribute__((__warn_unused_result__)) static QByteArray
  number(uint, int base = 10);
  __attribute__((__warn_unused_result__)) static QByteArray
  number(qlonglong, int base = 10);
  __attribute__((__warn_unused_result__)) static QByteArray
  number(qulonglong, int base = 10);
  __attribute__((__warn_unused_result__)) static QByteArray
  number(double, char f = 'g', int prec = 6);
  __attribute__((__warn_unused_result__)) static QByteArray
  fromRawData(const char *, int size);

  class FromBase64Result;
  __attribute__((__warn_unused_result__)) static FromBase64Result
  fromBase64Encoding(QByteArray &&base64,
                     Base64Options options = Base64Encoding);
  __attribute__((__warn_unused_result__)) static FromBase64Result
  fromBase64Encoding(const QByteArray &base64,
                     Base64Options options = Base64Encoding);
  __attribute__((__warn_unused_result__)) static QByteArray
  fromBase64(const QByteArray &base64, Base64Options options);
  __attribute__((__warn_unused_result__)) static QByteArray
  fromBase64(const QByteArray &base64);
  __attribute__((__warn_unused_result__)) static QByteArray
  fromHex(const QByteArray &hexEncoded);
  __attribute__((__warn_unused_result__)) static QByteArray
  fromPercentEncoding(const QByteArray &pctEncoded, char percent = '%');

  static QByteArray fromCFData(CFDataRef data);
  static QByteArray fromRawCFData(CFDataRef data);
  CFDataRef toCFData() const __attribute__((cf_returns_retained));
  CFDataRef toRawCFData() const __attribute__((cf_returns_retained));
  static QByteArray fromNSData(const NSData *data);
  static QByteArray fromRawNSData(const NSData *data);
  NSData *toNSData() const;
  NSData *toRawNSData() const;

  typedef char *iterator;
  typedef const char *const_iterator;
  typedef iterator Iterator;
  typedef const_iterator ConstIterator;
  typedef std::reverse_iterator<iterator> reverse_iterator;
  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
  inline iterator begin();
  inline const_iterator begin() const;
  inline const_iterator cbegin() const;
  inline const_iterator constBegin() const;
  inline iterator end();
  inline const_iterator end() const;
  inline const_iterator cend() const;
  inline const_iterator constEnd() const;
  reverse_iterator rbegin() { return reverse_iterator(end()); }
  reverse_iterator rend() { return reverse_iterator(begin()); }
  const_reverse_iterator rbegin() const {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator rend() const {
    return const_reverse_iterator(begin());
  }
  const_reverse_iterator crbegin() const {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator crend() const {
    return const_reverse_iterator(begin());
  }

  typedef int size_type;
  typedef qptrdiff difference_type;
  typedef const char &const_reference;
  typedef char &reference;
  typedef char *pointer;
  typedef const char *const_pointer;
  typedef char value_type;
  inline void push_back(char c);
  inline void push_back(const char *c);
  inline void push_back(const QByteArray &a);
  inline void push_front(char c);
  inline void push_front(const char *c);
  inline void push_front(const QByteArray &a);
  void shrink_to_fit() { squeeze(); }

  static inline QByteArray fromStdString(const std::string &s);
  inline std::string toStdString() const;

  inline int count() const { return d->size; }
  int length() const { return d->size; }
  bool isNull() const;

  inline QByteArray(QByteArrayDataPtr dd) : d(static_cast<Data *>(dd.ptr)) {}

private:
  operator QNoImplicitBoolCast() const;
  Data *d;
  void reallocData(uint alloc, Data::AllocationOptions options);
  void expand(int i);
  QByteArray nulTerminated() const;

  static QByteArray toLower_helper(const QByteArray &a);
  static QByteArray toLower_helper(QByteArray &a);
  static QByteArray toUpper_helper(const QByteArray &a);
  static QByteArray toUpper_helper(QByteArray &a);
  static QByteArray trimmed_helper(const QByteArray &a);
  static QByteArray trimmed_helper(QByteArray &a);
  static QByteArray simplified_helper(const QByteArray &a);
  static QByteArray simplified_helper(QByteArray &a);

  friend class QByteRef;
  friend class QString;
  friend __attribute__((visibility("default"))) QByteArray
  qUncompress(const uchar *data, int nbytes);

public:
  typedef Data *DataPtr;
  inline DataPtr &data_ptr() { return d; }
};

constexpr inline QFlags<QByteArray::Base64Options::enum_type>
operator|(QByteArray::Base64Options::enum_type f1,
          QByteArray::Base64Options::enum_type f2) noexcept {
  return QFlags<QByteArray::Base64Options::enum_type>(f1) | f2;
}
constexpr inline QFlags<QByteArray::Base64Options::enum_type>
operator|(QByteArray::Base64Options::enum_type f1,
          QFlags<QByteArray::Base64Options::enum_type> f2) noexcept {
  return f2 | f1;
}
constexpr inline QIncompatibleFlag
operator|(QByteArray::Base64Options::enum_type f1, int f2) noexcept {
  return QIncompatibleFlag(int(f1) | f2);
}

inline QByteArray::QByteArray() noexcept : d(Data::sharedNull()) {}
inline QByteArray::~QByteArray() {
  if (!d->ref.deref())
    Data::deallocate(d);
}
inline int QByteArray::size() const { return d->size; }

inline char QByteArray::at(int i) const {
  ((uint(i) < uint(size()))
       ? static_cast<void>(0)
       : qt_assert("uint(i) < uint(size())",
                   "/usr/local/include/QtCore/qbytearray.h", 493));
  return d->data()[i];
}
inline char QByteArray::operator[](int i) const {
  ((uint(i) < uint(size()))
       ? static_cast<void>(0)
       : qt_assert("uint(i) < uint(size())",
                   "/usr/local/include/QtCore/qbytearray.h", 495));
  return d->data()[i];
}
inline char QByteArray::operator[](uint i) const {
  ((i < uint(size()))
       ? static_cast<void>(0)
       : qt_assert("i < uint(size())", "/usr/local/include/QtCore/qbytearray.h",
                   497));
  return d->data()[i];
}

inline bool QByteArray::isEmpty() const { return d->size == 0; }

inline QByteArray::operator const char *() const { return d->data(); }
inline QByteArray::operator const void *() const { return d->data(); }

inline char *QByteArray::data() {
  detach();
  return d->data();
}
inline const char *QByteArray::data() const { return d->data(); }
inline const char *QByteArray::constData() const { return d->data(); }
inline void QByteArray::detach() {
  if (d->ref.isShared() || (d->offset != sizeof(QByteArrayData)))
    reallocData(uint(d->size) + 1u, d->detachFlags());
}
inline bool QByteArray::isDetached() const { return !d->ref.isShared(); }
inline QByteArray::QByteArray(const QByteArray &a) noexcept : d(a.d) {
  d->ref.ref();
}

inline int QByteArray::capacity() const { return d->alloc ? d->alloc - 1 : 0; }

inline void QByteArray::reserve(int asize) {
  if (d->ref.isShared() || uint(asize) + 1u > d->alloc) {
    reallocData(qMax(uint(size()), uint(asize)) + 1u,
                d->detachFlags() | Data::CapacityReserved);
  } else {

    d->capacityReserved = true;
  }
}

inline void QByteArray::squeeze() {
  if (d->ref.isShared() || uint(d->size) + 1u < d->alloc) {
    reallocData(uint(d->size) + 1u, d->detachFlags() & ~Data::CapacityReserved);
  } else {

    d->capacityReserved = false;
  }
}

namespace QtPrivate {
namespace DeprecatedRefClassBehavior {
enum class EmittingClass {
  QByteRef,
  QCharRef,
};

enum class WarningType {
  OutOfRange,
  DelayedDetach,
};

__attribute__((visibility("default"))) __attribute__((cold)) void
warn(WarningType w, EmittingClass c);
} // namespace DeprecatedRefClassBehavior
} // namespace QtPrivate

class

    __attribute__((visibility("default")))

    QByteRef {
  QByteArray &a;
  int i;
  inline QByteRef(QByteArray &array, int idx) : a(array), i(idx) {}
  friend class QByteArray;

public:
  inline operator char() const {
    using namespace QtPrivate::DeprecatedRefClassBehavior;
    if (__builtin_expect(!!(i < a.d->size), true))
      return a.d->data()[i];

    warn(WarningType::OutOfRange, EmittingClass::QByteRef);

    return char(0);
  }
  inline QByteRef &operator=(char c) {
    using namespace QtPrivate::DeprecatedRefClassBehavior;
    if (__builtin_expect(!!(i >= a.d->size), false)) {

      warn(WarningType::OutOfRange, EmittingClass::QByteRef);

      a.expand(i);
    } else {

      if (__builtin_expect(!!(!a.isDetached()), false))
        warn(WarningType::DelayedDetach, EmittingClass::QByteRef);

      a.detach();
    }
    a.d->data()[i] = c;
    return *this;
  }
  inline QByteRef &operator=(const QByteRef &c) { return operator=(char(c)); }
  inline bool operator==(char c) const { return a.d->data()[i] == c; }
  inline bool operator!=(char c) const { return a.d->data()[i] != c; }
  inline bool operator>(char c) const { return a.d->data()[i] > c; }
  inline bool operator>=(char c) const { return a.d->data()[i] >= c; }
  inline bool operator<(char c) const { return a.d->data()[i] < c; }
  inline bool operator<=(char c) const { return a.d->data()[i] <= c; }
};

inline QByteRef QByteArray::operator[](int i) {
  ((i >= 0)
       ? static_cast<void>(0)
       : qt_assert("i >= 0", "/usr/local/include/QtCore/qbytearray.h", 619));
  detach();
  return QByteRef(*this, i);
}
inline QByteRef QByteArray::operator[](uint i) {
  detach();
  return QByteRef(*this, i);
}
inline QByteRef QByteArray::front() { return operator[](0); }
inline QByteRef QByteArray::back() { return operator[](size() - 1); }
inline QByteArray::iterator QByteArray::begin() {
  detach();
  return d->data();
}
inline QByteArray::const_iterator QByteArray::begin() const {
  return d->data();
}
inline QByteArray::const_iterator QByteArray::cbegin() const {
  return d->data();
}
inline QByteArray::const_iterator QByteArray::constBegin() const {
  return d->data();
}
inline QByteArray::iterator QByteArray::end() {
  detach();
  return d->data() + d->size;
}
inline QByteArray::const_iterator QByteArray::end() const {
  return d->data() + d->size;
}
inline QByteArray::const_iterator QByteArray::cend() const {
  return d->data() + d->size;
}
inline QByteArray::const_iterator QByteArray::constEnd() const {
  return d->data() + d->size;
}
inline QByteArray &QByteArray::append(int n, char ch) {
  return insert(d->size, n, ch);
}
inline QByteArray &QByteArray::prepend(int n, char ch) {
  return insert(0, n, ch);
}
inline QByteArray &QByteArray::operator+=(char c) { return append(c); }
inline QByteArray &QByteArray::operator+=(const char *s) { return append(s); }
inline QByteArray &QByteArray::operator+=(const QByteArray &a) {
  return append(a);
}
inline void QByteArray::push_back(char c) { append(c); }
inline void QByteArray::push_back(const char *c) { append(c); }
inline void QByteArray::push_back(const QByteArray &a) { append(a); }
inline void QByteArray::push_front(char c) { prepend(c); }
inline void QByteArray::push_front(const char *c) { prepend(c); }
inline void QByteArray::push_front(const QByteArray &a) { prepend(a); }
inline bool QByteArray::contains(const QByteArray &a) const {
  return indexOf(a) != -1;
}
inline bool QByteArray::contains(char c) const { return indexOf(c) != -1; }
inline int QByteArray::compare(const char *c,
                               Qt::CaseSensitivity cs) const noexcept {
  return cs == Qt::CaseSensitive ? qstrcmp(*this, c)
                                 : qstrnicmp(data(), size(), c, -1);
}
inline int QByteArray::compare(const QByteArray &a,
                               Qt::CaseSensitivity cs) const noexcept {
  return cs == Qt::CaseSensitive
             ? qstrcmp(*this, a)
             : qstrnicmp(data(), size(), a.data(), a.size());
}
inline bool operator==(const QByteArray &a1, const QByteArray &a2) noexcept {
  return (a1.size() == a2.size()) &&
         (memcmp(a1.constData(), a2.constData(), a1.size()) == 0);
}
inline bool operator==(const QByteArray &a1, const char *a2) noexcept {
  return a2 ? qstrcmp(a1, a2) == 0 : a1.isEmpty();
}
inline bool operator==(const char *a1, const QByteArray &a2) noexcept {
  return a1 ? qstrcmp(a1, a2) == 0 : a2.isEmpty();
}
inline bool operator!=(const QByteArray &a1, const QByteArray &a2) noexcept {
  return !(a1 == a2);
}
inline bool operator!=(const QByteArray &a1, const char *a2) noexcept {
  return a2 ? qstrcmp(a1, a2) != 0 : !a1.isEmpty();
}
inline bool operator!=(const char *a1, const QByteArray &a2) noexcept {
  return a1 ? qstrcmp(a1, a2) != 0 : !a2.isEmpty();
}
inline bool operator<(const QByteArray &a1, const QByteArray &a2) noexcept {
  return qstrcmp(a1, a2) < 0;
}
inline bool operator<(const QByteArray &a1, const char *a2) noexcept {
  return qstrcmp(a1, a2) < 0;
}
inline bool operator<(const char *a1, const QByteArray &a2) noexcept {
  return qstrcmp(a1, a2) < 0;
}
inline bool operator<=(const QByteArray &a1, const QByteArray &a2) noexcept {
  return qstrcmp(a1, a2) <= 0;
}
inline bool operator<=(const QByteArray &a1, const char *a2) noexcept {
  return qstrcmp(a1, a2) <= 0;
}
inline bool operator<=(const char *a1, const QByteArray &a2) noexcept {
  return qstrcmp(a1, a2) <= 0;
}
inline bool operator>(const QByteArray &a1, const QByteArray &a2) noexcept {
  return qstrcmp(a1, a2) > 0;
}
inline bool operator>(const QByteArray &a1, const char *a2) noexcept {
  return qstrcmp(a1, a2) > 0;
}
inline bool operator>(const char *a1, const QByteArray &a2) noexcept {
  return qstrcmp(a1, a2) > 0;
}
inline bool operator>=(const QByteArray &a1, const QByteArray &a2) noexcept {
  return qstrcmp(a1, a2) >= 0;
}
inline bool operator>=(const QByteArray &a1, const char *a2) noexcept {
  return qstrcmp(a1, a2) >= 0;
}
inline bool operator>=(const char *a1, const QByteArray &a2) noexcept {
  return qstrcmp(a1, a2) >= 0;
}

inline const QByteArray operator+(const QByteArray &a1, const QByteArray &a2) {
  return QByteArray(a1) += a2;
}
inline const QByteArray operator+(const QByteArray &a1, const char *a2) {
  return QByteArray(a1) += a2;
}
inline const QByteArray operator+(const QByteArray &a1, char a2) {
  return QByteArray(a1) += a2;
}
inline const QByteArray operator+(const char *a1, const QByteArray &a2) {
  return QByteArray(a1) += a2;
}
inline const QByteArray operator+(char a1, const QByteArray &a2) {
  return QByteArray(&a1, 1) += a2;
}

inline bool QByteArray::contains(const char *c) const {
  return indexOf(c) != -1;
}
inline QByteArray &QByteArray::replace(char before, const char *c) {
  return replace(&before, 1, c, qstrlen(c));
}
inline QByteArray &QByteArray::replace(const QByteArray &before,
                                       const char *c) {
  return replace(before.constData(), before.size(), c, qstrlen(c));
}
inline QByteArray &QByteArray::replace(const char *before, const char *after) {
  return replace(before, qstrlen(before), after, qstrlen(after));
}

inline QByteArray &QByteArray::setNum(short n, int base) {
  return base == 10 ? setNum(qlonglong(n), base)
                    : setNum(qulonglong(ushort(n)), base);
}
inline QByteArray &QByteArray::setNum(ushort n, int base) {
  return setNum(qulonglong(n), base);
}
inline QByteArray &QByteArray::setNum(int n, int base) {
  return base == 10 ? setNum(qlonglong(n), base)
                    : setNum(qulonglong(uint(n)), base);
}
inline QByteArray &QByteArray::setNum(uint n, int base) {
  return setNum(qulonglong(n), base);
}
inline QByteArray &QByteArray::setNum(float n, char f, int prec) {
  return setNum(double(n), f, prec);
}

inline std::string QByteArray::toStdString() const {
  return std::string(constData(), length());
}

inline QByteArray QByteArray::fromStdString(const std::string &s) {
  return QByteArray(s.data(), int(s.size()));
}

__attribute__((visibility("default"))) QDataStream &
operator<<(QDataStream &, const QByteArray &);
__attribute__((visibility("default"))) QDataStream &operator>>(QDataStream &,
                                                               QByteArray &);

__attribute__((visibility("default"))) QByteArray
qCompress(const uchar *data, int nbytes, int compressionLevel = -1);
__attribute__((visibility("default"))) QByteArray qUncompress(const uchar *data,
                                                              int nbytes);
inline QByteArray qCompress(const QByteArray &data, int compressionLevel = -1) {
  return qCompress(reinterpret_cast<const uchar *>(data.constData()),
                   data.size(), compressionLevel);
}
inline QByteArray qUncompress(const QByteArray &data) {
  return qUncompress(reinterpret_cast<const uchar *>(data.constData()),
                     data.size());
}

template <> class QTypeInfo<QByteArray> {
public:
  enum {
    isSpecialized = true,
    isComplex =
        (((Q_MOVABLE_TYPE)&Q_PRIMITIVE_TYPE) == 0) && !qIsTrivial<QByteArray>(),
    isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0),
    isRelocatable = !isStatic || ((Q_MOVABLE_TYPE)&Q_RELOCATABLE_TYPE) ||
                    qIsRelocatable<QByteArray>(),
    isLarge = (sizeof(QByteArray) > sizeof(void *)),
    isPointer = false,
    isIntegral = std::is_integral<QByteArray>::value,
    isDummy = (((Q_MOVABLE_TYPE)&Q_DUMMY_TYPE) != 0),
    sizeOf = sizeof(QByteArray)
  };
  static inline const char *name() { return "QByteArray"; }
};
inline void swap(QByteArray &value1,
                 QByteArray &value2) noexcept(noexcept(value1.swap(value2))) {
  value1.swap(value2);
}

class QByteArray::FromBase64Result {
public:
  QByteArray decoded;
  QByteArray::Base64DecodingStatus decodingStatus;

  void swap(QByteArray::FromBase64Result &other) noexcept {
    qSwap(decoded, other.decoded);
    qSwap(decodingStatus, other.decodingStatus);
  }

  explicit operator bool() const noexcept {
    return decodingStatus == QByteArray::Base64DecodingStatus::Ok;
  }

  QByteArray &operator*() &noexcept { return decoded; }
  const QByteArray &operator*() const &noexcept { return decoded; }
  QByteArray &&operator*() &&noexcept { return std::move(decoded); }
};

template <> class QTypeInfo<QByteArray::FromBase64Result> {
public:
  enum {
    isSpecialized = true,
    isComplex = (((Q_MOVABLE_TYPE)&Q_PRIMITIVE_TYPE) == 0) &&
                !qIsTrivial<QByteArray::FromBase64Result>(),
    isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0),
    isRelocatable = !isStatic || ((Q_MOVABLE_TYPE)&Q_RELOCATABLE_TYPE) ||
                    qIsRelocatable<QByteArray::FromBase64Result>(),
    isLarge = (sizeof(QByteArray::FromBase64Result) > sizeof(void *)),
    isPointer = false,
    isIntegral = std::is_integral<QByteArray::FromBase64Result>::value,
    isDummy = (((Q_MOVABLE_TYPE)&Q_DUMMY_TYPE) != 0),
    sizeOf = sizeof(QByteArray::FromBase64Result)
  };
  static inline const char *name() { return "QByteArray::FromBase64Result"; }
};
inline void swap(QByteArray::FromBase64Result &value1,
                 QByteArray::FromBase64Result
                     &value2) noexcept(noexcept(value1.swap(value2))) {
  value1.swap(value2);
}

inline bool operator==(const QByteArray::FromBase64Result &lhs,
                       const QByteArray::FromBase64Result &rhs) noexcept {
  if (lhs.decodingStatus != rhs.decodingStatus)
    return false;

  if (lhs.decodingStatus == QByteArray::Base64DecodingStatus::Ok &&
      lhs.decoded != rhs.decoded)
    return false;

  return true;
}

inline bool operator!=(const QByteArray::FromBase64Result &lhs,
                       const QByteArray::FromBase64Result &rhs) noexcept {
  return !operator==(lhs, rhs);
}

__attribute__((visibility("default"))) __attribute__((pure)) uint
qHash(const QByteArray::FromBase64Result &key, uint seed = 0) noexcept;
# 48 "/usr/local/include/QtCore/qmetatype.h" 2
# 1 "/usr/local/include/QtCore/qvarlengtharray.h" 1
# 43 "/usr/local/include/QtCore/qvarlengtharray.h"
# 1 "/usr/local/include/QtCore/qcontainerfwd.h" 1
# 48 "/usr/local/include/QtCore/qcontainerfwd.h"
template <class Key, class T> class QCache;
template <class Key, class T> class QHash;

template <class T> class QLinkedList;

template <class T> class QList;
template <class Key, class T> class QMap;
template <class Key, class T> class QMultiHash;
template <class Key, class T> class QMultiMap;
template <class T1, class T2> struct QPair;
template <class T> class QQueue;
template <class T> class QSet;
template <class T> class QStack;
template <class T, int Prealloc = 256> class QVarLengthArray;
template <class T> class QVector;
# 44 "/usr/local/include/QtCore/qvarlengtharray.h" 2

# 1 "/usr/local/include/QtCore/qalgorithms.h" 1
# 50 "/usr/local/include/QtCore/qalgorithms.h"
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

namespace QAlgorithmsPrivate {

template <typename RandomAccessIterator, typename T, typename LessThan>
__attribute__((__deprecated__("Use std::sort"))) void
qSortHelper(RandomAccessIterator start, RandomAccessIterator end, const T &t,
            LessThan lessThan);
template <typename RandomAccessIterator, typename T>
__attribute__((__deprecated__("Use std::sort"))) inline void
qSortHelper(RandomAccessIterator begin, RandomAccessIterator end,
            const T &dummy);

template <typename RandomAccessIterator, typename T, typename LessThan>
__attribute__((__deprecated__("Use std::stable_sort"))) void
qStableSortHelper(RandomAccessIterator start, RandomAccessIterator end,
                  const T &t, LessThan lessThan);
template <typename RandomAccessIterator, typename T>
__attribute__((__deprecated__("Use std::stable_sort"))) inline void
qStableSortHelper(RandomAccessIterator, RandomAccessIterator, const T &);

template <typename RandomAccessIterator, typename T, typename LessThan>
__attribute__((__deprecated__("Use std::lower_bound"))) RandomAccessIterator
qLowerBoundHelper(RandomAccessIterator begin, RandomAccessIterator end,
                  const T &value, LessThan lessThan);
template <typename RandomAccessIterator, typename T, typename LessThan>
__attribute__((__deprecated__("Use std::upper_bound"))) RandomAccessIterator
qUpperBoundHelper(RandomAccessIterator begin, RandomAccessIterator end,
                  const T &value, LessThan lessThan);
template <typename RandomAccessIterator, typename T, typename LessThan>
__attribute__((__deprecated__("Use std::binary_search"))) RandomAccessIterator
qBinaryFindHelper(RandomAccessIterator begin, RandomAccessIterator end,
                  const T &value, LessThan lessThan);

} // namespace QAlgorithmsPrivate

template <typename InputIterator, typename OutputIterator>
__attribute__((__deprecated__("Use std::copy"))) inline OutputIterator
qCopy(InputIterator begin, InputIterator end, OutputIterator dest) {
  while (begin != end)
    *dest++ = *begin++;
  return dest;
}

template <typename BiIterator1, typename BiIterator2>
__attribute__((__deprecated__("Use std::copy_backward"))) inline BiIterator2
qCopyBackward(BiIterator1 begin, BiIterator1 end, BiIterator2 dest) {
  while (begin != end)
    *--dest = *--end;
  return dest;
}

template <typename InputIterator1, typename InputIterator2>
__attribute__((__deprecated__("Use std::equal"))) inline bool
qEqual(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2) {
  for (; first1 != last1; ++first1, ++first2)
    if (!(*first1 == *first2))
      return false;
  return true;
}

template <typename ForwardIterator, typename T>
__attribute__((__deprecated__("Use std::fill"))) inline void
qFill(ForwardIterator first, ForwardIterator last, const T &val) {
  for (; first != last; ++first)
    *first = val;
}

template <typename Container, typename T>
__attribute__((__deprecated__("Use std::fill"))) inline void
qFill(Container &container, const T &val) {
  qFill(container.begin(), container.end(), val);
}

template <typename InputIterator, typename T>
__attribute__((__deprecated__("Use std::find"))) inline InputIterator
qFind(InputIterator first, InputIterator last, const T &val) {
  while (first != last && !(*first == val))
    ++first;
  return first;
}

template <typename Container, typename T>
__attribute__((__deprecated__("Use std::find"))) inline
    typename Container::const_iterator
    qFind(const Container &container, const T &val) {
  return qFind(container.constBegin(), container.constEnd(), val);
}

template <typename InputIterator, typename T, typename Size>
__attribute__((__deprecated__("Use std::count"))) inline void
qCount(InputIterator first, InputIterator last, const T &value, Size &n) {
  for (; first != last; ++first)
    if (*first == value)
      ++n;
}

template <typename Container, typename T, typename Size>
__attribute__((__deprecated__("Use std::count"))) inline void
qCount(const Container &container, const T &value, Size &n) {
  qCount(container.constBegin(), container.constEnd(), value, n);
}

template <typename T>
class __attribute__((__deprecated__("Use std::less"))) qLess {
public:
  inline bool operator()(const T &t1, const T &t2) const { return (t1 < t2); }
};

template <typename T>
class __attribute__((__deprecated__("Use std::greater"))) qGreater {
public:
  inline bool operator()(const T &t1, const T &t2) const { return (t2 < t1); }
};

template <typename RandomAccessIterator>
__attribute__((__deprecated__("Use std::sort"))) inline void
qSort(RandomAccessIterator start, RandomAccessIterator end) {
  if (start != end)
    QAlgorithmsPrivate::qSortHelper(start, end, *start);
}

template <typename RandomAccessIterator, typename LessThan>
__attribute__((__deprecated__("Use std::sort"))) inline void
qSort(RandomAccessIterator start, RandomAccessIterator end, LessThan lessThan) {
  if (start != end)
    QAlgorithmsPrivate::qSortHelper(start, end, *start, lessThan);
}

template <typename Container>
__attribute__((__deprecated__("Use std::sort"))) inline void
qSort(Container &c) {

  if (!c.empty())
    QAlgorithmsPrivate::qSortHelper(c.begin(), c.end(), *c.begin());
}

template <typename RandomAccessIterator>
__attribute__((__deprecated__("Use std::stable_sort"))) inline void
qStableSort(RandomAccessIterator start, RandomAccessIterator end) {
  if (start != end)
    QAlgorithmsPrivate::qStableSortHelper(start, end, *start);
}

template <typename RandomAccessIterator, typename LessThan>
__attribute__((__deprecated__("Use std::stable_sort"))) inline void
qStableSort(RandomAccessIterator start, RandomAccessIterator end,
            LessThan lessThan) {
  if (start != end)
    QAlgorithmsPrivate::qStableSortHelper(start, end, *start, lessThan);
}

template <typename Container>
__attribute__((__deprecated__("Use std::stable_sort"))) inline void
qStableSort(Container &c) {

  if (!c.empty())
    QAlgorithmsPrivate::qStableSortHelper(c.begin(), c.end(), *c.begin());
}

template <typename RandomAccessIterator, typename T>
__attribute__((__deprecated__("Use std::lower_bound"))) RandomAccessIterator
qLowerBound(RandomAccessIterator begin, RandomAccessIterator end,
            const T &value) {

  RandomAccessIterator middle;
  int n = end - begin;
  int half;

  while (n > 0) {
    half = n >> 1;
    middle = begin + half;
    if (*middle < value) {
      begin = middle + 1;
      n -= half + 1;
    } else {
      n = half;
    }
  }
  return begin;
}

template <typename RandomAccessIterator, typename T, typename LessThan>
__attribute__((__deprecated__("Use std::lower_bound"))) RandomAccessIterator
qLowerBound(RandomAccessIterator begin, RandomAccessIterator end,
            const T &value, LessThan lessThan) {
  return QAlgorithmsPrivate::qLowerBoundHelper(begin, end, value, lessThan);
}

template <typename Container, typename T>
__attribute__((__deprecated__("Use std::lower_bound")))
typename Container::const_iterator
qLowerBound(const Container &container, const T &value) {
  return QAlgorithmsPrivate::qLowerBoundHelper(
      container.constBegin(), container.constEnd(), value, qLess<T>());
}

template <typename RandomAccessIterator, typename T>
__attribute__((__deprecated__("Use std::upper_bound"))) RandomAccessIterator
qUpperBound(RandomAccessIterator begin, RandomAccessIterator end,
            const T &value) {

  RandomAccessIterator middle;
  int n = end - begin;
  int half;

  while (n > 0) {
    half = n >> 1;
    middle = begin + half;
    if (value < *middle) {
      n = half;
    } else {
      begin = middle + 1;
      n -= half + 1;
    }
  }
  return begin;
}

template <typename RandomAccessIterator, typename T, typename LessThan>
__attribute__((__deprecated__("Use std::upper_bound"))) RandomAccessIterator
qUpperBound(RandomAccessIterator begin, RandomAccessIterator end,
            const T &value, LessThan lessThan) {
  return QAlgorithmsPrivate::qUpperBoundHelper(begin, end, value, lessThan);
}

template <typename Container, typename T>
__attribute__((__deprecated__("Use std::upper_bound")))
typename Container::const_iterator
qUpperBound(const Container &container, const T &value) {
  return QAlgorithmsPrivate::qUpperBoundHelper(
      container.constBegin(), container.constEnd(), value, qLess<T>());
}

template <typename RandomAccessIterator, typename T>
__attribute__((__deprecated__("Use std::binary_search"))) RandomAccessIterator
qBinaryFind(RandomAccessIterator begin, RandomAccessIterator end,
            const T &value) {

  RandomAccessIterator it = qLowerBound(begin, end, value);

  if (it == end || value < *it)
    return end;

  return it;
}

template <typename RandomAccessIterator, typename T, typename LessThan>
__attribute__((__deprecated__("Use std::binary_search"))) RandomAccessIterator
qBinaryFind(RandomAccessIterator begin, RandomAccessIterator end,
            const T &value, LessThan lessThan) {
  return QAlgorithmsPrivate::qBinaryFindHelper(begin, end, value, lessThan);
}

template <typename Container, typename T>
__attribute__((__deprecated__("Use std::binary_search")))
typename Container::const_iterator
qBinaryFind(const Container &container, const T &value) {
  return QAlgorithmsPrivate::qBinaryFindHelper(
      container.constBegin(), container.constEnd(), value, qLess<T>());
}

template <typename ForwardIterator>
void qDeleteAll(ForwardIterator begin, ForwardIterator end) {
  while (begin != end) {
    delete *begin;
    ++begin;
  }
}

template <typename Container> inline void qDeleteAll(const Container &c) {
  qDeleteAll(c.begin(), c.end());
}

namespace QAlgorithmsPrivate {

template <typename RandomAccessIterator, typename T, typename LessThan>
__attribute__((__deprecated__("Use std::sort"))) void
qSortHelper(RandomAccessIterator start, RandomAccessIterator end, const T &t,
            LessThan lessThan) {
top:
  int span = int(end - start);
  if (span < 2)
    return;

  --end;
  RandomAccessIterator low = start, high = end - 1;
  RandomAccessIterator pivot = start + span / 2;

  if (lessThan(*end, *start))
    qSwap(*end, *start);
  if (span == 2)
    return;

  if (lessThan(*pivot, *start))
    qSwap(*pivot, *start);
  if (lessThan(*end, *pivot))
    qSwap(*end, *pivot);
  if (span == 3)
    return;

  qSwap(*pivot, *end);

  while (low < high) {
    while (low < high && lessThan(*low, *end))
      ++low;

    while (high > low && lessThan(*end, *high))
      --high;

    if (low < high) {
      qSwap(*low, *high);
      ++low;
      --high;
    } else {
      break;
    }
  }

  if (lessThan(*low, *end))
    ++low;

  qSwap(*end, *low);
  qSortHelper(start, low, t, lessThan);

  start = low + 1;
  ++end;
  goto top;
}

template <typename RandomAccessIterator, typename T>
__attribute__((__deprecated__("Use std::sort"))) inline void
qSortHelper(RandomAccessIterator begin, RandomAccessIterator end,
            const T &dummy) {
  qSortHelper(begin, end, dummy, qLess<T>());
}

template <typename RandomAccessIterator>
__attribute__((__deprecated__("Use std::reverse"))) void
qReverse(RandomAccessIterator begin, RandomAccessIterator end) {
  --end;
  while (begin < end)
    qSwap(*begin++, *end--);
}

template <typename RandomAccessIterator>
__attribute__((__deprecated__("Use std::rotate"))) void
qRotate(RandomAccessIterator begin, RandomAccessIterator middle,
        RandomAccessIterator end) {
  qReverse(begin, middle);
  qReverse(middle, end);
  qReverse(begin, end);
}

template <typename RandomAccessIterator, typename T, typename LessThan>
__attribute__((__deprecated__("Use std::merge"))) void
qMerge(RandomAccessIterator begin, RandomAccessIterator pivot,
       RandomAccessIterator end, T &t, LessThan lessThan) {
  const int len1 = pivot - begin;
  const int len2 = end - pivot;

  if (len1 == 0 || len2 == 0)
    return;

  if (len1 + len2 == 2) {
    if (lessThan(*(begin + 1), *(begin)))
      qSwap(*begin, *(begin + 1));
    return;
  }

  RandomAccessIterator firstCut;
  RandomAccessIterator secondCut;
  int len2Half;
  if (len1 > len2) {
    const int len1Half = len1 / 2;
    firstCut = begin + len1Half;
    secondCut = qLowerBound(pivot, end, *firstCut, lessThan);
    len2Half = secondCut - pivot;
  } else {
    len2Half = len2 / 2;
    secondCut = pivot + len2Half;
    firstCut = qUpperBound(begin, pivot, *secondCut, lessThan);
  }

  qRotate(firstCut, pivot, secondCut);
  const RandomAccessIterator newPivot = firstCut + len2Half;
  qMerge(begin, firstCut, newPivot, t, lessThan);
  qMerge(newPivot, secondCut, end, t, lessThan);
}

template <typename RandomAccessIterator, typename T, typename LessThan>
__attribute__((__deprecated__("Use std::stable_sort"))) void
qStableSortHelper(RandomAccessIterator begin, RandomAccessIterator end,
                  const T &t, LessThan lessThan) {
  const int span = end - begin;
  if (span < 2)
    return;

  const RandomAccessIterator middle = begin + span / 2;
  qStableSortHelper(begin, middle, t, lessThan);
  qStableSortHelper(middle, end, t, lessThan);
  qMerge(begin, middle, end, t, lessThan);
}

template <typename RandomAccessIterator, typename T>
__attribute__((__deprecated__("Use std::stable_sort"))) inline void
qStableSortHelper(RandomAccessIterator begin, RandomAccessIterator end,
                  const T &dummy) {
  qStableSortHelper(begin, end, dummy, qLess<T>());
}

template <typename RandomAccessIterator, typename T, typename LessThan>
__attribute__((__deprecated__("Use std::lower_bound"))) RandomAccessIterator
qLowerBoundHelper(RandomAccessIterator begin, RandomAccessIterator end,
                  const T &value, LessThan lessThan) {
  RandomAccessIterator middle;
  int n = int(end - begin);
  int half;

  while (n > 0) {
    half = n >> 1;
    middle = begin + half;
    if (lessThan(*middle, value)) {
      begin = middle + 1;
      n -= half + 1;
    } else {
      n = half;
    }
  }
  return begin;
}

template <typename RandomAccessIterator, typename T, typename LessThan>
__attribute__((__deprecated__("Use std::upper_bound"))) RandomAccessIterator
qUpperBoundHelper(RandomAccessIterator begin, RandomAccessIterator end,
                  const T &value, LessThan lessThan) {
  RandomAccessIterator middle;
  int n = end - begin;
  int half;

  while (n > 0) {
    half = n >> 1;
    middle = begin + half;
    if (lessThan(value, *middle)) {
      n = half;
    } else {
      begin = middle + 1;
      n -= half + 1;
    }
  }
  return begin;
}

template <typename RandomAccessIterator, typename T, typename LessThan>
__attribute__((__deprecated__("Use std::binary_search"))) RandomAccessIterator
qBinaryFindHelper(RandomAccessIterator begin, RandomAccessIterator end,
                  const T &value, LessThan lessThan) {
  RandomAccessIterator it = qLowerBoundHelper(begin, end, value, lessThan);

  if (it == end || lessThan(value, *it))
    return end;

  return it;
}
# 536 "/usr/local/include/QtCore/qalgorithms.h"
constexpr inline __attribute__((always_inline)) uint
qt_builtin_ctzs(quint16 v) noexcept {

  return __builtin_ctzs(v);
}

constexpr inline __attribute__((always_inline)) uint
qt_builtin_clzs(quint16 v) noexcept {

  return __builtin_clzs(v);
}

constexpr inline __attribute__((always_inline)) uint
qt_builtin_ctz(quint32 v) noexcept {
  return __builtin_ctz(v);
}

constexpr inline __attribute__((always_inline)) uint
qt_builtin_clz(quint32 v) noexcept {
  return __builtin_clz(v);
}

constexpr inline __attribute__((always_inline)) uint
qt_builtin_ctzll(quint64 v) noexcept {
  return __builtin_ctzll(v);
}

constexpr inline __attribute__((always_inline)) uint
qt_builtin_clzll(quint64 v) noexcept {
  return __builtin_clzll(v);
}

constexpr inline __attribute__((always_inline)) uint
qt_builtin_popcount(quint32 v) noexcept {
  return __builtin_popcount(v);
}
constexpr inline __attribute__((always_inline)) uint
qt_builtin_popcount(quint8 v) noexcept {
  return __builtin_popcount(v);
}
constexpr inline __attribute__((always_inline)) uint
qt_builtin_popcount(quint16 v) noexcept {
  return __builtin_popcount(v);
}

constexpr inline __attribute__((always_inline)) uint
qt_builtin_popcountll(quint64 v) noexcept {
  return __builtin_popcountll(v);
}
# 686 "/usr/local/include/QtCore/qalgorithms.h"
} // namespace QAlgorithmsPrivate

__attribute__((const)) constexpr inline uint
qPopulationCount(quint32 v) noexcept {

  return QAlgorithmsPrivate::qt_builtin_popcount(v);
}

__attribute__((const)) constexpr inline uint
qPopulationCount(quint8 v) noexcept {

  return QAlgorithmsPrivate::qt_builtin_popcount(v);
}

__attribute__((const)) constexpr inline uint
qPopulationCount(quint16 v) noexcept {

  return QAlgorithmsPrivate::qt_builtin_popcount(v);
}

__attribute__((const)) constexpr inline uint
qPopulationCount(quint64 v) noexcept {

  return QAlgorithmsPrivate::qt_builtin_popcountll(v);
# 735 "/usr/local/include/QtCore/qalgorithms.h"
}

__attribute__((const)) constexpr inline uint
qPopulationCount(long unsigned int v) noexcept {
  return qPopulationCount(static_cast<quint64>(v));
}

constexpr inline uint qCountTrailingZeroBits(quint32 v) noexcept {

  return v ? QAlgorithmsPrivate::qt_builtin_ctz(v) : 32U;
# 763 "/usr/local/include/QtCore/qalgorithms.h"
}

constexpr inline uint qCountTrailingZeroBits(quint8 v) noexcept {

  return v ? QAlgorithmsPrivate::qt_builtin_ctz(v) : 8U;
# 778 "/usr/local/include/QtCore/qalgorithms.h"
}

constexpr inline uint qCountTrailingZeroBits(quint16 v) noexcept {

  return v ? QAlgorithmsPrivate::qt_builtin_ctzs(v) : 16U;
# 794 "/usr/local/include/QtCore/qalgorithms.h"
}

constexpr inline uint qCountTrailingZeroBits(quint64 v) noexcept {

  return v ? QAlgorithmsPrivate::qt_builtin_ctzll(v) : 64;
}

constexpr inline uint qCountTrailingZeroBits(unsigned long v) noexcept {
  return qCountTrailingZeroBits(QIntegerForSizeof<long>::Unsigned(v));
}

constexpr inline uint qCountLeadingZeroBits(quint32 v) noexcept {

  return v ? QAlgorithmsPrivate::qt_builtin_clz(v) : 32U;
# 825 "/usr/local/include/QtCore/qalgorithms.h"
}

constexpr inline uint qCountLeadingZeroBits(quint8 v) noexcept {

  return v ? QAlgorithmsPrivate::qt_builtin_clz(v) - 24U : 8U;
}

constexpr inline uint qCountLeadingZeroBits(quint16 v) noexcept {

  return v ? QAlgorithmsPrivate::qt_builtin_clzs(v) : 16U;
}

constexpr inline uint qCountLeadingZeroBits(quint64 v) noexcept {

  return v ? QAlgorithmsPrivate::qt_builtin_clzll(v) : 64U;
# 865 "/usr/local/include/QtCore/qalgorithms.h"
}

constexpr inline uint qCountLeadingZeroBits(unsigned long v) noexcept {
  return qCountLeadingZeroBits(QIntegerForSizeof<long>::Unsigned(v));
}

#pragma clang diagnostic pop
# 46 "/usr/local/include/QtCore/qvarlengtharray.h" 2
# 1 "/usr/local/include/QtCore/qcontainertools_impl.h" 1
# 54 "/usr/local/include/QtCore/qcontainertools_impl.h"
namespace QtPrivate {
template <typename Iterator>
using IfIsInputIterator = typename std::enable_if<
    std::is_convertible<
        typename std::iterator_traits<Iterator>::iterator_category,
        std::input_iterator_tag>::value,
    bool>::type;

template <typename Iterator>
using IfIsForwardIterator = typename std::enable_if<
    std::is_convertible<
        typename std::iterator_traits<Iterator>::iterator_category,
        std::forward_iterator_tag>::value,
    bool>::type;

template <typename Iterator>
using IfIsNotForwardIterator = typename std::enable_if<
    !std::is_convertible<
        typename std::iterator_traits<Iterator>::iterator_category,
        std::forward_iterator_tag>::value,
    bool>::type;

template <typename Container, typename InputIterator,
          IfIsNotForwardIterator<InputIterator> = true>
void reserveIfForwardIterator(Container *, InputIterator, InputIterator) {}

template <typename Container, typename ForwardIterator,
          IfIsForwardIterator<ForwardIterator> = true>
void reserveIfForwardIterator(Container *c, ForwardIterator f,
                              ForwardIterator l) {
  c->reserve(static_cast<typename Container::size_type>(std::distance(f, l)));
}

template <typename... T> using void_t = void;

template <typename Iterator, typename = void_t<>>
struct AssociativeIteratorHasKeyAndValue : std::false_type {};

template <typename Iterator>
struct AssociativeIteratorHasKeyAndValue<
    Iterator, void_t<decltype(std::declval<Iterator &>().key()),
                     decltype(std::declval<Iterator &>().value())>>
    : std::true_type {};

template <typename Iterator, typename = void_t<>, typename = void_t<>>
struct AssociativeIteratorHasFirstAndSecond : std::false_type {};

template <typename Iterator>
struct AssociativeIteratorHasFirstAndSecond<
    Iterator, void_t<decltype(std::declval<Iterator &>()->first),
                     decltype(std::declval<Iterator &>()->second)>>
    : std::true_type {};

template <typename Iterator>
using IfAssociativeIteratorHasKeyAndValue =
    typename std::enable_if<AssociativeIteratorHasKeyAndValue<Iterator>::value,
                            bool>::type;

template <typename Iterator>
using IfAssociativeIteratorHasFirstAndSecond = typename std::enable_if<
    AssociativeIteratorHasFirstAndSecond<Iterator>::value, bool>::type;

} // namespace QtPrivate
# 47 "/usr/local/include/QtCore/qvarlengtharray.h" 2
# 1 "/usr/local/include/QtCore/qhashfunctions.h" 1
# 44 "/usr/local/include/QtCore/qhashfunctions.h"
# 1 "/usr/local/include/QtCore/qstring.h" 1
# 49 "/usr/local/include/QtCore/qstring.h"
# 1 "/usr/local/include/QtCore/qchar.h" 1
# 48 "/usr/local/include/QtCore/qchar.h"
class QString;

struct QLatin1Char {
public:
  constexpr inline explicit QLatin1Char(char c) noexcept : ch(c) {}
  constexpr inline char toLatin1() const noexcept { return ch; }
  constexpr inline ushort unicode() const noexcept { return ushort(uchar(ch)); }

private:
  char ch;
};

constexpr inline bool operator==(char lhs, QLatin1Char rhs) noexcept {
  return lhs == rhs.toLatin1();
}
constexpr inline bool operator!=(char lhs, QLatin1Char rhs) noexcept {
  return lhs != rhs.toLatin1();
}
constexpr inline bool operator<=(char lhs, QLatin1Char rhs) noexcept {
  return lhs <= rhs.toLatin1();
}
constexpr inline bool operator>=(char lhs, QLatin1Char rhs) noexcept {
  return lhs >= rhs.toLatin1();
}
constexpr inline bool operator<(char lhs, QLatin1Char rhs) noexcept {
  return lhs < rhs.toLatin1();
}
constexpr inline bool operator>(char lhs, QLatin1Char rhs) noexcept {
  return lhs > rhs.toLatin1();
}

constexpr inline bool operator==(QLatin1Char lhs, char rhs) noexcept {
  return lhs.toLatin1() == rhs;
}
constexpr inline bool operator!=(QLatin1Char lhs, char rhs) noexcept {
  return lhs.toLatin1() != rhs;
}
constexpr inline bool operator<=(QLatin1Char lhs, char rhs) noexcept {
  return lhs.toLatin1() <= rhs;
}
constexpr inline bool operator>=(QLatin1Char lhs, char rhs) noexcept {
  return lhs.toLatin1() >= rhs;
}
constexpr inline bool operator<(QLatin1Char lhs, char rhs) noexcept {
  return lhs.toLatin1() < rhs;
}
constexpr inline bool operator>(QLatin1Char lhs, char rhs) noexcept {
  return lhs.toLatin1() > rhs;
}

class __attribute__((visibility("default"))) QChar {
public:
  enum SpecialCharacter {
    Null = 0x0000,
    Tabulation = 0x0009,
    LineFeed = 0x000a,
    FormFeed = 0x000c,
    CarriageReturn = 0x000d,
    Space = 0x0020,
    Nbsp = 0x00a0,
    SoftHyphen = 0x00ad,
    ReplacementCharacter = 0xfffd,
    ObjectReplacementCharacter = 0xfffc,
    ByteOrderMark = 0xfeff,
    ByteOrderSwapped = 0xfffe,
    ParagraphSeparator = 0x2029,
    LineSeparator = 0x2028,
    LastValidCodePoint = 0x10ffff
  };

  constexpr QChar() noexcept : ucs(0) {}
  constexpr QChar(ushort rc) noexcept : ucs(rc) {}
  constexpr QChar(uchar c, uchar r) noexcept : ucs(ushort((r << 8) | c)) {}
  constexpr QChar(short rc) noexcept : ucs(ushort(rc)) {}
  constexpr QChar(uint rc) noexcept : ucs(ushort(rc & 0xffff)) {}
  constexpr QChar(int rc) noexcept : ucs(ushort(rc & 0xffff)) {}
  constexpr QChar(SpecialCharacter s) noexcept : ucs(ushort(s)) {}
  constexpr QChar(QLatin1Char ch) noexcept : ucs(ch.unicode()) {}

  constexpr QChar(char16_t ch) noexcept : ucs(ushort(ch)) {}
# 116 "/usr/local/include/QtCore/qchar.h"
  constexpr explicit QChar(char c) noexcept : ucs(uchar(c)) {}

  constexpr explicit QChar(uchar c) noexcept : ucs(c) {}

  enum Category {
    Mark_NonSpacing,
    Mark_SpacingCombining,
    Mark_Enclosing,

    Number_DecimalDigit,
    Number_Letter,
    Number_Other,

    Separator_Space,
    Separator_Line,
    Separator_Paragraph,

    Other_Control,
    Other_Format,
    Other_Surrogate,
    Other_PrivateUse,
    Other_NotAssigned,

    Letter_Uppercase,
    Letter_Lowercase,
    Letter_Titlecase,
    Letter_Modifier,
    Letter_Other,

    Punctuation_Connector,
    Punctuation_Dash,
    Punctuation_Open,
    Punctuation_Close,
    Punctuation_InitialQuote,
    Punctuation_FinalQuote,
    Punctuation_Other,

    Symbol_Math,
    Symbol_Currency,
    Symbol_Modifier,
    Symbol_Other
  };

  enum Script {
    Script_Unknown,
    Script_Inherited,
    Script_Common,

    Script_Latin,
    Script_Greek,
    Script_Cyrillic,
    Script_Armenian,
    Script_Hebrew,
    Script_Arabic,
    Script_Syriac,
    Script_Thaana,
    Script_Devanagari,
    Script_Bengali,
    Script_Gurmukhi,
    Script_Gujarati,
    Script_Oriya,
    Script_Tamil,
    Script_Telugu,
    Script_Kannada,
    Script_Malayalam,
    Script_Sinhala,
    Script_Thai,
    Script_Lao,
    Script_Tibetan,
    Script_Myanmar,
    Script_Georgian,
    Script_Hangul,
    Script_Ethiopic,
    Script_Cherokee,
    Script_CanadianAboriginal,
    Script_Ogham,
    Script_Runic,
    Script_Khmer,
    Script_Mongolian,
    Script_Hiragana,
    Script_Katakana,
    Script_Bopomofo,
    Script_Han,
    Script_Yi,
    Script_OldItalic,
    Script_Gothic,
    Script_Deseret,
    Script_Tagalog,
    Script_Hanunoo,
    Script_Buhid,
    Script_Tagbanwa,
    Script_Coptic,

    Script_Limbu,
    Script_TaiLe,
    Script_LinearB,
    Script_Ugaritic,
    Script_Shavian,
    Script_Osmanya,
    Script_Cypriot,
    Script_Braille,

    Script_Buginese,
    Script_NewTaiLue,
    Script_Glagolitic,
    Script_Tifinagh,
    Script_SylotiNagri,
    Script_OldPersian,
    Script_Kharoshthi,

    Script_Balinese,
    Script_Cuneiform,
    Script_Phoenician,
    Script_PhagsPa,
    Script_Nko,

    Script_Sundanese,
    Script_Lepcha,
    Script_OlChiki,
    Script_Vai,
    Script_Saurashtra,
    Script_KayahLi,
    Script_Rejang,
    Script_Lycian,
    Script_Carian,
    Script_Lydian,
    Script_Cham,

    Script_TaiTham,
    Script_TaiViet,
    Script_Avestan,
    Script_EgyptianHieroglyphs,
    Script_Samaritan,
    Script_Lisu,
    Script_Bamum,
    Script_Javanese,
    Script_MeeteiMayek,
    Script_ImperialAramaic,
    Script_OldSouthArabian,
    Script_InscriptionalParthian,
    Script_InscriptionalPahlavi,
    Script_OldTurkic,
    Script_Kaithi,

    Script_Batak,
    Script_Brahmi,
    Script_Mandaic,

    Script_Chakma,
    Script_MeroiticCursive,
    Script_MeroiticHieroglyphs,
    Script_Miao,
    Script_Sharada,
    Script_SoraSompeng,
    Script_Takri,

    Script_CaucasianAlbanian,
    Script_BassaVah,
    Script_Duployan,
    Script_Elbasan,
    Script_Grantha,
    Script_PahawhHmong,
    Script_Khojki,
    Script_LinearA,
    Script_Mahajani,
    Script_Manichaean,
    Script_MendeKikakui,
    Script_Modi,
    Script_Mro,
    Script_OldNorthArabian,
    Script_Nabataean,
    Script_Palmyrene,
    Script_PauCinHau,
    Script_OldPermic,
    Script_PsalterPahlavi,
    Script_Siddham,
    Script_Khudawadi,
    Script_Tirhuta,
    Script_WarangCiti,

    Script_Ahom,
    Script_AnatolianHieroglyphs,
    Script_Hatran,
    Script_Multani,
    Script_OldHungarian,
    Script_SignWriting,

    Script_Adlam,
    Script_Bhaiksuki,
    Script_Marchen,
    Script_Newa,
    Script_Osage,
    Script_Tangut,

    Script_MasaramGondi,
    Script_Nushu,
    Script_Soyombo,
    Script_ZanabazarSquare,

    Script_Dogra,
    Script_GunjalaGondi,
    Script_HanifiRohingya,
    Script_Makasar,
    Script_Medefaidrin,
    Script_OldSogdian,
    Script_Sogdian,
    Script_Elymaic,
    Script_Nandinagari,
    Script_NyiakengPuachueHmong,
    Script_Wancho,

    Script_Chorasmian,
    Script_DivesAkuru,
    Script_KhitanSmallScript,
    Script_Yezidi,

    ScriptCount
  };

  enum Direction {
    DirL,
    DirR,
    DirEN,
    DirES,
    DirET,
    DirAN,
    DirCS,
    DirB,
    DirS,
    DirWS,
    DirON,
    DirLRE,
    DirLRO,
    DirAL,
    DirRLE,
    DirRLO,
    DirPDF,
    DirNSM,
    DirBN,
    DirLRI,
    DirRLI,
    DirFSI,
    DirPDI
  };

  enum Decomposition {
    NoDecomposition,
    Canonical,
    Font,
    NoBreak,
    Initial,
    Medial,
    Final,
    Isolated,
    Circle,
    Super,
    Sub,
    Vertical,
    Wide,
    Narrow,
    Small,
    Square,
    Compat,
    Fraction
  };

  enum JoiningType {
    Joining_None,
    Joining_Causing,
    Joining_Dual,
    Joining_Right,
    Joining_Left,
    Joining_Transparent
  };

  enum Joining { OtherJoining, Dual, Right, Center };

  enum CombiningClass {
    Combining_BelowLeftAttached = 200,
    Combining_BelowAttached = 202,
    Combining_BelowRightAttached = 204,
    Combining_LeftAttached = 208,
    Combining_RightAttached = 210,
    Combining_AboveLeftAttached = 212,
    Combining_AboveAttached = 214,
    Combining_AboveRightAttached = 216,

    Combining_BelowLeft = 218,
    Combining_Below = 220,
    Combining_BelowRight = 222,
    Combining_Left = 224,
    Combining_Right = 226,
    Combining_AboveLeft = 228,
    Combining_Above = 230,
    Combining_AboveRight = 232,

    Combining_DoubleBelow = 233,
    Combining_DoubleAbove = 234,
    Combining_IotaSubscript = 240
  };

  enum UnicodeVersion {
    Unicode_Unassigned,
    Unicode_1_1,
    Unicode_2_0,
    Unicode_2_1_2,
    Unicode_3_0,
    Unicode_3_1,
    Unicode_3_2,
    Unicode_4_0,
    Unicode_4_1,
    Unicode_5_0,
    Unicode_5_1,
    Unicode_5_2,
    Unicode_6_0,
    Unicode_6_1,
    Unicode_6_2,
    Unicode_6_3,
    Unicode_7_0,
    Unicode_8_0,
    Unicode_9_0,
    Unicode_10_0,
    Unicode_11_0,
    Unicode_12_0,
    Unicode_12_1,
    Unicode_13_0
  };

  inline Category category() const noexcept { return QChar::category(ucs); }
  inline Direction direction() const noexcept { return QChar::direction(ucs); }
  inline JoiningType joiningType() const noexcept {
    return QChar::joiningType(ucs);
  }

  __attribute__((__deprecated__)) inline Joining joining() const noexcept {
    switch (QChar::joiningType(ucs)) {
    case QChar::Joining_Causing:
      return QChar::Center;
    case QChar::Joining_Dual:
      return QChar::Dual;
    case QChar::Joining_Right:
      return QChar::Right;
    case QChar::Joining_None:
    case QChar::Joining_Left:
    case QChar::Joining_Transparent:
    default:
      return QChar::OtherJoining;
    }
  }

  inline unsigned char combiningClass() const noexcept {
    return QChar::combiningClass(ucs);
  }

  inline QChar mirroredChar() const noexcept {
    return QChar(QChar::mirroredChar(ucs));
  }
  inline bool hasMirrored() const noexcept { return QChar::hasMirrored(ucs); }

  QString decomposition() const;
  inline Decomposition decompositionTag() const noexcept {
    return QChar::decompositionTag(ucs);
  }

  inline int digitValue() const noexcept { return QChar::digitValue(ucs); }
  inline QChar toLower() const noexcept { return QChar(QChar::toLower(ucs)); }
  inline QChar toUpper() const noexcept { return QChar(QChar::toUpper(ucs)); }
  inline QChar toTitleCase() const noexcept {
    return QChar(QChar::toTitleCase(ucs));
  }
  inline QChar toCaseFolded() const noexcept {
    return QChar(QChar::toCaseFolded(ucs));
  }

  inline Script script() const noexcept { return QChar::script(ucs); }

  inline UnicodeVersion unicodeVersion() const noexcept {
    return QChar::unicodeVersion(ucs);
  }

  constexpr inline char toLatin1() const noexcept {
    return ucs > 0xff ? '\0' : char(ucs);
  }
  constexpr inline ushort unicode() const noexcept { return ucs; }
  constexpr inline ushort &unicode() noexcept { return ucs; }

  static constexpr inline QChar fromLatin1(char c) noexcept {
    return QChar(ushort(uchar(c)));
  }

  constexpr inline bool isNull() const noexcept { return ucs == 0; }

  inline bool isPrint() const noexcept { return QChar::isPrint(ucs); }
  constexpr inline bool isSpace() const noexcept { return QChar::isSpace(ucs); }
  inline bool isMark() const noexcept { return QChar::isMark(ucs); }
  inline bool isPunct() const noexcept { return QChar::isPunct(ucs); }
  inline bool isSymbol() const noexcept { return QChar::isSymbol(ucs); }
  constexpr inline bool isLetter() const noexcept {
    return QChar::isLetter(ucs);
  }
  constexpr inline bool isNumber() const noexcept {
    return QChar::isNumber(ucs);
  }
  constexpr inline bool isLetterOrNumber() const noexcept {
    return QChar::isLetterOrNumber(ucs);
  }
  constexpr inline bool isDigit() const noexcept { return QChar::isDigit(ucs); }
  constexpr inline bool isLower() const noexcept { return QChar::isLower(ucs); }
  constexpr inline bool isUpper() const noexcept { return QChar::isUpper(ucs); }
  constexpr inline bool isTitleCase() const noexcept {
    return QChar::isTitleCase(ucs);
  }

  constexpr inline bool isNonCharacter() const noexcept {
    return QChar::isNonCharacter(ucs);
  }
  constexpr inline bool isHighSurrogate() const noexcept {
    return QChar::isHighSurrogate(ucs);
  }
  constexpr inline bool isLowSurrogate() const noexcept {
    return QChar::isLowSurrogate(ucs);
  }
  constexpr inline bool isSurrogate() const noexcept {
    return QChar::isSurrogate(ucs);
  }

  constexpr inline uchar cell() const noexcept { return uchar(ucs & 0xff); }
  constexpr inline uchar row() const noexcept {
    return uchar((ucs >> 8) & 0xff);
  }
  constexpr inline void setCell(uchar acell) noexcept {
    ucs = ushort((ucs & 0xff00) + acell);
  }
  constexpr inline void setRow(uchar arow) noexcept {
    ucs = ushort((ushort(arow) << 8) + (ucs & 0xff));
  }

  static constexpr inline bool isNonCharacter(uint ucs4) noexcept {
    return ucs4 >= 0xfdd0 && (ucs4 <= 0xfdef || (ucs4 & 0xfffe) == 0xfffe);
  }
  static constexpr inline bool isHighSurrogate(uint ucs4) noexcept {
    return ((ucs4 & 0xfffffc00) == 0xd800);
  }
  static constexpr inline bool isLowSurrogate(uint ucs4) noexcept {
    return ((ucs4 & 0xfffffc00) == 0xdc00);
  }
  static constexpr inline bool isSurrogate(uint ucs4) noexcept {
    return (ucs4 - 0xd800u < 2048u);
  }
  static constexpr inline bool requiresSurrogates(uint ucs4) noexcept {
    return (ucs4 >= 0x10000);
  }
  static constexpr inline uint surrogateToUcs4(ushort high,
                                               ushort low) noexcept {
    return (uint(high) << 10) + low - 0x35fdc00;
  }
  static constexpr inline uint surrogateToUcs4(QChar high, QChar low) noexcept {
    return surrogateToUcs4(high.ucs, low.ucs);
  }
  static constexpr inline ushort highSurrogate(uint ucs4) noexcept {
    return ushort((ucs4 >> 10) + 0xd7c0);
  }
  static constexpr inline ushort lowSurrogate(uint ucs4) noexcept {
    return ushort(ucs4 % 0x400 + 0xdc00);
  }

  static Category category(uint ucs4) noexcept __attribute__((const));
  static Direction direction(uint ucs4) noexcept __attribute__((const));
  static JoiningType joiningType(uint ucs4) noexcept __attribute__((const));

  __attribute__((__deprecated__)) static Joining joining(uint ucs4) noexcept
      __attribute__((const));

  static unsigned char combiningClass(uint ucs4) noexcept
      __attribute__((const));

  static uint mirroredChar(uint ucs4) noexcept __attribute__((const));
  static bool hasMirrored(uint ucs4) noexcept __attribute__((const));

  static QString decomposition(uint ucs4);
  static Decomposition decompositionTag(uint ucs4) noexcept
      __attribute__((const));

  static int digitValue(uint ucs4) noexcept __attribute__((const));
  static uint toLower(uint ucs4) noexcept __attribute__((const));
  static uint toUpper(uint ucs4) noexcept __attribute__((const));
  static uint toTitleCase(uint ucs4) noexcept __attribute__((const));
  static uint toCaseFolded(uint ucs4) noexcept __attribute__((const));

  static Script script(uint ucs4) noexcept __attribute__((const));

  static UnicodeVersion unicodeVersion(uint ucs4) noexcept
      __attribute__((const));

  static UnicodeVersion currentUnicodeVersion() noexcept __attribute__((const));

  static bool isPrint(uint ucs4) noexcept __attribute__((const));
  static constexpr inline bool isSpace(uint ucs4) noexcept
      __attribute__((const)) {

    return ucs4 == 0x20 || (ucs4 <= 0x0d && ucs4 >= 0x09) ||
           (ucs4 > 127 &&
            (ucs4 == 0x85 || ucs4 == 0xa0 || QChar::isSpace_helper(ucs4)));
  }
  static bool isMark(uint ucs4) noexcept __attribute__((const));
  static bool isPunct(uint ucs4) noexcept __attribute__((const));
  static bool isSymbol(uint ucs4) noexcept __attribute__((const));
  static constexpr inline bool isLetter(uint ucs4) noexcept
      __attribute__((const)) {
    return (ucs4 >= 'A' && ucs4 <= 'z' && (ucs4 >= 'a' || ucs4 <= 'Z')) ||
           (ucs4 > 127 && QChar::isLetter_helper(ucs4));
  }
  static constexpr inline bool isNumber(uint ucs4) noexcept
      __attribute__((const)) {
    return (ucs4 <= '9' && ucs4 >= '0') ||
           (ucs4 > 127 && QChar::isNumber_helper(ucs4));
  }
  static constexpr inline bool isLetterOrNumber(uint ucs4) noexcept
      __attribute__((const)) {
    return (ucs4 >= 'A' && ucs4 <= 'z' && (ucs4 >= 'a' || ucs4 <= 'Z')) ||
           (ucs4 >= '0' && ucs4 <= '9') ||
           (ucs4 > 127 && QChar::isLetterOrNumber_helper(ucs4));
  }
  static constexpr inline bool isDigit(uint ucs4) noexcept
      __attribute__((const)) {
    return (ucs4 <= '9' && ucs4 >= '0') ||
           (ucs4 > 127 && QChar::category(ucs4) == Number_DecimalDigit);
  }
  static constexpr inline bool isLower(uint ucs4) noexcept
      __attribute__((const)) {
    return (ucs4 <= 'z' && ucs4 >= 'a') ||
           (ucs4 > 127 && QChar::category(ucs4) == Letter_Lowercase);
  }
  static constexpr inline bool isUpper(uint ucs4) noexcept
      __attribute__((const)) {
    return (ucs4 <= 'Z' && ucs4 >= 'A') ||
           (ucs4 > 127 && QChar::category(ucs4) == Letter_Uppercase);
  }
  static constexpr inline bool isTitleCase(uint ucs4) noexcept
      __attribute__((const)) {
    return ucs4 > 127 && QChar::category(ucs4) == Letter_Titlecase;
  }

private:
  static bool isSpace_helper(uint ucs4) noexcept __attribute__((const));
  static bool isLetter_helper(uint ucs4) noexcept __attribute__((const));
  static bool isNumber_helper(uint ucs4) noexcept __attribute__((const));
  static bool isLetterOrNumber_helper(uint ucs4) noexcept
      __attribute__((const));

  friend constexpr bool operator==(QChar, QChar) noexcept;
  friend constexpr bool operator<(QChar, QChar) noexcept;
  ushort ucs;
};

template <> class QTypeInfo<QChar> {
public:
  enum {
    isSpecialized = true,
    isComplex =
        (((Q_MOVABLE_TYPE)&Q_PRIMITIVE_TYPE) == 0) && !qIsTrivial<QChar>(),
    isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0),
    isRelocatable = !isStatic || ((Q_MOVABLE_TYPE)&Q_RELOCATABLE_TYPE) ||
                    qIsRelocatable<QChar>(),
    isLarge = (sizeof(QChar) > sizeof(void *)),
    isPointer = false,
    isIntegral = std::is_integral<QChar>::value,
    isDummy = (((Q_MOVABLE_TYPE)&Q_DUMMY_TYPE) != 0),
    sizeOf = sizeof(QChar)
  };
  static inline const char *name() { return "QChar"; }
};

constexpr inline bool operator==(QChar c1, QChar c2) noexcept {
  return c1.ucs == c2.ucs;
}
constexpr inline bool operator<(QChar c1, QChar c2) noexcept {
  return c1.ucs < c2.ucs;
}

constexpr inline bool operator!=(QChar c1, QChar c2) noexcept {
  return !operator==(c1, c2);
}
constexpr inline bool operator>=(QChar c1, QChar c2) noexcept {
  return !operator<(c1, c2);
}
constexpr inline bool operator>(QChar c1, QChar c2) noexcept {
  return operator<(c2, c1);
}
constexpr inline bool operator<=(QChar c1, QChar c2) noexcept {
  return !operator<(c2, c1);
}

constexpr inline bool operator==(QChar lhs, std::nullptr_t) noexcept {
  return lhs.isNull();
}
constexpr inline bool operator<(QChar, std::nullptr_t) noexcept {
  return false;
}
constexpr inline bool operator==(std::nullptr_t, QChar rhs) noexcept {
  return rhs.isNull();
}
constexpr inline bool operator<(std::nullptr_t, QChar rhs) noexcept {
  return !rhs.isNull();
}

constexpr inline bool operator!=(QChar lhs, std::nullptr_t) noexcept {
  return !operator==(lhs, nullptr);
}
constexpr inline bool operator>=(QChar lhs, std::nullptr_t) noexcept {
  return !operator<(lhs, nullptr);
}
constexpr inline bool operator>(QChar lhs, std::nullptr_t) noexcept {
  return operator<(nullptr, lhs);
}
constexpr inline bool operator<=(QChar lhs, std::nullptr_t) noexcept {
  return !operator<(nullptr, lhs);
}

constexpr inline bool operator!=(std::nullptr_t, QChar rhs) noexcept {
  return !operator==(nullptr, rhs);
}
constexpr inline bool operator>=(std::nullptr_t, QChar rhs) noexcept {
  return !operator<(nullptr, rhs);
}
constexpr inline bool operator>(std::nullptr_t, QChar rhs) noexcept {
  return operator<(rhs, nullptr);
}
constexpr inline bool operator<=(std::nullptr_t, QChar rhs) noexcept {
  return !operator<(rhs, nullptr);
}

__attribute__((visibility("default"))) QDataStream &operator<<(QDataStream &,
                                                               QChar);
__attribute__((visibility("default"))) QDataStream &operator>>(QDataStream &,
                                                               QChar &);
# 50 "/usr/local/include/QtCore/qstring.h" 2

# 1 "/usr/local/include/QtCore/qstringliteral.h" 1
# 52 "/usr/local/include/QtCore/qstringliteral.h"
typedef QTypedArrayData<ushort> QStringData;

typedef char16_t qunicodechar;

static_assert(bool(sizeof(qunicodechar) == 2),
              "qunicodechar must typedef an integral type of size 2");
# 89 "/usr/local/include/QtCore/qstringliteral.h"
template <int N> struct QStaticStringData {
  QArrayData str;
  qunicodechar data[N + 1];

  QStringData *data_ptr() const {
    ((str.ref.isStatic())
         ? static_cast<void>(0)
         : qt_assert("str.ref.isStatic()",
                     "/usr/local/include/QtCore/qstringliteral.h", 97));
    return const_cast<QStringData *>(static_cast<const QStringData *>(&str));
  }
};

struct QStringDataPtr {
  QStringData *ptr;
};
# 54 "/usr/local/include/QtCore/qstring.h" 2
# 1 "/usr/local/include/QtCore/qstringalgorithms.h" 1
# 51 "/usr/local/include/QtCore/qstringalgorithms.h"
class QByteArray;
class QLatin1String;
class QStringView;
class QChar;
template <typename T> class QVector;

namespace QtPrivate {

__attribute__((__warn_unused_result__)) __attribute__((visibility("default")))
__attribute__((pure)) qsizetype
qustrlen(const ushort *str) noexcept;
__attribute__((__warn_unused_result__)) __attribute__((visibility("default")))
__attribute__((pure)) const ushort *
qustrchr(QStringView str, ushort ch) noexcept;

__attribute__((__warn_unused_result__)) __attribute__((visibility("default")))
__attribute__((pure)) int
compareStrings(QStringView lhs, QStringView rhs,
               Qt::CaseSensitivity cs = Qt::CaseSensitive) noexcept;
__attribute__((__warn_unused_result__)) __attribute__((visibility("default")))
__attribute__((pure)) int
compareStrings(QStringView lhs, QLatin1String rhs,
               Qt::CaseSensitivity cs = Qt::CaseSensitive) noexcept;
__attribute__((__warn_unused_result__)) __attribute__((visibility("default")))
__attribute__((pure)) int
compareStrings(QLatin1String lhs, QStringView rhs,
               Qt::CaseSensitivity cs = Qt::CaseSensitive) noexcept;
__attribute__((__warn_unused_result__)) __attribute__((visibility("default")))
__attribute__((pure)) int
compareStrings(QLatin1String lhs, QLatin1String rhs,
               Qt::CaseSensitivity cs = Qt::CaseSensitive) noexcept;

__attribute__((__warn_unused_result__)) __attribute__((visibility("default")))
__attribute__((pure)) bool
startsWith(QStringView haystack, QStringView needle,
           Qt::CaseSensitivity cs = Qt::CaseSensitive) noexcept;
__attribute__((__warn_unused_result__)) __attribute__((visibility("default")))
__attribute__((pure)) bool
startsWith(QStringView haystack, QLatin1String needle,
           Qt::CaseSensitivity cs = Qt::CaseSensitive) noexcept;
__attribute__((__warn_unused_result__)) __attribute__((visibility("default")))
__attribute__((pure)) bool
startsWith(QLatin1String haystack, QStringView needle,
           Qt::CaseSensitivity cs = Qt::CaseSensitive) noexcept;
__attribute__((__warn_unused_result__)) __attribute__((visibility("default")))
__attribute__((pure)) bool
startsWith(QLatin1String haystack, QLatin1String needle,
           Qt::CaseSensitivity cs = Qt::CaseSensitive) noexcept;

__attribute__((__warn_unused_result__)) __attribute__((visibility("default")))
__attribute__((pure)) bool
endsWith(QStringView haystack, QStringView needle,
         Qt::CaseSensitivity cs = Qt::CaseSensitive) noexcept;
__attribute__((__warn_unused_result__)) __attribute__((visibility("default")))
__attribute__((pure)) bool
endsWith(QStringView haystack, QLatin1String needle,
         Qt::CaseSensitivity cs = Qt::CaseSensitive) noexcept;
__attribute__((__warn_unused_result__)) __attribute__((visibility("default")))
__attribute__((pure)) bool
endsWith(QLatin1String haystack, QStringView needle,
         Qt::CaseSensitivity cs = Qt::CaseSensitive) noexcept;
__attribute__((__warn_unused_result__)) __attribute__((visibility("default")))
__attribute__((pure)) bool
endsWith(QLatin1String haystack, QLatin1String needle,
         Qt::CaseSensitivity cs = Qt::CaseSensitive) noexcept;

__attribute__((__warn_unused_result__)) __attribute__((visibility("default")))
__attribute__((pure)) qsizetype
findString(QStringView haystack, qsizetype from, QStringView needle,
           Qt::CaseSensitivity cs = Qt::CaseSensitive) noexcept;
__attribute__((__warn_unused_result__)) __attribute__((visibility("default")))
__attribute__((pure)) qsizetype
findString(QStringView haystack, qsizetype from, QLatin1String needle,
           Qt::CaseSensitivity cs = Qt::CaseSensitive) noexcept;
__attribute__((__warn_unused_result__)) __attribute__((visibility("default")))
__attribute__((pure)) qsizetype
findString(QLatin1String haystack, qsizetype from, QStringView needle,
           Qt::CaseSensitivity cs = Qt::CaseSensitive) noexcept;
__attribute__((__warn_unused_result__)) __attribute__((visibility("default")))
__attribute__((pure)) qsizetype
findString(QLatin1String haystack, qsizetype from, QLatin1String needle,
           Qt::CaseSensitivity cs = Qt::CaseSensitive) noexcept;

__attribute__((__warn_unused_result__)) __attribute__((visibility("default")))
__attribute__((pure)) qsizetype
lastIndexOf(QStringView haystack, qsizetype from, QStringView needle,
            Qt::CaseSensitivity cs = Qt::CaseSensitive) noexcept;
__attribute__((__warn_unused_result__)) __attribute__((visibility("default")))
__attribute__((pure)) qsizetype
lastIndexOf(QStringView haystack, qsizetype from, QLatin1String needle,
            Qt::CaseSensitivity cs = Qt::CaseSensitive) noexcept;
__attribute__((__warn_unused_result__)) __attribute__((visibility("default")))
__attribute__((pure)) qsizetype
lastIndexOf(QLatin1String haystack, qsizetype from, QStringView needle,
            Qt::CaseSensitivity cs = Qt::CaseSensitive) noexcept;
__attribute__((__warn_unused_result__)) __attribute__((visibility("default")))
__attribute__((pure)) qsizetype
lastIndexOf(QLatin1String haystack, qsizetype from, QLatin1String needle,
            Qt::CaseSensitivity cs = Qt::CaseSensitive) noexcept;

__attribute__((__warn_unused_result__)) __attribute__((visibility("default")))
__attribute__((pure)) QStringView
trimmed(QStringView s) noexcept;
__attribute__((__warn_unused_result__)) __attribute__((visibility("default")))
__attribute__((pure)) QLatin1String
trimmed(QLatin1String s) noexcept;

__attribute__((__warn_unused_result__)) __attribute__((visibility("default")))
QByteArray
convertToLatin1(QStringView str);
__attribute__((__warn_unused_result__)) __attribute__((visibility("default")))
QByteArray
convertToUtf8(QStringView str);
__attribute__((__warn_unused_result__)) __attribute__((visibility("default")))
QByteArray
convertToLocal8Bit(QStringView str);
__attribute__((__warn_unused_result__)) __attribute__((visibility("default")))
QVector<uint>
convertToUcs4(QStringView str);

__attribute__((__warn_unused_result__)) __attribute__((visibility("default")))
__attribute__((pure)) bool
isRightToLeft(QStringView string) noexcept;

__attribute__((__warn_unused_result__)) __attribute__((visibility("default")))
__attribute__((pure)) bool
isAscii(QLatin1String s) noexcept;
__attribute__((__warn_unused_result__)) __attribute__((visibility("default")))
__attribute__((pure)) bool
isAscii(QStringView s) noexcept;
__attribute__((__warn_unused_result__)) constexpr inline bool
isLatin1(QLatin1String s) noexcept;
__attribute__((__warn_unused_result__)) __attribute__((visibility("default")))
__attribute__((pure)) bool
isLatin1(QStringView s) noexcept;
__attribute__((__warn_unused_result__)) __attribute__((visibility("default")))
__attribute__((pure)) bool
isValidUtf16(QStringView s) noexcept;

} // namespace QtPrivate
# 55 "/usr/local/include/QtCore/qstring.h" 2
# 1 "/usr/local/include/QtCore/qstringview.h" 1
# 56 "/usr/local/include/QtCore/qstringview.h"
class QString;
class QStringRef;

namespace QtPrivate {
template <typename Char>
struct IsCompatibleCharTypeHelper
    : std::integral_constant<bool, std::is_same<Char, QChar>::value ||
                                       std::is_same<Char, ushort>::value ||
                                       std::is_same<Char, char16_t>::value ||
                                       (std::is_same<Char, wchar_t>::value &&
                                        sizeof(wchar_t) == sizeof(QChar))> {};
template <typename Char>
struct IsCompatibleCharType
    : IsCompatibleCharTypeHelper<typename std::remove_cv<
          typename std::remove_reference<Char>::type>::type> {};

template <typename Array> struct IsCompatibleArrayHelper : std::false_type {};
template <typename Char, size_t N>
struct IsCompatibleArrayHelper<Char[N]> : IsCompatibleCharType<Char> {};
template <typename Array>
struct IsCompatibleArray
    : IsCompatibleArrayHelper<typename std::remove_cv<
          typename std::remove_reference<Array>::type>::type> {};

template <typename Pointer>
struct IsCompatiblePointerHelper : std::false_type {};
template <typename Char>
struct IsCompatiblePointerHelper<Char *> : IsCompatibleCharType<Char> {};
template <typename Pointer>
struct IsCompatiblePointer
    : IsCompatiblePointerHelper<typename std::remove_cv<
          typename std::remove_reference<Pointer>::type>::type> {};

template <typename T>
struct IsCompatibleStdBasicStringHelper : std::false_type {};
template <typename Char, typename... Args>
struct IsCompatibleStdBasicStringHelper<std::basic_string<Char, Args...>>
    : IsCompatibleCharType<Char> {};

template <typename T>
struct IsCompatibleStdBasicString
    : IsCompatibleStdBasicStringHelper<typename std::remove_cv<
          typename std::remove_reference<T>::type>::type> {};

} // namespace QtPrivate

class QStringView {
public:
  typedef char16_t storage_type;
  typedef const QChar value_type;
  typedef std::ptrdiff_t difference_type;
  typedef qsizetype size_type;
  typedef value_type &reference;
  typedef value_type &const_reference;
  typedef value_type *pointer;
  typedef value_type *const_pointer;

  typedef pointer iterator;
  typedef const_pointer const_iterator;
  typedef std::reverse_iterator<iterator> reverse_iterator;
  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

private:
  template <typename Char>
  using if_compatible_char =
      typename std::enable_if<QtPrivate::IsCompatibleCharType<Char>::value,
                              bool>::type;

  template <typename Array>
  using if_compatible_array =
      typename std::enable_if<QtPrivate::IsCompatibleArray<Array>::value,
                              bool>::type;

  template <typename Pointer>
  using if_compatible_pointer =
      typename std::enable_if<QtPrivate::IsCompatiblePointer<Pointer>::value,
                              bool>::type;

  template <typename T>
  using if_compatible_string =
      typename std::enable_if<QtPrivate::IsCompatibleStdBasicString<T>::value,
                              bool>::type;

  template <typename T>
  using if_compatible_qstring_like =
      typename std::enable_if<std::is_same<T, QString>::value ||
                                  std::is_same<T, QStringRef>::value,
                              bool>::type;

  template <typename Char, size_t N>
  static constexpr qsizetype lengthHelperArray(const Char (&)[N]) noexcept {
    return qsizetype(N - 1);
  }

  template <typename Char>
  static qsizetype lengthHelperPointer(const Char *str) noexcept {
# 153 "/usr/local/include/QtCore/qstringview.h"
    return QtPrivate::qustrlen(reinterpret_cast<const ushort *>(str));
  }
  static qsizetype lengthHelperPointer(const QChar *str) noexcept {
    return QtPrivate::qustrlen(reinterpret_cast<const ushort *>(str));
  }

  template <typename Char>
  static const storage_type *castHelper(const Char *str) noexcept {
    return reinterpret_cast<const storage_type *>(str);
  }
  static constexpr const storage_type *
  castHelper(const storage_type *str) noexcept {
    return str;
  }

public:
  constexpr QStringView() noexcept : m_size(0), m_data(nullptr) {}
  constexpr QStringView(std::nullptr_t) noexcept : QStringView() {}

  template <typename Char, if_compatible_char<Char> = true>
  constexpr QStringView(const Char *str, qsizetype len)
      : m_size(
            (((len >= 0)
                  ? static_cast<void>(0)
                  : qt_assert("len >= 0",
                              "/usr/local/include/QtCore/qstringview.h", 174)),
             ((str || !len)
                  ? static_cast<void>(0)
                  : qt_assert("str || !len",
                              "/usr/local/include/QtCore/qstringview.h", 174)),
             len)),
        m_data(castHelper(str)) {}

  template <typename Char, if_compatible_char<Char> = true>
  constexpr QStringView(const Char *f, const Char *l) : QStringView(f, l - f) {}
# 189 "/usr/local/include/QtCore/qstringview.h"
  template <typename Array, if_compatible_array<Array> = true>
  __attribute__((__deprecated__(R"(Use u"~~~" or QStringView(u"~~~") instead of QStringViewLiteral("~~~"))"))) constexpr QStringView(
      const Array &str, QtPrivate::Deprecated_t) noexcept
      : QStringView(str, lengthHelperArray(str)) {}

  template <typename Array, if_compatible_array<Array> = true>
  constexpr QStringView(const Array &str) noexcept
      : QStringView(str, lengthHelperArray(str)) {}

  template <typename Pointer, if_compatible_pointer<Pointer> = true>
  constexpr QStringView(const Pointer &str) noexcept
      : QStringView(str, str ? lengthHelperPointer(str) : 0) {}

  template <typename String, if_compatible_qstring_like<String> = true>
  QStringView(const String &str) noexcept
      : QStringView(str.isNull() ? nullptr : str.data(),
                    qsizetype(str.size())) {}

  template <typename StdBasicString,
            if_compatible_string<StdBasicString> = true>
  constexpr QStringView(const StdBasicString &str) noexcept
      : QStringView(str.data(), qsizetype(str.size())) {}

  __attribute__((__warn_unused_result__)) inline QString toString() const;

  __attribute__((__warn_unused_result__)) constexpr qsizetype
  size() const noexcept {
    return m_size;
  }
  __attribute__((__warn_unused_result__)) const_pointer data() const noexcept {
    return reinterpret_cast<const_pointer>(m_data);
  }
  __attribute__((__warn_unused_result__)) constexpr const storage_type *
  utf16() const noexcept {
    return m_data;
  }

  __attribute__((__warn_unused_result__)) constexpr QChar
  operator[](qsizetype n) const {
    return ((n >= 0)
                ? static_cast<void>(0)
                : qt_assert("n >= 0", "/usr/local/include/QtCore/qstringview.h",
                            224)),
           ((n < size())
                ? static_cast<void>(0)
                : qt_assert("n < size()",
                            "/usr/local/include/QtCore/qstringview.h", 224)),
           QChar(m_data[n]);
  }

  template <typename... Args>
  __attribute__((__warn_unused_result__)) inline QString
  arg(Args &&...args) const;

  __attribute__((__warn_unused_result__)) QByteArray toLatin1() const {
    return QtPrivate::convertToLatin1(*this);
  }
  __attribute__((__warn_unused_result__)) QByteArray toUtf8() const {
    return QtPrivate::convertToUtf8(*this);
  }
  __attribute__((__warn_unused_result__)) QByteArray toLocal8Bit() const {
    return QtPrivate::convertToLocal8Bit(*this);
  }
  __attribute__((__warn_unused_result__)) inline QVector<uint> toUcs4() const;

  __attribute__((__warn_unused_result__)) constexpr QChar
  at(qsizetype n) const {
    return (*this)[n];
  }

  __attribute__((__warn_unused_result__)) constexpr QStringView
  mid(qsizetype pos) const {
    return ((pos >= 0)
                ? static_cast<void>(0)
                : qt_assert("pos >= 0",
                            "/usr/local/include/QtCore/qstringview.h", 241)),
           ((pos <= size())
                ? static_cast<void>(0)
                : qt_assert("pos <= size()",
                            "/usr/local/include/QtCore/qstringview.h", 241)),
           QStringView(m_data + pos, m_size - pos);
  }
  __attribute__((__warn_unused_result__)) constexpr QStringView
  mid(qsizetype pos, qsizetype n) const {
    return ((pos >= 0)
                ? static_cast<void>(0)
                : qt_assert("pos >= 0",
                            "/usr/local/include/QtCore/qstringview.h", 243)),
           ((n >= 0)
                ? static_cast<void>(0)
                : qt_assert("n >= 0", "/usr/local/include/QtCore/qstringview.h",
                            243)),
           ((pos + n <= size())
                ? static_cast<void>(0)
                : qt_assert("pos + n <= size()",
                            "/usr/local/include/QtCore/qstringview.h", 243)),
           QStringView(m_data + pos, n);
  }
  __attribute__((__warn_unused_result__)) constexpr QStringView
  left(qsizetype n) const {
    return ((n >= 0)
                ? static_cast<void>(0)
                : qt_assert("n >= 0", "/usr/local/include/QtCore/qstringview.h",
                            245)),
           ((n <= size())
                ? static_cast<void>(0)
                : qt_assert("n <= size()",
                            "/usr/local/include/QtCore/qstringview.h", 245)),
           QStringView(m_data, n);
  }
  __attribute__((__warn_unused_result__)) constexpr QStringView
  right(qsizetype n) const {
    return ((n >= 0)
                ? static_cast<void>(0)
                : qt_assert("n >= 0", "/usr/local/include/QtCore/qstringview.h",
                            247)),
           ((n <= size())
                ? static_cast<void>(0)
                : qt_assert("n <= size()",
                            "/usr/local/include/QtCore/qstringview.h", 247)),
           QStringView(m_data + m_size - n, n);
  }
  __attribute__((__warn_unused_result__)) constexpr QStringView
  chopped(qsizetype n) const {
    return ((n >= 0)
                ? static_cast<void>(0)
                : qt_assert("n >= 0", "/usr/local/include/QtCore/qstringview.h",
                            249)),
           ((n <= size())
                ? static_cast<void>(0)
                : qt_assert("n <= size()",
                            "/usr/local/include/QtCore/qstringview.h", 249)),
           QStringView(m_data, m_size - n);
  }

  constexpr void truncate(qsizetype n) {
    ((n >= 0)
         ? static_cast<void>(0)
         : qt_assert("n >= 0", "/usr/local/include/QtCore/qstringview.h", 252));
    ((n <= size()) ? static_cast<void>(0)
                   : qt_assert("n <= size()",
                               "/usr/local/include/QtCore/qstringview.h", 252));
    m_size = n;
  }
  constexpr void chop(qsizetype n) {
    ((n >= 0)
         ? static_cast<void>(0)
         : qt_assert("n >= 0", "/usr/local/include/QtCore/qstringview.h", 254));
    ((n <= size()) ? static_cast<void>(0)
                   : qt_assert("n <= size()",
                               "/usr/local/include/QtCore/qstringview.h", 254));
    m_size -= n;
  }

  __attribute__((__warn_unused_result__)) QStringView trimmed() const noexcept {
    return QtPrivate::trimmed(*this);
  }

  __attribute__((__warn_unused_result__)) int
  compare(QStringView other,
          Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept {
    return QtPrivate::compareStrings(*this, other, cs);
  }
  __attribute__((__warn_unused_result__)) inline int
  compare(QLatin1String other,
          Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept;
  __attribute__((__warn_unused_result__)) constexpr int
  compare(QChar c) const noexcept {
    return empty() || front() == c ? size() - 1 : *utf16() - c.unicode();
  }
  __attribute__((__warn_unused_result__)) int
  compare(QChar c, Qt::CaseSensitivity cs) const noexcept {
    return QtPrivate::compareStrings(*this, QStringView(&c, 1), cs);
  }

  __attribute__((__warn_unused_result__)) bool
  startsWith(QStringView s,
             Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept {
    return QtPrivate::startsWith(*this, s, cs);
  }
  __attribute__((__warn_unused_result__)) inline bool
  startsWith(QLatin1String s,
             Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept;
  __attribute__((__warn_unused_result__)) bool
  startsWith(QChar c) const noexcept {
    return !empty() && front() == c;
  }
  __attribute__((__warn_unused_result__)) bool
  startsWith(QChar c, Qt::CaseSensitivity cs) const noexcept {
    return QtPrivate::startsWith(*this, QStringView(&c, 1), cs);
  }

  __attribute__((__warn_unused_result__)) bool
  endsWith(QStringView s,
           Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept {
    return QtPrivate::endsWith(*this, s, cs);
  }
  __attribute__((__warn_unused_result__)) inline bool
  endsWith(QLatin1String s,
           Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept;
  __attribute__((__warn_unused_result__)) bool
  endsWith(QChar c) const noexcept {
    return !empty() && back() == c;
  }
  __attribute__((__warn_unused_result__)) bool
  endsWith(QChar c, Qt::CaseSensitivity cs) const noexcept {
    return QtPrivate::endsWith(*this, QStringView(&c, 1), cs);
  }

  __attribute__((__warn_unused_result__)) qsizetype
  indexOf(QChar c, qsizetype from = 0,
          Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept {
    return QtPrivate::findString(*this, from, QStringView(&c, 1), cs);
  }
  __attribute__((__warn_unused_result__)) qsizetype
  indexOf(QStringView s, qsizetype from = 0,
          Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept {
    return QtPrivate::findString(*this, from, s, cs);
  }
  __attribute__((__warn_unused_result__)) inline qsizetype
  indexOf(QLatin1String s, qsizetype from = 0,
          Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept;

  __attribute__((__warn_unused_result__)) bool
  contains(QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept {
    return indexOf(QStringView(&c, 1), 0, cs) != qsizetype(-1);
  }
  __attribute__((__warn_unused_result__)) bool
  contains(QStringView s,
           Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept {
    return indexOf(s, 0, cs) != qsizetype(-1);
  }
  __attribute__((__warn_unused_result__)) inline bool
  contains(QLatin1String s,
           Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept;

  __attribute__((__warn_unused_result__)) qsizetype
  lastIndexOf(QChar c, qsizetype from = -1,
              Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept {
    return QtPrivate::lastIndexOf(*this, from, QStringView(&c, 1), cs);
  }
  __attribute__((__warn_unused_result__)) qsizetype
  lastIndexOf(QStringView s, qsizetype from = -1,
              Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept {
    return QtPrivate::lastIndexOf(*this, from, s, cs);
  }
  __attribute__((__warn_unused_result__)) inline qsizetype
  lastIndexOf(QLatin1String s, qsizetype from = -1,
              Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept;

  __attribute__((__warn_unused_result__)) bool isRightToLeft() const noexcept {
    return QtPrivate::isRightToLeft(*this);
  }
  __attribute__((__warn_unused_result__)) bool isValidUtf16() const noexcept {
    return QtPrivate::isValidUtf16(*this);
  }

  __attribute__((__warn_unused_result__)) inline int
  toWCharArray(wchar_t *array) const;

  __attribute__((__warn_unused_result__)) const_iterator
  begin() const noexcept {
    return data();
  }
  __attribute__((__warn_unused_result__)) const_iterator end() const noexcept {
    return data() + size();
  }
  __attribute__((__warn_unused_result__)) const_iterator
  cbegin() const noexcept {
    return begin();
  }
  __attribute__((__warn_unused_result__)) const_iterator cend() const noexcept {
    return end();
  }
  __attribute__((__warn_unused_result__)) const_reverse_iterator
  rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  __attribute__((__warn_unused_result__)) const_reverse_iterator
  rend() const noexcept {
    return const_reverse_iterator(begin());
  }
  __attribute__((__warn_unused_result__)) const_reverse_iterator
  crbegin() const noexcept {
    return rbegin();
  }
  __attribute__((__warn_unused_result__)) const_reverse_iterator
  crend() const noexcept {
    return rend();
  }

  __attribute__((__warn_unused_result__)) constexpr bool
  empty() const noexcept {
    return size() == 0;
  }
  __attribute__((__warn_unused_result__)) constexpr QChar front() const {
    return ((!empty())
                ? static_cast<void>(0)
                : qt_assert("!empty()",
                            "/usr/local/include/QtCore/qstringview.h", 320)),
           QChar(m_data[0]);
  }
  __attribute__((__warn_unused_result__)) constexpr QChar back() const {
    return ((!empty())
                ? static_cast<void>(0)
                : qt_assert("!empty()",
                            "/usr/local/include/QtCore/qstringview.h", 321)),
           QChar(m_data[m_size - 1]);
  }

  __attribute__((__warn_unused_result__)) constexpr bool
  isNull() const noexcept {
    return !m_data;
  }
  __attribute__((__warn_unused_result__)) constexpr bool
  isEmpty() const noexcept {
    return empty();
  }
  __attribute__((__warn_unused_result__)) constexpr int length() const {
    return ((int(size()) == size())
                ? static_cast<void>(0)
                : qt_assert("int(size()) == size()",
                            "/usr/local/include/QtCore/qstringview.h", 329)),
           int(size());
  }
  __attribute__((__warn_unused_result__)) constexpr QChar first() const {
    return front();
  }
  __attribute__((__warn_unused_result__)) constexpr QChar last() const {
    return back();
  }

private:
  qsizetype m_size;
  const storage_type *m_data;
};
template <> class QTypeInfo<QStringView> {
public:
  enum {
    isSpecialized = true,
    isComplex = (((Q_PRIMITIVE_TYPE)&Q_PRIMITIVE_TYPE) == 0) &&
                !qIsTrivial<QStringView>(),
    isStatic =
        (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0),
    isRelocatable = !isStatic || ((Q_PRIMITIVE_TYPE)&Q_RELOCATABLE_TYPE) ||
                    qIsRelocatable<QStringView>(),
    isLarge = (sizeof(QStringView) > sizeof(void *)),
    isPointer = false,
    isIntegral = std::is_integral<QStringView>::value,
    isDummy = (((Q_PRIMITIVE_TYPE)&Q_DUMMY_TYPE) != 0),
    sizeOf = sizeof(QStringView)
  };
  static inline const char *name() { return "QStringView"; }
};

template <
    typename QStringLike,
    typename std::enable_if<std::is_same<QStringLike, QString>::value ||
                                std::is_same<QStringLike, QStringRef>::value,
                            bool>::type = true>
inline QStringView qToStringViewIgnoringNull(const QStringLike &s) noexcept {
  return QStringView(s.data(), s.size());
}
# 56 "/usr/local/include/QtCore/qstring.h" 2
# 67 "/usr/local/include/QtCore/qstring.h"
typedef const struct __CFString *CFStringRef;
typedef struct objc_object NSString;

class QCharRef;
class QRegExp;
class QRegularExpression;
class QRegularExpressionMatch;
class QString;
class QStringList;
class QTextCodec;
class QStringRef;
template <typename T> class QVector;

namespace QtPrivate {
template <bool... B> class BoolList;
}

class QLatin1String {
public:
  constexpr inline QLatin1String() noexcept : m_size(0), m_data(nullptr) {}
  constexpr inline explicit QLatin1String(const char *s) noexcept
      : m_size(s ? int(strlen(s)) : 0), m_data(s) {}
  constexpr explicit QLatin1String(const char *f, const char *l)
      : QLatin1String(f, int(l - f)) {}
  constexpr inline explicit QLatin1String(const char *s, int sz) noexcept
      : m_size(sz), m_data(s) {}
  inline explicit QLatin1String(const QByteArray &s) noexcept
      : m_size(int(qstrnlen(s.constData(), s.size()))), m_data(s.constData()) {}

  constexpr const char *latin1() const noexcept { return m_data; }
  constexpr int size() const noexcept { return m_size; }
  constexpr const char *data() const noexcept { return m_data; }

  constexpr bool isNull() const noexcept { return !data(); }
  constexpr bool isEmpty() const noexcept { return !size(); }

  template <typename... Args>
  __attribute__((__warn_unused_result__)) inline QString
  arg(Args &&...args) const;

  constexpr QLatin1Char at(int i) const {
    return ((i >= 0) ? static_cast<void>(0)
                     : qt_assert("i >= 0",
                                 "/usr/local/include/QtCore/qstring.h", 108)),
           ((i < size())
                ? static_cast<void>(0)
                : qt_assert("i < size()", "/usr/local/include/QtCore/qstring.h",
                            108)),
           QLatin1Char(m_data[i]);
  }
  constexpr QLatin1Char operator[](int i) const { return at(i); }

  __attribute__((__warn_unused_result__)) constexpr QLatin1Char front() const {
    return at(0);
  }
  __attribute__((__warn_unused_result__)) constexpr QLatin1Char back() const {
    return at(size() - 1);
  }

  __attribute__((__warn_unused_result__)) int
  compare(QStringView other,
          Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept {
    return QtPrivate::compareStrings(*this, other, cs);
  }
  __attribute__((__warn_unused_result__)) int
  compare(QLatin1String other,
          Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept {
    return QtPrivate::compareStrings(*this, other, cs);
  }
  __attribute__((__warn_unused_result__)) constexpr int
  compare(QChar c) const noexcept {
    return isEmpty() || front() == c ? size() - 1
                                     : uchar(m_data[0]) - c.unicode();
  }
  __attribute__((__warn_unused_result__)) int
  compare(QChar c, Qt::CaseSensitivity cs) const noexcept {
    return QtPrivate::compareStrings(*this, QStringView(&c, 1), cs);
  }

  __attribute__((__warn_unused_result__)) bool
  startsWith(QStringView s,
             Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept {
    return QtPrivate::startsWith(*this, s, cs);
  }
  __attribute__((__warn_unused_result__)) bool
  startsWith(QLatin1String s,
             Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept {
    return QtPrivate::startsWith(*this, s, cs);
  }
  __attribute__((__warn_unused_result__)) constexpr bool
  startsWith(QChar c) const noexcept {
    return !isEmpty() && front() == c;
  }
  __attribute__((__warn_unused_result__)) inline bool
  startsWith(QChar c, Qt::CaseSensitivity cs) const noexcept {
    return QtPrivate::startsWith(*this, QStringView(&c, 1), cs);
  }

  __attribute__((__warn_unused_result__)) bool
  endsWith(QStringView s,
           Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept {
    return QtPrivate::endsWith(*this, s, cs);
  }
  __attribute__((__warn_unused_result__)) bool
  endsWith(QLatin1String s,
           Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept {
    return QtPrivate::endsWith(*this, s, cs);
  }
  __attribute__((__warn_unused_result__)) constexpr bool
  endsWith(QChar c) const noexcept {
    return !isEmpty() && back() == c;
  }
  __attribute__((__warn_unused_result__)) inline bool
  endsWith(QChar c, Qt::CaseSensitivity cs) const noexcept {
    return QtPrivate::endsWith(*this, QStringView(&c, 1), cs);
  }

  __attribute__((__warn_unused_result__)) int
  indexOf(QStringView s, int from = 0,
          Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept {
    return int(QtPrivate::findString(*this, from, s, cs));
  }
  __attribute__((__warn_unused_result__)) int
  indexOf(QLatin1String s, int from = 0,
          Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept {
    return int(QtPrivate::findString(*this, from, s, cs));
  }
  __attribute__((__warn_unused_result__)) inline int
  indexOf(QChar c, int from = 0,
          Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept {
    return int(QtPrivate::findString(*this, from, QStringView(&c, 1), cs));
  }

  __attribute__((__warn_unused_result__)) bool
  contains(QStringView s,
           Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept {
    return indexOf(s, 0, cs) != -1;
  }
  __attribute__((__warn_unused_result__)) bool
  contains(QLatin1String s,
           Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept {
    return indexOf(s, 0, cs) != -1;
  }
  __attribute__((__warn_unused_result__)) inline bool
  contains(QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept {
    return indexOf(QStringView(&c, 1), 0, cs) != -1;
  }

  __attribute__((__warn_unused_result__)) int
  lastIndexOf(QStringView s, int from = -1,
              Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept {
    return int(QtPrivate::lastIndexOf(*this, from, s, cs));
  }
  __attribute__((__warn_unused_result__)) int
  lastIndexOf(QLatin1String s, int from = -1,
              Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept {
    return int(QtPrivate::lastIndexOf(*this, from, s, cs));
  }
  __attribute__((__warn_unused_result__)) inline int
  lastIndexOf(QChar c, int from = -1,
              Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept {
    return int(QtPrivate::lastIndexOf(*this, from, QStringView(&c, 1), cs));
  }

  using value_type = const char;
  using reference = value_type &;
  using const_reference = reference;
  using iterator = value_type *;
  using const_iterator = iterator;
  using difference_type = int;
  using size_type = int;

  constexpr const_iterator begin() const noexcept { return data(); }
  constexpr const_iterator cbegin() const noexcept { return data(); }
  constexpr const_iterator end() const noexcept { return data() + size(); }
  constexpr const_iterator cend() const noexcept { return data() + size(); }

  using reverse_iterator = std::reverse_iterator<iterator>;
  using const_reverse_iterator = reverse_iterator;

  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator crbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }
  const_reverse_iterator crend() const noexcept {
    return const_reverse_iterator(begin());
  }

  constexpr QLatin1String mid(int pos) const {
    return ((pos >= 0) ? static_cast<void>(0)
                       : qt_assert("pos >= 0",
                                   "/usr/local/include/QtCore/qstring.h", 184)),
           ((pos <= size())
                ? static_cast<void>(0)
                : qt_assert("pos <= size()",
                            "/usr/local/include/QtCore/qstring.h", 184)),
           QLatin1String(m_data + pos, m_size - pos);
  }
  constexpr QLatin1String mid(int pos, int n) const {
    return ((pos >= 0) ? static_cast<void>(0)
                       : qt_assert("pos >= 0",
                                   "/usr/local/include/QtCore/qstring.h", 186)),
           ((n >= 0) ? static_cast<void>(0)
                     : qt_assert("n >= 0",
                                 "/usr/local/include/QtCore/qstring.h", 186)),
           ((pos + n <= size())
                ? static_cast<void>(0)
                : qt_assert("pos + n <= size()",
                            "/usr/local/include/QtCore/qstring.h", 186)),
           QLatin1String(m_data + pos, n);
  }
  constexpr QLatin1String left(int n) const {
    return ((n >= 0) ? static_cast<void>(0)
                     : qt_assert("n >= 0",
                                 "/usr/local/include/QtCore/qstring.h", 188)),
           ((n <= size())
                ? static_cast<void>(0)
                : qt_assert("n <= size()",
                            "/usr/local/include/QtCore/qstring.h", 188)),
           QLatin1String(m_data, n);
  }
  constexpr QLatin1String right(int n) const {
    return ((n >= 0) ? static_cast<void>(0)
                     : qt_assert("n >= 0",
                                 "/usr/local/include/QtCore/qstring.h", 190)),
           ((n <= size())
                ? static_cast<void>(0)
                : qt_assert("n <= size()",
                            "/usr/local/include/QtCore/qstring.h", 190)),
           QLatin1String(m_data + m_size - n, n);
  }
  __attribute__((__warn_unused_result__)) constexpr QLatin1String
  chopped(int n) const {
    return ((n >= 0) ? static_cast<void>(0)
                     : qt_assert("n >= 0",
                                 "/usr/local/include/QtCore/qstring.h", 192)),
           ((n <= size())
                ? static_cast<void>(0)
                : qt_assert("n <= size()",
                            "/usr/local/include/QtCore/qstring.h", 192)),
           QLatin1String(m_data, m_size - n);
  }

  constexpr void chop(int n) {
    ((n >= 0)
         ? static_cast<void>(0)
         : qt_assert("n >= 0", "/usr/local/include/QtCore/qstring.h", 195));
    ((n <= size()) ? static_cast<void>(0)
                   : qt_assert("n <= size()",
                               "/usr/local/include/QtCore/qstring.h", 195));
    m_size -= n;
  }
  constexpr void truncate(int n) {
    ((n >= 0)
         ? static_cast<void>(0)
         : qt_assert("n >= 0", "/usr/local/include/QtCore/qstring.h", 197));
    ((n <= size()) ? static_cast<void>(0)
                   : qt_assert("n <= size()",
                               "/usr/local/include/QtCore/qstring.h", 197));
    m_size = n;
  }

  __attribute__((__warn_unused_result__)) QLatin1String
  trimmed() const noexcept {
    return QtPrivate::trimmed(*this);
  }

  inline bool operator==(const QString &s) const noexcept;
  inline bool operator!=(const QString &s) const noexcept;
  inline bool operator>(const QString &s) const noexcept;
  inline bool operator<(const QString &s) const noexcept;
  inline bool operator>=(const QString &s) const noexcept;
  inline bool operator<=(const QString &s) const noexcept;

  inline bool operator==(const char *s) const;
  inline bool operator!=(const char *s) const;
  inline bool operator<(const char *s) const;
  inline bool operator>(const char *s) const;
  inline bool operator<=(const char *s) const;
  inline bool operator>=(const char *s) const;

  inline bool operator==(const QByteArray &s) const;
  inline bool operator!=(const QByteArray &s) const;
  inline bool operator<(const QByteArray &s) const;
  inline bool operator>(const QByteArray &s) const;
  inline bool operator<=(const QByteArray &s) const;
  inline bool operator>=(const QByteArray &s) const;

private:
  int m_size;
  const char *m_data;
};
template <> class QTypeInfo<QLatin1String> {
public:
  enum {
    isSpecialized = true,
    isComplex = (((Q_MOVABLE_TYPE)&Q_PRIMITIVE_TYPE) == 0) &&
                !qIsTrivial<QLatin1String>(),
    isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0),
    isRelocatable = !isStatic || ((Q_MOVABLE_TYPE)&Q_RELOCATABLE_TYPE) ||
                    qIsRelocatable<QLatin1String>(),
    isLarge = (sizeof(QLatin1String) > sizeof(void *)),
    isPointer = false,
    isIntegral = std::is_integral<QLatin1String>::value,
    isDummy = (((Q_MOVABLE_TYPE)&Q_DUMMY_TYPE) != 0),
    sizeOf = sizeof(QLatin1String)
  };
  static inline const char *name() { return "QLatin1String"; }
};

__attribute__((
    __deprecated__("Use QLatin1String"))) typedef QLatin1String QLatin1Literal;

constexpr bool QtPrivate::isLatin1(QLatin1String) noexcept { return true; }

int QStringView::compare(QLatin1String s,
                         Qt::CaseSensitivity cs) const noexcept {
  return QtPrivate::compareStrings(*this, s, cs);
}
bool QStringView::startsWith(QLatin1String s,
                             Qt::CaseSensitivity cs) const noexcept {
  return QtPrivate::startsWith(*this, s, cs);
}
bool QStringView::endsWith(QLatin1String s,
                           Qt::CaseSensitivity cs) const noexcept {
  return QtPrivate::endsWith(*this, s, cs);
}
qsizetype QStringView::indexOf(QLatin1String s, qsizetype from,
                               Qt::CaseSensitivity cs) const noexcept {
  return QtPrivate::findString(*this, from, s, cs);
}
bool QStringView::contains(QLatin1String s,
                           Qt::CaseSensitivity cs) const noexcept {
  return indexOf(s, 0, cs) != qsizetype(-1);
}
qsizetype QStringView::lastIndexOf(QLatin1String s, qsizetype from,
                                   Qt::CaseSensitivity cs) const noexcept {
  return QtPrivate::lastIndexOf(*this, from, s, cs);
}

class __attribute__((visibility("default"))) QString {
public:
  typedef QStringData Data;

  inline QString() noexcept;
  explicit QString(const QChar *unicode, int size = -1);
  QString(QChar c);
  QString(int size, QChar c);
  inline QString(QLatin1String latin1);
  inline QString(const QString &) noexcept;
  inline ~QString();
  QString &operator=(QChar c);
  QString &operator=(const QString &) noexcept;
  QString &operator=(QLatin1String latin1);
  inline QString(QString &&other) noexcept : d(other.d) {
    other.d = Data::sharedNull();
  }
  inline QString &operator=(QString &&other) noexcept {
    qSwap(d, other.d);
    return *this;
  }
  inline void swap(QString &other) noexcept { qSwap(d, other.d); }
  inline int size() const { return d->size; }
  inline int count() const { return d->size; }
  inline int length() const;
  inline bool isEmpty() const;
  void resize(int size);
  void resize(int size, QChar fillChar);

  QString &fill(QChar c, int size = -1);
  void truncate(int pos);
  void chop(int n);

  int capacity() const;
  inline void reserve(int size);
  inline void squeeze();

  inline const QChar *unicode() const;
  inline QChar *data();
  inline const QChar *data() const;
  inline const QChar *constData() const;

  inline void detach();
  inline bool isDetached() const;
  inline bool isSharedWith(const QString &other) const { return d == other.d; }
  void clear();

  inline const QChar at(int i) const;
  const QChar operator[](int i) const;
  __attribute__((__warn_unused_result__)) QCharRef operator[](int i);
  const QChar operator[](uint i) const;
  __attribute__((__warn_unused_result__)) QCharRef operator[](uint i);

  __attribute__((__warn_unused_result__)) inline QChar front() const {
    return at(0);
  }
  __attribute__((__warn_unused_result__)) inline QCharRef front();
  __attribute__((__warn_unused_result__)) inline QChar back() const {
    return at(size() - 1);
  }
  __attribute__((__warn_unused_result__)) inline QCharRef back();

  __attribute__((__warn_unused_result__)) QString
  arg(qlonglong a, int fieldwidth = 0, int base = 10,
      QChar fillChar = QLatin1Char(' ')) const;
  __attribute__((__warn_unused_result__)) QString
  arg(qulonglong a, int fieldwidth = 0, int base = 10,
      QChar fillChar = QLatin1Char(' ')) const;
  __attribute__((__warn_unused_result__)) QString
  arg(long a, int fieldwidth = 0, int base = 10,
      QChar fillChar = QLatin1Char(' ')) const;
  __attribute__((__warn_unused_result__)) QString
  arg(ulong a, int fieldwidth = 0, int base = 10,
      QChar fillChar = QLatin1Char(' ')) const;
  __attribute__((__warn_unused_result__)) QString
  arg(int a, int fieldWidth = 0, int base = 10,
      QChar fillChar = QLatin1Char(' ')) const;
  __attribute__((__warn_unused_result__)) QString
  arg(uint a, int fieldWidth = 0, int base = 10,
      QChar fillChar = QLatin1Char(' ')) const;
  __attribute__((__warn_unused_result__)) QString
  arg(short a, int fieldWidth = 0, int base = 10,
      QChar fillChar = QLatin1Char(' ')) const;
  __attribute__((__warn_unused_result__)) QString
  arg(ushort a, int fieldWidth = 0, int base = 10,
      QChar fillChar = QLatin1Char(' ')) const;
  __attribute__((__warn_unused_result__)) QString
  arg(double a, int fieldWidth = 0, char fmt = 'g', int prec = -1,
      QChar fillChar = QLatin1Char(' ')) const;
  __attribute__((__warn_unused_result__)) QString
  arg(char a, int fieldWidth = 0, QChar fillChar = QLatin1Char(' ')) const;
  __attribute__((__warn_unused_result__)) QString
  arg(QChar a, int fieldWidth = 0, QChar fillChar = QLatin1Char(' ')) const;

  __attribute__((__warn_unused_result__)) QString
  arg(const QString &a, int fieldWidth = 0,
      QChar fillChar = QLatin1Char(' ')) const;

  __attribute__((__warn_unused_result__)) QString
  arg(QStringView a, int fieldWidth = 0,
      QChar fillChar = QLatin1Char(' ')) const;
  __attribute__((__warn_unused_result__)) QString
  arg(QLatin1String a, int fieldWidth = 0,
      QChar fillChar = QLatin1Char(' ')) const;

  __attribute__((__warn_unused_result__)) QString arg(const QString &a1,
                                                      const QString &a2) const;
  __attribute__((__warn_unused_result__)) QString
  arg(const QString &a1, const QString &a2, const QString &a3) const;
  __attribute__((__warn_unused_result__)) QString arg(const QString &a1,
                                                      const QString &a2,
                                                      const QString &a3,
                                                      const QString &a4) const;
  __attribute__((__warn_unused_result__)) QString
  arg(const QString &a1, const QString &a2, const QString &a3,
      const QString &a4, const QString &a5) const;
  __attribute__((__warn_unused_result__)) QString
  arg(const QString &a1, const QString &a2, const QString &a3,
      const QString &a4, const QString &a5, const QString &a6) const;
  __attribute__((__warn_unused_result__)) QString
  arg(const QString &a1, const QString &a2, const QString &a3,
      const QString &a4, const QString &a5, const QString &a6,
      const QString &a7) const;
  __attribute__((__warn_unused_result__)) QString
  arg(const QString &a1, const QString &a2, const QString &a3,
      const QString &a4, const QString &a5, const QString &a6,
      const QString &a7, const QString &a8) const;
  __attribute__((__warn_unused_result__)) QString
  arg(const QString &a1, const QString &a2, const QString &a3,
      const QString &a4, const QString &a5, const QString &a6,
      const QString &a7, const QString &a8, const QString &a9) const;

private:
  template <typename T>
  struct is_convertible_to_view_or_qstring_helper
      : std::integral_constant<
            bool, std::is_convertible<T, QString>::value ||
                      std::is_convertible<T, QStringView>::value ||
                      std::is_convertible<T, QLatin1String>::value> {};
  template <typename T>
  struct is_convertible_to_view_or_qstring
      : is_convertible_to_view_or_qstring_helper<typename std::decay<T>::type> {
  };

public:
  template <typename... Args>
  __attribute__((__warn_unused_result__))

  typename std::enable_if<
      sizeof...(Args) >= 2 &&
          std::is_same<
              QtPrivate::BoolList<
                  is_convertible_to_view_or_qstring<Args>::value..., true>,
              QtPrivate::BoolList<true, is_convertible_to_view_or_qstring<
                                            Args>::value...>>::value,
      QString>::type

  arg(Args &&...args) const {
    return qToStringViewIgnoringNull(*this).arg(std::forward<Args>(args)...);
  }

  __attribute__((__deprecated__(
      "Use vasprintf(), arg() or QTextStream instead"))) QString &
  vsprintf(const char *format, va_list ap)
      __attribute__((format(printf, (2), (0))));
  __attribute__((
      __deprecated__("Use asprintf(), arg() or QTextStream instead"))) QString &
  sprintf(const char *format, ...) __attribute__((format(printf, (2), (3))));

  static QString vasprintf(const char *format, va_list ap)
      __attribute__((format(printf, (1), (0))));
  static QString asprintf(const char *format, ...)
      __attribute__((format(printf, (1), (2))));

  int indexOf(QChar c, int from = 0,
              Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
  int indexOf(QLatin1String s, int from = 0,
              Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

  int indexOf(const QString &s, int from = 0,
              Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
  int indexOf(const QStringRef &s, int from = 0,
              Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

  __attribute__((__warn_unused_result__)) int
  indexOf(QStringView s, int from = 0,
          Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept {
    return int(QtPrivate::findString(*this, from, s, cs));
  }
  int lastIndexOf(QChar c, int from = -1,
                  Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
  int lastIndexOf(QLatin1String s, int from = -1,
                  Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

  int lastIndexOf(const QString &s, int from = -1,
                  Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
  int lastIndexOf(const QStringRef &s, int from = -1,
                  Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

  __attribute__((__warn_unused_result__)) int
  lastIndexOf(QStringView s, int from = -1,
              Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept {
    return int(QtPrivate::lastIndexOf(*this, from, s, cs));
  }

  inline bool contains(QChar c,
                       Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

  inline bool contains(const QString &s,
                       Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
  inline bool contains(const QStringRef &s,
                       Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

  inline bool contains(QLatin1String s,
                       Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
  inline bool
  contains(QStringView s,
           Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept;
  int count(QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
  int count(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
  int count(const QStringRef &s,
            Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

  int indexOf(const QRegExp &, int from = 0) const;
  int lastIndexOf(const QRegExp &, int from = -1) const;
  inline bool contains(const QRegExp &rx) const { return indexOf(rx) != -1; }
  int count(const QRegExp &) const;

  int indexOf(QRegExp &, int from = 0) const;
  int lastIndexOf(QRegExp &, int from = -1) const;
  inline bool contains(QRegExp &rx) const { return indexOf(rx) != -1; }

  int indexOf(const QRegularExpression &re, int from = 0) const;
  int indexOf(const QRegularExpression &re, int from,
              QRegularExpressionMatch *rmatch) const;
  int lastIndexOf(const QRegularExpression &re, int from = -1) const;
  int lastIndexOf(const QRegularExpression &re, int from,
                  QRegularExpressionMatch *rmatch) const;
  bool contains(const QRegularExpression &re) const;
  bool contains(const QRegularExpression &re,
                QRegularExpressionMatch *rmatch) const;
  int count(const QRegularExpression &re) const;

  enum SectionFlag {
    SectionDefault = 0x00,
    SectionSkipEmpty = 0x01,
    SectionIncludeLeadingSep = 0x02,
    SectionIncludeTrailingSep = 0x04,
    SectionCaseInsensitiveSeps = 0x08
  };
  typedef QFlags<SectionFlag> SectionFlags;

  QString section(QChar sep, int start, int end = -1,
                  SectionFlags flags = SectionDefault) const;
  QString section(const QString &in_sep, int start, int end = -1,
                  SectionFlags flags = SectionDefault) const;

  QString section(const QRegExp &reg, int start, int end = -1,
                  SectionFlags flags = SectionDefault) const;

  QString section(const QRegularExpression &re, int start, int end = -1,
                  SectionFlags flags = SectionDefault) const;

  __attribute__((__warn_unused_result__)) QString left(int n) const;
  __attribute__((__warn_unused_result__)) QString right(int n) const;
  __attribute__((__warn_unused_result__)) QString mid(int position,
                                                      int n = -1) const;
  __attribute__((__warn_unused_result__)) QString chopped(int n) const {
    ((n >= 0)
         ? static_cast<void>(0)
         : qt_assert("n >= 0", "/usr/local/include/QtCore/qstring.h", 469));
    ((n <= size()) ? static_cast<void>(0)
                   : qt_assert("n <= size()",
                               "/usr/local/include/QtCore/qstring.h", 469));
    return left(size() - n);
  }

  __attribute__((__warn_unused_result__)) QStringRef leftRef(int n) const;
  __attribute__((__warn_unused_result__)) QStringRef rightRef(int n) const;
  __attribute__((__warn_unused_result__)) QStringRef midRef(int position,
                                                            int n = -1) const;

  bool startsWith(const QString &s,
                  Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
  bool startsWith(const QStringRef &s,
                  Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

  __attribute__((__warn_unused_result__)) bool
  startsWith(QStringView s,
             Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept {
    return QtPrivate::startsWith(*this, s, cs);
  }
  bool startsWith(QLatin1String s,
                  Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
  bool startsWith(QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

  bool endsWith(const QString &s,
                Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
  bool endsWith(const QStringRef &s,
                Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

  __attribute__((__warn_unused_result__)) bool
  endsWith(QStringView s,
           Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept {
    return QtPrivate::endsWith(*this, s, cs);
  }
  bool endsWith(QLatin1String s,
                Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
  bool endsWith(QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

  bool isUpper() const;
  bool isLower() const;

  __attribute__((__warn_unused_result__)) QString
  leftJustified(int width, QChar fill = QLatin1Char(' '),
                bool trunc = false) const;
  __attribute__((__warn_unused_result__)) QString
  rightJustified(int width, QChar fill = QLatin1Char(' '),
                 bool trunc = false) const;
# 508 "/usr/local/include/QtCore/qstring.h"
  __attribute__((__warn_unused_result__)) QString toLower() const & {
    return toLower_helper(*this);
  }
  __attribute__((__warn_unused_result__)) QString toLower() && {
    return toLower_helper(*this);
  }
  __attribute__((__warn_unused_result__)) QString toUpper() const & {
    return toUpper_helper(*this);
  }
  __attribute__((__warn_unused_result__)) QString toUpper() && {
    return toUpper_helper(*this);
  }
  __attribute__((__warn_unused_result__)) QString toCaseFolded() const & {
    return toCaseFolded_helper(*this);
  }
  __attribute__((__warn_unused_result__)) QString toCaseFolded() && {
    return toCaseFolded_helper(*this);
  }
  __attribute__((__warn_unused_result__)) QString trimmed() const & {
    return trimmed_helper(*this);
  }
  __attribute__((__warn_unused_result__)) QString trimmed() && {
    return trimmed_helper(*this);
  }
  __attribute__((__warn_unused_result__)) QString simplified() const & {
    return simplified_helper(*this);
  }
  __attribute__((__warn_unused_result__)) QString simplified() && {
    return simplified_helper(*this);
  }
# 538 "/usr/local/include/QtCore/qstring.h"
  __attribute__((__warn_unused_result__)) QString toHtmlEscaped() const;

  QString &insert(int i, QChar c);
  QString &insert(int i, const QChar *uc, int len);
  inline QString &insert(int i, const QString &s) {
    return insert(i, s.constData(), s.length());
  }
  inline QString &insert(int i, const QStringRef &s);
  QString &insert(int i, QLatin1String s);
  QString &append(QChar c);
  QString &append(const QChar *uc, int len);
  QString &append(const QString &s);
  QString &append(const QStringRef &s);
  QString &append(QLatin1String s);
  inline QString &prepend(QChar c) { return insert(0, c); }
  inline QString &prepend(const QChar *uc, int len) {
    return insert(0, uc, len);
  }
  inline QString &prepend(const QString &s) { return insert(0, s); }
  inline QString &prepend(const QStringRef &s) { return insert(0, s); }
  inline QString &prepend(QLatin1String s) { return insert(0, s); }

  inline QString &operator+=(QChar c) {
    if (d->ref.isShared() || uint(d->size) + 2u > d->alloc)
      reallocData(uint(d->size) + 2u, true);
    d->data()[d->size++] = c.unicode();
    d->data()[d->size] = '\0';
    return *this;
  }

  inline QString &operator+=(QChar::SpecialCharacter c) {
    return append(QChar(c));
  }
  inline QString &operator+=(const QString &s) { return append(s); }
  inline QString &operator+=(const QStringRef &s) { return append(s); }
  inline QString &operator+=(QLatin1String s) { return append(s); }

  QString &remove(int i, int len);
  QString &remove(QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive);
  QString &remove(QLatin1String s, Qt::CaseSensitivity cs = Qt::CaseSensitive);
  QString &remove(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive);
  QString &replace(int i, int len, QChar after);
  QString &replace(int i, int len, const QChar *s, int slen);
  QString &replace(int i, int len, const QString &after);
  QString &replace(QChar before, QChar after,
                   Qt::CaseSensitivity cs = Qt::CaseSensitive);
  QString &replace(const QChar *before, int blen, const QChar *after, int alen,
                   Qt::CaseSensitivity cs = Qt::CaseSensitive);
  QString &replace(QLatin1String before, QLatin1String after,
                   Qt::CaseSensitivity cs = Qt::CaseSensitive);
  QString &replace(QLatin1String before, const QString &after,
                   Qt::CaseSensitivity cs = Qt::CaseSensitive);
  QString &replace(const QString &before, QLatin1String after,
                   Qt::CaseSensitivity cs = Qt::CaseSensitive);
  QString &replace(const QString &before, const QString &after,
                   Qt::CaseSensitivity cs = Qt::CaseSensitive);
  QString &replace(QChar c, const QString &after,
                   Qt::CaseSensitivity cs = Qt::CaseSensitive);
  QString &replace(QChar c, QLatin1String after,
                   Qt::CaseSensitivity cs = Qt::CaseSensitive);

  QString &replace(const QRegExp &rx, const QString &after);
  inline QString &remove(const QRegExp &rx) { return replace(rx, QString()); }

  QString &replace(const QRegularExpression &re, const QString &after);
  inline QString &remove(const QRegularExpression &re) {
    return replace(re, QString());
  }

  enum SplitBehavior { KeepEmptyParts, SkipEmptyParts };

  __attribute__((__warn_unused_result__))
  __attribute__((__deprecated__("Use Qt::SplitBehavior variant instead")))
  QStringList
  split(const QString &sep, SplitBehavior behavior,
        Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
  __attribute__((__warn_unused_result__))
  __attribute__((__deprecated__("Use Qt::SplitBehavior variant instead")))
  QVector<QStringRef>
  splitRef(const QString &sep, SplitBehavior behavior,
           Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
  __attribute__((__warn_unused_result__))
  __attribute__((__deprecated__("Use Qt::SplitBehavior variant instead")))
  QStringList
  split(QChar sep, SplitBehavior behavior,
        Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
  __attribute__((__warn_unused_result__))
  __attribute__((__deprecated__("Use Qt::SplitBehavior variant instead")))
  QVector<QStringRef>
  splitRef(QChar sep, SplitBehavior behavior,
           Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

  __attribute__((__warn_unused_result__))
  __attribute__((__deprecated__("Use Qt::SplitBehavior variant instead")))
  QStringList
  split(const QRegExp &sep, SplitBehavior behavior) const;
  __attribute__((__warn_unused_result__))
  __attribute__((__deprecated__("Use Qt::SplitBehavior variant instead")))
  QVector<QStringRef>
  splitRef(const QRegExp &sep, SplitBehavior behavior) const;

  __attribute__((__warn_unused_result__))
  __attribute__((__deprecated__("Use Qt::SplitBehavior variant instead")))
  QStringList
  split(const QRegularExpression &sep, SplitBehavior behavior) const;
  __attribute__((__warn_unused_result__))
  __attribute__((__deprecated__("Use Qt::SplitBehavior variant instead")))
  QVector<QStringRef>
  splitRef(const QRegularExpression &sep, SplitBehavior behavior) const;

public:
  __attribute__((__warn_unused_result__)) QStringList
  split(const QString &sep, Qt::SplitBehavior behavior = Qt::KeepEmptyParts,
        Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
  __attribute__((__warn_unused_result__)) QVector<QStringRef>
  splitRef(const QString &sep, Qt::SplitBehavior behavior = Qt::KeepEmptyParts,
           Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
  __attribute__((__warn_unused_result__)) QStringList
  split(QChar sep, Qt::SplitBehavior behavior = Qt::KeepEmptyParts,
        Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
  __attribute__((__warn_unused_result__)) QVector<QStringRef>
  splitRef(QChar sep, Qt::SplitBehavior behavior = Qt::KeepEmptyParts,
           Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

  __attribute__((__warn_unused_result__)) QStringList
  split(const QRegExp &sep,
        Qt::SplitBehavior behavior = Qt::KeepEmptyParts) const;
  __attribute__((__warn_unused_result__)) QVector<QStringRef>
  splitRef(const QRegExp &sep,
           Qt::SplitBehavior behavior = Qt::KeepEmptyParts) const;

  __attribute__((__warn_unused_result__)) QStringList
  split(const QRegularExpression &sep,
        Qt::SplitBehavior behavior = Qt::KeepEmptyParts) const;
  __attribute__((__warn_unused_result__)) QVector<QStringRef>
  splitRef(const QRegularExpression &sep,
           Qt::SplitBehavior behavior = Qt::KeepEmptyParts) const;

  enum NormalizationForm {
    NormalizationForm_D,
    NormalizationForm_C,
    NormalizationForm_KD,
    NormalizationForm_KC
  };
  __attribute__((__warn_unused_result__)) QString
  normalized(NormalizationForm mode,
             QChar::UnicodeVersion version = QChar::Unicode_Unassigned) const;

  __attribute__((__warn_unused_result__)) QString repeated(int times) const;

  const ushort *utf16() const;

  __attribute__((__warn_unused_result__)) QByteArray toLatin1() const & {
    return toLatin1_helper(*this);
  }
  __attribute__((__warn_unused_result__)) QByteArray toLatin1() && {
    return toLatin1_helper_inplace(*this);
  }
  __attribute__((__warn_unused_result__)) QByteArray toUtf8() const & {
    return toUtf8_helper(*this);
  }
  __attribute__((__warn_unused_result__)) QByteArray toUtf8() && {
    return toUtf8_helper(*this);
  }
  __attribute__((__warn_unused_result__)) QByteArray toLocal8Bit() const & {
    return toLocal8Bit_helper(isNull() ? nullptr : constData(), size());
  }
  __attribute__((__warn_unused_result__)) QByteArray toLocal8Bit() && {
    return toLocal8Bit_helper(isNull() ? nullptr : constData(), size());
  }

  __attribute__((__warn_unused_result__)) QVector<uint> toUcs4() const;

  static inline QString fromLatin1(const char *str, int size = -1) {
    QStringDataPtr dataPtr = {
        fromLatin1_helper(str, (str && size == -1) ? int(strlen(str)) : size)};
    return QString(dataPtr);
  }
  static inline QString fromUtf8(const char *str, int size = -1) {
    return fromUtf8_helper(str, (str && size == -1) ? int(strlen(str)) : size);
  }
  static inline QString fromLocal8Bit(const char *str, int size = -1) {
    return fromLocal8Bit_helper(str,
                                (str && size == -1) ? int(strlen(str)) : size);
  }
  static inline QString fromLatin1(const QByteArray &str) {
    return str.isNull()
               ? QString()
               : fromLatin1(str.data(), qstrnlen(str.constData(), str.size()));
  }
  static inline QString fromUtf8(const QByteArray &str) {
    return str.isNull()
               ? QString()
               : fromUtf8(str.data(), qstrnlen(str.constData(), str.size()));
  }
  static inline QString fromLocal8Bit(const QByteArray &str) {
    return str.isNull() ? QString()
                        : fromLocal8Bit(str.data(),
                                        qstrnlen(str.constData(), str.size()));
  }
  static QString fromUtf16(const ushort *, int size = -1);
  static QString fromUcs4(const uint *, int size = -1);
  static QString fromRawData(const QChar *, int size);

  static QString fromUtf16(const char16_t *str, int size = -1) {
    return fromUtf16(reinterpret_cast<const ushort *>(str), size);
  }
  static QString fromUcs4(const char32_t *str, int size = -1) {
    return fromUcs4(reinterpret_cast<const uint *>(str), size);
  }
# 733 "/usr/local/include/QtCore/qstring.h"
  inline int toWCharArray(wchar_t *array) const;
  __attribute__((__warn_unused_result__)) static inline QString
  fromWCharArray(const wchar_t *string, int size = -1);

  QString &setRawData(const QChar *unicode, int size);
  QString &setUnicode(const QChar *unicode, int size);
  inline QString &setUtf16(const ushort *utf16, int size);

  int compare(const QString &s,
              Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept;
  inline int compare(const QStringRef &s,
                     Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept;

  int compare(QLatin1String other,
              Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept;
  inline int compare(QStringView s,
                     Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept;
  int compare(QChar ch,
              Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept {
    return compare(QStringView{&ch, 1}, cs);
  }

  static inline int
  compare(const QString &s1, const QString &s2,
          Qt::CaseSensitivity cs = Qt::CaseSensitive) noexcept {
    return s1.compare(s2, cs);
  }

  static inline int
  compare(const QString &s1, QLatin1String s2,
          Qt::CaseSensitivity cs = Qt::CaseSensitive) noexcept {
    return s1.compare(s2, cs);
  }
  static inline int
  compare(QLatin1String s1, const QString &s2,
          Qt::CaseSensitivity cs = Qt::CaseSensitive) noexcept {
    return -s2.compare(s1, cs);
  }

  static int compare(const QString &s1, const QStringRef &s2,
                     Qt::CaseSensitivity = Qt::CaseSensitive) noexcept;

  int localeAwareCompare(const QString &s) const;
  static int localeAwareCompare(const QString &s1, const QString &s2) {
    return s1.localeAwareCompare(s2);
  }

  int localeAwareCompare(const QStringRef &s) const;
  static int localeAwareCompare(const QString &s1, const QStringRef &s2);

  short toShort(bool *ok = nullptr, int base = 10) const;
  ushort toUShort(bool *ok = nullptr, int base = 10) const;
  int toInt(bool *ok = nullptr, int base = 10) const;
  uint toUInt(bool *ok = nullptr, int base = 10) const;
  long toLong(bool *ok = nullptr, int base = 10) const;
  ulong toULong(bool *ok = nullptr, int base = 10) const;
  qlonglong toLongLong(bool *ok = nullptr, int base = 10) const;
  qulonglong toULongLong(bool *ok = nullptr, int base = 10) const;
  float toFloat(bool *ok = nullptr) const;
  double toDouble(bool *ok = nullptr) const;

  QString &setNum(short, int base = 10);
  QString &setNum(ushort, int base = 10);
  QString &setNum(int, int base = 10);
  QString &setNum(uint, int base = 10);
  QString &setNum(long, int base = 10);
  QString &setNum(ulong, int base = 10);
  QString &setNum(qlonglong, int base = 10);
  QString &setNum(qulonglong, int base = 10);
  QString &setNum(float, char f = 'g', int prec = 6);
  QString &setNum(double, char f = 'g', int prec = 6);

  static QString number(int, int base = 10);
  static QString number(uint, int base = 10);
  static QString number(long, int base = 10);
  static QString number(ulong, int base = 10);
  static QString number(qlonglong, int base = 10);
  static QString number(qulonglong, int base = 10);
  static QString number(double, char f = 'g', int prec = 6);

  friend __attribute__((visibility("default"))) bool
  operator==(const QString &s1, const QString &s2) noexcept;
  friend __attribute__((visibility("default"))) bool
  operator<(const QString &s1, const QString &s2) noexcept;
  friend inline bool operator>(const QString &s1, const QString &s2) noexcept {
    return s2 < s1;
  }
  friend inline bool operator!=(const QString &s1, const QString &s2) noexcept {
    return !(s1 == s2);
  }
  friend inline bool operator<=(const QString &s1, const QString &s2) noexcept {
    return !(s1 > s2);
  }
  friend inline bool operator>=(const QString &s1, const QString &s2) noexcept {
    return !(s1 < s2);
  }

  bool operator==(QLatin1String s) const noexcept;
  bool operator<(QLatin1String s) const noexcept;
  bool operator>(QLatin1String s) const noexcept;
  inline bool operator!=(QLatin1String s) const noexcept {
    return !operator==(s);
  }
  inline bool operator<=(QLatin1String s) const noexcept {
    return !operator>(s);
  }
  inline bool operator>=(QLatin1String s) const noexcept {
    return !operator<(s);
  }
# 830 "/usr/local/include/QtCore/qstring.h"
  inline QString(const char *ch)
      : d(fromAscii_helper(ch, ch ? int(strlen(ch)) : -1)) {}
  inline QString(const QByteArray &a)
      : d(fromAscii_helper(a.constData(), qstrnlen(a.constData(), a.size()))) {}
  inline QString &operator=(const char *ch) { return (*this = fromUtf8(ch)); }
  inline QString &operator=(const QByteArray &a) {
    return (*this = fromUtf8(a));
  }
  inline QString &operator=(char c) { return (*this = QChar::fromLatin1(c)); }

  inline QString &prepend(const char *s) {
    return prepend(QString::fromUtf8(s));
  }
  inline QString &prepend(const QByteArray &s) {
    return prepend(QString::fromUtf8(s));
  }
  inline QString &append(const char *s) { return append(QString::fromUtf8(s)); }
  inline QString &append(const QByteArray &s) {
    return append(QString::fromUtf8(s));
  }
  inline QString &insert(int i, const char *s) {
    return insert(i, QString::fromUtf8(s));
  }
  inline QString &insert(int i, const QByteArray &s) {
    return insert(i, QString::fromUtf8(s));
  }
  inline QString &operator+=(const char *s) {
    return append(QString::fromUtf8(s));
  }
  inline QString &operator+=(const QByteArray &s) {
    return append(QString::fromUtf8(s));
  }
  inline QString &operator+=(char c) { return append(QChar::fromLatin1(c)); }

  inline bool operator==(const char *s) const;
  inline bool operator!=(const char *s) const;
  inline bool operator<(const char *s) const;
  inline bool operator<=(const char *s) const;
  inline bool operator>(const char *s) const;
  inline bool operator>=(const char *s) const;

  inline bool operator==(const QByteArray &s) const;
  inline bool operator!=(const QByteArray &s) const;
  inline bool operator<(const QByteArray &s) const;
  inline bool operator>(const QByteArray &s) const;
  inline bool operator<=(const QByteArray &s) const;
  inline bool operator>=(const QByteArray &s) const;

  friend inline bool operator==(const char *s1, const QString &s2);
  friend inline bool operator!=(const char *s1, const QString &s2);
  friend inline bool operator<(const char *s1, const QString &s2);
  friend inline bool operator>(const char *s1, const QString &s2);
  friend inline bool operator<=(const char *s1, const QString &s2);
  friend inline bool operator>=(const char *s1, const QString &s2);

  friend inline bool operator==(const char *s1, const QStringRef &s2);
  friend inline bool operator!=(const char *s1, const QStringRef &s2);
  friend inline bool operator<(const char *s1, const QStringRef &s2);
  friend inline bool operator>(const char *s1, const QStringRef &s2);
  friend inline bool operator<=(const char *s1, const QStringRef &s2);
  friend inline bool operator>=(const char *s1, const QStringRef &s2);

  typedef QChar *iterator;
  typedef const QChar *const_iterator;
  typedef iterator Iterator;
  typedef const_iterator ConstIterator;
  typedef std::reverse_iterator<iterator> reverse_iterator;
  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
  inline iterator begin();
  inline const_iterator begin() const;
  inline const_iterator cbegin() const;
  inline const_iterator constBegin() const;
  inline iterator end();
  inline const_iterator end() const;
  inline const_iterator cend() const;
  inline const_iterator constEnd() const;
  reverse_iterator rbegin() { return reverse_iterator(end()); }
  reverse_iterator rend() { return reverse_iterator(begin()); }
  const_reverse_iterator rbegin() const {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator rend() const {
    return const_reverse_iterator(begin());
  }
  const_reverse_iterator crbegin() const {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator crend() const {
    return const_reverse_iterator(begin());
  }

  typedef int size_type;
  typedef qptrdiff difference_type;
  typedef const QChar &const_reference;
  typedef QChar &reference;
  typedef QChar *pointer;
  typedef const QChar *const_pointer;
  typedef QChar value_type;
  inline void push_back(QChar c) { append(c); }
  inline void push_back(const QString &s) { append(s); }
  inline void push_front(QChar c) { prepend(c); }
  inline void push_front(const QString &s) { prepend(s); }
  void shrink_to_fit() { squeeze(); }

  static inline QString fromStdString(const std::string &s);
  inline std::string toStdString() const;
  static inline QString fromStdWString(const std::wstring &s);
  inline std::wstring toStdWString() const;

  static inline QString fromStdU16String(const std::u16string &s);
  inline std::u16string toStdU16String() const;
  static inline QString fromStdU32String(const std::u32string &s);
  inline std::u32string toStdU32String() const;

  static QString fromCFString(CFStringRef string);
  CFStringRef toCFString() const __attribute__((cf_returns_retained));
  static QString fromNSString(const NSString *string);
  NSString *toNSString() const;

  struct Null {};
  __attribute__((__deprecated__("use QString()"))) static const Null null;
  inline QString(const Null &) : d(Data::sharedNull()) {}
  inline QString &operator=(const Null &) {
    *this = QString();
    return *this;
  }

  inline bool isNull() const { return d == Data::sharedNull(); }

  bool isSimpleText() const;
  bool isRightToLeft() const;
  __attribute__((__warn_unused_result__)) bool isValidUtf16() const noexcept {
    return QStringView(*this).isValidUtf16();
  }

  QString(int size, Qt::Initialization);
  constexpr inline QString(QStringDataPtr dd) : d(dd.ptr) {}

private:
# 974 "/usr/local/include/QtCore/qstring.h"
  Data *d;

  friend inline bool operator==(QChar, const QString &) noexcept;
  friend inline bool operator<(QChar, const QString &) noexcept;
  friend inline bool operator>(QChar, const QString &) noexcept;
  friend inline bool operator==(QChar, const QStringRef &) noexcept;
  friend inline bool operator<(QChar, const QStringRef &) noexcept;
  friend inline bool operator>(QChar, const QStringRef &) noexcept;
  friend inline bool operator==(QChar, QLatin1String) noexcept;
  friend inline bool operator<(QChar, QLatin1String) noexcept;
  friend inline bool operator>(QChar, QLatin1String) noexcept;

  void reallocData(uint alloc, bool grow = false);

  void expand(int i);
  QString multiArg(int numArgs, const QString **args) const;

  static int
  compare_helper(const QChar *data1, int length1, const QChar *data2,
                 int length2,
                 Qt::CaseSensitivity cs = Qt::CaseSensitive) noexcept;
  static int compare_helper(const QChar *data1, int length1, const char *data2,
                            int length2,
                            Qt::CaseSensitivity cs = Qt::CaseSensitive);
  static int
  compare_helper(const QChar *data1, int length1, QLatin1String s2,
                 Qt::CaseSensitivity cs = Qt::CaseSensitive) noexcept;
  static int localeAwareCompare_helper(const QChar *data1, int length1,
                                       const QChar *data2, int length2);
  static QString toLower_helper(const QString &str);
  static QString toLower_helper(QString &str);
  static QString toUpper_helper(const QString &str);
  static QString toUpper_helper(QString &str);
  static QString toCaseFolded_helper(const QString &str);
  static QString toCaseFolded_helper(QString &str);
  static QString trimmed_helper(const QString &str);
  static QString trimmed_helper(QString &str);
  static QString simplified_helper(const QString &str);
  static QString simplified_helper(QString &str);
  static Data *fromLatin1_helper(const char *str, int size = -1);
  static Data *fromAscii_helper(const char *str, int size = -1);
  static QString fromUtf8_helper(const char *str, int size);
  static QString fromLocal8Bit_helper(const char *, int size);
  static QByteArray toLatin1_helper(const QString &);
  static QByteArray toLatin1_helper_inplace(QString &);
  static QByteArray toUtf8_helper(const QString &);
  static QByteArray toLocal8Bit_helper(const QChar *data, int size);
  static int toUcs4_helper(const ushort *uc, int length, uint *out);
  static qlonglong toIntegral_helper(const QChar *data, int len, bool *ok,
                                     int base);
  static qulonglong toIntegral_helper(const QChar *data, uint len, bool *ok,
                                      int base);
  void replace_helper(uint *indices, int nIndices, int blen, const QChar *after,
                      int alen);
  friend class QCharRef;
  friend class QTextCodec;
  friend class QStringRef;
  friend class QStringView;
  friend class QByteArray;
  friend class QCollator;
  friend struct QAbstractConcatenable;

  template <typename T>
  static T toIntegral_helper(const QChar *data, int len, bool *ok, int base) {
    using Int64 = typename std::conditional<std::is_unsigned<T>::value,
                                            qulonglong, qlonglong>::type;
    using Int32 =
        typename std::conditional<std::is_unsigned<T>::value, uint, int>::type;

    Int64 val = toIntegral_helper(data, Int32(len), ok, base);
    if (T(val) != val) {
      if (ok)
        *ok = false;
      val = 0;
    }
    return T(val);
  }

public:
  typedef Data *DataPtr;
  inline DataPtr &data_ptr() { return d; }
};

QString QStringView::toString() const {
  return ((size() == length())
              ? static_cast<void>(0)
              : qt_assert("size() == length()",
                          "/usr/local/include/QtCore/qstring.h", 1057)),
         QString(data(), length());
}

inline QString::QString(QLatin1String aLatin1)
    : d(fromLatin1_helper(aLatin1.latin1(), aLatin1.size())) {}
inline int QString::length() const { return d->size; }
inline const QChar QString::at(int i) const {
  ((uint(i) < uint(size()))
       ? static_cast<void>(0)
       : qt_assert("uint(i) < uint(size())",
                   "/usr/local/include/QtCore/qstring.h", 1067));
  return QChar(d->data()[i]);
}
inline const QChar QString::operator[](int i) const {
  ((uint(i) < uint(size()))
       ? static_cast<void>(0)
       : qt_assert("uint(i) < uint(size())",
                   "/usr/local/include/QtCore/qstring.h", 1069));
  return QChar(d->data()[i]);
}
inline const QChar QString::operator[](uint i) const {
  ((i < uint(size())) ? static_cast<void>(0)
                      : qt_assert("i < uint(size())",
                                  "/usr/local/include/QtCore/qstring.h", 1071));
  return QChar(d->data()[i]);
}
inline bool QString::isEmpty() const { return d->size == 0; }
inline const QChar *QString::unicode() const {
  return reinterpret_cast<const QChar *>(d->data());
}
inline const QChar *QString::data() const {
  return reinterpret_cast<const QChar *>(d->data());
}
inline QChar *QString::data() {
  detach();
  return reinterpret_cast<QChar *>(d->data());
}
inline const QChar *QString::constData() const {
  return reinterpret_cast<const QChar *>(d->data());
}
inline void QString::detach() {
  if (d->ref.isShared() || (d->offset != sizeof(QStringData)))
    reallocData(uint(d->size) + 1u);
}
inline bool QString::isDetached() const { return !d->ref.isShared(); }
inline void QString::clear() {
  if (!isNull())
    *this = QString();
}
inline QString::QString(const QString &other) noexcept : d(other.d) {
  ((&other != this) ? static_cast<void>(0)
                    : qt_assert("&other != this",
                                "/usr/local/include/QtCore/qstring.h", 1089));
  d->ref.ref();
}
inline int QString::capacity() const { return d->alloc ? d->alloc - 1 : 0; }
inline QString &QString::setNum(short n, int base) {
  return setNum(qlonglong(n), base);
}
inline QString &QString::setNum(ushort n, int base) {
  return setNum(qulonglong(n), base);
}
inline QString &QString::setNum(int n, int base) {
  return setNum(qlonglong(n), base);
}
inline QString &QString::setNum(uint n, int base) {
  return setNum(qulonglong(n), base);
}
inline QString &QString::setNum(long n, int base) {
  return setNum(qlonglong(n), base);
}
inline QString &QString::setNum(ulong n, int base) {
  return setNum(qulonglong(n), base);
}
inline QString &QString::setNum(float n, char f, int prec) {
  return setNum(double(n), f, prec);
}
inline QString QString::arg(int a, int fieldWidth, int base,
                            QChar fillChar) const {
  return arg(qlonglong(a), fieldWidth, base, fillChar);
}
inline QString QString::arg(uint a, int fieldWidth, int base,
                            QChar fillChar) const {
  return arg(qulonglong(a), fieldWidth, base, fillChar);
}
inline QString QString::arg(long a, int fieldWidth, int base,
                            QChar fillChar) const {
  return arg(qlonglong(a), fieldWidth, base, fillChar);
}
inline QString QString::arg(ulong a, int fieldWidth, int base,
                            QChar fillChar) const {
  return arg(qulonglong(a), fieldWidth, base, fillChar);
}
inline QString QString::arg(short a, int fieldWidth, int base,
                            QChar fillChar) const {
  return arg(qlonglong(a), fieldWidth, base, fillChar);
}
inline QString QString::arg(ushort a, int fieldWidth, int base,
                            QChar fillChar) const {
  return arg(qulonglong(a), fieldWidth, base, fillChar);
}

inline QString QString::arg(const QString &a1, const QString &a2) const {
  return qToStringViewIgnoringNull(*this).arg(a1, a2);
}
inline QString QString::arg(const QString &a1, const QString &a2,
                            const QString &a3) const {
  return qToStringViewIgnoringNull(*this).arg(a1, a2, a3);
}
inline QString QString::arg(const QString &a1, const QString &a2,
                            const QString &a3, const QString &a4) const {
  return qToStringViewIgnoringNull(*this).arg(a1, a2, a3, a4);
}
inline QString QString::arg(const QString &a1, const QString &a2,
                            const QString &a3, const QString &a4,
                            const QString &a5) const {
  return qToStringViewIgnoringNull(*this).arg(a1, a2, a3, a4, a5);
}
inline QString QString::arg(const QString &a1, const QString &a2,
                            const QString &a3, const QString &a4,
                            const QString &a5, const QString &a6) const {
  return qToStringViewIgnoringNull(*this).arg(a1, a2, a3, a4, a5, a6);
}
inline QString QString::arg(const QString &a1, const QString &a2,
                            const QString &a3, const QString &a4,
                            const QString &a5, const QString &a6,
                            const QString &a7) const {
  return qToStringViewIgnoringNull(*this).arg(a1, a2, a3, a4, a5, a6, a7);
}
inline QString QString::arg(const QString &a1, const QString &a2,
                            const QString &a3, const QString &a4,
                            const QString &a5, const QString &a6,
                            const QString &a7, const QString &a8) const {
  return qToStringViewIgnoringNull(*this).arg(a1, a2, a3, a4, a5, a6, a7, a8);
}
inline QString QString::arg(const QString &a1, const QString &a2,
                            const QString &a3, const QString &a4,
                            const QString &a5, const QString &a6,
                            const QString &a7, const QString &a8,
                            const QString &a9) const {
  return qToStringViewIgnoringNull(*this).arg(a1, a2, a3, a4, a5, a6, a7, a8,
                                              a9);
}

inline QString QString::section(QChar asep, int astart, int aend,
                                SectionFlags aflags) const {
  return section(QString(asep), astart, aend, aflags);
}

#pragma clang diagnostic push

inline int QString::toWCharArray(wchar_t *array) const {
  return qToStringViewIgnoringNull(*this).toWCharArray(array);
}

int QStringView::toWCharArray(wchar_t *array) const {
  if (sizeof(wchar_t) == sizeof(QChar)) {
    if (auto src = data())
      memcpy(array, src, sizeof(QChar) * size());
    return int(size());
  } else {
    return QString::toUcs4_helper(reinterpret_cast<const ushort *>(data()),
                                  int(size()), reinterpret_cast<uint *>(array));
  }
}

#pragma clang diagnostic pop

inline QString QString::fromWCharArray(const wchar_t *string, int size) {
  return sizeof(wchar_t) == sizeof(QChar)
             ? fromUtf16(reinterpret_cast<const ushort *>(string), size)
             : fromUcs4(reinterpret_cast<const uint *>(string), size);
}

class

    __attribute__((visibility("default")))

    QCharRef {
  QString &s;
  int i;
  inline QCharRef(QString &str, int idx) : s(str), i(idx) {}
  friend class QString;

public:
  inline operator QChar() const {
    using namespace QtPrivate::DeprecatedRefClassBehavior;
    if (__builtin_expect(!!(i < s.d->size), true))
      return QChar(s.d->data()[i]);

    warn(WarningType::OutOfRange, EmittingClass::QCharRef);

    return QChar();
  }
  inline QCharRef &operator=(QChar c) {
    using namespace QtPrivate::DeprecatedRefClassBehavior;
    if (__builtin_expect(!!(i >= s.d->size), false)) {

      warn(WarningType::OutOfRange, EmittingClass::QCharRef);

      s.resize(i + 1, QLatin1Char(' '));
    } else {

      if (__builtin_expect(!!(!s.isDetached()), false))
        warn(WarningType::DelayedDetach, EmittingClass::QCharRef);

      s.detach();
    }
    s.d->data()[i] = c.unicode();
    return *this;
  }

  inline QCharRef &operator=(char c) { return operator=(QChar::fromLatin1(c)); }
  inline QCharRef &operator=(uchar c) {
    return operator=(QChar::fromLatin1(c));
  }

  inline QCharRef &operator=(const QCharRef &c) { return operator=(QChar(c)); }
  inline QCharRef &operator=(ushort rc) { return operator=(QChar(rc)); }
  inline QCharRef &operator=(short rc) { return operator=(QChar(rc)); }
  inline QCharRef &operator=(uint rc) { return operator=(QChar(rc)); }
  inline QCharRef &operator=(int rc) { return operator=(QChar(rc)); }

  inline bool isNull() const { return QChar(*this).isNull(); }
  inline bool isPrint() const { return QChar(*this).isPrint(); }
  inline bool isPunct() const { return QChar(*this).isPunct(); }
  inline bool isSpace() const { return QChar(*this).isSpace(); }
  inline bool isMark() const { return QChar(*this).isMark(); }
  inline bool isLetter() const { return QChar(*this).isLetter(); }
  inline bool isNumber() const { return QChar(*this).isNumber(); }
  inline bool isLetterOrNumber() { return QChar(*this).isLetterOrNumber(); }
  inline bool isDigit() const { return QChar(*this).isDigit(); }
  inline bool isLower() const { return QChar(*this).isLower(); }
  inline bool isUpper() const { return QChar(*this).isUpper(); }
  inline bool isTitleCase() const { return QChar(*this).isTitleCase(); }

  inline int digitValue() const { return QChar(*this).digitValue(); }
  QChar toLower() const { return QChar(*this).toLower(); }
  QChar toUpper() const { return QChar(*this).toUpper(); }
  QChar toTitleCase() const { return QChar(*this).toTitleCase(); }

  QChar::Category category() const { return QChar(*this).category(); }
  QChar::Direction direction() const { return QChar(*this).direction(); }
  QChar::JoiningType joiningType() const { return QChar(*this).joiningType(); }

  __attribute__((__deprecated__)) QChar::Joining joining() const {
    switch (QChar(*this).joiningType()) {
    case QChar::Joining_Causing:
      return QChar::Center;
    case QChar::Joining_Dual:
      return QChar::Dual;
    case QChar::Joining_Right:
      return QChar::Right;
    case QChar::Joining_None:
    case QChar::Joining_Left:
    case QChar::Joining_Transparent:
    default:
      return QChar::OtherJoining;
    }
  }

  bool hasMirrored() const { return QChar(*this).hasMirrored(); }
  QChar mirroredChar() const { return QChar(*this).mirroredChar(); }
  QString decomposition() const { return QChar(*this).decomposition(); }
  QChar::Decomposition decompositionTag() const {
    return QChar(*this).decompositionTag();
  }
  uchar combiningClass() const { return QChar(*this).combiningClass(); }

  inline QChar::Script script() const { return QChar(*this).script(); }

  QChar::UnicodeVersion unicodeVersion() const {
    return QChar(*this).unicodeVersion();
  }

  inline uchar cell() const { return QChar(*this).cell(); }
  inline uchar row() const { return QChar(*this).row(); }
  inline void setCell(uchar cell);
  inline void setRow(uchar row);

  char toLatin1() const { return QChar(*this).toLatin1(); }
  ushort unicode() const { return QChar(*this).unicode(); }
  ushort &unicode() { return s.data()[i].unicode(); }
};
template <> class QTypeInfo<QCharRef> {
public:
  enum {
    isSpecialized = true,
    isComplex =
        (((Q_MOVABLE_TYPE)&Q_PRIMITIVE_TYPE) == 0) && !qIsTrivial<QCharRef>(),
    isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0),
    isRelocatable = !isStatic || ((Q_MOVABLE_TYPE)&Q_RELOCATABLE_TYPE) ||
                    qIsRelocatable<QCharRef>(),
    isLarge = (sizeof(QCharRef) > sizeof(void *)),
    isPointer = false,
    isIntegral = std::is_integral<QCharRef>::value,
    isDummy = (((Q_MOVABLE_TYPE)&Q_DUMMY_TYPE) != 0),
    sizeOf = sizeof(QCharRef)
  };
  static inline const char *name() { return "QCharRef"; }
};

inline void QCharRef::setRow(uchar arow) { QChar(*this).setRow(arow); }
inline void QCharRef::setCell(uchar acell) { QChar(*this).setCell(acell); }

inline QString::QString() noexcept : d(Data::sharedNull()) {}
inline QString::~QString() {
  if (!d->ref.deref())
    Data::deallocate(d);
}

inline void QString::reserve(int asize) {
  if (d->ref.isShared() || uint(asize) >= d->alloc)
    reallocData(qMax(asize, d->size) + 1u);

  if (!d->capacityReserved) {

    d->capacityReserved = true;
  }
}

inline void QString::squeeze() {
  if (d->ref.isShared() || uint(d->size) + 1u < d->alloc)
    reallocData(uint(d->size) + 1u);

  if (d->capacityReserved) {

    d->capacityReserved = false;
  }
}

inline QString &QString::setUtf16(const ushort *autf16, int asize) {
  return setUnicode(reinterpret_cast<const QChar *>(autf16), asize);
}
inline QCharRef QString::operator[](int i) {
  ((i >= 0) ? static_cast<void>(0)
            : qt_assert("i >= 0", "/usr/local/include/QtCore/qstring.h", 1329));
  detach();
  return QCharRef(*this, i);
}
inline QCharRef QString::operator[](uint i) {
  detach();
  return QCharRef(*this, i);
}
inline QCharRef QString::front() { return operator[](0); }
inline QCharRef QString::back() { return operator[](size() - 1); }
inline QString::iterator QString::begin() {
  detach();
  return reinterpret_cast<QChar *>(d->data());
}
inline QString::const_iterator QString::begin() const {
  return reinterpret_cast<const QChar *>(d->data());
}
inline QString::const_iterator QString::cbegin() const {
  return reinterpret_cast<const QChar *>(d->data());
}
inline QString::const_iterator QString::constBegin() const {
  return reinterpret_cast<const QChar *>(d->data());
}
inline QString::iterator QString::end() {
  detach();
  return reinterpret_cast<QChar *>(d->data() + d->size);
}
inline QString::const_iterator QString::end() const {
  return reinterpret_cast<const QChar *>(d->data() + d->size);
}
inline QString::const_iterator QString::cend() const {
  return reinterpret_cast<const QChar *>(d->data() + d->size);
}
inline QString::const_iterator QString::constEnd() const {
  return reinterpret_cast<const QChar *>(d->data() + d->size);
}

inline bool QString::contains(const QString &s, Qt::CaseSensitivity cs) const {
  return indexOf(s, 0, cs) != -1;
}
inline bool QString::contains(const QStringRef &s,
                              Qt::CaseSensitivity cs) const {
  return indexOf(s, 0, cs) != -1;
}

inline bool QString::contains(QLatin1String s, Qt::CaseSensitivity cs) const {
  return indexOf(s, 0, cs) != -1;
}
inline bool QString::contains(QChar c, Qt::CaseSensitivity cs) const {
  return indexOf(c, 0, cs) != -1;
}
inline bool QString::contains(QStringView s,
                              Qt::CaseSensitivity cs) const noexcept {
  return indexOf(s, 0, cs) != -1;
}

inline bool operator==(QString::Null, QString::Null) { return true; }
__attribute__((__deprecated__("use QString::isNull()"))) inline bool
operator==(QString::Null, const QString &s) {
  return s.isNull();
}
__attribute__((__deprecated__("use QString::isNull()"))) inline bool
operator==(const QString &s, QString::Null) {
  return s.isNull();
}
inline bool operator!=(QString::Null, QString::Null) { return false; }
__attribute__((__deprecated__("use !QString::isNull()"))) inline bool
operator!=(QString::Null, const QString &s) {
  return !s.isNull();
}
__attribute__((__deprecated__("use !QString::isNull()"))) inline bool
operator!=(const QString &s, QString::Null) {
  return !s.isNull();
}

inline bool operator==(QLatin1String s1, QLatin1String s2) noexcept {
  return s1.size() == s2.size() &&
         (!s1.size() || !memcmp(s1.latin1(), s2.latin1(), s1.size()));
}
inline bool operator!=(QLatin1String s1, QLatin1String s2) noexcept {
  return !operator==(s1, s2);
}
inline bool operator<(QLatin1String s1, QLatin1String s2) noexcept {
  const int len = qMin(s1.size(), s2.size());
  const int r = len ? memcmp(s1.latin1(), s2.latin1(), len) : 0;
  return r < 0 || (r == 0 && s1.size() < s2.size());
}
inline bool operator>(QLatin1String s1, QLatin1String s2) noexcept {
  return operator<(s2, s1);
}
inline bool operator<=(QLatin1String s1, QLatin1String s2) noexcept {
  return !operator>(s1, s2);
}
inline bool operator>=(QLatin1String s1, QLatin1String s2) noexcept {
  return !operator<(s1, s2);
}

inline bool QLatin1String::operator==(const QString &s) const noexcept {
  return s == *this;
}
inline bool QLatin1String::operator!=(const QString &s) const noexcept {
  return s != *this;
}
inline bool QLatin1String::operator>(const QString &s) const noexcept {
  return s < *this;
}
inline bool QLatin1String::operator<(const QString &s) const noexcept {
  return s > *this;
}
inline bool QLatin1String::operator>=(const QString &s) const noexcept {
  return s <= *this;
}
inline bool QLatin1String::operator<=(const QString &s) const noexcept {
  return s >= *this;
}

inline bool QString::operator==(const char *s) const {
  return QString::compare_helper(constData(), size(), s, -1) == 0;
}
inline bool QString::operator!=(const char *s) const {
  return QString::compare_helper(constData(), size(), s, -1) != 0;
}
inline bool QString::operator<(const char *s) const {
  return QString::compare_helper(constData(), size(), s, -1) < 0;
}
inline bool QString::operator>(const char *s) const {
  return QString::compare_helper(constData(), size(), s, -1) > 0;
}
inline bool QString::operator<=(const char *s) const {
  return QString::compare_helper(constData(), size(), s, -1) <= 0;
}
inline bool QString::operator>=(const char *s) const {
  return QString::compare_helper(constData(), size(), s, -1) >= 0;
}

inline bool operator==(const char *s1, const QString &s2) {
  return QString::compare_helper(s2.constData(), s2.size(), s1, -1) == 0;
}
inline bool operator!=(const char *s1, const QString &s2) {
  return QString::compare_helper(s2.constData(), s2.size(), s1, -1) != 0;
}
inline bool operator<(const char *s1, const QString &s2) {
  return QString::compare_helper(s2.constData(), s2.size(), s1, -1) > 0;
}
inline bool operator>(const char *s1, const QString &s2) {
  return QString::compare_helper(s2.constData(), s2.size(), s1, -1) < 0;
}
inline bool operator<=(const char *s1, const QString &s2) {
  return QString::compare_helper(s2.constData(), s2.size(), s1, -1) >= 0;
}
inline bool operator>=(const char *s1, const QString &s2) {
  return QString::compare_helper(s2.constData(), s2.size(), s1, -1) <= 0;
}

inline bool operator==(const char *s1, QLatin1String s2) {
  return QString::fromUtf8(s1) == s2;
}
inline bool operator!=(const char *s1, QLatin1String s2) {
  return QString::fromUtf8(s1) != s2;
}
inline bool operator<(const char *s1, QLatin1String s2) {
  return (QString::fromUtf8(s1) < s2);
}
inline bool operator>(const char *s1, QLatin1String s2) {
  return (QString::fromUtf8(s1) > s2);
}
inline bool operator<=(const char *s1, QLatin1String s2) {
  return (QString::fromUtf8(s1) <= s2);
}
inline bool operator>=(const char *s1, QLatin1String s2) {
  return (QString::fromUtf8(s1) >= s2);
}

inline bool QLatin1String::operator==(const char *s) const {
  return QString::fromUtf8(s) == *this;
}
inline bool QLatin1String::operator!=(const char *s) const {
  return QString::fromUtf8(s) != *this;
}
inline bool QLatin1String::operator<(const char *s) const {
  return QString::fromUtf8(s) > *this;
}
inline bool QLatin1String::operator>(const char *s) const {
  return QString::fromUtf8(s) < *this;
}
inline bool QLatin1String::operator<=(const char *s) const {
  return QString::fromUtf8(s) >= *this;
}
inline bool QLatin1String::operator>=(const char *s) const {
  return QString::fromUtf8(s) <= *this;
}

inline bool QLatin1String::operator==(const QByteArray &s) const {
  return QString::fromUtf8(s) == *this;
}
inline bool QLatin1String::operator!=(const QByteArray &s) const {
  return QString::fromUtf8(s) != *this;
}
inline bool QLatin1String::operator<(const QByteArray &s) const {
  return QString::fromUtf8(s) > *this;
}
inline bool QLatin1String::operator>(const QByteArray &s) const {
  return QString::fromUtf8(s) < *this;
}
inline bool QLatin1String::operator<=(const QByteArray &s) const {
  return QString::fromUtf8(s) >= *this;
}
inline bool QLatin1String::operator>=(const QByteArray &s) const {
  return QString::fromUtf8(s) <= *this;
}

inline bool QString::operator==(const QByteArray &s) const {
  return QString::compare_helper(constData(), size(), s.constData(),
                                 qstrnlen(s.constData(), s.size())) == 0;
}
inline bool QString::operator!=(const QByteArray &s) const {
  return QString::compare_helper(constData(), size(), s.constData(),
                                 qstrnlen(s.constData(), s.size())) != 0;
}
inline bool QString::operator<(const QByteArray &s) const {
  return QString::compare_helper(constData(), size(), s.constData(), s.size()) <
         0;
}
inline bool QString::operator>(const QByteArray &s) const {
  return QString::compare_helper(constData(), size(), s.constData(), s.size()) >
         0;
}
inline bool QString::operator<=(const QByteArray &s) const {
  return QString::compare_helper(constData(), size(), s.constData(),
                                 s.size()) <= 0;
}
inline bool QString::operator>=(const QByteArray &s) const {
  return QString::compare_helper(constData(), size(), s.constData(),
                                 s.size()) >= 0;
}

inline bool QByteArray::operator==(const QString &s) const {
  return QString::compare_helper(s.constData(), s.size(), constData(),
                                 qstrnlen(constData(), size())) == 0;
}
inline bool QByteArray::operator!=(const QString &s) const {
  return QString::compare_helper(s.constData(), s.size(), constData(),
                                 qstrnlen(constData(), size())) != 0;
}
inline bool QByteArray::operator<(const QString &s) const {
  return QString::compare_helper(s.constData(), s.size(), constData(), size()) >
         0;
}
inline bool QByteArray::operator>(const QString &s) const {
  return QString::compare_helper(s.constData(), s.size(), constData(), size()) <
         0;
}
inline bool QByteArray::operator<=(const QString &s) const {
  return QString::compare_helper(s.constData(), s.size(), constData(),
                                 size()) >= 0;
}
inline bool QByteArray::operator>=(const QString &s) const {
  return QString::compare_helper(s.constData(), s.size(), constData(),
                                 size()) <= 0;
}

inline QByteArray &QByteArray::append(const QString &s) {
  return append(s.toUtf8());
}
inline QByteArray &QByteArray::insert(int i, const QString &s) {
  return insert(i, s.toUtf8());
}
inline QByteArray &QByteArray::replace(char c, const QString &after) {
  return replace(c, after.toUtf8());
}
inline QByteArray &QByteArray::replace(const QString &before,
                                       const char *after) {
  return replace(before.toUtf8(), after);
}
inline QByteArray &QByteArray::replace(const QString &before,
                                       const QByteArray &after) {
  return replace(before.toUtf8(), after);
}
inline QByteArray &QByteArray::operator+=(const QString &s) {
  return operator+=(s.toUtf8());
}
inline int QByteArray::indexOf(const QString &s, int from) const {
  return indexOf(s.toUtf8(), from);
}
inline int QByteArray::lastIndexOf(const QString &s, int from) const {
  return lastIndexOf(s.toUtf8(), from);
}

inline const QString operator+(const QString &s1, const QString &s2) {
  QString t(s1);
  t += s2;
  return t;
}
inline const QString operator+(const QString &s1, QChar s2) {
  QString t(s1);
  t += s2;
  return t;
}
inline const QString operator+(QChar s1, const QString &s2) {
  QString t(s1);
  t += s2;
  return t;
}

inline const QString operator+(const QString &s1, const char *s2) {
  QString t(s1);
  t += QString::fromUtf8(s2);
  return t;
}
inline const QString operator+(const char *s1, const QString &s2) {
  QString t = QString::fromUtf8(s1);
  t += s2;
  return t;
}
inline const QString operator+(char c, const QString &s) {
  QString t = s;
  t.prepend(QChar::fromLatin1(c));
  return t;
}
inline const QString operator+(const QString &s, char c) {
  QString t = s;
  t += QChar::fromLatin1(c);
  return t;
}
inline const QString operator+(const QByteArray &ba, const QString &s) {
  QString t = QString::fromUtf8(ba);
  t += s;
  return t;
}
inline const QString operator+(const QString &s, const QByteArray &ba) {
  QString t(s);
  t += QString::fromUtf8(ba);
  return t;
}

inline std::string QString::toStdString() const {
  return toUtf8().toStdString();
}

inline QString QString::fromStdString(const std::string &s) {
  return fromUtf8(s.data(), int(s.size()));
}

inline std::wstring QString::toStdWString() const {
  std::wstring str;
  str.resize(length());

  if (length())
    str.resize(toWCharArray(&str.front()));

  return str;
}

inline QString QString::fromStdWString(const std::wstring &s) {
  return fromWCharArray(s.data(), int(s.size()));
}

inline QString QString::fromStdU16String(const std::u16string &s) {
  return fromUtf16(s.data(), int(s.size()));
}

inline std::u16string QString::toStdU16String() const {
  return std::u16string(reinterpret_cast<const char16_t *>(utf16()), length());
}

inline QString QString::fromStdU32String(const std::u32string &s) {
  return fromUcs4(s.data(), int(s.size()));
}

inline std::u32string QString::toStdU32String() const {
  std::u32string u32str(length(), char32_t(0));
  int len =
      toUcs4_helper(d->data(), length(), reinterpret_cast<uint *>(&u32str[0]));
  u32str.resize(len);
  return u32str;
}

__attribute__((visibility("default"))) QDataStream &operator<<(QDataStream &,
                                                               const QString &);
__attribute__((visibility("default"))) QDataStream &operator>>(QDataStream &,
                                                               QString &);

template <> class QTypeInfo<QString> {
public:
  enum {
    isSpecialized = true,
    isComplex =
        (((Q_MOVABLE_TYPE)&Q_PRIMITIVE_TYPE) == 0) && !qIsTrivial<QString>(),
    isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0),
    isRelocatable = !isStatic || ((Q_MOVABLE_TYPE)&Q_RELOCATABLE_TYPE) ||
                    qIsRelocatable<QString>(),
    isLarge = (sizeof(QString) > sizeof(void *)),
    isPointer = false,
    isIntegral = std::is_integral<QString>::value,
    isDummy = (((Q_MOVABLE_TYPE)&Q_DUMMY_TYPE) != 0),
    sizeOf = sizeof(QString)
  };
  static inline const char *name() { return "QString"; }
};
inline void swap(QString &value1,
                 QString &value2) noexcept(noexcept(value1.swap(value2))) {
  value1.swap(value2);
}
constexpr inline QFlags<QString::SectionFlags::enum_type>
operator|(QString::SectionFlags::enum_type f1,
          QString::SectionFlags::enum_type f2) noexcept {
  return QFlags<QString::SectionFlags::enum_type>(f1) | f2;
}
constexpr inline QFlags<QString::SectionFlags::enum_type>
operator|(QString::SectionFlags::enum_type f1,
          QFlags<QString::SectionFlags::enum_type> f2) noexcept {
  return f2 | f1;
}
constexpr inline QIncompatibleFlag
operator|(QString::SectionFlags::enum_type f1, int f2) noexcept {
  return QIncompatibleFlag(int(f1) | f2);
}

class __attribute__((visibility("default"))) QStringRef {
  const QString *m_string;
  int m_position;
  int m_size;

public:
  typedef QString::size_type size_type;
  typedef QString::value_type value_type;
  typedef const QChar *const_iterator;
  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
  typedef QString::const_pointer const_pointer;
  typedef QString::const_reference const_reference;

  inline QStringRef() : m_string(nullptr), m_position(0), m_size(0) {}
  inline QStringRef(const QString *string, int position, int size);
  inline QStringRef(const QString *string);

  QStringRef(const QStringRef &other) noexcept
      : m_string(other.m_string), m_position(other.m_position),
        m_size(other.m_size) {}
  QStringRef(QStringRef &&other) noexcept
      : m_string(other.m_string), m_position(other.m_position),
        m_size(other.m_size) {}
  QStringRef &operator=(QStringRef &&other) noexcept { return *this = other; }
  QStringRef &operator=(const QStringRef &other) noexcept {
    m_string = other.m_string;
    m_position = other.m_position;
    m_size = other.m_size;
    return *this;
  }
  inline ~QStringRef() {}

  inline const QString *string() const { return m_string; }
  inline int position() const { return m_position; }
  inline int size() const { return m_size; }
  inline int count() const { return m_size; }
  inline int length() const { return m_size; }

  int indexOf(const QString &str, int from = 0,
              Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
  int indexOf(const QStringRef &str, int from = 0,
              Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

  __attribute__((__warn_unused_result__)) int
  indexOf(QStringView s, int from = 0,
          Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept {
    return int(QtPrivate::findString(*this, from, s, cs));
  }
  int indexOf(QChar ch, int from = 0,
              Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
  int indexOf(QLatin1String str, int from = 0,
              Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

  int lastIndexOf(const QStringRef &str, int from = -1,
                  Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
  int lastIndexOf(const QString &str, int from = -1,
                  Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

  int lastIndexOf(QChar ch, int from = -1,
                  Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
  int lastIndexOf(QLatin1String str, int from = -1,
                  Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
  __attribute__((__warn_unused_result__)) int
  lastIndexOf(QStringView s, int from = -1,
              Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept {
    return int(QtPrivate::lastIndexOf(*this, from, s, cs));
  }

  inline bool contains(const QString &str,
                       Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
  inline bool contains(const QStringRef &str,
                       Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

  inline bool contains(QChar ch,
                       Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
  inline bool contains(QLatin1String str,
                       Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
  inline bool
  contains(QStringView str,
           Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept;

  int count(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
  int count(QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
  int count(const QStringRef &s,
            Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

  __attribute__((__warn_unused_result__))
  __attribute__((__deprecated__("Use Qt::SplitBehavior variant instead")))
  QVector<QStringRef>
  split(const QString &sep, QString::SplitBehavior behavior,
        Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
  __attribute__((__warn_unused_result__))
  __attribute__((__deprecated__("Use Qt::SplitBehavior variant instead")))
  QVector<QStringRef>
  split(QChar sep, QString::SplitBehavior behavior,
        Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

  __attribute__((__warn_unused_result__)) QVector<QStringRef>
  split(const QString &sep, Qt::SplitBehavior behavior = Qt::KeepEmptyParts,
        Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
  __attribute__((__warn_unused_result__)) QVector<QStringRef>
  split(QChar sep, Qt::SplitBehavior behavior = Qt::KeepEmptyParts,
        Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

  __attribute__((__warn_unused_result__)) QStringRef left(int n) const;
  __attribute__((__warn_unused_result__)) QStringRef right(int n) const;
  __attribute__((__warn_unused_result__)) QStringRef mid(int pos,
                                                         int n = -1) const;
  __attribute__((__warn_unused_result__)) QStringRef chopped(int n) const {
    ((n >= 0)
         ? static_cast<void>(0)
         : qt_assert("n >= 0", "/usr/local/include/QtCore/qstring.h", 1678));
    ((n <= size()) ? static_cast<void>(0)
                   : qt_assert("n <= size()",
                               "/usr/local/include/QtCore/qstring.h", 1678));
    return left(size() - n);
  }

  void truncate(int pos) noexcept { m_size = qBound(0, pos, m_size); }
  void chop(int n) noexcept {
    if (n >= m_size)
      m_size = 0;
    else if (n > 0)
      m_size -= n;
  }

  bool isRightToLeft() const;

  __attribute__((__warn_unused_result__)) bool
  startsWith(QStringView s,
             Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept {
    return QtPrivate::startsWith(*this, s, cs);
  }
  bool startsWith(QLatin1String s,
                  Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
  bool startsWith(QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

  bool startsWith(const QString &s,
                  Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
  bool startsWith(const QStringRef &c,
                  Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

  __attribute__((__warn_unused_result__)) bool
  endsWith(QStringView s,
           Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept {
    return QtPrivate::endsWith(*this, s, cs);
  }
  bool endsWith(QLatin1String s,
                Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
  bool endsWith(QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

  bool endsWith(const QString &s,
                Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
  bool endsWith(const QStringRef &c,
                Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

  inline QStringRef &operator=(const QString *string);

  inline const QChar *unicode() const {
    if (!m_string)
      return reinterpret_cast<const QChar *>(
          QString::Data::sharedNull()->data());
    return m_string->unicode() + m_position;
  }
  inline const QChar *data() const { return unicode(); }
  inline const QChar *constData() const { return unicode(); }

  inline const_iterator begin() const { return unicode(); }
  inline const_iterator cbegin() const { return unicode(); }
  inline const_iterator constBegin() const { return unicode(); }
  inline const_iterator end() const { return unicode() + size(); }
  inline const_iterator cend() const { return unicode() + size(); }
  inline const_iterator constEnd() const { return unicode() + size(); }
  inline const_reverse_iterator rbegin() const {
    return const_reverse_iterator(end());
  }
  inline const_reverse_iterator crbegin() const { return rbegin(); }
  inline const_reverse_iterator rend() const {
    return const_reverse_iterator(begin());
  }
  inline const_reverse_iterator crend() const { return rend(); }

  __attribute__((__warn_unused_result__)) QByteArray toLatin1() const;
  __attribute__((__warn_unused_result__)) QByteArray toUtf8() const;
  __attribute__((__warn_unused_result__)) QByteArray toLocal8Bit() const;
  __attribute__((__warn_unused_result__)) QVector<uint> toUcs4() const;

  inline void clear() {
    m_string = nullptr;
    m_position = m_size = 0;
  }
  QString toString() const;
  inline bool isEmpty() const { return m_size == 0; }
  inline bool isNull() const {
    return m_string == nullptr || m_string->isNull();
  }

  QStringRef appendTo(QString *string) const;

  inline const QChar at(int i) const {
    ((uint(i) < uint(size()))
         ? static_cast<void>(0)
         : qt_assert("uint(i) < uint(size())",
                     "/usr/local/include/QtCore/qstring.h", 1748));
    return m_string->at(i + m_position);
  }
  QChar operator[](int i) const { return at(i); }
  __attribute__((__warn_unused_result__)) QChar front() const { return at(0); }
  __attribute__((__warn_unused_result__)) QChar back() const {
    return at(size() - 1);
  }

  inline bool operator==(const char *s) const;
  inline bool operator!=(const char *s) const;
  inline bool operator<(const char *s) const;
  inline bool operator<=(const char *s) const;
  inline bool operator>(const char *s) const;
  inline bool operator>=(const char *s) const;

  int compare(const QString &s,
              Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept;
  int compare(const QStringRef &s,
              Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept;
  int compare(QChar c,
              Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept {
    return QtPrivate::compareStrings(*this, QStringView(&c, 1), cs);
  }
  int compare(QLatin1String s,
              Qt::CaseSensitivity cs = Qt::CaseSensitive) const noexcept;

  int compare(const QByteArray &s,
              Qt::CaseSensitivity cs = Qt::CaseSensitive) const {
    return QString::compare_helper(unicode(), size(), s.data(),
                                   qstrnlen(s.data(), s.size()), cs);
  }

  static int compare(const QStringRef &s1, const QString &s2,
                     Qt::CaseSensitivity = Qt::CaseSensitive) noexcept;
  static int compare(const QStringRef &s1, const QStringRef &s2,
                     Qt::CaseSensitivity = Qt::CaseSensitive) noexcept;
  static int compare(const QStringRef &s1, QLatin1String s2,
                     Qt::CaseSensitivity cs = Qt::CaseSensitive) noexcept;

  int localeAwareCompare(const QString &s) const;
  int localeAwareCompare(const QStringRef &s) const;
  static int localeAwareCompare(const QStringRef &s1, const QString &s2);
  static int localeAwareCompare(const QStringRef &s1, const QStringRef &s2);

  __attribute__((__warn_unused_result__)) QStringRef trimmed() const;
  short toShort(bool *ok = nullptr, int base = 10) const;
  ushort toUShort(bool *ok = nullptr, int base = 10) const;
  int toInt(bool *ok = nullptr, int base = 10) const;
  uint toUInt(bool *ok = nullptr, int base = 10) const;
  long toLong(bool *ok = nullptr, int base = 10) const;
  ulong toULong(bool *ok = nullptr, int base = 10) const;
  qlonglong toLongLong(bool *ok = nullptr, int base = 10) const;
  qulonglong toULongLong(bool *ok = nullptr, int base = 10) const;
  float toFloat(bool *ok = nullptr) const;
  double toDouble(bool *ok = nullptr) const;
};
template <> class QTypeInfo<QStringRef> {
public:
  enum {
    isSpecialized = true,
    isComplex = (((Q_PRIMITIVE_TYPE)&Q_PRIMITIVE_TYPE) == 0) &&
                !qIsTrivial<QStringRef>(),
    isStatic =
        (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0),
    isRelocatable = !isStatic || ((Q_PRIMITIVE_TYPE)&Q_RELOCATABLE_TYPE) ||
                    qIsRelocatable<QStringRef>(),
    isLarge = (sizeof(QStringRef) > sizeof(void *)),
    isPointer = false,
    isIntegral = std::is_integral<QStringRef>::value,
    isDummy = (((Q_PRIMITIVE_TYPE)&Q_DUMMY_TYPE) != 0),
    sizeOf = sizeof(QStringRef)
  };
  static inline const char *name() { return "QStringRef"; }
};

inline QStringRef &QStringRef::operator=(const QString *aString) {
  m_string = aString;
  m_position = 0;
  m_size = aString ? aString->size() : 0;
  return *this;
}

inline QStringRef::QStringRef(const QString *aString, int aPosition, int aSize)
    : m_string(aString), m_position(aPosition), m_size(aSize) {}

inline QStringRef::QStringRef(const QString *aString)
    : m_string(aString), m_position(0), m_size(aString ? aString->size() : 0) {}

__attribute__((visibility("default"))) bool
operator==(const QStringRef &s1, const QStringRef &s2) noexcept;
inline bool operator!=(const QStringRef &s1, const QStringRef &s2) noexcept {
  return !(s1 == s2);
}
__attribute__((visibility("default"))) bool
operator<(const QStringRef &s1, const QStringRef &s2) noexcept;
inline bool operator>(const QStringRef &s1, const QStringRef &s2) noexcept {
  return s2 < s1;
}
inline bool operator<=(const QStringRef &s1, const QStringRef &s2) noexcept {
  return !(s1 > s2);
}
inline bool operator>=(const QStringRef &s1, const QStringRef &s2) noexcept {
  return !(s1 < s2);
}

__attribute__((visibility("default"))) bool
operator==(const QString &lhs, const QStringRef &rhs) noexcept;
inline bool operator!=(const QString &lhs, const QStringRef &rhs) noexcept {
  return lhs.compare(rhs) != 0;
}
inline bool operator<(const QString &lhs, const QStringRef &rhs) noexcept {
  return lhs.compare(rhs) < 0;
}
inline bool operator>(const QString &lhs, const QStringRef &rhs) noexcept {
  return lhs.compare(rhs) > 0;
}
inline bool operator<=(const QString &lhs, const QStringRef &rhs) noexcept {
  return lhs.compare(rhs) <= 0;
}
inline bool operator>=(const QString &lhs, const QStringRef &rhs) noexcept {
  return lhs.compare(rhs) >= 0;
}

inline bool operator==(const QStringRef &lhs, const QString &rhs) noexcept {
  return rhs == lhs;
}
inline bool operator!=(const QStringRef &lhs, const QString &rhs) noexcept {
  return rhs != lhs;
}
inline bool operator<(const QStringRef &lhs, const QString &rhs) noexcept {
  return rhs > lhs;
}
inline bool operator>(const QStringRef &lhs, const QString &rhs) noexcept {
  return rhs < lhs;
}
inline bool operator<=(const QStringRef &lhs, const QString &rhs) noexcept {
  return rhs >= lhs;
}
inline bool operator>=(const QStringRef &lhs, const QString &rhs) noexcept {
  return rhs <= lhs;
}

inline int QString::compare(const QStringRef &s,
                            Qt::CaseSensitivity cs) const noexcept {
  return QString::compare_helper(constData(), length(), s.constData(),
                                 s.length(), cs);
}

inline int QString::compare(QStringView s,
                            Qt::CaseSensitivity cs) const noexcept {
  return -s.compare(*this, cs);
}
inline int QString::compare(const QString &s1, const QStringRef &s2,
                            Qt::CaseSensitivity cs) noexcept {
  return QString::compare_helper(s1.constData(), s1.length(), s2.constData(),
                                 s2.length(), cs);
}
inline int QStringRef::compare(const QString &s,
                               Qt::CaseSensitivity cs) const noexcept {
  return QString::compare_helper(constData(), length(), s.constData(),
                                 s.length(), cs);
}
inline int QStringRef::compare(const QStringRef &s,
                               Qt::CaseSensitivity cs) const noexcept {
  return QString::compare_helper(constData(), length(), s.constData(),
                                 s.length(), cs);
}
inline int QStringRef::compare(QLatin1String s,
                               Qt::CaseSensitivity cs) const noexcept {
  return QString::compare_helper(constData(), length(), s, cs);
}
inline int QStringRef::compare(const QStringRef &s1, const QString &s2,
                               Qt::CaseSensitivity cs) noexcept {
  return QString::compare_helper(s1.constData(), s1.length(), s2.constData(),
                                 s2.length(), cs);
}
inline int QStringRef::compare(const QStringRef &s1, const QStringRef &s2,
                               Qt::CaseSensitivity cs) noexcept {
  return QString::compare_helper(s1.constData(), s1.length(), s2.constData(),
                                 s2.length(), cs);
}
inline int QStringRef::compare(const QStringRef &s1, QLatin1String s2,
                               Qt::CaseSensitivity cs) noexcept {
  return QString::compare_helper(s1.constData(), s1.length(), s2, cs);
}

__attribute__((visibility("default"))) bool
operator==(QLatin1String lhs, const QStringRef &rhs) noexcept;
inline bool operator!=(QLatin1String lhs, const QStringRef &rhs) noexcept {
  return rhs.compare(lhs) != 0;
}
inline bool operator<(QLatin1String lhs, const QStringRef &rhs) noexcept {
  return rhs.compare(lhs) > 0;
}
inline bool operator>(QLatin1String lhs, const QStringRef &rhs) noexcept {
  return rhs.compare(lhs) < 0;
}
inline bool operator<=(QLatin1String lhs, const QStringRef &rhs) noexcept {
  return rhs.compare(lhs) >= 0;
}
inline bool operator>=(QLatin1String lhs, const QStringRef &rhs) noexcept {
  return rhs.compare(lhs) <= 0;
}

inline bool operator==(const QStringRef &lhs, QLatin1String rhs) noexcept {
  return rhs == lhs;
}
inline bool operator!=(const QStringRef &lhs, QLatin1String rhs) noexcept {
  return rhs != lhs;
}
inline bool operator<(const QStringRef &lhs, QLatin1String rhs) noexcept {
  return rhs > lhs;
}
inline bool operator>(const QStringRef &lhs, QLatin1String rhs) noexcept {
  return rhs < lhs;
}
inline bool operator<=(const QStringRef &lhs, QLatin1String rhs) noexcept {
  return rhs >= lhs;
}
inline bool operator>=(const QStringRef &lhs, QLatin1String rhs) noexcept {
  return rhs <= lhs;
}

inline bool operator==(QChar lhs, const QString &rhs) noexcept {
  return rhs.size() == 1 && lhs == rhs.front();
}
inline bool operator<(QChar lhs, const QString &rhs) noexcept {
  return QString::compare_helper(&lhs, 1, rhs.data(), rhs.size()) < 0;
}
inline bool operator>(QChar lhs, const QString &rhs) noexcept {
  return QString::compare_helper(&lhs, 1, rhs.data(), rhs.size()) > 0;
}

inline bool operator!=(QChar lhs, const QString &rhs) noexcept {
  return !(lhs == rhs);
}
inline bool operator<=(QChar lhs, const QString &rhs) noexcept {
  return !(lhs > rhs);
}
inline bool operator>=(QChar lhs, const QString &rhs) noexcept {
  return !(lhs < rhs);
}

inline bool operator==(const QString &lhs, QChar rhs) noexcept {
  return rhs == lhs;
}
inline bool operator!=(const QString &lhs, QChar rhs) noexcept {
  return !(rhs == lhs);
}
inline bool operator<(const QString &lhs, QChar rhs) noexcept {
  return rhs > lhs;
}
inline bool operator>(const QString &lhs, QChar rhs) noexcept {
  return rhs < lhs;
}
inline bool operator<=(const QString &lhs, QChar rhs) noexcept {
  return !(rhs < lhs);
}
inline bool operator>=(const QString &lhs, QChar rhs) noexcept {
  return !(rhs > lhs);
}

inline bool operator==(QChar lhs, const QStringRef &rhs) noexcept {
  return rhs.size() == 1 && lhs == rhs.front();
}
inline bool operator<(QChar lhs, const QStringRef &rhs) noexcept {
  return QString::compare_helper(&lhs, 1, rhs.data(), rhs.size()) < 0;
}
inline bool operator>(QChar lhs, const QStringRef &rhs) noexcept {
  return QString::compare_helper(&lhs, 1, rhs.data(), rhs.size()) > 0;
}

inline bool operator!=(QChar lhs, const QStringRef &rhs) noexcept {
  return !(lhs == rhs);
}
inline bool operator<=(QChar lhs, const QStringRef &rhs) noexcept {
  return !(lhs > rhs);
}
inline bool operator>=(QChar lhs, const QStringRef &rhs) noexcept {
  return !(lhs < rhs);
}

inline bool operator==(const QStringRef &lhs, QChar rhs) noexcept {
  return rhs == lhs;
}
inline bool operator!=(const QStringRef &lhs, QChar rhs) noexcept {
  return !(rhs == lhs);
}
inline bool operator<(const QStringRef &lhs, QChar rhs) noexcept {
  return rhs > lhs;
}
inline bool operator>(const QStringRef &lhs, QChar rhs) noexcept {
  return rhs < lhs;
}
inline bool operator<=(const QStringRef &lhs, QChar rhs) noexcept {
  return !(rhs < lhs);
}
inline bool operator>=(const QStringRef &lhs, QChar rhs) noexcept {
  return !(rhs > lhs);
}

inline bool operator==(QChar lhs, QLatin1String rhs) noexcept {
  return rhs.size() == 1 && lhs == rhs.front();
}
inline bool operator<(QChar lhs, QLatin1String rhs) noexcept {
  return QString::compare_helper(&lhs, 1, rhs) < 0;
}
inline bool operator>(QChar lhs, QLatin1String rhs) noexcept {
  return QString::compare_helper(&lhs, 1, rhs) > 0;
}

inline bool operator!=(QChar lhs, QLatin1String rhs) noexcept {
  return !(lhs == rhs);
}
inline bool operator<=(QChar lhs, QLatin1String rhs) noexcept {
  return !(lhs > rhs);
}
inline bool operator>=(QChar lhs, QLatin1String rhs) noexcept {
  return !(lhs < rhs);
}

inline bool operator==(QLatin1String lhs, QChar rhs) noexcept {
  return rhs == lhs;
}
inline bool operator!=(QLatin1String lhs, QChar rhs) noexcept {
  return !(rhs == lhs);
}
inline bool operator<(QLatin1String lhs, QChar rhs) noexcept {
  return rhs > lhs;
}
inline bool operator>(QLatin1String lhs, QChar rhs) noexcept {
  return rhs < lhs;
}
inline bool operator<=(QLatin1String lhs, QChar rhs) noexcept {
  return !(rhs < lhs);
}
inline bool operator>=(QLatin1String lhs, QChar rhs) noexcept {
  return !(rhs > lhs);
}

inline bool operator==(QStringView lhs, QStringView rhs) noexcept {
  return lhs.size() == rhs.size() && QtPrivate::compareStrings(lhs, rhs) == 0;
}
inline bool operator!=(QStringView lhs, QStringView rhs) noexcept {
  return !(lhs == rhs);
}
inline bool operator<(QStringView lhs, QStringView rhs) noexcept {
  return QtPrivate::compareStrings(lhs, rhs) < 0;
}
inline bool operator<=(QStringView lhs, QStringView rhs) noexcept {
  return QtPrivate::compareStrings(lhs, rhs) <= 0;
}
inline bool operator>(QStringView lhs, QStringView rhs) noexcept {
  return QtPrivate::compareStrings(lhs, rhs) > 0;
}
inline bool operator>=(QStringView lhs, QStringView rhs) noexcept {
  return QtPrivate::compareStrings(lhs, rhs) >= 0;
}

inline bool operator==(QStringView lhs, QChar rhs) noexcept {
  return lhs == QStringView(&rhs, 1);
}
inline bool operator!=(QStringView lhs, QChar rhs) noexcept {
  return lhs != QStringView(&rhs, 1);
}
inline bool operator<(QStringView lhs, QChar rhs) noexcept {
  return lhs < QStringView(&rhs, 1);
}
inline bool operator<=(QStringView lhs, QChar rhs) noexcept {
  return lhs <= QStringView(&rhs, 1);
}
inline bool operator>(QStringView lhs, QChar rhs) noexcept {
  return lhs > QStringView(&rhs, 1);
}
inline bool operator>=(QStringView lhs, QChar rhs) noexcept {
  return lhs >= QStringView(&rhs, 1);
}

inline bool operator==(QChar lhs, QStringView rhs) noexcept {
  return QStringView(&lhs, 1) == rhs;
}
inline bool operator!=(QChar lhs, QStringView rhs) noexcept {
  return QStringView(&lhs, 1) != rhs;
}
inline bool operator<(QChar lhs, QStringView rhs) noexcept {
  return QStringView(&lhs, 1) < rhs;
}
inline bool operator<=(QChar lhs, QStringView rhs) noexcept {
  return QStringView(&lhs, 1) <= rhs;
}
inline bool operator>(QChar lhs, QStringView rhs) noexcept {
  return QStringView(&lhs, 1) > rhs;
}
inline bool operator>=(QChar lhs, QStringView rhs) noexcept {
  return QStringView(&lhs, 1) >= rhs;
}

inline bool operator==(QStringView lhs, QLatin1String rhs) noexcept {
  return lhs.size() == rhs.size() && QtPrivate::compareStrings(lhs, rhs) == 0;
}
inline bool operator!=(QStringView lhs, QLatin1String rhs) noexcept {
  return !(lhs == rhs);
}
inline bool operator<(QStringView lhs, QLatin1String rhs) noexcept {
  return QtPrivate::compareStrings(lhs, rhs) < 0;
}
inline bool operator<=(QStringView lhs, QLatin1String rhs) noexcept {
  return QtPrivate::compareStrings(lhs, rhs) <= 0;
}
inline bool operator>(QStringView lhs, QLatin1String rhs) noexcept {
  return QtPrivate::compareStrings(lhs, rhs) > 0;
}
inline bool operator>=(QStringView lhs, QLatin1String rhs) noexcept {
  return QtPrivate::compareStrings(lhs, rhs) >= 0;
}

inline bool operator==(QLatin1String lhs, QStringView rhs) noexcept {
  return lhs.size() == rhs.size() && QtPrivate::compareStrings(lhs, rhs) == 0;
}
inline bool operator!=(QLatin1String lhs, QStringView rhs) noexcept {
  return !(lhs == rhs);
}
inline bool operator<(QLatin1String lhs, QStringView rhs) noexcept {
  return QtPrivate::compareStrings(lhs, rhs) < 0;
}
inline bool operator<=(QLatin1String lhs, QStringView rhs) noexcept {
  return QtPrivate::compareStrings(lhs, rhs) <= 0;
}
inline bool operator>(QLatin1String lhs, QStringView rhs) noexcept {
  return QtPrivate::compareStrings(lhs, rhs) > 0;
}
inline bool operator>=(QLatin1String lhs, QStringView rhs) noexcept {
  return QtPrivate::compareStrings(lhs, rhs) >= 0;
}

inline bool operator==(const QStringRef &lhs, const QByteArray &rhs) {
  return lhs.compare(rhs) == 0;
}
inline bool operator!=(const QStringRef &lhs, const QByteArray &rhs) {
  return lhs.compare(rhs) != 0;
}
inline bool operator<(const QStringRef &lhs, const QByteArray &rhs) {
  return lhs.compare(rhs) < 0;
}
inline bool operator>(const QStringRef &lhs, const QByteArray &rhs) {
  return lhs.compare(rhs) > 0;
}
inline bool operator<=(const QStringRef &lhs, const QByteArray &rhs) {
  return lhs.compare(rhs) <= 0;
}
inline bool operator>=(const QStringRef &lhs, const QByteArray &rhs) {
  return lhs.compare(rhs) >= 0;
}

inline bool operator==(const QByteArray &lhs, const QStringRef &rhs) {
  return rhs.compare(lhs) == 0;
}
inline bool operator!=(const QByteArray &lhs, const QStringRef &rhs) {
  return rhs.compare(lhs) != 0;
}
inline bool operator<(const QByteArray &lhs, const QStringRef &rhs) {
  return rhs.compare(lhs) > 0;
}
inline bool operator>(const QByteArray &lhs, const QStringRef &rhs) {
  return rhs.compare(lhs) < 0;
}
inline bool operator<=(const QByteArray &lhs, const QStringRef &rhs) {
  return rhs.compare(lhs) >= 0;
}
inline bool operator>=(const QByteArray &lhs, const QStringRef &rhs) {
  return rhs.compare(lhs) <= 0;
}

inline bool QStringRef::operator==(const char *s) const {
  return QString::compare_helper(constData(), size(), s, -1) == 0;
}
inline bool QStringRef::operator!=(const char *s) const {
  return QString::compare_helper(constData(), size(), s, -1) != 0;
}
inline bool QStringRef::operator<(const char *s) const {
  return QString::compare_helper(constData(), size(), s, -1) < 0;
}
inline bool QStringRef::operator<=(const char *s) const {
  return QString::compare_helper(constData(), size(), s, -1) <= 0;
}
inline bool QStringRef::operator>(const char *s) const {
  return QString::compare_helper(constData(), size(), s, -1) > 0;
}
inline bool QStringRef::operator>=(const char *s) const {
  return QString::compare_helper(constData(), size(), s, -1) >= 0;
}

inline bool operator==(const char *s1, const QStringRef &s2) {
  return QString::compare_helper(s2.constData(), s2.size(), s1, -1) == 0;
}
inline bool operator!=(const char *s1, const QStringRef &s2) {
  return QString::compare_helper(s2.constData(), s2.size(), s1, -1) != 0;
}
inline bool operator<(const char *s1, const QStringRef &s2) {
  return QString::compare_helper(s2.constData(), s2.size(), s1, -1) > 0;
}
inline bool operator<=(const char *s1, const QStringRef &s2) {
  return QString::compare_helper(s2.constData(), s2.size(), s1, -1) >= 0;
}
inline bool operator>(const char *s1, const QStringRef &s2) {
  return QString::compare_helper(s2.constData(), s2.size(), s1, -1) < 0;
}
inline bool operator>=(const char *s1, const QStringRef &s2) {
  return QString::compare_helper(s2.constData(), s2.size(), s1, -1) <= 0;
}

inline int QString::localeAwareCompare(const QStringRef &s) const {
  return localeAwareCompare_helper(constData(), length(), s.constData(),
                                   s.length());
}
inline int QString::localeAwareCompare(const QString &s1,
                                       const QStringRef &s2) {
  return localeAwareCompare_helper(s1.constData(), s1.length(), s2.constData(),
                                   s2.length());
}
inline int QStringRef::localeAwareCompare(const QString &s) const {
  return QString::localeAwareCompare_helper(constData(), length(),
                                            s.constData(), s.length());
}
inline int QStringRef::localeAwareCompare(const QStringRef &s) const {
  return QString::localeAwareCompare_helper(constData(), length(),
                                            s.constData(), s.length());
}
inline int QStringRef::localeAwareCompare(const QStringRef &s1,
                                          const QString &s2) {
  return QString::localeAwareCompare_helper(s1.constData(), s1.length(),
                                            s2.constData(), s2.length());
}
inline int QStringRef::localeAwareCompare(const QStringRef &s1,
                                          const QStringRef &s2) {
  return QString::localeAwareCompare_helper(s1.constData(), s1.length(),
                                            s2.constData(), s2.length());
}

inline bool QStringRef::contains(const QString &s,
                                 Qt::CaseSensitivity cs) const {
  return indexOf(s, 0, cs) != -1;
}
inline bool QStringRef::contains(const QStringRef &s,
                                 Qt::CaseSensitivity cs) const {
  return indexOf(s, 0, cs) != -1;
}

inline bool QStringRef::contains(QLatin1String s,
                                 Qt::CaseSensitivity cs) const {
  return indexOf(s, 0, cs) != -1;
}
inline bool QStringRef::contains(QChar c, Qt::CaseSensitivity cs) const {
  return indexOf(c, 0, cs) != -1;
}
inline bool QStringRef::contains(QStringView s,
                                 Qt::CaseSensitivity cs) const noexcept {
  return indexOf(s, 0, cs) != -1;
}

inline QString &QString::insert(int i, const QStringRef &s) {
  return insert(i, s.constData(), s.length());
}

inline QString operator+(const QString &s1, const QStringRef &s2) {
  QString t;
  t.reserve(s1.size() + s2.size());
  t += s1;
  t += s2;
  return t;
}
inline QString operator+(const QStringRef &s1, const QString &s2) {
  QString t;
  t.reserve(s1.size() + s2.size());
  t += s1;
  t += s2;
  return t;
}
inline QString operator+(const QStringRef &s1, QLatin1String s2) {
  QString t;
  t.reserve(s1.size() + s2.size());
  t += s1;
  t += s2;
  return t;
}
inline QString operator+(QLatin1String s1, const QStringRef &s2) {
  QString t;
  t.reserve(s1.size() + s2.size());
  t += s1;
  t += s2;
  return t;
}
inline QString operator+(const QStringRef &s1, const QStringRef &s2) {
  QString t;
  t.reserve(s1.size() + s2.size());
  t += s1;
  t += s2;
  return t;
}
inline QString operator+(const QStringRef &s1, QChar s2) {
  QString t;
  t.reserve(s1.size() + 1);
  t += s1;
  t += s2;
  return t;
}
inline QString operator+(QChar s1, const QStringRef &s2) {
  QString t;
  t.reserve(1 + s2.size());
  t += s1;
  t += s2;
  return t;
}

namespace Qt {}

namespace QtPrivate {

inline const QString &asString(const QString &s) { return s; }
inline QString &&asString(QString &&s) { return std::move(s); }
} // namespace QtPrivate

namespace QtPrivate {

struct ArgBase {
  enum Tag : uchar { L1, U8, U16 } tag;
};

struct QStringViewArg : ArgBase {
  QStringView string;
  QStringViewArg() = default;
  constexpr explicit QStringViewArg(QStringView v) noexcept
      : ArgBase{U16}, string{v} {}
};

struct QLatin1StringArg : ArgBase {
  QLatin1String string;
  QLatin1StringArg() = default;
  constexpr explicit QLatin1StringArg(QLatin1String v) noexcept
      : ArgBase{L1}, string{v} {}
};

__attribute__((__warn_unused_result__)) __attribute__((visibility("default")))
QString
argToQString(QStringView pattern, size_t n, const ArgBase **args);
__attribute__((__warn_unused_result__)) __attribute__((visibility("default")))
QString
argToQString(QLatin1String pattern, size_t n, const ArgBase **args);

template <typename StringView, typename... Args>
__attribute__((__warn_unused_result__)) inline __attribute__((always_inline))
QString
argToQStringDispatch(StringView pattern, const Args &...args) {
  const ArgBase *argBases[] = {&args..., nullptr};
  return QtPrivate::argToQString(pattern, sizeof...(Args), argBases);
}

inline QStringViewArg qStringLikeToArg(const QString &s) noexcept {
  return QStringViewArg{qToStringViewIgnoringNull(s)};
}
constexpr inline QStringViewArg qStringLikeToArg(QStringView s) noexcept {
  return QStringViewArg{s};
}
inline QStringViewArg qStringLikeToArg(const QChar &c) noexcept {
  return QStringViewArg{QStringView{&c, 1}};
}
constexpr inline QLatin1StringArg qStringLikeToArg(QLatin1String s) noexcept {
  return QLatin1StringArg{s};
}

} // namespace QtPrivate

template <typename... Args>
inline __attribute__((always_inline)) QString
QStringView::arg(Args &&...args) const {
  return QtPrivate::argToQStringDispatch(*this,
                                         QtPrivate::qStringLikeToArg(args)...);
}

template <typename... Args>
inline __attribute__((always_inline)) QString
QLatin1String::arg(Args &&...args) const {
  return QtPrivate::argToQStringDispatch(*this,
                                         QtPrivate::qStringLikeToArg(args)...);
}
# 45 "/usr/local/include/QtCore/qhashfunctions.h" 2
# 1 "/usr/local/include/QtCore/qpair.h" 1
# 48 "/usr/local/include/QtCore/qpair.h"
template <class T1, class T2> struct QPair {
  typedef T1 first_type;
  typedef T2 second_type;

  constexpr QPair() noexcept(
      (std::is_nothrow_default_constructible<T1>::value &&
       std::is_nothrow_default_constructible<T2>::value))
      : first(), second() {}
  constexpr QPair(const T1 &t1, const T2 &t2) noexcept(
      (std::is_nothrow_copy_constructible<T1>::value &&
       std::is_nothrow_copy_constructible<T2>::value))
      : first(t1), second(t2) {}

  template <typename TT1, typename TT2>
  constexpr QPair(const QPair<TT1, TT2> &p) noexcept(
      (std::is_nothrow_constructible<T1, TT1 &>::value &&
       std::is_nothrow_constructible<T2, TT2 &>::value))
      : first(p.first), second(p.second) {}
  template <typename TT1, typename TT2>
  constexpr QPair &operator=(const QPair<TT1, TT2> &p) noexcept(
      (std::is_nothrow_assignable<T1, TT1 &>::value &&
       std::is_nothrow_assignable<T2, TT2 &>::value)) {
    first = p.first;
    second = p.second;
    return *this;
  }
  template <typename TT1, typename TT2>
  constexpr QPair(QPair<TT1, TT2> &&p) noexcept(
      (std::is_nothrow_constructible<T1, TT1>::value &&
       std::is_nothrow_constructible<T2, TT2>::value))

      : first(static_cast<TT1 &&>(p.first)),
        second(static_cast<TT2 &&>(p.second)) {}
  template <typename TT1, typename TT2>
  constexpr QPair &operator=(QPair<TT1, TT2> &&p) noexcept(
      (std::is_nothrow_assignable<T1, TT1>::value &&
       std::is_nothrow_assignable<T2, TT2>::value)) {
    first = std::move(p.first);
    second = std::move(p.second);
    return *this;
  }

  constexpr void swap(QPair &other) noexcept(noexcept(
      qSwap(other.first, other.first)) &&noexcept(qSwap(other.second,
                                                        other.second))) {

    qSwap(first, other.first);
    qSwap(second, other.second);
  }

  T1 first;
  T2 second;
};

template <typename T1, typename T2>
void swap(QPair<T1, T2> &lhs,
          QPair<T1, T2> &rhs) noexcept(noexcept(lhs.swap(rhs))) {
  lhs.swap(rhs);
}

template <class T1, class T2>
class QTypeInfo<QPair<T1, T2>> : public QTypeInfoMerger<QPair<T1, T2>, T1, T2> {
};

template <class T1, class T2>
constexpr inline bool
operator==(const QPair<T1, T2> &p1,
           const QPair<T1, T2> &p2) noexcept(noexcept(p1.first == p2.first &&
                                                      p1.second == p2.second)) {
  return p1.first == p2.first && p1.second == p2.second;
}

template <class T1, class T2>
constexpr inline bool
operator!=(const QPair<T1, T2> &p1,
           const QPair<T1, T2> &p2) noexcept(noexcept(!(p1 == p2))) {
  return !(p1 == p2);
}

template <class T1, class T2>
constexpr inline bool
operator<(const QPair<T1, T2> &p1, const QPair<T1, T2> &p2) noexcept(noexcept(
    p1.first < p2.first || (!(p2.first < p1.first) && p1.second < p2.second))) {
  return p1.first < p2.first ||
         (!(p2.first < p1.first) && p1.second < p2.second);
}

template <class T1, class T2>
constexpr inline bool
operator>(const QPair<T1, T2> &p1,
          const QPair<T1, T2> &p2) noexcept(noexcept(p2 < p1)) {
  return p2 < p1;
}

template <class T1, class T2>
constexpr inline bool
operator<=(const QPair<T1, T2> &p1,
           const QPair<T1, T2> &p2) noexcept(noexcept(!(p2 < p1))) {
  return !(p2 < p1);
}

template <class T1, class T2>
constexpr inline bool
operator>=(const QPair<T1, T2> &p1,
           const QPair<T1, T2> &p2) noexcept(noexcept(!(p1 < p2))) {
  return !(p1 < p2);
}

template <class T1, class T2>
constexpr QPair<T1, T2>
qMakePair(const T1 &x, const T2 &y) noexcept(noexcept(QPair<T1, T2>(x, y))) {
  return QPair<T1, T2>(x, y);
}
# 46 "/usr/local/include/QtCore/qhashfunctions.h" 2

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/numeric" 1 3
# 144 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/numeric" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 145 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/numeric" 2 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cmath" 1 3
# 303 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cmath" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 304 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cmath" 2 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/math.h" 1 3
# 305 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cmath" 2 3
# 310 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cmath" 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_macros" 1 3
# 314 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cmath" 2 3

namespace std {
inline namespace __1 {

using ::fpclassify;
using ::isfinite;
using ::isgreater;
using ::isgreaterequal;
using ::isinf;
using ::isless;
using ::islessequal;
using ::islessgreater;
using ::isnan;
using ::isnormal;
using ::isunordered;
using ::signbit;

using ::double_t;
using ::float_t;

using ::abs;

using ::acos;
using ::acosf;
using ::asin;
using ::asinf;
using ::atan;
using ::atan2;
using ::atan2f;
using ::atanf;
using ::ceil;
using ::ceilf;
using ::cos;
using ::cosf;
using ::cosh;
using ::coshf;

using ::exp;
using ::expf;

using ::fabs;
using ::fabsf;
using ::floor;
using ::floorf;

using ::fmod;
using ::fmodf;

using ::frexp;
using ::frexpf;
using ::ldexp;
using ::ldexpf;

using ::log;
using ::logf;

using ::log10;
using ::log10f;
using ::modf;
using ::modff;

using ::pow;
using ::powf;

using ::sin;
using ::sinf;
using ::sinh;
using ::sinhf;

using ::sqrt;
using ::sqrtf;
using ::tan;
using ::tanf;

using ::tanh;
using ::tanhf;

using ::acosh;
using ::acoshf;
using ::asinh;
using ::asinhf;
using ::atanh;
using ::atanhf;
using ::cbrt;
using ::cbrtf;

using ::copysign;
using ::copysignf;

using ::erf;
using ::erfc;
using ::erfcf;
using ::erff;
using ::exp2;
using ::exp2f;
using ::expm1;
using ::expm1f;
using ::fdim;
using ::fdimf;
using ::fma;
using ::fmaf;
using ::fmax;
using ::fmaxf;
using ::fmin;
using ::fminf;
using ::hypot;
using ::hypotf;
using ::ilogb;
using ::ilogbf;
using ::lgamma;
using ::lgammaf;
using ::llrint;
using ::llrintf;
using ::llround;
using ::llroundf;
using ::log1p;
using ::log1pf;
using ::log2;
using ::log2f;
using ::logb;
using ::logbf;
using ::lrint;
using ::lrintf;
using ::lround;
using ::lroundf;

using ::nan;
using ::nanf;

using ::nearbyint;
using ::nearbyintf;
using ::nextafter;
using ::nextafterf;
using ::nexttoward;
using ::nexttowardf;
using ::remainder;
using ::remainderf;
using ::remquo;
using ::remquof;
using ::rint;
using ::rintf;
using ::round;
using ::roundf;
using ::scalbln;
using ::scalblnf;
using ::scalbn;
using ::scalbnf;
using ::tgamma;
using ::tgammaf;
using ::trunc;
using ::truncf;

using ::acosl;
using ::asinl;
using ::atan2l;
using ::atanl;
using ::ceill;
using ::coshl;
using ::cosl;
using ::expl;
using ::fabsl;
using ::floorl;
using ::fmodl;
using ::frexpl;
using ::ldexpl;
using ::log10l;
using ::logl;
using ::modfl;
using ::powl;
using ::sinhl;
using ::sinl;
using ::sqrtl;
using ::tanl;

using ::acoshl;
using ::asinhl;
using ::atanhl;
using ::cbrtl;
using ::tanhl;

using ::copysignl;

using ::erfcl;
using ::erfl;
using ::exp2l;
using ::expm1l;
using ::fdiml;
using ::fmal;
using ::fmaxl;
using ::fminl;
using ::hypotl;
using ::ilogbl;
using ::lgammal;
using ::llrintl;
using ::llroundl;
using ::log1pl;
using ::log2l;
using ::logbl;
using ::lrintl;
using ::lroundl;
using ::nanl;
using ::nearbyintl;
using ::nextafterl;
using ::nexttowardl;
using ::remainderl;
using ::remquol;
using ::rintl;
using ::roundl;
using ::scalblnl;
using ::scalbnl;
using ::tgammal;
using ::truncl;
# 553 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cmath" 3
template <class _A1>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr
    typename enable_if<is_floating_point<_A1>::value, bool>::type
    __libcpp_isnan_or_builtin(_A1 __lcpp_x) noexcept {

  return __builtin_isnan(__lcpp_x);
}

template <class _A1>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr
    typename enable_if<!is_floating_point<_A1>::value, bool>::type
    __libcpp_isnan_or_builtin(_A1 __lcpp_x) noexcept {
  return isnan(__lcpp_x);
}

template <class _A1>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr
    typename enable_if<is_floating_point<_A1>::value, bool>::type
    __libcpp_isinf_or_builtin(_A1 __lcpp_x) noexcept {

  return __builtin_isinf(__lcpp_x);
}

template <class _A1>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr
    typename enable_if<!is_floating_point<_A1>::value, bool>::type
    __libcpp_isinf_or_builtin(_A1 __lcpp_x) noexcept {
  return isinf(__lcpp_x);
}

template <class _A1>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr
    typename enable_if<is_floating_point<_A1>::value, bool>::type
    __libcpp_isfinite_or_builtin(_A1 __lcpp_x) noexcept {

  return __builtin_isfinite(__lcpp_x);
}

template <class _A1>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr
    typename enable_if<!is_floating_point<_A1>::value, bool>::type
    __libcpp_isfinite_or_builtin(_A1 __lcpp_x) noexcept {
  return isfinite(__lcpp_x);
}
# 639 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cmath" 3
template <class _IntT, class _FloatT,
          bool _FloatBigger = (numeric_limits<_FloatT>::digits >
                               numeric_limits<_IntT>::digits),
          int _Bits = (numeric_limits<_IntT>::digits -
                       numeric_limits<_FloatT>::digits)>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) constexpr _IntT
__max_representable_int_for_float() noexcept {
  static_assert(is_floating_point<_FloatT>::value,
                "must be a floating point type");
  static_assert(is_integral<_IntT>::value, "must be an integral type");
  static_assert(numeric_limits<_FloatT>::radix == 2,
                "FloatT has incorrect radix");
  static_assert((_IsSame<_FloatT, float>::value ||
                 _IsSame<_FloatT, double>::value ||
                 _IsSame<_FloatT, long double>::value),
                "unsupported floating point type");
  return _FloatBigger ? numeric_limits<_IntT>::max()
                      : (numeric_limits<_IntT>::max() >> _Bits << _Bits);
}

template <class _IntT, class _RealT>
__attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _IntT
__clamp_to_integral(_RealT __r) noexcept {
  using _Lim = std::numeric_limits<_IntT>;
  const _IntT _MaxVal = std::__max_representable_int_for_float<_IntT, _RealT>();
  if (__r >= ::nextafter(static_cast<_RealT>(_MaxVal), __builtin_huge_valf())) {
    return _Lim::max();
  } else if (__r <= _Lim::lowest()) {
    return _Lim::min();
  }
  return static_cast<_IntT>(__r);
}

} // namespace __1
} // namespace std
# 149 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/numeric" 2 3
# 153 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/numeric" 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_macros" 1 3
# 157 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/numeric" 2 3

namespace std {
inline namespace __1 {

template <class _InputIterator, class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _Tp
accumulate(_InputIterator __first, _InputIterator __last, _Tp __init) {
  for (; __first != __last; ++__first)
    __init = __init + *__first;
  return __init;
}

template <class _InputIterator, class _Tp, class _BinaryOperation>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _Tp
accumulate(_InputIterator __first, _InputIterator __last, _Tp __init,
           _BinaryOperation __binary_op) {
  for (; __first != __last; ++__first)
    __init = __binary_op(__init, *__first);
  return __init;
}
# 209 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/numeric" 3
template <class _InputIterator1, class _InputIterator2, class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _Tp
inner_product(_InputIterator1 __first1, _InputIterator1 __last1,
              _InputIterator2 __first2, _Tp __init) {
  for (; __first1 != __last1; ++__first1, (void)++__first2)
    __init = __init + *__first1 * *__first2;
  return __init;
}

template <class _InputIterator1, class _InputIterator2, class _Tp,
          class _BinaryOperation1, class _BinaryOperation2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _Tp
inner_product(_InputIterator1 __first1, _InputIterator1 __last1,
              _InputIterator2 __first2, _Tp __init,
              _BinaryOperation1 __binary_op1, _BinaryOperation2 __binary_op2) {
  for (; __first1 != __last1; ++__first1, (void)++__first2)
    __init = __binary_op1(__init, __binary_op2(*__first1, *__first2));
  return __init;
}
# 265 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/numeric" 3
template <class _InputIterator, class _OutputIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _OutputIterator
partial_sum(_InputIterator __first, _InputIterator __last,
            _OutputIterator __result) {
  if (__first != __last) {
    typename iterator_traits<_InputIterator>::value_type __t(*__first);
    *__result = __t;
    for (++__first, (void)++__result; __first != __last;
         ++__first, (void)++__result) {
      __t = __t + *__first;
      *__result = __t;
    }
  }
  return __result;
}

template <class _InputIterator, class _OutputIterator, class _BinaryOperation>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _OutputIterator
partial_sum(_InputIterator __first, _InputIterator __last,
            _OutputIterator __result, _BinaryOperation __binary_op) {
  if (__first != __last) {
    typename iterator_traits<_InputIterator>::value_type __t(*__first);
    *__result = __t;
    for (++__first, (void)++__result; __first != __last;
         ++__first, (void)++__result) {
      __t = __binary_op(__t, *__first);
      *__result = __t;
    }
  }
  return __result;
}
# 413 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/numeric" 3
template <class _InputIterator, class _OutputIterator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _OutputIterator
adjacent_difference(_InputIterator __first, _InputIterator __last,
                    _OutputIterator __result) {
  if (__first != __last) {
    typename iterator_traits<_InputIterator>::value_type __t1(*__first);
    *__result = __t1;
    for (++__first, (void)++__result; __first != __last;
         ++__first, (void)++__result) {
      typename iterator_traits<_InputIterator>::value_type __t2(*__first);
      *__result = __t2 - __t1;
      __t1 = std::__1::move(__t2);
    }
  }
  return __result;
}

template <class _InputIterator, class _OutputIterator, class _BinaryOperation>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _OutputIterator
adjacent_difference(_InputIterator __first, _InputIterator __last,
                    _OutputIterator __result, _BinaryOperation __binary_op) {
  if (__first != __last) {
    typename iterator_traits<_InputIterator>::value_type __t1(*__first);
    *__result = __t1;
    for (++__first, (void)++__result; __first != __last;
         ++__first, (void)++__result) {
      typename iterator_traits<_InputIterator>::value_type __t2(*__first);
      *__result = __binary_op(__t2, __t1);
      __t1 = std::__1::move(__t2);
    }
  }
  return __result;
}

template <class _ForwardIterator, class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
iota(_ForwardIterator __first, _ForwardIterator __last, _Tp __value_) {
  for (; __first != __last; ++__first, (void)++__value_)
    *__first = __value_;
}
# 582 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/numeric" 3
} // namespace __1
} // namespace std
# 48 "/usr/local/include/QtCore/qhashfunctions.h" 2
# 62 "/usr/local/include/QtCore/qhashfunctions.h"
class QBitArray;
class QByteArray;
class QString;
class QStringRef;
class QLatin1String;

__attribute__((visibility("default"))) int qGlobalQHashSeed();
__attribute__((visibility("default"))) void qSetGlobalQHashSeed(int newSeed);

__attribute__((visibility("default"))) __attribute__((pure)) uint
qHashBits(const void *p, size_t size, uint seed = 0) noexcept;

__attribute__((const)) constexpr inline uint qHash(char key,
                                                   uint seed = 0) noexcept {
  return uint(key) ^ seed;
}
__attribute__((const)) constexpr inline uint qHash(uchar key,
                                                   uint seed = 0) noexcept {
  return uint(key) ^ seed;
}
__attribute__((const)) constexpr inline uint qHash(signed char key,
                                                   uint seed = 0) noexcept {
  return uint(key) ^ seed;
}
__attribute__((const)) constexpr inline uint qHash(ushort key,
                                                   uint seed = 0) noexcept {
  return uint(key) ^ seed;
}
__attribute__((const)) constexpr inline uint qHash(short key,
                                                   uint seed = 0) noexcept {
  return uint(key) ^ seed;
}
__attribute__((const)) constexpr inline uint qHash(uint key,
                                                   uint seed = 0) noexcept {
  return key ^ seed;
}
__attribute__((const)) constexpr inline uint qHash(int key,
                                                   uint seed = 0) noexcept {
  return uint(key) ^ seed;
}
__attribute__((const)) constexpr inline uint qHash(ulong key,
                                                   uint seed = 0) noexcept {
  return (sizeof(ulong) > sizeof(uint))
             ? (uint(((key >> (8 * sizeof(uint) - 1)) ^ key) & (~0U)) ^ seed)
             : (uint(key & (~0U)) ^ seed);
}
__attribute__((const)) constexpr inline uint qHash(long key,
                                                   uint seed = 0) noexcept {
  return qHash(ulong(key), seed);
}
__attribute__((const)) constexpr inline uint qHash(quint64 key,
                                                   uint seed = 0) noexcept {
  return uint(((key >> (8 * sizeof(uint) - 1)) ^ key) & (~0U)) ^ seed;
}
__attribute__((const)) constexpr inline uint qHash(qint64 key,
                                                   uint seed = 0) noexcept {
  return qHash(quint64(key), seed);
}
__attribute__((visibility("default"))) __attribute__((const)) uint
qHash(float key, uint seed = 0) noexcept;
__attribute__((visibility("default"))) __attribute__((const)) uint
qHash(double key, uint seed = 0) noexcept;

__attribute__((const)) constexpr inline uint qHash(const QChar key,
                                                   uint seed = 0) noexcept {
  return qHash(key.unicode(), seed);
}
__attribute__((visibility("default"))) __attribute__((pure)) uint
qHash(const QByteArray &key, uint seed = 0) noexcept;

__attribute__((visibility("default"))) __attribute__((pure)) uint
qHash(const QString &key, uint seed = 0) noexcept;
__attribute__((visibility("default"))) __attribute__((pure)) uint
qHash(const QStringRef &key, uint seed = 0) noexcept;

__attribute__((visibility("default"))) __attribute__((pure)) uint
qHash(QStringView key, uint seed = 0) noexcept;
__attribute__((visibility("default"))) __attribute__((pure)) uint
qHash(const QBitArray &key, uint seed = 0) noexcept;
__attribute__((visibility("default"))) __attribute__((pure)) uint
qHash(QLatin1String key, uint seed = 0) noexcept;
__attribute__((visibility("default"))) __attribute__((pure)) uint
qt_hash(QStringView key, uint chained = 0) noexcept;

__attribute__((const)) inline uint qHash(std::nullptr_t,
                                         uint seed = 0) noexcept {
  return qHash(reinterpret_cast<quintptr>(nullptr), seed);
}

template <class T> inline uint qHash(const T *key, uint seed = 0) noexcept {
  return qHash(reinterpret_cast<quintptr>(key), seed);
}
template <typename T>
inline uint qHash(const T &t, uint seed) noexcept(noexcept(qHash(t))) {
  return qHash(t) ^ seed;
}

namespace QtPrivate {

struct QHashCombine {
  typedef uint result_type;
  template <typename T>
  constexpr result_type operator()(uint seed, const T &t) const
      noexcept(noexcept(qHash(t)))

  {
    return seed ^ (qHash(t) + 0x9e3779b9 + (seed << 6) + (seed >> 2));
  }
};

struct QHashCombineCommutative {

  typedef uint result_type;
  template <typename T>
  constexpr result_type operator()(uint seed, const T &t) const
      noexcept(noexcept(qHash(t))) {
    return seed + qHash(t);
  }
};

} // namespace QtPrivate

template <typename InputIterator>
inline uint qHashRange(InputIterator first, InputIterator last,
                       uint seed = 0) noexcept(noexcept(qHash(*first))) {
  return std::accumulate(first, last, seed, QtPrivate::QHashCombine());
}

template <typename InputIterator>
inline uint
qHashRangeCommutative(InputIterator first, InputIterator last,
                      uint seed = 0) noexcept(noexcept(qHash(*first))) {
  return std::accumulate(first, last, seed,
                         QtPrivate::QHashCombineCommutative());
}

template <typename T1, typename T2>
inline uint qHash(const QPair<T1, T2> &key, uint seed = 0) noexcept(
    noexcept(qHash(key.first, seed)) &&noexcept(qHash(key.second, seed))) {
  uint h1 = qHash(key.first, seed);
  uint h2 = qHash(key.second, seed);
  return ((h1 << 16) | (h1 >> 16)) ^ h2 ^ seed;
}

template <typename T1, typename T2>
inline uint qHash(const std::pair<T1, T2> &key, uint seed = 0) noexcept(
    noexcept(qHash(key.first, seed)) &&noexcept(qHash(key.second, seed))) {
  QtPrivate::QHashCombine hash;
  seed = hash(seed, key.first);
  seed = hash(seed, key.second);
  return seed;
}
# 204 "/usr/local/include/QtCore/qhashfunctions.h"
namespace std {
template <> struct hash<::QString> {
  using argument_type = ::QString;
  using result_type = size_t;
  size_t operator()(const argument_type &s) const
      noexcept(noexcept(::qHash(s))) {
    return ::qHash(s, ::qHash(std::hash<int>{}(0)));
  }
};
} // namespace std
namespace std {
template <> struct hash<::QStringRef> {
  using argument_type = ::QStringRef;
  using result_type = size_t;
  size_t operator()(const argument_type &s) const
      noexcept(noexcept(::qHash(s))) {
    return ::qHash(s, ::qHash(std::hash<int>{}(0)));
  }
};
} // namespace std
namespace std {
template <> struct hash<::QStringView> {
  using argument_type = ::QStringView;
  using result_type = size_t;
  size_t operator()(argument_type s) const noexcept(noexcept(::qHash(s))) {
    return ::qHash(s, ::qHash(std::hash<int>{}(0)));
  }
};
} // namespace std
namespace std {
template <> struct hash<::QLatin1String> {
  using argument_type = ::QLatin1String;
  using result_type = size_t;
  size_t operator()(argument_type s) const noexcept(noexcept(::qHash(s))) {
    return ::qHash(s, ::qHash(std::hash<int>{}(0)));
  }
};
} // namespace std
namespace std {
template <> struct hash<::QByteArray> {
  using argument_type = ::QByteArray;
  using result_type = size_t;
  size_t operator()(const argument_type &s) const
      noexcept(noexcept(::qHash(s))) {
    return ::qHash(s, ::qHash(std::hash<int>{}(0)));
  }
};
} // namespace std
namespace std {
template <> struct hash<::QBitArray> {
  using argument_type = ::QBitArray;
  using result_type = size_t;
  size_t operator()(const argument_type &s) const
      noexcept(noexcept(::qHash(s))) {
    return ::qHash(s, ::qHash(std::hash<int>{}(0)));
  }
};
} // namespace std
# 48 "/usr/local/include/QtCore/qvarlengtharray.h" 2

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/stdlib.h" 1 3
# 55 "/usr/local/include/QtCore/qvarlengtharray.h" 2

template <class T, int Prealloc> class QVarLengthArray {
public:
  QVarLengthArray() : QVarLengthArray(0) {}

  inline explicit QVarLengthArray(int size);

  inline QVarLengthArray(const QVarLengthArray<T, Prealloc> &other)
      : a(Prealloc), s(0), ptr(reinterpret_cast<T *>(array)) {
    append(other.constData(), other.size());
  }

  QVarLengthArray(std::initializer_list<T> args)
      : QVarLengthArray(args.begin(), args.end()) {}

  template <typename InputIterator,
            QtPrivate::IfIsInputIterator<InputIterator> = true>
  inline QVarLengthArray(InputIterator first, InputIterator last)
      : QVarLengthArray() {
    QtPrivate::reserveIfForwardIterator(this, first, last);
    std::copy(first, last, std::back_inserter(*this));
  }

  inline ~QVarLengthArray() {
    if (QTypeInfo<T>::isComplex) {
      T *i = ptr + s;
      while (i-- != ptr)
        i->~T();
    }
    if (ptr != reinterpret_cast<T *>(array))
      free(ptr);
  }
  inline QVarLengthArray<T, Prealloc> &
  operator=(const QVarLengthArray<T, Prealloc> &other) {
    if (this != &other) {
      clear();
      append(other.constData(), other.size());
    }
    return *this;
  }

  QVarLengthArray<T, Prealloc> &operator=(std::initializer_list<T> list) {
    resize(int(list.size()));
    std::copy(list.begin(), list.end(), (this->begin()));
    return *this;
  }

  inline void removeLast() {
    ((s > 0) ? static_cast<void>(0)
             : qt_assert("s > 0", "/usr/local/include/QtCore/qvarlengtharray.h",
                         114));
    if (QTypeInfo<T>::isComplex)
      ptr[s - 1].~T();
    --s;
  }
  inline int size() const { return s; }
  inline int count() const { return s; }
  inline int length() const { return s; }
  inline T &first() {
    ((!isEmpty())
         ? static_cast<void>(0)
         : qt_assert("!isEmpty()",
                     "/usr/local/include/QtCore/qvarlengtharray.h", 122));
    return *begin();
  }
  inline const T &first() const {
    ((!isEmpty())
         ? static_cast<void>(0)
         : qt_assert("!isEmpty()",
                     "/usr/local/include/QtCore/qvarlengtharray.h", 123));
    return *begin();
  }
  T &last() {
    ((!isEmpty())
         ? static_cast<void>(0)
         : qt_assert("!isEmpty()",
                     "/usr/local/include/QtCore/qvarlengtharray.h", 124));
    return *(end() - 1);
  }
  const T &last() const {
    ((!isEmpty())
         ? static_cast<void>(0)
         : qt_assert("!isEmpty()",
                     "/usr/local/include/QtCore/qvarlengtharray.h", 125));
    return *(end() - 1);
  }
  inline bool isEmpty() const { return (s == 0); }
  inline void resize(int size);
  inline void clear() { resize(0); }
  inline void squeeze();

  inline int capacity() const { return a; }
  inline void reserve(int size);

  inline int indexOf(const T &t, int from = 0) const;
  inline int lastIndexOf(const T &t, int from = -1) const;
  inline bool contains(const T &t) const;

  inline T &operator[](int idx) {
    ((idx >= 0 && idx < s)
         ? static_cast<void>(0)
         : qt_assert("idx >= 0 && idx < s",
                     "/usr/local/include/QtCore/qvarlengtharray.h", 139));
    return ptr[idx];
  }
  inline const T &operator[](int idx) const {
    ((idx >= 0 && idx < s)
         ? static_cast<void>(0)
         : qt_assert("idx >= 0 && idx < s",
                     "/usr/local/include/QtCore/qvarlengtharray.h", 143));
    return ptr[idx];
  }
  inline const T &at(int idx) const { return operator[](idx); }

  T value(int i) const;
  T value(int i, const T &defaultValue) const;

  inline void append(const T &t) {
    if (s == a) {
      T copy(t);
      realloc(s, s << 1);
      const int idx = s++;
      if (QTypeInfo<T>::isComplex) {
        new (ptr + idx) T(std::move(copy));
      } else {
        ptr[idx] = std::move(copy);
      }
    } else {
      const int idx = s++;
      if (QTypeInfo<T>::isComplex) {
        new (ptr + idx) T(t);
      } else {
        ptr[idx] = t;
      }
    }
  }

  void append(T &&t) {
    if (s == a)
      realloc(s, s << 1);
    const int idx = s++;
    if (QTypeInfo<T>::isComplex)
      new (ptr + idx) T(std::move(t));
    else
      ptr[idx] = std::move(t);
  }

  void append(const T *buf, int size);
  inline QVarLengthArray<T, Prealloc> &operator<<(const T &t) {
    append(t);
    return *this;
  }
  inline QVarLengthArray<T, Prealloc> &operator<<(T &&t) {
    append(std::move(t));
    return *this;
  }
  inline QVarLengthArray<T, Prealloc> &operator+=(const T &t) {
    append(t);
    return *this;
  }
  inline QVarLengthArray<T, Prealloc> &operator+=(T &&t) {
    append(std::move(t));
    return *this;
  }

  void prepend(T &&t);
  void prepend(const T &t);
  void insert(int i, T &&t);
  void insert(int i, const T &t);
  void insert(int i, int n, const T &t);
  void replace(int i, const T &t);
  void remove(int i);
  void remove(int i, int n);

  inline T *data() { return ptr; }
  inline const T *data() const { return ptr; }
  inline const T *constData() const { return ptr; }
  typedef int size_type;
  typedef T value_type;
  typedef value_type *pointer;
  typedef const value_type *const_pointer;
  typedef value_type &reference;
  typedef const value_type &const_reference;
  typedef qptrdiff difference_type;

  typedef T *iterator;
  typedef const T *const_iterator;
  typedef std::reverse_iterator<iterator> reverse_iterator;
  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

  inline iterator begin() { return ptr; }
  inline const_iterator begin() const { return ptr; }
  inline const_iterator cbegin() const { return ptr; }
  inline const_iterator constBegin() const { return ptr; }
  inline iterator end() { return ptr + s; }
  inline const_iterator end() const { return ptr + s; }
  inline const_iterator cend() const { return ptr + s; }
  inline const_iterator constEnd() const { return ptr + s; }
  reverse_iterator rbegin() { return reverse_iterator(end()); }
  reverse_iterator rend() { return reverse_iterator(begin()); }
  const_reverse_iterator rbegin() const {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator rend() const {
    return const_reverse_iterator(begin());
  }
  const_reverse_iterator crbegin() const {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator crend() const {
    return const_reverse_iterator(begin());
  }
  iterator insert(const_iterator before, int n, const T &x);
  iterator insert(const_iterator before, T &&x);
  inline iterator insert(const_iterator before, const T &x) {
    return insert(before, 1, x);
  }
  iterator erase(const_iterator begin, const_iterator end);
  inline iterator erase(const_iterator pos) { return erase(pos, pos + 1); }

  inline bool empty() const { return isEmpty(); }
  inline void push_back(const T &t) { append(t); }
  void push_back(T &&t) { append(std::move(t)); }
  inline void pop_back() { removeLast(); }
  inline T &front() { return first(); }
  inline const T &front() const { return first(); }
  inline T &back() { return last(); }
  inline const T &back() const { return last(); }
  void shrink_to_fit() { squeeze(); }

private:
  void realloc(int size, int alloc);

  int a;
  int s;
  T *ptr;
  union {
    char array[Prealloc * sizeof(T)];
    qint64 q_for_alignment_1;
    double q_for_alignment_2;
  };

  bool isValidIterator(const const_iterator &i) const {
    const std::less<const T *> less = {};
    return !less(cend(), i) && !less(i, cbegin());
  }
};
# 275 "/usr/local/include/QtCore/qvarlengtharray.h"
template <class T, int Prealloc>
inline QVarLengthArray<T, Prealloc>::QVarLengthArray(int asize) : s(asize) {
  static_assert(bool(Prealloc > 0),
                "QVarLengthArray Prealloc must be greater than 0.");
  ((s >= 0) ? static_cast<void>(0)
            : qt_assert_x("QVarLengthArray::QVarLengthArray()",
                          "Size must be greater than or equal to 0.",
                          "/usr/local/include/QtCore/qvarlengtharray.h", 279));
  if (s > Prealloc) {
    ptr = reinterpret_cast<T *>(malloc(s * sizeof(T)));
    do {
      if (!(ptr))
        qBadAlloc();
    } while (false);
    a = s;
  } else {
    ptr = reinterpret_cast<T *>(array);
    a = Prealloc;
  }
  if (QTypeInfo<T>::isComplex) {
    T *i = ptr + s;
    while (i != ptr)
      new (--i) T;
  }
}

template <class T, int Prealloc>
inline void QVarLengthArray<T, Prealloc>::resize(int asize) {
  realloc(asize, qMax(asize, a));
}

template <class T, int Prealloc>
inline void QVarLengthArray<T, Prealloc>::reserve(int asize) {
  if (asize > a)
    realloc(s, asize);
}

template <class T, int Prealloc>
inline int QVarLengthArray<T, Prealloc>::indexOf(const T &t, int from) const {
  if (from < 0)
    from = qMax(from + s, 0);
  if (from < s) {
    T *n = ptr + from - 1;
    T *e = ptr + s;
    while (++n != e)
      if (*n == t)
        return n - ptr;
  }
  return -1;
}

template <class T, int Prealloc>
inline int QVarLengthArray<T, Prealloc>::lastIndexOf(const T &t,
                                                     int from) const {
  if (from < 0)
    from += s;
  else if (from >= s)
    from = s - 1;
  if (from >= 0) {
    T *b = ptr;
    T *n = ptr + from + 1;
    while (n != b) {
      if (*--n == t)
        return n - b;
    }
  }
  return -1;
}

template <class T, int Prealloc>
inline bool QVarLengthArray<T, Prealloc>::contains(const T &t) const {
  T *b = ptr;
  T *i = ptr + s;
  while (i != b) {
    if (*--i == t)
      return true;
  }
  return false;
}

template <class T, int Prealloc>
void QVarLengthArray<T, Prealloc>::append(const T *abuf, int increment) {
  ((abuf)
       ? static_cast<void>(0)
       : qt_assert("abuf", "/usr/local/include/QtCore/qvarlengtharray.h", 351));
  if (increment <= 0)
    return;

  const int asize = s + increment;

  if (asize >= a)
    realloc(s, qMax(s * 2, asize));

  if (QTypeInfo<T>::isComplex) {

    while (s < asize)
      new (ptr + (s++)) T(*abuf++);
  } else {
    memcpy(static_cast<void *>(&ptr[s]), static_cast<const void *>(abuf),
           increment * sizeof(T));
    s = asize;
  }
}

template <class T, int Prealloc>
inline void QVarLengthArray<T, Prealloc>::squeeze() {
  realloc(s, s);
}

template <class T, int Prealloc>
void QVarLengthArray<T, Prealloc>::realloc(int asize, int aalloc) {
  ((aalloc >= asize)
       ? static_cast<void>(0)
       : qt_assert("aalloc >= asize",
                   "/usr/local/include/QtCore/qvarlengtharray.h", 377));
  T *oldPtr = ptr;
  int osize = s;

  const int copySize = qMin(asize, osize);
  do {
    const bool valueOfExpression = copySize >= 0;
    ((valueOfExpression)
         ? static_cast<void>(0)
         : qt_assert_x("Q_ASSUME()",
                       "Assumption in Q_ASSUME(\""
                       "copySize >= 0"
                       "\") was not correct",
                       "/usr/local/include/QtCore/qvarlengtharray.h", 382));
    __builtin_assume(valueOfExpression);
  } while (false);
  if (aalloc != a) {
    if (aalloc > Prealloc) {
      T *newPtr = reinterpret_cast<T *>(malloc(aalloc * sizeof(T)));
      do {
        if (!(newPtr))
          qBadAlloc();
      } while (false);

      ptr = newPtr;
      a = aalloc;
    } else {
      ptr = reinterpret_cast<T *>(array);
      a = Prealloc;
    }
    s = 0;
    if (!QTypeInfoQuery<T>::isRelocatable) {
      try {

        while (s < copySize) {
          new (ptr + s) T(std::move(*(oldPtr + s)));
          (oldPtr + s)->~T();
          s++;
        }
      } catch (...) {

        int sClean = s;
        while (sClean < osize)
          (oldPtr + (sClean++))->~T();
        if (oldPtr != reinterpret_cast<T *>(array) && oldPtr != ptr)
          free(oldPtr);
        throw;
      }
    } else {
      memcpy(static_cast<void *>(ptr), static_cast<const void *>(oldPtr),
             copySize * sizeof(T));
    }
  }
  s = copySize;

  if (QTypeInfo<T>::isComplex) {

    while (osize > asize)
      (oldPtr + (--osize))->~T();
  }

  if (oldPtr != reinterpret_cast<T *>(array) && oldPtr != ptr)
    free(oldPtr);

  if (QTypeInfo<T>::isComplex) {

    while (s < asize)
      new (ptr + (s++)) T;
  } else {
    s = asize;
  }
}

template <class T, int Prealloc>
T QVarLengthArray<T, Prealloc>::value(int i) const {
  if (uint(i) >= uint(size())) {
    return T();
  }
  return at(i);
}
template <class T, int Prealloc>
T QVarLengthArray<T, Prealloc>::value(int i, const T &defaultValue) const {
  return (uint(i) >= uint(size())) ? defaultValue : at(i);
}

template <class T, int Prealloc>
inline void QVarLengthArray<T, Prealloc>::insert(int i, T &&t) {
  ((i >= 0 && i <= s)
       ? static_cast<void>(0)
       : qt_assert_x("QVarLengthArray::insert", "index out of range",
                     "/usr/local/include/QtCore/qvarlengtharray.h", 452));
  insert(cbegin() + i, std::move(t));
}
template <class T, int Prealloc>
inline void QVarLengthArray<T, Prealloc>::insert(int i, const T &t) {
  ((i >= 0 && i <= s)
       ? static_cast<void>(0)
       : qt_assert_x("QVarLengthArray::insert", "index out of range",
                     "/usr/local/include/QtCore/qvarlengtharray.h", 456));
  insert(begin() + i, 1, t);
}
template <class T, int Prealloc>
inline void QVarLengthArray<T, Prealloc>::insert(int i, int n, const T &t) {
  ((i >= 0 && i <= s)
       ? static_cast<void>(0)
       : qt_assert_x("QVarLengthArray::insert", "index out of range",
                     "/usr/local/include/QtCore/qvarlengtharray.h", 460));
  insert(begin() + i, n, t);
}
template <class T, int Prealloc>
inline void QVarLengthArray<T, Prealloc>::remove(int i, int n) {
  ((i >= 0 && n >= 0 && i + n <= s)
       ? static_cast<void>(0)
       : qt_assert_x("QVarLengthArray::remove", "index out of range",
                     "/usr/local/include/QtCore/qvarlengtharray.h", 464));
  erase(begin() + i, begin() + i + n);
}
template <class T, int Prealloc>
inline void QVarLengthArray<T, Prealloc>::remove(int i) {
  ((i >= 0 && i < s)
       ? static_cast<void>(0)
       : qt_assert_x("QVarLengthArray::remove", "index out of range",
                     "/usr/local/include/QtCore/qvarlengtharray.h", 468));
  erase(begin() + i, begin() + i + 1);
}
template <class T, int Prealloc>
inline void QVarLengthArray<T, Prealloc>::prepend(T &&t) {
  insert(cbegin(), std::move(t));
}
template <class T, int Prealloc>
inline void QVarLengthArray<T, Prealloc>::prepend(const T &t) {
  insert(begin(), 1, t);
}

template <class T, int Prealloc>
inline void QVarLengthArray<T, Prealloc>::replace(int i, const T &t) {
  ((i >= 0 && i < s)
       ? static_cast<void>(0)
       : qt_assert_x("QVarLengthArray::replace", "index out of range",
                     "/usr/local/include/QtCore/qvarlengtharray.h", 480));
  const T copy(t);
  data()[i] = copy;
}

template <class T, int Prealloc>
typename QVarLengthArray<T, Prealloc>::iterator
QVarLengthArray<T, Prealloc>::insert(const_iterator before, T &&t) {
  ((isValidIterator(before))
       ? static_cast<void>(0)
       : qt_assert_x(
             "QVarLengthArray::insert",
             "The specified const_iterator argument 'before' is invalid",
             "/usr/local/include/QtCore/qvarlengtharray.h", 488));

  int offset = int(before - ptr);
  reserve(s + 1);
  if (!QTypeInfo<T>::isRelocatable) {
    T *b = ptr + offset;
    T *i = ptr + s;
    T *j = i + 1;

    if (i != b) {
      new (--j) T(std::move(*--i));
      while (i != b)
        *--j = std::move(*--i);
      *b = std::move(t);
    } else {
      new (b) T(std::move(t));
    }
  } else {
    T *b = ptr + offset;
    memmove(static_cast<void *>(b + 1), static_cast<const void *>(b),
            (s - offset) * sizeof(T));
    new (b) T(std::move(t));
  }
  s += 1;
  return ptr + offset;
}

template <class T, int Prealloc>
typename QVarLengthArray<T, Prealloc>::iterator
QVarLengthArray<T, Prealloc>::insert(const_iterator before, size_type n,
                                     const T &t) {
  ((isValidIterator(before))
       ? static_cast<void>(0)
       : qt_assert_x(
             "QVarLengthArray::insert",
             "The specified const_iterator argument 'before' is invalid",
             "/usr/local/include/QtCore/qvarlengtharray.h", 517));

  int offset = int(before - ptr);
  if (n != 0) {
    resize(s + n);
    const T copy(t);
    if (!QTypeInfoQuery<T>::isRelocatable) {
      T *b = ptr + offset;
      T *j = ptr + s;
      T *i = j - n;
      while (i != b)
        *--j = *--i;
      i = b + n;
      while (i != b)
        *--i = copy;
    } else {
      T *b = ptr + offset;
      T *i = b + n;
      memmove(static_cast<void *>(i), static_cast<const void *>(b),
              (s - offset - n) * sizeof(T));
      while (i != b)
        new (--i) T(copy);
    }
  }
  return ptr + offset;
}

template <class T, int Prealloc>
typename QVarLengthArray<T, Prealloc>::iterator
QVarLengthArray<T, Prealloc>::erase(const_iterator abegin,
                                    const_iterator aend) {
  ((isValidIterator(abegin))
       ? static_cast<void>(0)
       : qt_assert_x(
             "QVarLengthArray::insert",
             "The specified const_iterator argument 'abegin' is invalid",
             "/usr/local/include/QtCore/qvarlengtharray.h", 546));
  ((isValidIterator(aend))
       ? static_cast<void>(0)
       : qt_assert_x("QVarLengthArray::insert",
                     "The specified const_iterator argument 'aend' is invalid",
                     "/usr/local/include/QtCore/qvarlengtharray.h", 547));

  int f = int(abegin - ptr);
  int l = int(aend - ptr);
  int n = l - f;
  if (QTypeInfo<T>::isComplex) {
    std::copy(ptr + l, ptr + s, (ptr + f));
    T *i = ptr + s;
    T *b = ptr + s - n;
    while (i != b) {
      --i;
      i->~T();
    }
  } else {
    memmove(static_cast<void *>(ptr + f), static_cast<const void *>(ptr + l),
            (s - l) * sizeof(T));
  }
  s -= n;
  return ptr + f;
}

template <typename T, int Prealloc1, int Prealloc2>
bool operator==(const QVarLengthArray<T, Prealloc1> &l,
                const QVarLengthArray<T, Prealloc2> &r) {
  if (l.size() != r.size())
    return false;
  const T *rb = r.begin();
  const T *b = l.begin();
  const T *e = l.end();
  return std::equal(b, e, (rb));
}

template <typename T, int Prealloc1, int Prealloc2>
bool operator!=(const QVarLengthArray<T, Prealloc1> &l,
                const QVarLengthArray<T, Prealloc2> &r) {
  return !(l == r);
}

template <typename T, int Prealloc1, int Prealloc2>
bool operator<(
    const QVarLengthArray<T, Prealloc1> &lhs,
    const QVarLengthArray<T, Prealloc2>
        &rhs) noexcept(noexcept(std::lexicographical_compare(lhs.begin(),
                                                             lhs.end(),
                                                             rhs.begin(),
                                                             rhs.end()))) {
  return std::lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(),
                                      rhs.end());
}

template <typename T, int Prealloc1, int Prealloc2>
inline bool operator>(
    const QVarLengthArray<T, Prealloc1> &lhs,
    const QVarLengthArray<T, Prealloc2> &rhs) noexcept(noexcept(lhs < rhs)) {
  return rhs < lhs;
}

template <typename T, int Prealloc1, int Prealloc2>
inline bool operator<=(
    const QVarLengthArray<T, Prealloc1> &lhs,
    const QVarLengthArray<T, Prealloc2> &rhs) noexcept(noexcept(lhs < rhs)) {
  return !(lhs > rhs);
}

template <typename T, int Prealloc1, int Prealloc2>
inline bool operator>=(
    const QVarLengthArray<T, Prealloc1> &lhs,
    const QVarLengthArray<T, Prealloc2> &rhs) noexcept(noexcept(lhs < rhs)) {
  return !(lhs < rhs);
}

template <typename T, int Prealloc>
uint qHash(const QVarLengthArray<T, Prealloc> &key,
           uint seed = 0) noexcept(noexcept(qHashRange(key.cbegin(), key.cend(),
                                                       seed))) {
  return qHashRange(key.cbegin(), key.cend(), seed);
}
# 49 "/usr/local/include/QtCore/qmetatype.h" 2

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/vector" 1 3
# 272 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/vector" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 273 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/vector" 2 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__bit_reference" 1 3
# 13 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__bit_reference" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 14 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__bit_reference" 2 3
# 19 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__bit_reference" 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_macros" 1 3
# 23 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__bit_reference" 2 3

namespace std {
inline namespace __1 {

template <class _Cp, bool _IsConst, typename _Cp::__storage_type = 0>
class __bit_iterator;
template <class _Cp> class __bit_const_reference;

template <class _Tp> struct __has_storage_type {
  static const bool value = false;
};

template <class _Cp, bool = __has_storage_type<_Cp>::value>
class __bit_reference {
  typedef typename _Cp::__storage_type __storage_type;
  typedef typename _Cp::__storage_pointer __storage_pointer;

  __storage_pointer __seg_;
  __storage_type __mask_;

  friend typename _Cp::__self;

  friend class __bit_const_reference<_Cp>;
  friend class __bit_iterator<_Cp, false>;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __bit_reference(const __bit_reference &) = default;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  operator bool() const noexcept {
    return static_cast<bool>(*__seg_ & __mask_);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator~() const noexcept {
    return !static_cast<bool>(*this);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __bit_reference &
  operator=(bool __x) noexcept {
    if (__x)
      *__seg_ |= __mask_;
    else
      *__seg_ &= ~__mask_;
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __bit_reference &
  operator=(const __bit_reference &__x) noexcept {
    return operator=(static_cast<bool>(__x));
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  flip() noexcept {
    *__seg_ ^= __mask_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __bit_iterator<_Cp, false>
  operator&() const noexcept {
    return __bit_iterator<_Cp, false>(
        __seg_, static_cast<unsigned>(__libcpp_ctz(__mask_)));
  }

private:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __bit_reference(__storage_pointer __s, __storage_type __m) noexcept
      : __seg_(__s), __mask_(__m) {}
};

template <class _Cp> class __bit_reference<_Cp, false> {};

template <class _Cp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
swap(__bit_reference<_Cp> __x, __bit_reference<_Cp> __y) noexcept {
  bool __t = __x;
  __x = __y;
  __y = __t;
}

template <class _Cp, class _Dp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
swap(__bit_reference<_Cp> __x, __bit_reference<_Dp> __y) noexcept {
  bool __t = __x;
  __x = __y;
  __y = __t;
}

template <class _Cp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
swap(__bit_reference<_Cp> __x, bool &__y) noexcept {
  bool __t = __x;
  __x = __y;
  __y = __t;
}

template <class _Cp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
swap(bool &__x, __bit_reference<_Cp> __y) noexcept {
  bool __t = __x;
  __x = __y;
  __y = __t;
}

template <class _Cp> class __bit_const_reference {
  typedef typename _Cp::__storage_type __storage_type;
  typedef typename _Cp::__const_storage_pointer __storage_pointer;

  __storage_pointer __seg_;
  __storage_type __mask_;

  friend typename _Cp::__self;
  friend class __bit_iterator<_Cp, true>;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __bit_const_reference(const __bit_const_reference &) = default;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __bit_const_reference(const __bit_reference<_Cp> &__x) noexcept
      : __seg_(__x.__seg_), __mask_(__x.__mask_) {}

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr
  operator bool() const noexcept {
    return static_cast<bool>(*__seg_ & __mask_);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __bit_iterator<_Cp, true>
  operator&() const noexcept {
    return __bit_iterator<_Cp, true>(
        __seg_, static_cast<unsigned>(__libcpp_ctz(__mask_)));
  }

private:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) constexpr __bit_const_reference(
      __storage_pointer __s, __storage_type __m) noexcept
      : __seg_(__s), __mask_(__m) {}

  __bit_const_reference &operator=(const __bit_const_reference &) = delete;
};

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, _IsConst>
__find_bool_true(__bit_iterator<_Cp, _IsConst> __first,
                 typename _Cp::size_type __n) {
  typedef __bit_iterator<_Cp, _IsConst> _It;
  typedef typename _It::__storage_type __storage_type;
  static const int __bits_per_word = _It::__bits_per_word;

  if (__first.__ctz_ != 0) {
    __storage_type __clz_f =
        static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
    __storage_type __dn = std::__1::min(__clz_f, __n);
    __storage_type __m = (~__storage_type(0) << __first.__ctz_) &
                         (~__storage_type(0) >> (__clz_f - __dn));
    __storage_type __b = *__first.__seg_ & __m;
    if (__b)
      return _It(__first.__seg_,
                 static_cast<unsigned>(std::__1::__libcpp_ctz(__b)));
    if (__n == __dn)
      return __first + __n;
    __n -= __dn;
    ++__first.__seg_;
  }

  for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
    if (*__first.__seg_)
      return _It(__first.__seg_, static_cast<unsigned>(
                                     std::__1::__libcpp_ctz(*__first.__seg_)));

  if (__n > 0) {
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
    __storage_type __b = *__first.__seg_ & __m;
    if (__b)
      return _It(__first.__seg_,
                 static_cast<unsigned>(std::__1::__libcpp_ctz(__b)));
  }
  return _It(__first.__seg_, static_cast<unsigned>(__n));
}

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, _IsConst>
__find_bool_false(__bit_iterator<_Cp, _IsConst> __first,
                  typename _Cp::size_type __n) {
  typedef __bit_iterator<_Cp, _IsConst> _It;
  typedef typename _It::__storage_type __storage_type;
  const int __bits_per_word = _It::__bits_per_word;

  if (__first.__ctz_ != 0) {
    __storage_type __clz_f =
        static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
    __storage_type __dn = std::__1::min(__clz_f, __n);
    __storage_type __m = (~__storage_type(0) << __first.__ctz_) &
                         (~__storage_type(0) >> (__clz_f - __dn));
    __storage_type __b = ~*__first.__seg_ & __m;
    if (__b)
      return _It(__first.__seg_,
                 static_cast<unsigned>(std::__1::__libcpp_ctz(__b)));
    if (__n == __dn)
      return __first + __n;
    __n -= __dn;
    ++__first.__seg_;
  }

  for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word) {
    __storage_type __b = ~*__first.__seg_;
    if (__b)
      return _It(__first.__seg_,
                 static_cast<unsigned>(std::__1::__libcpp_ctz(__b)));
  }

  if (__n > 0) {
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
    __storage_type __b = ~*__first.__seg_ & __m;
    if (__b)
      return _It(__first.__seg_,
                 static_cast<unsigned>(std::__1::__libcpp_ctz(__b)));
  }
  return _It(__first.__seg_, static_cast<unsigned>(__n));
}

template <class _Cp, bool _IsConst, class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) __bit_iterator<_Cp, _IsConst>
find(__bit_iterator<_Cp, _IsConst> __first,
     __bit_iterator<_Cp, _IsConst> __last, const _Tp &__value_) {
  if (static_cast<bool>(__value_))
    return __find_bool_true(
        __first, static_cast<typename _Cp::size_type>(__last - __first));
  return __find_bool_false(
      __first, static_cast<typename _Cp::size_type>(__last - __first));
}

template <class _Cp, bool _IsConst>
typename __bit_iterator<_Cp, _IsConst>::difference_type
__count_bool_true(__bit_iterator<_Cp, _IsConst> __first,
                  typename _Cp::size_type __n) {
  typedef __bit_iterator<_Cp, _IsConst> _It;
  typedef typename _It::__storage_type __storage_type;
  typedef typename _It::difference_type difference_type;
  const int __bits_per_word = _It::__bits_per_word;
  difference_type __r = 0;

  if (__first.__ctz_ != 0) {
    __storage_type __clz_f =
        static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
    __storage_type __dn = std::__1::min(__clz_f, __n);
    __storage_type __m = (~__storage_type(0) << __first.__ctz_) &
                         (~__storage_type(0) >> (__clz_f - __dn));
    __r = std::__1::__libcpp_popcount(*__first.__seg_ & __m);
    __n -= __dn;
    ++__first.__seg_;
  }

  for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
    __r += std::__1::__libcpp_popcount(*__first.__seg_);

  if (__n > 0) {
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
    __r += std::__1::__libcpp_popcount(*__first.__seg_ & __m);
  }
  return __r;
}

template <class _Cp, bool _IsConst>
typename __bit_iterator<_Cp, _IsConst>::difference_type
__count_bool_false(__bit_iterator<_Cp, _IsConst> __first,
                   typename _Cp::size_type __n) {
  typedef __bit_iterator<_Cp, _IsConst> _It;
  typedef typename _It::__storage_type __storage_type;
  typedef typename _It::difference_type difference_type;
  const int __bits_per_word = _It::__bits_per_word;
  difference_type __r = 0;

  if (__first.__ctz_ != 0) {
    __storage_type __clz_f =
        static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
    __storage_type __dn = std::__1::min(__clz_f, __n);
    __storage_type __m = (~__storage_type(0) << __first.__ctz_) &
                         (~__storage_type(0) >> (__clz_f - __dn));
    __r = std::__1::__libcpp_popcount(~*__first.__seg_ & __m);
    __n -= __dn;
    ++__first.__seg_;
  }

  for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
    __r += std::__1::__libcpp_popcount(~*__first.__seg_);

  if (__n > 0) {
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
    __r += std::__1::__libcpp_popcount(~*__first.__seg_ & __m);
  }
  return __r;
}

template <class _Cp, bool _IsConst, class _Tp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename __bit_iterator<_Cp, _IsConst>::difference_type
count(__bit_iterator<_Cp, _IsConst> __first,
      __bit_iterator<_Cp, _IsConst> __last, const _Tp &__value_) {
  if (static_cast<bool>(__value_))
    return __count_bool_true(
        __first, static_cast<typename _Cp::size_type>(__last - __first));
  return __count_bool_false(
      __first, static_cast<typename _Cp::size_type>(__last - __first));
}

template <class _Cp>
void __fill_n_false(__bit_iterator<_Cp, false> __first,
                    typename _Cp::size_type __n) {
  typedef __bit_iterator<_Cp, false> _It;
  typedef typename _It::__storage_type __storage_type;
  const int __bits_per_word = _It::__bits_per_word;

  if (__first.__ctz_ != 0) {
    __storage_type __clz_f =
        static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
    __storage_type __dn = std::__1::min(__clz_f, __n);
    __storage_type __m = (~__storage_type(0) << __first.__ctz_) &
                         (~__storage_type(0) >> (__clz_f - __dn));
    *__first.__seg_ &= ~__m;
    __n -= __dn;
    ++__first.__seg_;
  }

  __storage_type __nw = __n / __bits_per_word;
  std::__1::memset(std::__1::__to_address(__first.__seg_), 0,
                   __nw * sizeof(__storage_type));
  __n -= __nw * __bits_per_word;

  if (__n > 0) {
    __first.__seg_ += __nw;
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
    *__first.__seg_ &= ~__m;
  }
}

template <class _Cp>
void __fill_n_true(__bit_iterator<_Cp, false> __first,
                   typename _Cp::size_type __n) {
  typedef __bit_iterator<_Cp, false> _It;
  typedef typename _It::__storage_type __storage_type;
  const int __bits_per_word = _It::__bits_per_word;

  if (__first.__ctz_ != 0) {
    __storage_type __clz_f =
        static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
    __storage_type __dn = std::__1::min(__clz_f, __n);
    __storage_type __m = (~__storage_type(0) << __first.__ctz_) &
                         (~__storage_type(0) >> (__clz_f - __dn));
    *__first.__seg_ |= __m;
    __n -= __dn;
    ++__first.__seg_;
  }

  __storage_type __nw = __n / __bits_per_word;
  std::__1::memset(std::__1::__to_address(__first.__seg_), -1,
                   __nw * sizeof(__storage_type));
  __n -= __nw * __bits_per_word;

  if (__n > 0) {
    __first.__seg_ += __nw;
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
    *__first.__seg_ |= __m;
  }
}

template <class _Cp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
fill_n(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n,
       bool __value_) {
  if (__n > 0) {
    if (__value_)
      __fill_n_true(__first, __n);
    else
      __fill_n_false(__first, __n);
  }
}

template <class _Cp>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
fill(__bit_iterator<_Cp, false> __first, __bit_iterator<_Cp, false> __last,
     bool __value_) {
  std::__1::fill_n(__first,
                   static_cast<typename _Cp::size_type>(__last - __first),
                   __value_);
}

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false> __copy_aligned(__bit_iterator<_Cp, _IsConst> __first,
                                          __bit_iterator<_Cp, _IsConst> __last,
                                          __bit_iterator<_Cp, false> __result) {
  typedef __bit_iterator<_Cp, _IsConst> _In;
  typedef typename _In::difference_type difference_type;
  typedef typename _In::__storage_type __storage_type;
  const int __bits_per_word = _In::__bits_per_word;
  difference_type __n = __last - __first;
  if (__n > 0) {

    if (__first.__ctz_ != 0) {
      unsigned __clz = __bits_per_word - __first.__ctz_;
      difference_type __dn =
          std::__1::min(static_cast<difference_type>(__clz), __n);
      __n -= __dn;
      __storage_type __m = (~__storage_type(0) << __first.__ctz_) &
                           (~__storage_type(0) >> (__clz - __dn));
      __storage_type __b = *__first.__seg_ & __m;
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b;
      __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
      __result.__ctz_ =
          static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
      ++__first.__seg_;
    }

    __storage_type __nw = __n / __bits_per_word;
    std::__1::memmove(std::__1::__to_address(__result.__seg_),
                      std::__1::__to_address(__first.__seg_),
                      __nw * sizeof(__storage_type));
    __n -= __nw * __bits_per_word;
    __result.__seg_ += __nw;

    if (__n > 0) {
      __first.__seg_ += __nw;
      __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
      __storage_type __b = *__first.__seg_ & __m;
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b;
      __result.__ctz_ = static_cast<unsigned>(__n);
    }
  }
  return __result;
}

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_unaligned(__bit_iterator<_Cp, _IsConst> __first,
                 __bit_iterator<_Cp, _IsConst> __last,
                 __bit_iterator<_Cp, false> __result) {
  typedef __bit_iterator<_Cp, _IsConst> _In;
  typedef typename _In::difference_type difference_type;
  typedef typename _In::__storage_type __storage_type;
  static const int __bits_per_word = _In::__bits_per_word;
  difference_type __n = __last - __first;
  if (__n > 0) {

    if (__first.__ctz_ != 0) {
      unsigned __clz_f = __bits_per_word - __first.__ctz_;
      difference_type __dn =
          std::__1::min(static_cast<difference_type>(__clz_f), __n);
      __n -= __dn;
      __storage_type __m = (~__storage_type(0) << __first.__ctz_) &
                           (~__storage_type(0) >> (__clz_f - __dn));
      __storage_type __b = *__first.__seg_ & __m;
      unsigned __clz_r = __bits_per_word - __result.__ctz_;
      __storage_type __ddn = std::__1::min<__storage_type>(__dn, __clz_r);
      __m = (~__storage_type(0) << __result.__ctz_) &
            (~__storage_type(0) >> (__clz_r - __ddn));
      *__result.__seg_ &= ~__m;
      if (__result.__ctz_ > __first.__ctz_)
        *__result.__seg_ |= __b << (__result.__ctz_ - __first.__ctz_);
      else
        *__result.__seg_ |= __b >> (__first.__ctz_ - __result.__ctz_);
      __result.__seg_ += (__ddn + __result.__ctz_) / __bits_per_word;
      __result.__ctz_ =
          static_cast<unsigned>((__ddn + __result.__ctz_) % __bits_per_word);
      __dn -= __ddn;
      if (__dn > 0) {
        __m = ~__storage_type(0) >> (__bits_per_word - __dn);
        *__result.__seg_ &= ~__m;
        *__result.__seg_ |= __b >> (__first.__ctz_ + __ddn);
        __result.__ctz_ = static_cast<unsigned>(__dn);
      }
      ++__first.__seg_;
    }

    unsigned __clz_r = __bits_per_word - __result.__ctz_;
    __storage_type __m = ~__storage_type(0) << __result.__ctz_;
    for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_) {
      __storage_type __b = *__first.__seg_;
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b << __result.__ctz_;
      ++__result.__seg_;
      *__result.__seg_ &= __m;
      *__result.__seg_ |= __b >> __clz_r;
    }

    if (__n > 0) {
      __m = ~__storage_type(0) >> (__bits_per_word - __n);
      __storage_type __b = *__first.__seg_ & __m;
      __storage_type __dn =
          std::__1::min(__n, static_cast<difference_type>(__clz_r));
      __m = (~__storage_type(0) << __result.__ctz_) &
            (~__storage_type(0) >> (__clz_r - __dn));
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b << __result.__ctz_;
      __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
      __result.__ctz_ =
          static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
      __n -= __dn;
      if (__n > 0) {
        __m = ~__storage_type(0) >> (__bits_per_word - __n);
        *__result.__seg_ &= ~__m;
        *__result.__seg_ |= __b >> __dn;
        __result.__ctz_ = static_cast<unsigned>(__n);
      }
    }
  }
  return __result;
}

template <class _Cp, bool _IsConst>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) __bit_iterator<_Cp, false>
copy(__bit_iterator<_Cp, _IsConst> __first,
     __bit_iterator<_Cp, _IsConst> __last,
     __bit_iterator<_Cp, false> __result) {
  if (__first.__ctz_ == __result.__ctz_)
    return __copy_aligned(__first, __last, __result);
  return __copy_unaligned(__first, __last, __result);
}

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_backward_aligned(__bit_iterator<_Cp, _IsConst> __first,
                        __bit_iterator<_Cp, _IsConst> __last,
                        __bit_iterator<_Cp, false> __result) {
  typedef __bit_iterator<_Cp, _IsConst> _In;
  typedef typename _In::difference_type difference_type;
  typedef typename _In::__storage_type __storage_type;
  const int __bits_per_word = _In::__bits_per_word;
  difference_type __n = __last - __first;
  if (__n > 0) {

    if (__last.__ctz_ != 0) {
      difference_type __dn =
          std::__1::min(static_cast<difference_type>(__last.__ctz_), __n);
      __n -= __dn;
      unsigned __clz = __bits_per_word - __last.__ctz_;
      __storage_type __m = (~__storage_type(0) << (__last.__ctz_ - __dn)) &
                           (~__storage_type(0) >> __clz);
      __storage_type __b = *__last.__seg_ & __m;
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b;
      __result.__ctz_ = static_cast<unsigned>(
          ((-__dn & (__bits_per_word - 1)) + __result.__ctz_) %
          __bits_per_word);
    }

    __storage_type __nw = __n / __bits_per_word;
    __result.__seg_ -= __nw;
    __last.__seg_ -= __nw;
    std::__1::memmove(std::__1::__to_address(__result.__seg_),
                      std::__1::__to_address(__last.__seg_),
                      __nw * sizeof(__storage_type));
    __n -= __nw * __bits_per_word;

    if (__n > 0) {
      __storage_type __m = ~__storage_type(0) << (__bits_per_word - __n);
      __storage_type __b = *--__last.__seg_ & __m;
      *--__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b;
      __result.__ctz_ = static_cast<unsigned>(-__n & (__bits_per_word - 1));
    }
  }
  return __result;
}

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_backward_unaligned(__bit_iterator<_Cp, _IsConst> __first,
                          __bit_iterator<_Cp, _IsConst> __last,
                          __bit_iterator<_Cp, false> __result) {
  typedef __bit_iterator<_Cp, _IsConst> _In;
  typedef typename _In::difference_type difference_type;
  typedef typename _In::__storage_type __storage_type;
  const int __bits_per_word = _In::__bits_per_word;
  difference_type __n = __last - __first;
  if (__n > 0) {

    if (__last.__ctz_ != 0) {
      difference_type __dn =
          std::__1::min(static_cast<difference_type>(__last.__ctz_), __n);
      __n -= __dn;
      unsigned __clz_l = __bits_per_word - __last.__ctz_;
      __storage_type __m = (~__storage_type(0) << (__last.__ctz_ - __dn)) &
                           (~__storage_type(0) >> __clz_l);
      __storage_type __b = *__last.__seg_ & __m;
      unsigned __clz_r = __bits_per_word - __result.__ctz_;
      __storage_type __ddn =
          std::__1::min(__dn, static_cast<difference_type>(__result.__ctz_));
      if (__ddn > 0) {
        __m = (~__storage_type(0) << (__result.__ctz_ - __ddn)) &
              (~__storage_type(0) >> __clz_r);
        *__result.__seg_ &= ~__m;
        if (__result.__ctz_ > __last.__ctz_)
          *__result.__seg_ |= __b << (__result.__ctz_ - __last.__ctz_);
        else
          *__result.__seg_ |= __b >> (__last.__ctz_ - __result.__ctz_);
        __result.__ctz_ = static_cast<unsigned>(
            ((-__ddn & (__bits_per_word - 1)) + __result.__ctz_) %
            __bits_per_word);
        __dn -= __ddn;
      }
      if (__dn > 0) {

        --__result.__seg_;
        __result.__ctz_ = static_cast<unsigned>(-__dn & (__bits_per_word - 1));
        __m = ~__storage_type(0) << __result.__ctz_;
        *__result.__seg_ &= ~__m;
        __last.__ctz_ -= __dn + __ddn;
        *__result.__seg_ |= __b << (__result.__ctz_ - __last.__ctz_);
      }
    }

    unsigned __clz_r = __bits_per_word - __result.__ctz_;
    __storage_type __m = ~__storage_type(0) >> __clz_r;
    for (; __n >= __bits_per_word; __n -= __bits_per_word) {
      __storage_type __b = *--__last.__seg_;
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b >> __clz_r;
      *--__result.__seg_ &= __m;
      *__result.__seg_ |= __b << __result.__ctz_;
    }

    if (__n > 0) {
      __m = ~__storage_type(0) << (__bits_per_word - __n);
      __storage_type __b = *--__last.__seg_ & __m;
      __clz_r = __bits_per_word - __result.__ctz_;
      __storage_type __dn =
          std::__1::min(__n, static_cast<difference_type>(__result.__ctz_));
      __m = (~__storage_type(0) << (__result.__ctz_ - __dn)) &
            (~__storage_type(0) >> __clz_r);
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b >> (__bits_per_word - __result.__ctz_);
      __result.__ctz_ = static_cast<unsigned>(
          ((-__dn & (__bits_per_word - 1)) + __result.__ctz_) %
          __bits_per_word);
      __n -= __dn;
      if (__n > 0) {

        --__result.__seg_;
        __result.__ctz_ = static_cast<unsigned>(-__n & (__bits_per_word - 1));
        __m = ~__storage_type(0) << __result.__ctz_;
        *__result.__seg_ &= ~__m;
        *__result.__seg_ |=
            __b << (__result.__ctz_ - (__bits_per_word - __n - __dn));
      }
    }
  }
  return __result;
}

template <class _Cp, bool _IsConst>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) __bit_iterator<_Cp, false>
copy_backward(__bit_iterator<_Cp, _IsConst> __first,
              __bit_iterator<_Cp, _IsConst> __last,
              __bit_iterator<_Cp, false> __result) {
  if (__last.__ctz_ == __result.__ctz_)
    return __copy_backward_aligned(__first, __last, __result);
  return __copy_backward_unaligned(__first, __last, __result);
}

template <class _Cp, bool _IsConst>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) __bit_iterator<_Cp, false>
move(__bit_iterator<_Cp, _IsConst> __first,
     __bit_iterator<_Cp, _IsConst> __last,
     __bit_iterator<_Cp, false> __result) {
  return std::__1::copy(__first, __last, __result);
}

template <class _Cp, bool _IsConst>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) __bit_iterator<_Cp, false>
move_backward(__bit_iterator<_Cp, _IsConst> __first,
              __bit_iterator<_Cp, _IsConst> __last,
              __bit_iterator<_Cp, false> __result) {
  return std::__1::copy_backward(__first, __last, __result);
}

template <class __C1, class __C2>
__bit_iterator<__C2, false>
__swap_ranges_aligned(__bit_iterator<__C1, false> __first,
                      __bit_iterator<__C1, false> __last,
                      __bit_iterator<__C2, false> __result) {
  typedef __bit_iterator<__C1, false> _I1;
  typedef typename _I1::difference_type difference_type;
  typedef typename _I1::__storage_type __storage_type;
  const int __bits_per_word = _I1::__bits_per_word;
  difference_type __n = __last - __first;
  if (__n > 0) {

    if (__first.__ctz_ != 0) {
      unsigned __clz = __bits_per_word - __first.__ctz_;
      difference_type __dn =
          std::__1::min(static_cast<difference_type>(__clz), __n);
      __n -= __dn;
      __storage_type __m = (~__storage_type(0) << __first.__ctz_) &
                           (~__storage_type(0) >> (__clz - __dn));
      __storage_type __b1 = *__first.__seg_ & __m;
      *__first.__seg_ &= ~__m;
      __storage_type __b2 = *__result.__seg_ & __m;
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b1;
      *__first.__seg_ |= __b2;
      __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
      __result.__ctz_ =
          static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
      ++__first.__seg_;
    }

    for (; __n >= __bits_per_word;
         __n -= __bits_per_word, ++__first.__seg_, ++__result.__seg_)
      swap(*__first.__seg_, *__result.__seg_);

    if (__n > 0) {
      __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
      __storage_type __b1 = *__first.__seg_ & __m;
      *__first.__seg_ &= ~__m;
      __storage_type __b2 = *__result.__seg_ & __m;
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b1;
      *__first.__seg_ |= __b2;
      __result.__ctz_ = static_cast<unsigned>(__n);
    }
  }
  return __result;
}

template <class __C1, class __C2>
__bit_iterator<__C2, false>
__swap_ranges_unaligned(__bit_iterator<__C1, false> __first,
                        __bit_iterator<__C1, false> __last,
                        __bit_iterator<__C2, false> __result) {
  typedef __bit_iterator<__C1, false> _I1;
  typedef typename _I1::difference_type difference_type;
  typedef typename _I1::__storage_type __storage_type;
  const int __bits_per_word = _I1::__bits_per_word;
  difference_type __n = __last - __first;
  if (__n > 0) {

    if (__first.__ctz_ != 0) {
      unsigned __clz_f = __bits_per_word - __first.__ctz_;
      difference_type __dn =
          std::__1::min(static_cast<difference_type>(__clz_f), __n);
      __n -= __dn;
      __storage_type __m = (~__storage_type(0) << __first.__ctz_) &
                           (~__storage_type(0) >> (__clz_f - __dn));
      __storage_type __b1 = *__first.__seg_ & __m;
      *__first.__seg_ &= ~__m;
      unsigned __clz_r = __bits_per_word - __result.__ctz_;
      __storage_type __ddn = std::__1::min<__storage_type>(__dn, __clz_r);
      __m = (~__storage_type(0) << __result.__ctz_) &
            (~__storage_type(0) >> (__clz_r - __ddn));
      __storage_type __b2 = *__result.__seg_ & __m;
      *__result.__seg_ &= ~__m;
      if (__result.__ctz_ > __first.__ctz_) {
        unsigned __s = __result.__ctz_ - __first.__ctz_;
        *__result.__seg_ |= __b1 << __s;
        *__first.__seg_ |= __b2 >> __s;
      } else {
        unsigned __s = __first.__ctz_ - __result.__ctz_;
        *__result.__seg_ |= __b1 >> __s;
        *__first.__seg_ |= __b2 << __s;
      }
      __result.__seg_ += (__ddn + __result.__ctz_) / __bits_per_word;
      __result.__ctz_ =
          static_cast<unsigned>((__ddn + __result.__ctz_) % __bits_per_word);
      __dn -= __ddn;
      if (__dn > 0) {
        __m = ~__storage_type(0) >> (__bits_per_word - __dn);
        __b2 = *__result.__seg_ & __m;
        *__result.__seg_ &= ~__m;
        unsigned __s = __first.__ctz_ + __ddn;
        *__result.__seg_ |= __b1 >> __s;
        *__first.__seg_ |= __b2 << __s;
        __result.__ctz_ = static_cast<unsigned>(__dn);
      }
      ++__first.__seg_;
    }

    __storage_type __m = ~__storage_type(0) << __result.__ctz_;
    unsigned __clz_r = __bits_per_word - __result.__ctz_;
    for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_) {
      __storage_type __b1 = *__first.__seg_;
      __storage_type __b2 = *__result.__seg_ & __m;
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b1 << __result.__ctz_;
      *__first.__seg_ = __b2 >> __result.__ctz_;
      ++__result.__seg_;
      __b2 = *__result.__seg_ & ~__m;
      *__result.__seg_ &= __m;
      *__result.__seg_ |= __b1 >> __clz_r;
      *__first.__seg_ |= __b2 << __clz_r;
    }

    if (__n > 0) {
      __m = ~__storage_type(0) >> (__bits_per_word - __n);
      __storage_type __b1 = *__first.__seg_ & __m;
      *__first.__seg_ &= ~__m;
      __storage_type __dn = std::__1::min<__storage_type>(__n, __clz_r);
      __m = (~__storage_type(0) << __result.__ctz_) &
            (~__storage_type(0) >> (__clz_r - __dn));
      __storage_type __b2 = *__result.__seg_ & __m;
      *__result.__seg_ &= ~__m;
      *__result.__seg_ |= __b1 << __result.__ctz_;
      *__first.__seg_ |= __b2 >> __result.__ctz_;
      __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
      __result.__ctz_ =
          static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
      __n -= __dn;
      if (__n > 0) {
        __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __b2 = *__result.__seg_ & __m;
        *__result.__seg_ &= ~__m;
        *__result.__seg_ |= __b1 >> __dn;
        *__first.__seg_ |= __b2 << __dn;
        __result.__ctz_ = static_cast<unsigned>(__n);
      }
    }
  }
  return __result;
}

template <class __C1, class __C2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) __bit_iterator<__C2, false>
swap_ranges(__bit_iterator<__C1, false> __first1,
            __bit_iterator<__C1, false> __last1,
            __bit_iterator<__C2, false> __first2) {
  if (__first1.__ctz_ == __first2.__ctz_)
    return __swap_ranges_aligned(__first1, __last1, __first2);
  return __swap_ranges_unaligned(__first1, __last1, __first2);
}

template <class _Cp> struct __bit_array {
  typedef typename _Cp::difference_type difference_type;
  typedef typename _Cp::__storage_type __storage_type;
  typedef typename _Cp::__storage_pointer __storage_pointer;
  typedef typename _Cp::iterator iterator;
  static const unsigned __bits_per_word = _Cp::__bits_per_word;
  static const unsigned _Np = 4;

  difference_type __size_;
  __storage_type __word_[_Np];

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static difference_type
  capacity() {
    return static_cast<difference_type>(_Np * __bits_per_word);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit __bit_array(difference_type __s)
      : __size_(__s) {}
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  begin() {
    return iterator(pointer_traits<__storage_pointer>::pointer_to(__word_[0]),
                    0);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  end() {
    return iterator(pointer_traits<__storage_pointer>::pointer_to(__word_[0]) +
                        __size_ / __bits_per_word,
                    static_cast<unsigned>(__size_ % __bits_per_word));
  }
};

template <class _Cp>
__bit_iterator<_Cp, false> rotate(__bit_iterator<_Cp, false> __first,
                                  __bit_iterator<_Cp, false> __middle,
                                  __bit_iterator<_Cp, false> __last) {
  typedef __bit_iterator<_Cp, false> _I1;
  typedef typename _I1::difference_type difference_type;
  difference_type __d1 = __middle - __first;
  difference_type __d2 = __last - __middle;
  _I1 __r = __first + __d2;
  while (__d1 != 0 && __d2 != 0) {
    if (__d1 <= __d2) {
      if (__d1 <= __bit_array<_Cp>::capacity()) {
        __bit_array<_Cp> __b(__d1);
        std::__1::copy(__first, __middle, __b.begin());
        std::__1::copy(__b.begin(), __b.end(),
                       std::__1::copy(__middle, __last, __first));
        break;
      } else {
        __bit_iterator<_Cp, false> __mp =
            std::__1::swap_ranges(__first, __middle, __middle);
        __first = __middle;
        __middle = __mp;
        __d2 -= __d1;
      }
    } else {
      if (__d2 <= __bit_array<_Cp>::capacity()) {
        __bit_array<_Cp> __b(__d2);
        std::__1::copy(__middle, __last, __b.begin());
        std::__1::copy_backward(
            __b.begin(), __b.end(),
            std::__1::copy_backward(__first, __middle, __last));
        break;
      } else {
        __bit_iterator<_Cp, false> __mp = __first + __d2;
        std::__1::swap_ranges(__first, __mp, __middle);
        __first = __mp;
        __d1 -= __d2;
      }
    }
  }
  return __r;
}

template <class _Cp, bool _IC1, bool _IC2>
bool __equal_unaligned(__bit_iterator<_Cp, _IC1> __first1,
                       __bit_iterator<_Cp, _IC1> __last1,
                       __bit_iterator<_Cp, _IC2> __first2) {
  typedef __bit_iterator<_Cp, _IC1> _It;
  typedef typename _It::difference_type difference_type;
  typedef typename _It::__storage_type __storage_type;
  static const int __bits_per_word = _It::__bits_per_word;
  difference_type __n = __last1 - __first1;
  if (__n > 0) {

    if (__first1.__ctz_ != 0) {
      unsigned __clz_f = __bits_per_word - __first1.__ctz_;
      difference_type __dn =
          std::__1::min(static_cast<difference_type>(__clz_f), __n);
      __n -= __dn;
      __storage_type __m = (~__storage_type(0) << __first1.__ctz_) &
                           (~__storage_type(0) >> (__clz_f - __dn));
      __storage_type __b = *__first1.__seg_ & __m;
      unsigned __clz_r = __bits_per_word - __first2.__ctz_;
      __storage_type __ddn = std::__1::min<__storage_type>(__dn, __clz_r);
      __m = (~__storage_type(0) << __first2.__ctz_) &
            (~__storage_type(0) >> (__clz_r - __ddn));
      if (__first2.__ctz_ > __first1.__ctz_) {
        if ((*__first2.__seg_ & __m) !=
            (__b << (__first2.__ctz_ - __first1.__ctz_)))
          return false;
      } else {
        if ((*__first2.__seg_ & __m) !=
            (__b >> (__first1.__ctz_ - __first2.__ctz_)))
          return false;
      }
      __first2.__seg_ += (__ddn + __first2.__ctz_) / __bits_per_word;
      __first2.__ctz_ =
          static_cast<unsigned>((__ddn + __first2.__ctz_) % __bits_per_word);
      __dn -= __ddn;
      if (__dn > 0) {
        __m = ~__storage_type(0) >> (__bits_per_word - __dn);
        if ((*__first2.__seg_ & __m) != (__b >> (__first1.__ctz_ + __ddn)))
          return false;
        __first2.__ctz_ = static_cast<unsigned>(__dn);
      }
      ++__first1.__seg_;
    }

    unsigned __clz_r = __bits_per_word - __first2.__ctz_;
    __storage_type __m = ~__storage_type(0) << __first2.__ctz_;
    for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first1.__seg_) {
      __storage_type __b = *__first1.__seg_;
      if ((*__first2.__seg_ & __m) != (__b << __first2.__ctz_))
        return false;
      ++__first2.__seg_;
      if ((*__first2.__seg_ & ~__m) != (__b >> __clz_r))
        return false;
    }

    if (__n > 0) {
      __m = ~__storage_type(0) >> (__bits_per_word - __n);
      __storage_type __b = *__first1.__seg_ & __m;
      __storage_type __dn =
          std::__1::min(__n, static_cast<difference_type>(__clz_r));
      __m = (~__storage_type(0) << __first2.__ctz_) &
            (~__storage_type(0) >> (__clz_r - __dn));
      if ((*__first2.__seg_ & __m) != (__b << __first2.__ctz_))
        return false;
      __first2.__seg_ += (__dn + __first2.__ctz_) / __bits_per_word;
      __first2.__ctz_ =
          static_cast<unsigned>((__dn + __first2.__ctz_) % __bits_per_word);
      __n -= __dn;
      if (__n > 0) {
        __m = ~__storage_type(0) >> (__bits_per_word - __n);
        if ((*__first2.__seg_ & __m) != (__b >> __dn))
          return false;
      }
    }
  }
  return true;
}

template <class _Cp, bool _IC1, bool _IC2>
bool __equal_aligned(__bit_iterator<_Cp, _IC1> __first1,
                     __bit_iterator<_Cp, _IC1> __last1,
                     __bit_iterator<_Cp, _IC2> __first2) {
  typedef __bit_iterator<_Cp, _IC1> _It;
  typedef typename _It::difference_type difference_type;
  typedef typename _It::__storage_type __storage_type;
  static const int __bits_per_word = _It::__bits_per_word;
  difference_type __n = __last1 - __first1;
  if (__n > 0) {

    if (__first1.__ctz_ != 0) {
      unsigned __clz = __bits_per_word - __first1.__ctz_;
      difference_type __dn =
          std::__1::min(static_cast<difference_type>(__clz), __n);
      __n -= __dn;
      __storage_type __m = (~__storage_type(0) << __first1.__ctz_) &
                           (~__storage_type(0) >> (__clz - __dn));
      if ((*__first2.__seg_ & __m) != (*__first1.__seg_ & __m))
        return false;
      ++__first2.__seg_;
      ++__first1.__seg_;
    }

    for (; __n >= __bits_per_word;
         __n -= __bits_per_word, ++__first1.__seg_, ++__first2.__seg_)
      if (*__first2.__seg_ != *__first1.__seg_)
        return false;

    if (__n > 0) {
      __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
      if ((*__first2.__seg_ & __m) != (*__first1.__seg_ & __m))
        return false;
    }
  }
  return true;
}

template <class _Cp, bool _IC1, bool _IC2>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
equal(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1,
      __bit_iterator<_Cp, _IC2> __first2) {
  if (__first1.__ctz_ == __first2.__ctz_)
    return __equal_aligned(__first1, __last1, __first2);
  return __equal_unaligned(__first1, __last1, __first2);
}

template <class _Cp, bool _IsConst, typename _Cp::__storage_type>
class __bit_iterator {
public:
  typedef typename _Cp::difference_type difference_type;
  typedef bool value_type;
  typedef __bit_iterator pointer;
  typedef typename conditional<_IsConst, __bit_const_reference<_Cp>,
                               __bit_reference<_Cp>>::type reference;
  typedef random_access_iterator_tag iterator_category;

private:
  typedef typename _Cp::__storage_type __storage_type;
  typedef typename conditional<_IsConst, typename _Cp::__const_storage_pointer,
                               typename _Cp::__storage_pointer>::type
      __storage_pointer;
  static const unsigned __bits_per_word = _Cp::__bits_per_word;

  __storage_pointer __seg_;
  unsigned __ctz_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __bit_iterator() noexcept

      : __seg_(nullptr), __ctz_(0)

  {}

  using __type_for_copy_to_const =
      _If<_IsConst, __bit_iterator<_Cp, false>, struct __private_nat>;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __bit_iterator(const __type_for_copy_to_const &__it) noexcept
      : __seg_(__it.__seg_), __ctz_(__it.__ctz_) {}

  using __type_for_abi_non_trivial_copy_ctor =
      _If<!_IsConst, __bit_iterator, struct __private_nat>;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __bit_iterator(__type_for_abi_non_trivial_copy_ctor const &__it) noexcept
      : __seg_(__it.__seg_), __ctz_(__it.__ctz_) {}

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __bit_iterator &
  operator=(__bit_iterator const &) = default;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reference
  operator*() const noexcept {
    return reference(__seg_, __storage_type(1) << __ctz_);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __bit_iterator &
  operator++() {
    if (__ctz_ != __bits_per_word - 1)
      ++__ctz_;
    else {
      __ctz_ = 0;
      ++__seg_;
    }
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __bit_iterator
  operator++(int) {
    __bit_iterator __tmp = *this;
    ++(*this);
    return __tmp;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __bit_iterator &
  operator--() {
    if (__ctz_ != 0)
      --__ctz_;
    else {
      __ctz_ = __bits_per_word - 1;
      --__seg_;
    }
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __bit_iterator
  operator--(int) {
    __bit_iterator __tmp = *this;
    --(*this);
    return __tmp;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __bit_iterator &
  operator+=(difference_type __n) {
    if (__n >= 0)
      __seg_ += (__n + __ctz_) / __bits_per_word;
    else
      __seg_ +=
          static_cast<difference_type>(__n - __bits_per_word + __ctz_ + 1) /
          static_cast<difference_type>(__bits_per_word);
    __n &= (__bits_per_word - 1);
    __ctz_ = static_cast<unsigned>((__n + __ctz_) % __bits_per_word);
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __bit_iterator &
  operator-=(difference_type __n) {
    return *this += -__n;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __bit_iterator
  operator+(difference_type __n) const {
    __bit_iterator __t(*this);
    __t += __n;
    return __t;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __bit_iterator
  operator-(difference_type __n) const {
    __bit_iterator __t(*this);
    __t -= __n;
    return __t;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) friend __bit_iterator
  operator+(difference_type __n, const __bit_iterator &__it) {
    return __it + __n;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) friend difference_type
  operator-(const __bit_iterator &__x, const __bit_iterator &__y) {
    return (__x.__seg_ - __y.__seg_) * __bits_per_word + __x.__ctz_ -
           __y.__ctz_;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reference
  operator[](difference_type __n) const {
    return *(*this + __n);
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) friend bool
  operator==(const __bit_iterator &__x, const __bit_iterator &__y) {
    return __x.__seg_ == __y.__seg_ && __x.__ctz_ == __y.__ctz_;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) friend bool
  operator!=(const __bit_iterator &__x, const __bit_iterator &__y) {
    return !(__x == __y);
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) friend bool
  operator<(const __bit_iterator &__x, const __bit_iterator &__y) {
    return __x.__seg_ < __y.__seg_ ||
           (__x.__seg_ == __y.__seg_ && __x.__ctz_ < __y.__ctz_);
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) friend bool
  operator>(const __bit_iterator &__x, const __bit_iterator &__y) {
    return __y < __x;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) friend bool
  operator<=(const __bit_iterator &__x, const __bit_iterator &__y) {
    return !(__y < __x);
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) friend bool
  operator>=(const __bit_iterator &__x, const __bit_iterator &__y) {
    return !(__x < __y);
  }

private:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __bit_iterator(__storage_pointer __s, unsigned __ctz) noexcept
      : __seg_(__s), __ctz_(__ctz) {}

  friend typename _Cp::__self;

  friend class __bit_reference<_Cp>;
  friend class __bit_const_reference<_Cp>;
  friend class __bit_iterator<_Cp, true>;
  template <class _Dp> friend struct __bit_array;
  template <class _Dp>
  friend void __fill_n_false(__bit_iterator<_Dp, false> __first,
                             typename _Dp::size_type __n);
  template <class _Dp>
  friend void __fill_n_true(__bit_iterator<_Dp, false> __first,
                            typename _Dp::size_type __n);
  template <class _Dp, bool _IC>
  friend __bit_iterator<_Dp, false>
  __copy_aligned(__bit_iterator<_Dp, _IC> __first,
                 __bit_iterator<_Dp, _IC> __last,
                 __bit_iterator<_Dp, false> __result);
  template <class _Dp, bool _IC>
  friend __bit_iterator<_Dp, false>
  __copy_unaligned(__bit_iterator<_Dp, _IC> __first,
                   __bit_iterator<_Dp, _IC> __last,
                   __bit_iterator<_Dp, false> __result);
  template <class _Dp, bool _IC>
  friend __bit_iterator<_Dp, false> copy(__bit_iterator<_Dp, _IC> __first,
                                         __bit_iterator<_Dp, _IC> __last,
                                         __bit_iterator<_Dp, false> __result);
  template <class _Dp, bool _IC>
  friend __bit_iterator<_Dp, false>
  __copy_backward_aligned(__bit_iterator<_Dp, _IC> __first,
                          __bit_iterator<_Dp, _IC> __last,
                          __bit_iterator<_Dp, false> __result);
  template <class _Dp, bool _IC>
  friend __bit_iterator<_Dp, false>
  __copy_backward_unaligned(__bit_iterator<_Dp, _IC> __first,
                            __bit_iterator<_Dp, _IC> __last,
                            __bit_iterator<_Dp, false> __result);
  template <class _Dp, bool _IC>
  friend __bit_iterator<_Dp, false>
  copy_backward(__bit_iterator<_Dp, _IC> __first,
                __bit_iterator<_Dp, _IC> __last,
                __bit_iterator<_Dp, false> __result);
  template <class __C1, class __C2>
  friend __bit_iterator<__C2, false>
      __swap_ranges_aligned(__bit_iterator<__C1, false>,
                            __bit_iterator<__C1, false>,
                            __bit_iterator<__C2, false>);
  template <class __C1, class __C2>
  friend __bit_iterator<__C2, false>
      __swap_ranges_unaligned(__bit_iterator<__C1, false>,
                              __bit_iterator<__C1, false>,
                              __bit_iterator<__C2, false>);
  template <class __C1, class __C2>
  friend __bit_iterator<__C2, false> swap_ranges(__bit_iterator<__C1, false>,
                                                 __bit_iterator<__C1, false>,
                                                 __bit_iterator<__C2, false>);
  template <class _Dp>
  friend __bit_iterator<_Dp, false> rotate(__bit_iterator<_Dp, false>,
                                           __bit_iterator<_Dp, false>,
                                           __bit_iterator<_Dp, false>);
  template <class _Dp, bool _IC1, bool _IC2>
  friend bool __equal_aligned(__bit_iterator<_Dp, _IC1>,
                              __bit_iterator<_Dp, _IC1>,
                              __bit_iterator<_Dp, _IC2>);
  template <class _Dp, bool _IC1, bool _IC2>
  friend bool __equal_unaligned(__bit_iterator<_Dp, _IC1>,
                                __bit_iterator<_Dp, _IC1>,
                                __bit_iterator<_Dp, _IC2>);
  template <class _Dp, bool _IC1, bool _IC2>
  friend bool equal(__bit_iterator<_Dp, _IC1>, __bit_iterator<_Dp, _IC1>,
                    __bit_iterator<_Dp, _IC2>);
  template <class _Dp, bool _IC>
  friend __bit_iterator<_Dp, _IC> __find_bool_true(__bit_iterator<_Dp, _IC>,
                                                   typename _Dp::size_type);
  template <class _Dp, bool _IC>
  friend __bit_iterator<_Dp, _IC> __find_bool_false(__bit_iterator<_Dp, _IC>,
                                                    typename _Dp::size_type);
  template <class _Dp, bool _IC>
  friend typename __bit_iterator<_Dp, _IC>::difference_type
      __count_bool_true(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
  template <class _Dp, bool _IC>
  friend typename __bit_iterator<_Dp, _IC>::difference_type
      __count_bool_false(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
};

} // namespace __1
} // namespace std
# 275 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/vector" 2 3
# 284 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/vector" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__split_buffer" 1 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 6 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__split_buffer" 2 3
# 11 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__split_buffer" 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_macros" 1 3
# 15 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__split_buffer" 2 3

namespace std {
inline namespace __1 {

template <bool> class __split_buffer_common {
protected:
  void __throw_length_error() const;
  void __throw_out_of_range() const;
};

template <class _Tp, class _Allocator = allocator<_Tp>>
struct __split_buffer : private __split_buffer_common<true> {
private:
  __split_buffer(const __split_buffer &);
  __split_buffer &operator=(const __split_buffer &);

public:
  typedef _Tp value_type;
  typedef _Allocator allocator_type;
  typedef typename remove_reference<allocator_type>::type __alloc_rr;
  typedef allocator_traits<__alloc_rr> __alloc_traits;
  typedef value_type &reference;
  typedef const value_type &const_reference;
  typedef typename __alloc_traits::size_type size_type;
  typedef typename __alloc_traits::difference_type difference_type;
  typedef typename __alloc_traits::pointer pointer;
  typedef typename __alloc_traits::const_pointer const_pointer;
  typedef pointer iterator;
  typedef const_pointer const_iterator;

  pointer __first_;
  pointer __begin_;
  pointer __end_;
  __compressed_pair<pointer, allocator_type> __end_cap_;

  typedef typename add_lvalue_reference<allocator_type>::type __alloc_ref;
  typedef typename add_lvalue_reference<allocator_type>::type __alloc_const_ref;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __alloc_rr &
  __alloc() noexcept {
    return __end_cap_.second();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const __alloc_rr &
  __alloc() const noexcept {
    return __end_cap_.second();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pointer &
  __end_cap() noexcept {
    return __end_cap_.first();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const pointer &
  __end_cap() const noexcept {
    return __end_cap_.first();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __split_buffer() noexcept(
      is_nothrow_default_constructible<allocator_type>::value);
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit __split_buffer(__alloc_rr &__a);
  __attribute__((__visibility__("hidden"))) __attribute__((
      internal_linkage)) explicit __split_buffer(const __alloc_rr &__a);
  __split_buffer(size_type __cap, size_type __start, __alloc_rr &__a);
  ~__split_buffer();

  __split_buffer(__split_buffer &&__c) noexcept(
      is_nothrow_move_constructible<allocator_type>::value);
  __split_buffer(__split_buffer &&__c, const __alloc_rr &__a);
  __split_buffer &operator=(__split_buffer &&__c) noexcept(
      (__alloc_traits::propagate_on_container_move_assignment::value &&
       is_nothrow_move_assignable<allocator_type>::value) ||
      !__alloc_traits::propagate_on_container_move_assignment::value);

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  begin() noexcept {
    return __begin_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_iterator
  begin() const noexcept {
    return __begin_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  end() noexcept {
    return __end_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_iterator
  end() const noexcept {
    return __end_;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  clear() noexcept {
    __destruct_at_end(__begin_);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  size() const {
    return static_cast<size_type>(__end_ - __begin_);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  empty() const {
    return __end_ == __begin_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  capacity() const {
    return static_cast<size_type>(__end_cap() - __first_);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  __front_spare() const {
    return static_cast<size_type>(__begin_ - __first_);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  __back_spare() const {
    return static_cast<size_type>(__end_cap() - __end_);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reference
  front() {
    return *__begin_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reference
  front() const {
    return *__begin_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reference
  back() {
    return *(__end_ - 1);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reference
  back() const {
    return *(__end_ - 1);
  }

  void reserve(size_type __n);
  void shrink_to_fit() noexcept;
  void push_front(const_reference __x);
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  push_back(const_reference __x);

  void push_front(value_type &&__x);
  void push_back(value_type &&__x);
  template <class... _Args> void emplace_back(_Args &&...__args);

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  pop_front() {
    __destruct_at_begin(__begin_ + 1);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  pop_back() {
    __destruct_at_end(__end_ - 1);
  }

  void __construct_at_end(size_type __n);
  void __construct_at_end(size_type __n, const_reference __x);
  template <class _InputIter>
  typename enable_if<__is_cpp17_input_iterator<_InputIter>::value &&
                         !__is_cpp17_forward_iterator<_InputIter>::value,
                     void>::type
  __construct_at_end(_InputIter __first, _InputIter __last);
  template <class _ForwardIterator>
  typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value,
                     void>::type
  __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __destruct_at_begin(pointer __new_begin) {
    __destruct_at_begin(__new_begin, is_trivially_destructible<value_type>());
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __destruct_at_begin(pointer __new_begin, false_type);
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __destruct_at_begin(pointer __new_begin, true_type);

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __destruct_at_end(pointer __new_last) noexcept {
    __destruct_at_end(__new_last, false_type());
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __destruct_at_end(pointer __new_last, false_type) noexcept;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __destruct_at_end(pointer __new_last, true_type) noexcept;

  void swap(__split_buffer &__x) noexcept(
      !__alloc_traits::propagate_on_container_swap::value ||
      __is_nothrow_swappable<__alloc_rr>::value);

  bool __invariants() const;

private:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __move_assign_alloc(__split_buffer &__c, true_type) noexcept(
      is_nothrow_move_assignable<allocator_type>::value) {
    __alloc() = std::__1::move(__c.__alloc());
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __move_assign_alloc(__split_buffer &, false_type) noexcept {}

  struct _ConstructTransaction {
    explicit _ConstructTransaction(pointer *__p, size_type __n) noexcept
        : __pos_(*__p), __end_(*__p + __n), __dest_(__p) {}
    ~_ConstructTransaction() { *__dest_ = __pos_; }
    pointer __pos_;
    const pointer __end_;

  private:
    pointer *__dest_;
  };
};

template <class _Tp, class _Allocator>
bool __split_buffer<_Tp, _Allocator>::__invariants() const {
  if (__first_ == nullptr) {
    if (__begin_ != nullptr)
      return false;
    if (__end_ != nullptr)
      return false;
    if (__end_cap() != nullptr)
      return false;
  } else {
    if (__begin_ < __first_)
      return false;
    if (__end_ < __begin_)
      return false;
    if (__end_cap() < __end_)
      return false;
  }
  return true;
}

template <class _Tp, class _Allocator>
void __split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n) {
  _ConstructTransaction __tx(&this->__end_, __n);
  for (; __tx.__pos_ != __tx.__end_; ++__tx.__pos_) {
    __alloc_traits::construct(this->__alloc(),
                              std::__1::__to_address(__tx.__pos_));
  }
}

template <class _Tp, class _Allocator>
void __split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n,
                                                         const_reference __x) {
  _ConstructTransaction __tx(&this->__end_, __n);
  for (; __tx.__pos_ != __tx.__end_; ++__tx.__pos_) {
    __alloc_traits::construct(this->__alloc(),
                              std::__1::__to_address(__tx.__pos_), __x);
  }
}

template <class _Tp, class _Allocator>
template <class _InputIter>
typename enable_if<__is_cpp17_input_iterator<_InputIter>::value &&
                       !__is_cpp17_forward_iterator<_InputIter>::value,
                   void>::type
__split_buffer<_Tp, _Allocator>::__construct_at_end(_InputIter __first,
                                                    _InputIter __last) {
  __alloc_rr &__a = this->__alloc();
  for (; __first != __last; ++__first) {
    if (__end_ == __end_cap()) {
      size_type __old_cap = __end_cap() - __first_;
      size_type __new_cap = std::__1::max<size_type>(2 * __old_cap, 8);
      __split_buffer __buf(__new_cap, 0, __a);
      for (pointer __p = __begin_; __p != __end_; ++__p, ++__buf.__end_)
        __alloc_traits::construct(__buf.__alloc(),
                                  std::__1::__to_address(__buf.__end_),
                                  std::__1::move(*__p));
      swap(__buf);
    }
    __alloc_traits::construct(__a, std::__1::__to_address(this->__end_),
                              *__first);
    ++this->__end_;
  }
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value,
                   void>::type
__split_buffer<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first,
                                                    _ForwardIterator __last) {
  _ConstructTransaction __tx(&this->__end_, std::distance(__first, __last));
  for (; __tx.__pos_ != __tx.__end_; ++__tx.__pos_, ++__first) {
    __alloc_traits::construct(this->__alloc(),
                              std::__1::__to_address(__tx.__pos_), *__first);
  }
}

template <class _Tp, class _Allocator>
inline void
__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin,
                                                     false_type) {
  while (__begin_ != __new_begin)
    __alloc_traits::destroy(__alloc(), __to_address(__begin_++));
}

template <class _Tp, class _Allocator>
inline void
__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin,
                                                     true_type) {
  __begin_ = __new_begin;
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last,
                                                   false_type) noexcept {
  while (__new_last != __end_)
    __alloc_traits::destroy(__alloc(), __to_address(--__end_));
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last,
                                                   true_type) noexcept {
  __end_ = __new_last;
}

template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator>::__split_buffer(size_type __cap,
                                                size_type __start,
                                                __alloc_rr &__a)
    : __end_cap_(nullptr, __a) {
  __first_ = __cap != 0 ? __alloc_traits::allocate(__alloc(), __cap) : nullptr;
  __begin_ = __end_ = __first_ + __start;
  __end_cap() = __first_ + __cap;
}

template <class _Tp, class _Allocator>
inline __split_buffer<_Tp, _Allocator>::__split_buffer() noexcept(
    is_nothrow_default_constructible<allocator_type>::value)
    : __first_(nullptr), __begin_(nullptr), __end_(nullptr),
      __end_cap_(nullptr, __default_init_tag()) {}

template <class _Tp, class _Allocator>
inline __split_buffer<_Tp, _Allocator>::__split_buffer(__alloc_rr &__a)
    : __first_(nullptr), __begin_(nullptr), __end_(nullptr),
      __end_cap_(nullptr, __a) {}

template <class _Tp, class _Allocator>
inline __split_buffer<_Tp, _Allocator>::__split_buffer(const __alloc_rr &__a)
    : __first_(nullptr), __begin_(nullptr), __end_(nullptr),
      __end_cap_(nullptr, __a) {}

template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator>::~__split_buffer() {
  clear();
  if (__first_)
    __alloc_traits::deallocate(__alloc(), __first_, capacity());
}

template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer &&__c) noexcept(
    is_nothrow_move_constructible<allocator_type>::value)
    : __first_(std::__1::move(__c.__first_)),
      __begin_(std::__1::move(__c.__begin_)),
      __end_(std::__1::move(__c.__end_)),
      __end_cap_(std::__1::move(__c.__end_cap_)) {
  __c.__first_ = nullptr;
  __c.__begin_ = nullptr;
  __c.__end_ = nullptr;
  __c.__end_cap() = nullptr;
}

template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer &&__c,
                                                const __alloc_rr &__a)
    : __end_cap_(nullptr, __a) {
  if (__a == __c.__alloc()) {
    __first_ = __c.__first_;
    __begin_ = __c.__begin_;
    __end_ = __c.__end_;
    __end_cap() = __c.__end_cap();
    __c.__first_ = nullptr;
    __c.__begin_ = nullptr;
    __c.__end_ = nullptr;
    __c.__end_cap() = nullptr;
  } else {
    size_type __cap = __c.size();
    __first_ = __alloc_traits::allocate(__alloc(), __cap);
    __begin_ = __end_ = __first_;
    __end_cap() = __first_ + __cap;
    typedef move_iterator<iterator> _Ip;
    __construct_at_end(_Ip(__c.begin()), _Ip(__c.end()));
  }
}

template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator> &
__split_buffer<_Tp, _Allocator>::operator=(__split_buffer &&__c) noexcept(
    (__alloc_traits::propagate_on_container_move_assignment::value &&
     is_nothrow_move_assignable<allocator_type>::value) ||
    !__alloc_traits::propagate_on_container_move_assignment::value)

{
  clear();
  shrink_to_fit();
  __first_ = __c.__first_;
  __begin_ = __c.__begin_;
  __end_ = __c.__end_;
  __end_cap() = __c.__end_cap();
  __move_assign_alloc(
      __c,
      integral_constant<
          bool,
          __alloc_traits::propagate_on_container_move_assignment::value>());
  __c.__first_ = __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;
  return *this;
}

template <class _Tp, class _Allocator>
void __split_buffer<_Tp, _Allocator>::swap(__split_buffer &__x) noexcept(
    !__alloc_traits::propagate_on_container_swap::value ||
    __is_nothrow_swappable<__alloc_rr>::value)

{
  std::__1::swap(__first_, __x.__first_);
  std::__1::swap(__begin_, __x.__begin_);
  std::__1::swap(__end_, __x.__end_);
  std::__1::swap(__end_cap(), __x.__end_cap());
  __swap_allocator(__alloc(), __x.__alloc());
}

template <class _Tp, class _Allocator>
void __split_buffer<_Tp, _Allocator>::reserve(size_type __n) {
  if (__n < capacity()) {
    __split_buffer<value_type, __alloc_rr &> __t(__n, 0, __alloc());
    __t.__construct_at_end(move_iterator<pointer>(__begin_),
                           move_iterator<pointer>(__end_));
    std::__1::swap(__first_, __t.__first_);
    std::__1::swap(__begin_, __t.__begin_);
    std::__1::swap(__end_, __t.__end_);
    std::__1::swap(__end_cap(), __t.__end_cap());
  }
}

template <class _Tp, class _Allocator>
void __split_buffer<_Tp, _Allocator>::shrink_to_fit() noexcept {
  if (capacity() > size()) {

    try {

      __split_buffer<value_type, __alloc_rr &> __t(size(), 0, __alloc());
      __t.__construct_at_end(move_iterator<pointer>(__begin_),
                             move_iterator<pointer>(__end_));
      __t.__end_ = __t.__begin_ + (__end_ - __begin_);
      std::__1::swap(__first_, __t.__first_);
      std::__1::swap(__begin_, __t.__begin_);
      std::__1::swap(__end_, __t.__end_);
      std::__1::swap(__end_cap(), __t.__end_cap());

    } catch (...) {
    }
  }
}

template <class _Tp, class _Allocator>
void __split_buffer<_Tp, _Allocator>::push_front(const_reference __x) {
  if (__begin_ == __first_) {
    if (__end_ < __end_cap()) {
      difference_type __d = __end_cap() - __end_;
      __d = (__d + 1) / 2;
      __begin_ = std::__1::move_backward(__begin_, __end_, __end_ + __d);
      __end_ += __d;
    } else {
      size_type __c =
          max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
      __split_buffer<value_type, __alloc_rr &> __t(__c, (__c + 3) / 4,
                                                   __alloc());
      __t.__construct_at_end(move_iterator<pointer>(__begin_),
                             move_iterator<pointer>(__end_));
      std::__1::swap(__first_, __t.__first_);
      std::__1::swap(__begin_, __t.__begin_);
      std::__1::swap(__end_, __t.__end_);
      std::__1::swap(__end_cap(), __t.__end_cap());
    }
  }
  __alloc_traits::construct(__alloc(), std::__1::__to_address(__begin_ - 1),
                            __x);
  --__begin_;
}

template <class _Tp, class _Allocator>
void __split_buffer<_Tp, _Allocator>::push_front(value_type &&__x) {
  if (__begin_ == __first_) {
    if (__end_ < __end_cap()) {
      difference_type __d = __end_cap() - __end_;
      __d = (__d + 1) / 2;
      __begin_ = std::__1::move_backward(__begin_, __end_, __end_ + __d);
      __end_ += __d;
    } else {
      size_type __c =
          max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
      __split_buffer<value_type, __alloc_rr &> __t(__c, (__c + 3) / 4,
                                                   __alloc());
      __t.__construct_at_end(move_iterator<pointer>(__begin_),
                             move_iterator<pointer>(__end_));
      std::__1::swap(__first_, __t.__first_);
      std::__1::swap(__begin_, __t.__begin_);
      std::__1::swap(__end_, __t.__end_);
      std::__1::swap(__end_cap(), __t.__end_cap());
    }
  }
  __alloc_traits::construct(__alloc(), std::__1::__to_address(__begin_ - 1),
                            std::__1::move(__x));
  --__begin_;
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
__split_buffer<_Tp, _Allocator>::push_back(const_reference __x) {
  if (__end_ == __end_cap()) {
    if (__begin_ > __first_) {
      difference_type __d = __begin_ - __first_;
      __d = (__d + 1) / 2;
      __end_ = std::__1::move(__begin_, __end_, __begin_ - __d);
      __begin_ -= __d;
    } else {
      size_type __c =
          max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
      __split_buffer<value_type, __alloc_rr &> __t(__c, __c / 4, __alloc());
      __t.__construct_at_end(move_iterator<pointer>(__begin_),
                             move_iterator<pointer>(__end_));
      std::__1::swap(__first_, __t.__first_);
      std::__1::swap(__begin_, __t.__begin_);
      std::__1::swap(__end_, __t.__end_);
      std::__1::swap(__end_cap(), __t.__end_cap());
    }
  }
  __alloc_traits::construct(__alloc(), std::__1::__to_address(__end_), __x);
  ++__end_;
}

template <class _Tp, class _Allocator>
void __split_buffer<_Tp, _Allocator>::push_back(value_type &&__x) {
  if (__end_ == __end_cap()) {
    if (__begin_ > __first_) {
      difference_type __d = __begin_ - __first_;
      __d = (__d + 1) / 2;
      __end_ = std::__1::move(__begin_, __end_, __begin_ - __d);
      __begin_ -= __d;
    } else {
      size_type __c =
          max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
      __split_buffer<value_type, __alloc_rr &> __t(__c, __c / 4, __alloc());
      __t.__construct_at_end(move_iterator<pointer>(__begin_),
                             move_iterator<pointer>(__end_));
      std::__1::swap(__first_, __t.__first_);
      std::__1::swap(__begin_, __t.__begin_);
      std::__1::swap(__end_, __t.__end_);
      std::__1::swap(__end_cap(), __t.__end_cap());
    }
  }
  __alloc_traits::construct(__alloc(), std::__1::__to_address(__end_),
                            std::__1::move(__x));
  ++__end_;
}

template <class _Tp, class _Allocator>
template <class... _Args>
void __split_buffer<_Tp, _Allocator>::emplace_back(_Args &&...__args) {
  if (__end_ == __end_cap()) {
    if (__begin_ > __first_) {
      difference_type __d = __begin_ - __first_;
      __d = (__d + 1) / 2;
      __end_ = std::__1::move(__begin_, __end_, __begin_ - __d);
      __begin_ -= __d;
    } else {
      size_type __c =
          max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
      __split_buffer<value_type, __alloc_rr &> __t(__c, __c / 4, __alloc());
      __t.__construct_at_end(move_iterator<pointer>(__begin_),
                             move_iterator<pointer>(__end_));
      std::__1::swap(__first_, __t.__first_);
      std::__1::swap(__begin_, __t.__begin_);
      std::__1::swap(__end_, __t.__end_);
      std::__1::swap(__end_cap(), __t.__end_cap());
    }
  }
  __alloc_traits::construct(__alloc(), std::__1::__to_address(__end_),
                            std::__1::forward<_Args>(__args)...);
  ++__end_;
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
swap(__split_buffer<_Tp, _Allocator> &__x,
     __split_buffer<_Tp, _Allocator> &__y) noexcept(noexcept(__x.swap(__y))) {
  __x.swap(__y);
}

} // namespace __1
} // namespace std
# 285 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/vector" 2 3
# 291 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/vector" 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_macros" 1 3
# 295 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/vector" 2 3

namespace std {
inline namespace __1 {

template <bool>
class __attribute__((__type_visibility__("default"))) __vector_base_common {
protected:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __vector_base_common() {}
  [[noreturn]] void __throw_length_error() const;
  [[noreturn]] void __throw_out_of_range() const;
};

template <bool __b>
void __vector_base_common<__b>::__throw_length_error() const {
  std::__1::__throw_length_error("vector");
}

template <bool __b>
void __vector_base_common<__b>::__throw_out_of_range() const {
  std::__1::__throw_out_of_range("vector");
}

extern template class __attribute__((__visibility__("default")))
__vector_base_common<true>;

template <class _Tp, class _Allocator>
class __vector_base : protected __vector_base_common<true> {
public:
  typedef _Allocator allocator_type;
  typedef allocator_traits<allocator_type> __alloc_traits;
  typedef typename __alloc_traits::size_type size_type;

protected:
  typedef _Tp value_type;
  typedef value_type &reference;
  typedef const value_type &const_reference;
  typedef typename __alloc_traits::difference_type difference_type;
  typedef typename __alloc_traits::pointer pointer;
  typedef typename __alloc_traits::const_pointer const_pointer;
  typedef pointer iterator;
  typedef const_pointer const_iterator;

  pointer __begin_;
  pointer __end_;
  __compressed_pair<pointer, allocator_type> __end_cap_;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  allocator_type &
  __alloc() noexcept {
    return __end_cap_.second();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const allocator_type &
  __alloc() const noexcept {
    return __end_cap_.second();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pointer &
  __end_cap() noexcept {
    return __end_cap_.first();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const pointer &
  __end_cap() const noexcept {
    return __end_cap_.first();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __vector_base() noexcept(
      is_nothrow_default_constructible<allocator_type>::value);
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __vector_base(const allocator_type &__a);

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __vector_base(allocator_type &&__a) noexcept;

  ~__vector_base();

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  clear() noexcept {
    __destruct_at_end(__begin_);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  capacity() const noexcept {
    return static_cast<size_type>(__end_cap() - __begin_);
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __destruct_at_end(pointer __new_last) noexcept;

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __copy_assign_alloc(const __vector_base &__c) {
    __copy_assign_alloc(
        __c,
        integral_constant<
            bool,
            __alloc_traits::propagate_on_container_copy_assignment::value>());
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __move_assign_alloc(__vector_base &__c) noexcept(
      !__alloc_traits::propagate_on_container_move_assignment::value ||
      is_nothrow_move_assignable<allocator_type>::value)

  {
    __move_assign_alloc(
        __c,
        integral_constant<
            bool,
            __alloc_traits::propagate_on_container_move_assignment::value>());
  }

private:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __copy_assign_alloc(const __vector_base &__c, true_type) {
    if (__alloc() != __c.__alloc()) {
      clear();
      __alloc_traits::deallocate(__alloc(), __begin_, capacity());
      __begin_ = __end_ = __end_cap() = nullptr;
    }
    __alloc() = __c.__alloc();
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __copy_assign_alloc(const __vector_base &, false_type) {}

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __move_assign_alloc(__vector_base &__c, true_type) noexcept(
      is_nothrow_move_assignable<allocator_type>::value) {
    __alloc() = std::__1::move(__c.__alloc());
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __move_assign_alloc(__vector_base &, false_type) noexcept {}
};

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
__vector_base<_Tp, _Allocator>::__destruct_at_end(pointer __new_last) noexcept {
  pointer __soon_to_be_end = __end_;
  while (__new_last != __soon_to_be_end)
    __alloc_traits::destroy(__alloc(),
                            std::__1::__to_address(--__soon_to_be_end));
  __end_ = __new_last;
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
__vector_base<_Tp, _Allocator>::__vector_base() noexcept(
    is_nothrow_default_constructible<allocator_type>::value)
    : __begin_(nullptr), __end_(nullptr),
      __end_cap_(nullptr, __default_init_tag()) {}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
__vector_base<_Tp, _Allocator>::__vector_base(const allocator_type &__a)
    : __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a) {}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
__vector_base<_Tp, _Allocator>::__vector_base(allocator_type &&__a) noexcept
    : __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, std::move(__a)) {}

template <class _Tp, class _Allocator>
__vector_base<_Tp, _Allocator>::~__vector_base() {
  if (__begin_ != nullptr) {
    clear();
    __alloc_traits::deallocate(__alloc(), __begin_, capacity());
  }
}

template <class _Tp, class _Allocator>
class __attribute__((__type_visibility__("default"))) vector
    : private __vector_base<_Tp, _Allocator> {
private:
  typedef __vector_base<_Tp, _Allocator> __base;
  typedef allocator<_Tp> __default_allocator_type;

public:
  typedef vector __self;
  typedef _Tp value_type;
  typedef _Allocator allocator_type;
  typedef typename __base::__alloc_traits __alloc_traits;
  typedef typename __base::reference reference;
  typedef typename __base::const_reference const_reference;
  typedef typename __base::size_type size_type;
  typedef typename __base::difference_type difference_type;
  typedef typename __base::pointer pointer;
  typedef typename __base::const_pointer const_pointer;
  typedef __wrap_iter<pointer> iterator;
  typedef __wrap_iter<const_pointer> const_iterator;
  typedef std::__1::reverse_iterator<iterator> reverse_iterator;
  typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

  static_assert(
      (is_same<typename allocator_type::value_type, value_type>::value),
      "Allocator::value_type must be same type as value_type");

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  vector() noexcept(is_nothrow_default_constructible<allocator_type>::value) {}
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit vector(const allocator_type &__a)

      noexcept(is_nothrow_copy_constructible<allocator_type>::value)

      : __base(__a) {}
  explicit vector(size_type __n);

  explicit vector(size_type __n, const allocator_type &__a);

  vector(size_type __n, const value_type &__x);
  vector(size_type __n, const value_type &__x, const allocator_type &__a);
  template <class _InputIterator>
  vector(
      _InputIterator __first,
      typename enable_if<
          __is_cpp17_input_iterator<_InputIterator>::value &&
              !__is_cpp17_forward_iterator<_InputIterator>::value &&
              is_constructible<
                  value_type,
                  typename iterator_traits<_InputIterator>::reference>::value,
          _InputIterator>::type __last);
  template <class _InputIterator>
  vector(
      _InputIterator __first, _InputIterator __last, const allocator_type &__a,
      typename enable_if<
          __is_cpp17_input_iterator<_InputIterator>::value &&
          !__is_cpp17_forward_iterator<_InputIterator>::value &&
          is_constructible<value_type,
                           typename iterator_traits<
                               _InputIterator>::reference>::value>::type * = 0);
  template <class _ForwardIterator>
  vector(
      _ForwardIterator __first,
      typename enable_if<
          __is_cpp17_forward_iterator<_ForwardIterator>::value &&
              is_constructible<
                  value_type,
                  typename iterator_traits<_ForwardIterator>::reference>::value,
          _ForwardIterator>::type __last);
  template <class _ForwardIterator>
  vector(_ForwardIterator __first, _ForwardIterator __last,
         const allocator_type &__a,
         typename enable_if<
             __is_cpp17_forward_iterator<_ForwardIterator>::value &&
             is_constructible<value_type,
                              typename iterator_traits<_ForwardIterator>::
                                  reference>::value>::type * = 0);

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) ~vector() {
    __annotate_delete();
  }

  vector(const vector &__x);
  vector(const vector &__x, const allocator_type &__a);
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  vector &
  operator=(const vector &__x);

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  vector(initializer_list<value_type> __il);

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  vector(initializer_list<value_type> __il, const allocator_type &__a);

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  vector(vector &&__x)

      noexcept(is_nothrow_move_constructible<allocator_type>::value);

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  vector(vector &&__x, const allocator_type &__a);
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  vector &
  operator=(vector &&__x) noexcept(
      (__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  vector &
  operator=(initializer_list<value_type> __il) {
    assign(__il.begin(), __il.end());
    return *this;
  }

  template <class _InputIterator>
  typename enable_if<
      __is_cpp17_input_iterator<_InputIterator>::value &&
          !__is_cpp17_forward_iterator<_InputIterator>::value &&
          is_constructible<value_type, typename iterator_traits<
                                           _InputIterator>::reference>::value,
      void>::type
  assign(_InputIterator __first, _InputIterator __last);
  template <class _ForwardIterator>
  typename enable_if<
      __is_cpp17_forward_iterator<_ForwardIterator>::value &&
          is_constructible<value_type, typename iterator_traits<
                                           _ForwardIterator>::reference>::value,
      void>::type
  assign(_ForwardIterator __first, _ForwardIterator __last);

  void assign(size_type __n, const_reference __u);

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  assign(initializer_list<value_type> __il) {
    assign(__il.begin(), __il.end());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  allocator_type
  get_allocator() const noexcept {
    return this->__alloc();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  begin() noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_iterator
  begin() const noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  end() noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_iterator
  end() const noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reverse_iterator
  rbegin() noexcept {
    return reverse_iterator(end());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reverse_iterator
  rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reverse_iterator
  rend() noexcept {
    return reverse_iterator(begin());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reverse_iterator
  rend() const noexcept {
    return const_reverse_iterator(begin());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_iterator
  cbegin() const noexcept {
    return begin();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_iterator
  cend() const noexcept {
    return end();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reverse_iterator
  crbegin() const noexcept {
    return rbegin();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reverse_iterator
  crend() const noexcept {
    return rend();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  size() const noexcept {
    return static_cast<size_type>(this->__end_ - this->__begin_);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  capacity() const noexcept {
    return __base::capacity();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  empty() const noexcept {
    return this->__begin_ == this->__end_;
  }
  size_type max_size() const noexcept;
  void reserve(size_type __n);
  void shrink_to_fit() noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reference
  operator[](size_type __n) noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reference
  operator[](size_type __n) const noexcept;
  reference at(size_type __n);
  const_reference at(size_type __n) const;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reference
  front() noexcept {
    ((void)0);
    return *this->__begin_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reference
  front() const noexcept {
    ((void)0);
    return *this->__begin_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reference
  back() noexcept {
    ((void)0);
    return *(this->__end_ - 1);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reference
  back() const noexcept {
    ((void)0);
    return *(this->__end_ - 1);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  value_type *
  data() noexcept {
    return std::__1::__to_address(this->__begin_);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const value_type *
  data() const noexcept {
    return std::__1::__to_address(this->__begin_);
  }

  template <class _Arg>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __emplace_back(_Arg &&__arg) {
    emplace_back(std::__1::forward<_Arg>(__arg));
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  push_back(const_reference __x);

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  push_back(value_type &&__x);

  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))

  void
  emplace_back(_Args &&...__args);

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  pop_back();

  iterator insert(const_iterator __position, const_reference __x);

  iterator insert(const_iterator __position, value_type &&__x);
  template <class... _Args>
  iterator emplace(const_iterator __position, _Args &&...__args);

  iterator insert(const_iterator __position, size_type __n,
                  const_reference __x);
  template <class _InputIterator>
  typename enable_if<
      __is_cpp17_input_iterator<_InputIterator>::value &&
          !__is_cpp17_forward_iterator<_InputIterator>::value &&
          is_constructible<value_type, typename iterator_traits<
                                           _InputIterator>::reference>::value,
      iterator>::type
  insert(const_iterator __position, _InputIterator __first,
         _InputIterator __last);
  template <class _ForwardIterator>
  typename enable_if<
      __is_cpp17_forward_iterator<_ForwardIterator>::value &&
          is_constructible<value_type, typename iterator_traits<
                                           _ForwardIterator>::reference>::value,
      iterator>::type
  insert(const_iterator __position, _ForwardIterator __first,
         _ForwardIterator __last);

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  insert(const_iterator __position, initializer_list<value_type> __il) {
    return insert(__position, __il.begin(), __il.end());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  erase(const_iterator __position);
  iterator erase(const_iterator __first, const_iterator __last);

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  clear() noexcept {
    size_type __old_size = size();
    __base::clear();
    __annotate_shrink(__old_size);
    __invalidate_all_iterators();
  }

  void resize(size_type __sz);
  void resize(size_type __sz, const_reference __x);

  void swap(vector &)

      noexcept;

  bool __invariants() const;
# 799 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/vector" 3
private:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __invalidate_all_iterators();
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __invalidate_iterators_past(pointer __new_last);
  void __vallocate(size_type __n);
  void __vdeallocate() noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  __recommend(size_type __new_size) const;
  void __construct_at_end(size_type __n);
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __construct_at_end(size_type __n, const_reference __x);
  template <class _ForwardIterator>
  typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value,
                     void>::type
  __construct_at_end(_ForwardIterator __first, _ForwardIterator __last,
                     size_type __n);
  void __append(size_type __n);
  void __append(size_type __n, const_reference __x);
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  __make_iter(pointer __p) noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_iterator
  __make_iter(const_pointer __p) const noexcept;
  void
  __swap_out_circular_buffer(__split_buffer<value_type, allocator_type &> &__v);
  pointer
  __swap_out_circular_buffer(__split_buffer<value_type, allocator_type &> &__v,
                             pointer __p);
  void __move_range(pointer __from_s, pointer __from_e, pointer __to);
  void __move_assign(vector &__c, true_type) noexcept(
      is_nothrow_move_assignable<allocator_type>::value);
  void
  __move_assign(vector &__c,
                false_type) noexcept(__alloc_traits::is_always_equal::value);
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __destruct_at_end(pointer __new_last) noexcept {
    __invalidate_iterators_past(__new_last);
    size_type __old_size = size();
    __base::__destruct_at_end(__new_last);
    __annotate_shrink(__old_size);
  }

  template <class _Up>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) inline void
  __push_back_slow_path(_Up &&__x);

  template <class... _Args>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) inline void
  __emplace_back_slow_path(_Args &&...__args);
# 865 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/vector" 3
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __annotate_contiguous_container(const void *, const void *, const void *,
                                  const void *) const noexcept {}

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __annotate_new(size_type __current_size) const noexcept {
    __annotate_contiguous_container(data(), data() + capacity(),
                                    data() + capacity(),
                                    data() + __current_size);
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __annotate_delete() const noexcept {
    __annotate_contiguous_container(data(), data() + capacity(),
                                    data() + size(), data() + capacity());
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __annotate_increase(size_type __n) const noexcept {
    __annotate_contiguous_container(data(), data() + capacity(),
                                    data() + size(), data() + size() + __n);
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __annotate_shrink(size_type __old_size) const noexcept {
    __annotate_contiguous_container(data(), data() + capacity(),
                                    data() + __old_size, data() + size());
  }

  struct _ConstructTransaction {
    explicit _ConstructTransaction(vector &__v, size_type __n)
        : __v_(__v), __pos_(__v.__end_), __new_end_(__v.__end_ + __n) {}
    ~_ConstructTransaction() { __v_.__end_ = __pos_; }

    vector &__v_;
    pointer __pos_;
    const_pointer const __new_end_;

  private:
    _ConstructTransaction(_ConstructTransaction const &) = delete;
    _ConstructTransaction &operator=(_ConstructTransaction const &) = delete;
  };

  template <class... _Args>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __construct_one_at_end(_Args &&...__args) {
    _ConstructTransaction __tx(*this, 1);
    __alloc_traits::construct(this->__alloc(),
                              std::__1::__to_address(__tx.__pos_),
                              std::__1::forward<_Args>(__args)...);
    ++__tx.__pos_;
  }
};
# 946 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/vector" 3
template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::__swap_out_circular_buffer(
    __split_buffer<value_type, allocator_type &> &__v) {

  __annotate_delete();
  __alloc_traits::__construct_backward_with_exception_guarantees(
      this->__alloc(), this->__begin_, this->__end_, __v.__begin_);
  std::__1::swap(this->__begin_, __v.__begin_);
  std::__1::swap(this->__end_, __v.__end_);
  std::__1::swap(this->__end_cap(), __v.__end_cap());
  __v.__first_ = __v.__begin_;
  __annotate_new(size());
  __invalidate_all_iterators();
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::pointer
vector<_Tp, _Allocator>::__swap_out_circular_buffer(
    __split_buffer<value_type, allocator_type &> &__v, pointer __p) {
  __annotate_delete();
  pointer __r = __v.__begin_;
  __alloc_traits::__construct_backward_with_exception_guarantees(
      this->__alloc(), this->__begin_, __p, __v.__begin_);
  __alloc_traits::__construct_forward_with_exception_guarantees(
      this->__alloc(), __p, this->__end_, __v.__end_);
  std::__1::swap(this->__begin_, __v.__begin_);
  std::__1::swap(this->__end_, __v.__end_);
  std::__1::swap(this->__end_cap(), __v.__end_cap());
  __v.__first_ = __v.__begin_;
  __annotate_new(size());
  __invalidate_all_iterators();
  return __r;
}
# 988 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/vector" 3
template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::__vallocate(size_type __n) {
  if (__n > max_size())
    this->__throw_length_error();
  this->__begin_ = this->__end_ =
      __alloc_traits::allocate(this->__alloc(), __n);
  this->__end_cap() = this->__begin_ + __n;
  __annotate_new(0);
}

template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::__vdeallocate() noexcept {
  if (this->__begin_ != nullptr) {
    clear();
    __alloc_traits::deallocate(this->__alloc(), this->__begin_, capacity());
    this->__begin_ = this->__end_ = this->__end_cap() = nullptr;
  }
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::size_type
vector<_Tp, _Allocator>::max_size() const noexcept {
  return std::__1::min<size_type>(__alloc_traits::max_size(this->__alloc()),
                                  numeric_limits<difference_type>::max());
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) typename vector<_Tp, _Allocator>::size_type
vector<_Tp, _Allocator>::__recommend(size_type __new_size) const {
  const size_type __ms = max_size();
  if (__new_size > __ms)
    this->__throw_length_error();
  const size_type __cap = capacity();
  if (__cap >= __ms / 2)
    return __ms;
  return std::__1::max<size_type>(2 * __cap, __new_size);
}

template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::__construct_at_end(size_type __n) {
  _ConstructTransaction __tx(*this, __n);
  for (; __tx.__pos_ != __tx.__new_end_; ++__tx.__pos_) {
    __alloc_traits::construct(this->__alloc(),
                              std::__1::__to_address(__tx.__pos_));
  }
}

template <class _Tp, class _Allocator>
inline void vector<_Tp, _Allocator>::__construct_at_end(size_type __n,
                                                        const_reference __x) {
  _ConstructTransaction __tx(*this, __n);
  for (; __tx.__pos_ != __tx.__new_end_; ++__tx.__pos_) {
    __alloc_traits::construct(this->__alloc(),
                              std::__1::__to_address(__tx.__pos_), __x);
  }
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value,
                   void>::type
vector<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first,
                                            _ForwardIterator __last,
                                            size_type __n) {
  _ConstructTransaction __tx(*this, __n);
  __alloc_traits::__construct_range_forward(this->__alloc(), __first, __last,
                                            __tx.__pos_);
}

template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::__append(size_type __n) {
  if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)
    this->__construct_at_end(__n);
  else {
    allocator_type &__a = this->__alloc();
    __split_buffer<value_type, allocator_type &> __v(__recommend(size() + __n),
                                                     size(), __a);
    __v.__construct_at_end(__n);
    __swap_out_circular_buffer(__v);
  }
}

template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::__append(size_type __n, const_reference __x) {
  if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)
    this->__construct_at_end(__n, __x);
  else {
    allocator_type &__a = this->__alloc();
    __split_buffer<value_type, allocator_type &> __v(__recommend(size() + __n),
                                                     size(), __a);
    __v.__construct_at_end(__n, __x);
    __swap_out_circular_buffer(__v);
  }
}

template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(size_type __n) {

  if (__n > 0) {
    __vallocate(__n);
    __construct_at_end(__n);
  }
}

template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(size_type __n, const allocator_type &__a)
    : __base(__a) {

  if (__n > 0) {
    __vallocate(__n);
    __construct_at_end(__n);
  }
}

template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(size_type __n, const value_type &__x) {

  if (__n > 0) {
    __vallocate(__n);
    __construct_at_end(__n, __x);
  }
}

template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(size_type __n, const value_type &__x,
                                const allocator_type &__a)
    : __base(__a) {

  if (__n > 0) {
    __vallocate(__n);
    __construct_at_end(__n, __x);
  }
}

template <class _Tp, class _Allocator>
template <class _InputIterator>
vector<_Tp, _Allocator>::vector(
    _InputIterator __first,
    typename enable_if<
        __is_cpp17_input_iterator<_InputIterator>::value &&
            !__is_cpp17_forward_iterator<_InputIterator>::value &&
            is_constructible<value_type, typename iterator_traits<
                                             _InputIterator>::reference>::value,
        _InputIterator>::type __last) {

  for (; __first != __last; ++__first)
    __emplace_back(*__first);
}

template <class _Tp, class _Allocator>
template <class _InputIterator>
vector<_Tp, _Allocator>::vector(
    _InputIterator __first, _InputIterator __last, const allocator_type &__a,
    typename enable_if<
        __is_cpp17_input_iterator<_InputIterator>::value &&
        !__is_cpp17_forward_iterator<_InputIterator>::value &&
        is_constructible<value_type, typename iterator_traits<_InputIterator>::
                                         reference>::value>::type *)
    : __base(__a) {

  for (; __first != __last; ++__first)
    __emplace_back(*__first);
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
vector<_Tp, _Allocator>::vector(
    _ForwardIterator __first,
    typename enable_if<
        __is_cpp17_forward_iterator<_ForwardIterator>::value &&
            is_constructible<
                value_type,
                typename iterator_traits<_ForwardIterator>::reference>::value,
        _ForwardIterator>::type __last) {

  size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
  if (__n > 0) {
    __vallocate(__n);
    __construct_at_end(__first, __last, __n);
  }
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
vector<_Tp, _Allocator>::vector(
    _ForwardIterator __first, _ForwardIterator __last,
    const allocator_type &__a,
    typename enable_if<
        __is_cpp17_forward_iterator<_ForwardIterator>::value &&
        is_constructible<
            value_type,
            typename iterator_traits<_ForwardIterator>::reference>::value>::type
        *)
    : __base(__a) {

  size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
  if (__n > 0) {
    __vallocate(__n);
    __construct_at_end(__first, __last, __n);
  }
}

template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(const vector &__x)
    : __base(__alloc_traits::select_on_container_copy_construction(
          __x.__alloc())) {

  size_type __n = __x.size();
  if (__n > 0) {
    __vallocate(__n);
    __construct_at_end(__x.__begin_, __x.__end_, __n);
  }
}

template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(const vector &__x, const allocator_type &__a)
    : __base(__a) {

  size_type __n = __x.size();
  if (__n > 0) {
    __vallocate(__n);
    __construct_at_end(__x.__begin_, __x.__end_, __n);
  }
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) vector<_Tp, _Allocator>::vector(vector &&__x)

    noexcept(is_nothrow_move_constructible<allocator_type>::value)

    : __base(std::__1::move(__x.__alloc())) {

  this->__begin_ = __x.__begin_;
  this->__end_ = __x.__end_;
  this->__end_cap() = __x.__end_cap();
  __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
vector<_Tp, _Allocator>::vector(vector &&__x, const allocator_type &__a)
    : __base(__a) {

  if (__a == __x.__alloc()) {
    this->__begin_ = __x.__begin_;
    this->__end_ = __x.__end_;
    this->__end_cap() = __x.__end_cap();
    __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;

  } else {
    typedef move_iterator<iterator> _Ip;
    assign(_Ip(__x.begin()), _Ip(__x.end()));
  }
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
vector<_Tp, _Allocator>::vector(initializer_list<value_type> __il) {

  if (__il.size() > 0) {
    __vallocate(__il.size());
    __construct_at_end(__il.begin(), __il.end(), __il.size());
  }
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
vector<_Tp, _Allocator>::vector(initializer_list<value_type> __il,
                                const allocator_type &__a)
    : __base(__a) {

  if (__il.size() > 0) {
    __vallocate(__il.size());
    __construct_at_end(__il.begin(), __il.end(), __il.size());
  }
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) vector<_Tp, _Allocator> &
vector<_Tp, _Allocator>::operator=(vector &&__x) noexcept(
    (__noexcept_move_assign_container<_Allocator, __alloc_traits>::value)) {
  __move_assign(
      __x,
      integral_constant<
          bool,
          __alloc_traits::propagate_on_container_move_assignment::value>());
  return *this;
}

template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::__move_assign(vector &__c, false_type) noexcept(
    __alloc_traits::is_always_equal::value) {
  if (__base::__alloc() != __c.__alloc()) {
    typedef move_iterator<iterator> _Ip;
    assign(_Ip(__c.begin()), _Ip(__c.end()));
  } else
    __move_assign(__c, true_type());
}

template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::__move_assign(vector &__c, true_type) noexcept(
    is_nothrow_move_assignable<allocator_type>::value) {
  __vdeallocate();
  __base::__move_assign_alloc(__c);
  this->__begin_ = __c.__begin_;
  this->__end_ = __c.__end_;
  this->__end_cap() = __c.__end_cap();
  __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) vector<_Tp, _Allocator> &
vector<_Tp, _Allocator>::operator=(const vector &__x) {
  if (this != &__x) {
    __base::__copy_assign_alloc(__x);
    assign(__x.__begin_, __x.__end_);
  }
  return *this;
}

template <class _Tp, class _Allocator>
template <class _InputIterator>
typename enable_if<
    __is_cpp17_input_iterator<_InputIterator>::value &&
        !__is_cpp17_forward_iterator<_InputIterator>::value &&
        is_constructible<
            _Tp, typename iterator_traits<_InputIterator>::reference>::value,
    void>::type
vector<_Tp, _Allocator>::assign(_InputIterator __first, _InputIterator __last) {
  clear();
  for (; __first != __last; ++__first)
    __emplace_back(*__first);
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename enable_if<
    __is_cpp17_forward_iterator<_ForwardIterator>::value &&
        is_constructible<
            _Tp, typename iterator_traits<_ForwardIterator>::reference>::value,
    void>::type
vector<_Tp, _Allocator>::assign(_ForwardIterator __first,
                                _ForwardIterator __last) {
  size_type __new_size =
      static_cast<size_type>(std::__1::distance(__first, __last));
  if (__new_size <= capacity()) {
    _ForwardIterator __mid = __last;
    bool __growing = false;
    if (__new_size > size()) {
      __growing = true;
      __mid = __first;
      std::__1::advance(__mid, size());
    }
    pointer __m = std::__1::copy(__first, __mid, this->__begin_);
    if (__growing)
      __construct_at_end(__mid, __last, __new_size - size());
    else
      this->__destruct_at_end(__m);
  } else {
    __vdeallocate();
    __vallocate(__recommend(__new_size));
    __construct_at_end(__first, __last, __new_size);
  }
  __invalidate_all_iterators();
}

template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::assign(size_type __n, const_reference __u) {
  if (__n <= capacity()) {
    size_type __s = size();
    std::__1::fill_n(this->__begin_, std::__1::min(__n, __s), __u);
    if (__n > __s)
      __construct_at_end(__n - __s, __u);
    else
      this->__destruct_at_end(this->__begin_ + __n);
  } else {
    __vdeallocate();
    __vallocate(__recommend(static_cast<size_type>(__n)));
    __construct_at_end(__n, __u);
  }
  __invalidate_all_iterators();
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::__make_iter(pointer __p) noexcept {

  return iterator(__p);
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename vector<_Tp, _Allocator>::const_iterator
vector<_Tp, _Allocator>::__make_iter(const_pointer __p) const noexcept {

  return const_iterator(__p);
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::begin() noexcept {
  return __make_iter(this->__begin_);
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename vector<_Tp, _Allocator>::const_iterator
vector<_Tp, _Allocator>::begin() const noexcept {
  return __make_iter(this->__begin_);
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::end() noexcept {
  return __make_iter(this->__end_);
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename vector<_Tp, _Allocator>::const_iterator
vector<_Tp, _Allocator>::end() const noexcept {
  return __make_iter(this->__end_);
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) typename vector<_Tp, _Allocator>::reference
vector<_Tp, _Allocator>::operator[](size_type __n) noexcept {
  ((void)0);
  return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
typename vector<_Tp, _Allocator>::const_reference
vector<_Tp, _Allocator>::operator[](size_type __n) const noexcept {
  ((void)0);
  return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::reference
vector<_Tp, _Allocator>::at(size_type __n) {
  if (__n >= size())
    this->__throw_out_of_range();
  return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::const_reference
vector<_Tp, _Allocator>::at(size_type __n) const {
  if (__n >= size())
    this->__throw_out_of_range();
  return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::reserve(size_type __n) {
  if (__n > capacity()) {
    allocator_type &__a = this->__alloc();
    __split_buffer<value_type, allocator_type &> __v(__n, size(), __a);
    __swap_out_circular_buffer(__v);
  }
}

template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::shrink_to_fit() noexcept {
  if (capacity() > size()) {

    try {

      allocator_type &__a = this->__alloc();
      __split_buffer<value_type, allocator_type &> __v(size(), size(), __a);
      __swap_out_circular_buffer(__v);

    } catch (...) {
    }
  }
}

template <class _Tp, class _Allocator>
template <class _Up>
void

vector<_Tp, _Allocator>::__push_back_slow_path(_Up&& __x)



{
  allocator_type &__a = this->__alloc();
  __split_buffer<value_type, allocator_type &> __v(__recommend(size() + 1),
                                                   size(), __a);

  __alloc_traits::construct(__a, std::__1::__to_address(__v.__end_),
                            std::__1::forward<_Up>(__x));
  __v.__end_++;
  __swap_out_circular_buffer(__v);
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
vector<_Tp, _Allocator>::push_back(const_reference __x) {
  if (this->__end_ != this->__end_cap()) {
    __construct_one_at_end(__x);
  } else
    __push_back_slow_path(__x);
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
vector<_Tp, _Allocator>::push_back(value_type &&__x) {
  if (this->__end_ < this->__end_cap()) {
    __construct_one_at_end(std::__1::move(__x));
  } else
    __push_back_slow_path(std::__1::move(__x));
}

template <class _Tp, class _Allocator>
template <class... _Args>
void vector<_Tp, _Allocator>::__emplace_back_slow_path(_Args &&...__args) {
  allocator_type &__a = this->__alloc();
  __split_buffer<value_type, allocator_type &> __v(__recommend(size() + 1),
                                                   size(), __a);

  __alloc_traits::construct(__a, std::__1::__to_address(__v.__end_),
                            std::__1::forward<_Args>(__args)...);
  __v.__end_++;
  __swap_out_circular_buffer(__v);
}

template <class _Tp, class _Allocator>
template <class... _Args>
inline

    void

    vector<_Tp, _Allocator>::emplace_back(_Args &&...__args) {
  if (this->__end_ < this->__end_cap()) {
    __construct_one_at_end(std::__1::forward<_Args>(__args)...);
  } else
    __emplace_back_slow_path(std::__1::forward<_Args>(__args)...);
}

template <class _Tp, class _Allocator>
inline void vector<_Tp, _Allocator>::pop_back() {
  ((void)0);
  this->__destruct_at_end(this->__end_ - 1);
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::erase(const_iterator __position) {

  ((void)0);

  difference_type __ps = __position - cbegin();
  pointer __p = this->__begin_ + __ps;
  this->__destruct_at_end(std::__1::move(__p + 1, this->__end_, __p));
  this->__invalidate_iterators_past(__p - 1);
  iterator __r = __make_iter(__p);
  return __r;
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::erase(const_iterator __first, const_iterator __last) {
# 1735 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/vector" 3
  ((void)0);
  pointer __p = this->__begin_ + (__first - begin());
  if (__first != __last) {
    this->__destruct_at_end(
        std::__1::move(__p + (__last - __first), this->__end_, __p));
    this->__invalidate_iterators_past(__p - 1);
  }
  iterator __r = __make_iter(__p);
  return __r;
}

template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::__move_range(pointer __from_s, pointer __from_e,
                                           pointer __to) {
  pointer __old_last = this->__end_;
  difference_type __n = __old_last - __to;
  {
    pointer __i = __from_s + __n;
    _ConstructTransaction __tx(*this, __from_e - __i);
    for (; __i < __from_e; ++__i, ++__tx.__pos_) {
      __alloc_traits::construct(this->__alloc(),
                                std::__1::__to_address(__tx.__pos_),
                                std::__1::move(*__i));
    }
  }
  std::__1::move_backward(__from_s, __from_s + __n, __old_last);
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::insert(const_iterator __position,
                                const_reference __x) {

  pointer __p = this->__begin_ + (__position - begin());
  if (this->__end_ < this->__end_cap()) {
    if (__p == this->__end_) {
      __construct_one_at_end(__x);
    } else {
      __move_range(__p, this->__end_, __p + 1);
      const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);
      if (__p <= __xr && __xr < this->__end_)
        ++__xr;
      *__p = *__xr;
    }
  } else {
    allocator_type &__a = this->__alloc();
    __split_buffer<value_type, allocator_type &> __v(__recommend(size() + 1),
                                                     __p - this->__begin_, __a);
    __v.push_back(__x);
    __p = __swap_out_circular_buffer(__v, __p);
  }
  return __make_iter(__p);
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::insert(const_iterator __position, value_type &&__x) {

  pointer __p = this->__begin_ + (__position - begin());
  if (this->__end_ < this->__end_cap()) {
    if (__p == this->__end_) {
      __construct_one_at_end(std::__1::move(__x));
    } else {
      __move_range(__p, this->__end_, __p + 1);
      *__p = std::__1::move(__x);
    }
  } else {
    allocator_type &__a = this->__alloc();
    __split_buffer<value_type, allocator_type &> __v(__recommend(size() + 1),
                                                     __p - this->__begin_, __a);
    __v.push_back(std::__1::move(__x));
    __p = __swap_out_circular_buffer(__v, __p);
  }
  return __make_iter(__p);
}

template <class _Tp, class _Allocator>
template <class... _Args>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::emplace(const_iterator __position, _Args &&...__args) {

  pointer __p = this->__begin_ + (__position - begin());
  if (this->__end_ < this->__end_cap()) {
    if (__p == this->__end_) {
      __construct_one_at_end(std::__1::forward<_Args>(__args)...);
    } else {
      __temp_value<value_type, _Allocator> __tmp(
          this->__alloc(), std::__1::forward<_Args>(__args)...);
      __move_range(__p, this->__end_, __p + 1);
      *__p = std::__1::move(__tmp.get());
    }
  } else {
    allocator_type &__a = this->__alloc();
    __split_buffer<value_type, allocator_type &> __v(__recommend(size() + 1),
                                                     __p - this->__begin_, __a);
    __v.emplace_back(std::__1::forward<_Args>(__args)...);
    __p = __swap_out_circular_buffer(__v, __p);
  }
  return __make_iter(__p);
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::insert(const_iterator __position, size_type __n,
                                const_reference __x) {

  pointer __p = this->__begin_ + (__position - begin());
  if (__n > 0) {
    if (__n <= static_cast<size_type>(this->__end_cap() - this->__end_)) {
      size_type __old_n = __n;
      pointer __old_last = this->__end_;
      if (__n > static_cast<size_type>(this->__end_ - __p)) {
        size_type __cx = __n - (this->__end_ - __p);
        __construct_at_end(__cx, __x);
        __n -= __cx;
      }
      if (__n > 0) {
        __move_range(__p, __old_last, __p + __old_n);
        const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);
        if (__p <= __xr && __xr < this->__end_)
          __xr += __old_n;
        std::__1::fill_n(__p, __n, *__xr);
      }
    } else {
      allocator_type &__a = this->__alloc();
      __split_buffer<value_type, allocator_type &> __v(
          __recommend(size() + __n), __p - this->__begin_, __a);
      __v.__construct_at_end(__n, __x);
      __p = __swap_out_circular_buffer(__v, __p);
    }
  }
  return __make_iter(__p);
}

template <class _Tp, class _Allocator>
template <class _InputIterator>
typename enable_if<
    __is_cpp17_input_iterator<_InputIterator>::value &&
        !__is_cpp17_forward_iterator<_InputIterator>::value &&
        is_constructible<
            _Tp, typename iterator_traits<_InputIterator>::reference>::value,
    typename vector<_Tp, _Allocator>::iterator>::type
vector<_Tp, _Allocator>::insert(const_iterator __position,
                                _InputIterator __first, _InputIterator __last) {

  difference_type __off = __position - begin();
  pointer __p = this->__begin_ + __off;
  allocator_type &__a = this->__alloc();
  pointer __old_last = this->__end_;
  for (; this->__end_ != this->__end_cap() && __first != __last; ++__first) {
    __construct_one_at_end(*__first);
  }
  __split_buffer<value_type, allocator_type &> __v(__a);
  if (__first != __last) {

    try {

      __v.__construct_at_end(__first, __last);
      difference_type __old_size = __old_last - this->__begin_;
      difference_type __old_p = __p - this->__begin_;
      reserve(__recommend(size() + __v.size()));
      __p = this->__begin_ + __old_p;
      __old_last = this->__begin_ + __old_size;

    } catch (...) {
      erase(__make_iter(__old_last), end());
      throw;
    }
  }
  __p = std::__1::rotate(__p, __old_last, this->__end_);
  insert(__make_iter(__p), make_move_iterator(__v.begin()),
         make_move_iterator(__v.end()));
  return begin() + __off;
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename enable_if<
    __is_cpp17_forward_iterator<_ForwardIterator>::value &&
        is_constructible<
            _Tp, typename iterator_traits<_ForwardIterator>::reference>::value,
    typename vector<_Tp, _Allocator>::iterator>::type
vector<_Tp, _Allocator>::insert(const_iterator __position,
                                _ForwardIterator __first,
                                _ForwardIterator __last) {

  pointer __p = this->__begin_ + (__position - begin());
  difference_type __n = std::__1::distance(__first, __last);
  if (__n > 0) {
    if (__n <= this->__end_cap() - this->__end_) {
      size_type __old_n = __n;
      pointer __old_last = this->__end_;
      _ForwardIterator __m = __last;
      difference_type __dx = this->__end_ - __p;
      if (__n > __dx) {
        __m = __first;
        difference_type __diff = this->__end_ - __p;
        std::__1::advance(__m, __diff);
        __construct_at_end(__m, __last, __n - __diff);
        __n = __dx;
      }
      if (__n > 0) {
        __move_range(__p, __old_last, __p + __old_n);
        std::__1::copy(__first, __m, __p);
      }
    } else {
      allocator_type &__a = this->__alloc();
      __split_buffer<value_type, allocator_type &> __v(
          __recommend(size() + __n), __p - this->__begin_, __a);
      __v.__construct_at_end(__first, __last);
      __p = __swap_out_circular_buffer(__v, __p);
    }
  }
  return __make_iter(__p);
}

template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::resize(size_type __sz) {
  size_type __cs = size();
  if (__cs < __sz)
    this->__append(__sz - __cs);
  else if (__cs > __sz)
    this->__destruct_at_end(this->__begin_ + __sz);
}

template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::resize(size_type __sz, const_reference __x) {
  size_type __cs = size();
  if (__cs < __sz)
    this->__append(__sz - __cs, __x);
  else if (__cs > __sz)
    this->__destruct_at_end(this->__begin_ + __sz);
}

template <class _Tp, class _Allocator>
void vector<_Tp, _Allocator>::swap(vector &__x)

    noexcept

{
  ((void)0);

  std::__1::swap(this->__begin_, __x.__begin_);
  std::__1::swap(this->__end_, __x.__end_);
  std::__1::swap(this->__end_cap(), __x.__end_cap());
  __swap_allocator(
      this->__alloc(), __x.__alloc(),
      integral_constant<bool,
                        __alloc_traits::propagate_on_container_swap::value>());
}

template <class _Tp, class _Allocator>
bool vector<_Tp, _Allocator>::__invariants() const {
  if (this->__begin_ == nullptr) {
    if (this->__end_ != nullptr || this->__end_cap() != nullptr)
      return false;
  } else {
    if (this->__begin_ > this->__end_)
      return false;
    if (this->__begin_ == this->__end_cap())
      return false;
    if (this->__end_ > this->__end_cap())
      return false;
  }
  return true;
}
# 2117 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/vector" 3
template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
vector<_Tp, _Allocator>::__invalidate_all_iterators() {}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
vector<_Tp, _Allocator>::__invalidate_iterators_past(pointer __new_last) {
# 2145 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/vector" 3
  ((void)__new_last);
}

template <class _Allocator> class vector<bool, _Allocator>;

template <class _Allocator> struct hash<vector<bool, _Allocator>>;

template <class _Allocator>
struct __has_storage_type<vector<bool, _Allocator>> {
  static const bool value = true;
};

template <class _Allocator>
class __attribute__((__type_visibility__("default")))
vector<bool, _Allocator> : private __vector_base_common<true> {
public:
  typedef vector __self;
  typedef bool value_type;
  typedef _Allocator allocator_type;
  typedef allocator_traits<allocator_type> __alloc_traits;
  typedef typename __alloc_traits::size_type size_type;
  typedef typename __alloc_traits::difference_type difference_type;
  typedef size_type __storage_type;
  typedef __bit_iterator<vector, false> pointer;
  typedef __bit_iterator<vector, true> const_pointer;
  typedef pointer iterator;
  typedef const_pointer const_iterator;
  typedef std::__1::reverse_iterator<iterator> reverse_iterator;
  typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

private:
  typedef typename __rebind_alloc_helper<__alloc_traits, __storage_type>::type
      __storage_allocator;
  typedef allocator_traits<__storage_allocator> __storage_traits;
  typedef typename __storage_traits::pointer __storage_pointer;
  typedef typename __storage_traits::const_pointer __const_storage_pointer;

  __storage_pointer __begin_;
  size_type __size_;
  __compressed_pair<size_type, __storage_allocator> __cap_alloc_;

public:
  typedef __bit_reference<vector> reference;
  typedef __bit_const_reference<vector> const_reference;

private:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type &
  __cap() noexcept {
    return __cap_alloc_.first();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const size_type &
  __cap() const noexcept {
    return __cap_alloc_.first();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __storage_allocator &
  __alloc() noexcept {
    return __cap_alloc_.second();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const __storage_allocator &
  __alloc() const noexcept {
    return __cap_alloc_.second();
  }

  static const unsigned __bits_per_word =
      static_cast<unsigned>(sizeof(__storage_type) * 8);

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static size_type
  __internal_cap_to_external(size_type __n) noexcept {
    return __n * __bits_per_word;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static size_type
  __external_cap_to_internal(size_type __n) noexcept {
    return (__n - 1) / __bits_per_word + 1;
  }

public:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  vector() noexcept(is_nothrow_default_constructible<allocator_type>::value);

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit vector(const allocator_type &__a)

      noexcept(is_nothrow_copy_constructible<allocator_type>::value);

  ~vector();
  explicit vector(size_type __n);

  explicit vector(size_type __n, const allocator_type &__a);

  vector(size_type __n, const value_type &__v);
  vector(size_type __n, const value_type &__v, const allocator_type &__a);
  template <class _InputIterator>
  vector(_InputIterator __first, _InputIterator __last,
         typename enable_if<
             __is_cpp17_input_iterator<_InputIterator>::value &&
             !__is_cpp17_forward_iterator<_InputIterator>::value>::type * = 0);
  template <class _InputIterator>
  vector(_InputIterator __first, _InputIterator __last,
         const allocator_type &__a,
         typename enable_if<
             __is_cpp17_input_iterator<_InputIterator>::value &&
             !__is_cpp17_forward_iterator<_InputIterator>::value>::type * = 0);
  template <class _ForwardIterator>
  vector(_ForwardIterator __first, _ForwardIterator __last,
         typename enable_if<
             __is_cpp17_forward_iterator<_ForwardIterator>::value>::type * = 0);
  template <class _ForwardIterator>
  vector(_ForwardIterator __first, _ForwardIterator __last,
         const allocator_type &__a,
         typename enable_if<
             __is_cpp17_forward_iterator<_ForwardIterator>::value>::type * = 0);

  vector(const vector &__v);
  vector(const vector &__v, const allocator_type &__a);
  vector &operator=(const vector &__v);

  vector(initializer_list<value_type> __il);
  vector(initializer_list<value_type> __il, const allocator_type &__a);

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  vector(vector &&__v)

      noexcept(is_nothrow_move_constructible<allocator_type>::value);

  vector(vector &&__v, const allocator_type &__a);
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  vector &
  operator=(vector &&__v) noexcept(
      (__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  vector &
  operator=(initializer_list<value_type> __il) {
    assign(__il.begin(), __il.end());
    return *this;
  }

  template <class _InputIterator>
  typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value &&
                         !__is_cpp17_forward_iterator<_InputIterator>::value,
                     void>::type
  assign(_InputIterator __first, _InputIterator __last);
  template <class _ForwardIterator>
  typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value,
                     void>::type
  assign(_ForwardIterator __first, _ForwardIterator __last);

  void assign(size_type __n, const value_type &__x);

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  assign(initializer_list<value_type> __il) {
    assign(__il.begin(), __il.end());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  allocator_type
  get_allocator() const noexcept {
    return allocator_type(this->__alloc());
  }

  size_type max_size() const noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  capacity() const noexcept {
    return __internal_cap_to_external(__cap());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  size() const noexcept {
    return __size_;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  empty() const noexcept {
    return __size_ == 0;
  }
  void reserve(size_type __n);
  void shrink_to_fit() noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  begin() noexcept {
    return __make_iter(0);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_iterator
  begin() const noexcept {
    return __make_iter(0);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  end() noexcept {
    return __make_iter(__size_);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_iterator
  end() const noexcept {
    return __make_iter(__size_);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reverse_iterator
  rbegin() noexcept {
    return reverse_iterator(end());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reverse_iterator
  rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reverse_iterator
  rend() noexcept {
    return reverse_iterator(begin());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reverse_iterator
  rend() const noexcept {
    return const_reverse_iterator(begin());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_iterator
  cbegin() const noexcept {
    return __make_iter(0);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_iterator
  cend() const noexcept {
    return __make_iter(__size_);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reverse_iterator
  crbegin() const noexcept {
    return rbegin();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reverse_iterator
  crend() const noexcept {
    return rend();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reference
  operator[](size_type __n) {
    return __make_ref(__n);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reference
  operator[](size_type __n) const {
    return __make_ref(__n);
  }
  reference at(size_type __n);
  const_reference at(size_type __n) const;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reference
  front() {
    return __make_ref(0);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reference
  front() const {
    return __make_ref(0);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reference
  back() {
    return __make_ref(__size_ - 1);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reference
  back() const {
    return __make_ref(__size_ - 1);
  }

  void push_back(const value_type &__x);

  template <class... _Args>

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  emplace_back(_Args &&...__args)

  {
    push_back(value_type(std::__1::forward<_Args>(__args)...));
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  pop_back() {
    --__size_;
  }

  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  emplace(const_iterator position, _Args &&...__args) {
    return insert(position, value_type(std::__1::forward<_Args>(__args)...));
  }

  iterator insert(const_iterator __position, const value_type &__x);
  iterator insert(const_iterator __position, size_type __n,
                  const value_type &__x);
  iterator insert(const_iterator __position, size_type __n,
                  const_reference __x);
  template <class _InputIterator>
  typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value &&
                         !__is_cpp17_forward_iterator<_InputIterator>::value,
                     iterator>::type
  insert(const_iterator __position, _InputIterator __first,
         _InputIterator __last);
  template <class _ForwardIterator>
  typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value,
                     iterator>::type
  insert(const_iterator __position, _ForwardIterator __first,
         _ForwardIterator __last);

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  insert(const_iterator __position, initializer_list<value_type> __il) {
    return insert(__position, __il.begin(), __il.end());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  erase(const_iterator __position);
  iterator erase(const_iterator __first, const_iterator __last);

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  clear() noexcept {
    __size_ = 0;
  }

  void swap(vector &)

      noexcept;

  static void swap(reference __x, reference __y) noexcept {
    std::__1::swap(__x, __y);
  }

  void resize(size_type __sz, value_type __x = false);
  void flip() noexcept;

  bool __invariants() const;

private:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __invalidate_all_iterators();
  void __vallocate(size_type __n);
  void __vdeallocate() noexcept;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static size_type
  __align_it(size_type __new_size) noexcept {
    return __new_size + (__bits_per_word - 1) &
           ~((size_type)__bits_per_word - 1);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  __recommend(size_type __new_size) const;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __construct_at_end(size_type __n, bool __x);
  template <class _ForwardIterator>
  typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value,
                     void>::type
  __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);
  void __append(size_type __n, const_reference __x);
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reference
  __make_ref(size_type __pos) noexcept {
    return reference(__begin_ + __pos / __bits_per_word,
                     __storage_type(1) << __pos % __bits_per_word);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reference
  __make_ref(size_type __pos) const noexcept {
    return const_reference(__begin_ + __pos / __bits_per_word,
                           __storage_type(1) << __pos % __bits_per_word);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  __make_iter(size_type __pos) noexcept {
    return iterator(__begin_ + __pos / __bits_per_word,
                    static_cast<unsigned>(__pos % __bits_per_word));
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_iterator
  __make_iter(size_type __pos) const noexcept {
    return const_iterator(__begin_ + __pos / __bits_per_word,
                          static_cast<unsigned>(__pos % __bits_per_word));
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  __const_iterator_cast(const_iterator __p) noexcept {
    return begin() + (__p - cbegin());
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __copy_assign_alloc(const vector &__v) {
    __copy_assign_alloc(
        __v,
        integral_constant<
            bool,
            __storage_traits::propagate_on_container_copy_assignment::value>());
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __copy_assign_alloc(const vector &__c, true_type) {
    if (__alloc() != __c.__alloc())
      __vdeallocate();
    __alloc() = __c.__alloc();
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __copy_assign_alloc(const vector &, false_type) {}

  void __move_assign(vector &__c, false_type);
  void __move_assign(vector &__c, true_type) noexcept(
      is_nothrow_move_assignable<allocator_type>::value);
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __move_assign_alloc(vector &__c) noexcept(
      !__storage_traits::propagate_on_container_move_assignment::value ||
      is_nothrow_move_assignable<allocator_type>::value)

  {
    __move_assign_alloc(
        __c,
        integral_constant<
            bool,
            __storage_traits::propagate_on_container_move_assignment::value>());
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __move_assign_alloc(vector &__c, true_type) noexcept(
      is_nothrow_move_assignable<allocator_type>::value) {
    __alloc() = std::__1::move(__c.__alloc());
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __move_assign_alloc(vector &, false_type) noexcept {}

  size_t __hash_code() const noexcept;

  friend class __bit_reference<vector>;
  friend class __bit_const_reference<vector>;
  friend class __bit_iterator<vector, false>;
  friend class __bit_iterator<vector, true>;
  friend struct __bit_array<vector>;
  friend struct __attribute__((__type_visibility__("default"))) hash<vector>;
};

template <class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
vector<bool, _Allocator>::__invalidate_all_iterators() {}
# 2526 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/vector" 3
template <class _Allocator>
void vector<bool, _Allocator>::__vallocate(size_type __n) {
  if (__n > max_size())
    this->__throw_length_error();
  __n = __external_cap_to_internal(__n);
  this->__begin_ = __storage_traits::allocate(this->__alloc(), __n);
  this->__size_ = 0;
  this->__cap() = __n;
}

template <class _Allocator>
void vector<bool, _Allocator>::__vdeallocate() noexcept {
  if (this->__begin_ != nullptr) {
    __storage_traits::deallocate(this->__alloc(), this->__begin_, __cap());
    __invalidate_all_iterators();
    this->__begin_ = nullptr;
    this->__size_ = this->__cap() = 0;
  }
}

template <class _Allocator>
typename vector<bool, _Allocator>::size_type
vector<bool, _Allocator>::max_size() const noexcept {
  size_type __amax = __storage_traits::max_size(__alloc());
  size_type __nmax = numeric_limits<size_type>::max() / 2;
  if (__nmax / __bits_per_word <= __amax)
    return __nmax;
  return __internal_cap_to_external(__amax);
}

template <class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) typename vector<bool, _Allocator>::size_type
vector<bool, _Allocator>::__recommend(size_type __new_size) const {
  const size_type __ms = max_size();
  if (__new_size > __ms)
    this->__throw_length_error();
  const size_type __cap = capacity();
  if (__cap >= __ms / 2)
    return __ms;
  return std::__1::max(2 * __cap, __align_it(__new_size));
}

template <class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
vector<bool, _Allocator>::__construct_at_end(size_type __n, bool __x) {
  size_type __old_size = this->__size_;
  this->__size_ += __n;
  if (__old_size == 0 || ((__old_size - 1) / __bits_per_word) !=
                             ((this->__size_ - 1) / __bits_per_word)) {
    if (this->__size_ <= __bits_per_word)
      this->__begin_[0] = __storage_type(0);
    else
      this->__begin_[(this->__size_ - 1) / __bits_per_word] = __storage_type(0);
  }
  std::__1::fill_n(__make_iter(__old_size), __n, __x);
}

template <class _Allocator>
template <class _ForwardIterator>
typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value,
                   void>::type
vector<bool, _Allocator>::__construct_at_end(_ForwardIterator __first,
                                             _ForwardIterator __last) {
  size_type __old_size = this->__size_;
  this->__size_ += std::__1::distance(__first, __last);
  if (__old_size == 0 || ((__old_size - 1) / __bits_per_word) !=
                             ((this->__size_ - 1) / __bits_per_word)) {
    if (this->__size_ <= __bits_per_word)
      this->__begin_[0] = __storage_type(0);
    else
      this->__begin_[(this->__size_ - 1) / __bits_per_word] = __storage_type(0);
  }
  std::__1::copy(__first, __last, __make_iter(__old_size));
}

template <class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) vector<bool, _Allocator>::vector() noexcept(
    is_nothrow_default_constructible<allocator_type>::value)
    : __begin_(nullptr), __size_(0), __cap_alloc_(0, __default_init_tag()) {}

template <class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage))
vector<bool, _Allocator>::vector(const allocator_type &__a)

    noexcept(is_nothrow_copy_constructible<allocator_type>::value)

    : __begin_(nullptr), __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a)) {}

template <class _Allocator>
vector<bool, _Allocator>::vector(size_type __n)
    : __begin_(nullptr), __size_(0), __cap_alloc_(0, __default_init_tag()) {
  if (__n > 0) {
    __vallocate(__n);
    __construct_at_end(__n, false);
  }
}

template <class _Allocator>
vector<bool, _Allocator>::vector(size_type __n, const allocator_type &__a)
    : __begin_(nullptr), __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a)) {
  if (__n > 0) {
    __vallocate(__n);
    __construct_at_end(__n, false);
  }
}

template <class _Allocator>
vector<bool, _Allocator>::vector(size_type __n, const value_type &__x)
    : __begin_(nullptr), __size_(0), __cap_alloc_(0, __default_init_tag()) {
  if (__n > 0) {
    __vallocate(__n);
    __construct_at_end(__n, __x);
  }
}

template <class _Allocator>
vector<bool, _Allocator>::vector(size_type __n, const value_type &__x,
                                 const allocator_type &__a)
    : __begin_(nullptr), __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a)) {
  if (__n > 0) {
    __vallocate(__n);
    __construct_at_end(__n, __x);
  }
}

template <class _Allocator>
template <class _InputIterator>
vector<bool, _Allocator>::vector(
    _InputIterator __first, _InputIterator __last,
    typename enable_if<
        __is_cpp17_input_iterator<_InputIterator>::value &&
        !__is_cpp17_forward_iterator<_InputIterator>::value>::type *)
    : __begin_(nullptr), __size_(0), __cap_alloc_(0, __default_init_tag()) {

  try {

    for (; __first != __last; ++__first)
      push_back(*__first);

  } catch (...) {
    if (__begin_ != nullptr)
      __storage_traits::deallocate(__alloc(), __begin_, __cap());
    __invalidate_all_iterators();
    throw;
  }
}

template <class _Allocator>
template <class _InputIterator>
vector<bool, _Allocator>::vector(
    _InputIterator __first, _InputIterator __last, const allocator_type &__a,
    typename enable_if<
        __is_cpp17_input_iterator<_InputIterator>::value &&
        !__is_cpp17_forward_iterator<_InputIterator>::value>::type *)
    : __begin_(nullptr), __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a)) {

  try {

    for (; __first != __last; ++__first)
      push_back(*__first);

  } catch (...) {
    if (__begin_ != nullptr)
      __storage_traits::deallocate(__alloc(), __begin_, __cap());
    __invalidate_all_iterators();
    throw;
  }
}

template <class _Allocator>
template <class _ForwardIterator>
vector<bool, _Allocator>::vector(
    _ForwardIterator __first, _ForwardIterator __last,
    typename enable_if<
        __is_cpp17_forward_iterator<_ForwardIterator>::value>::type *)
    : __begin_(nullptr), __size_(0), __cap_alloc_(0, __default_init_tag()) {
  size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
  if (__n > 0) {
    __vallocate(__n);
    __construct_at_end(__first, __last);
  }
}

template <class _Allocator>
template <class _ForwardIterator>
vector<bool, _Allocator>::vector(
    _ForwardIterator __first, _ForwardIterator __last,
    const allocator_type &__a,
    typename enable_if<
        __is_cpp17_forward_iterator<_ForwardIterator>::value>::type *)
    : __begin_(nullptr), __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a)) {
  size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
  if (__n > 0) {
    __vallocate(__n);
    __construct_at_end(__first, __last);
  }
}

template <class _Allocator>
vector<bool, _Allocator>::vector(initializer_list<value_type> __il)
    : __begin_(nullptr), __size_(0), __cap_alloc_(0, __default_init_tag()) {
  size_type __n = static_cast<size_type>(__il.size());
  if (__n > 0) {
    __vallocate(__n);
    __construct_at_end(__il.begin(), __il.end());
  }
}

template <class _Allocator>
vector<bool, _Allocator>::vector(initializer_list<value_type> __il,
                                 const allocator_type &__a)
    : __begin_(nullptr), __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a)) {
  size_type __n = static_cast<size_type>(__il.size());
  if (__n > 0) {
    __vallocate(__n);
    __construct_at_end(__il.begin(), __il.end());
  }
}

template <class _Allocator> vector<bool, _Allocator>::~vector() {
  if (__begin_ != nullptr)
    __storage_traits::deallocate(__alloc(), __begin_, __cap());
  __invalidate_all_iterators();
}

template <class _Allocator>
vector<bool, _Allocator>::vector(const vector &__v)
    : __begin_(nullptr), __size_(0),
      __cap_alloc_(0, __storage_traits::select_on_container_copy_construction(
                          __v.__alloc())) {
  if (__v.size() > 0) {
    __vallocate(__v.size());
    __construct_at_end(__v.begin(), __v.end());
  }
}

template <class _Allocator>
vector<bool, _Allocator>::vector(const vector &__v, const allocator_type &__a)
    : __begin_(nullptr), __size_(0), __cap_alloc_(0, __a) {
  if (__v.size() > 0) {
    __vallocate(__v.size());
    __construct_at_end(__v.begin(), __v.end());
  }
}

template <class _Allocator>
vector<bool, _Allocator> &
vector<bool, _Allocator>::operator=(const vector &__v) {
  if (this != &__v) {
    __copy_assign_alloc(__v);
    if (__v.__size_) {
      if (__v.__size_ > capacity()) {
        __vdeallocate();
        __vallocate(__v.__size_);
      }
      std::__1::copy(__v.__begin_,
                     __v.__begin_ + __external_cap_to_internal(__v.__size_),
                     __begin_);
    }
    __size_ = __v.__size_;
  }
  return *this;
}

template <class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) vector<bool, _Allocator>::vector(vector &&__v)

    noexcept(is_nothrow_move_constructible<allocator_type>::value)

    : __begin_(__v.__begin_), __size_(__v.__size_),
      __cap_alloc_(std::move(__v.__cap_alloc_)) {
  __v.__begin_ = nullptr;
  __v.__size_ = 0;
  __v.__cap() = 0;
}

template <class _Allocator>
vector<bool, _Allocator>::vector(vector &&__v, const allocator_type &__a)
    : __begin_(nullptr), __size_(0), __cap_alloc_(0, __a) {
  if (__a == allocator_type(__v.__alloc())) {
    this->__begin_ = __v.__begin_;
    this->__size_ = __v.__size_;
    this->__cap() = __v.__cap();
    __v.__begin_ = nullptr;
    __v.__cap() = __v.__size_ = 0;
  } else if (__v.size() > 0) {
    __vallocate(__v.size());
    __construct_at_end(__v.begin(), __v.end());
  }
}

template <class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) vector<bool, _Allocator> &
vector<bool, _Allocator>::operator=(vector &&__v) noexcept(
    (__noexcept_move_assign_container<_Allocator, __alloc_traits>::value)) {
  __move_assign(
      __v,
      integral_constant<
          bool,
          __storage_traits::propagate_on_container_move_assignment::value>());
  return *this;
}

template <class _Allocator>
void vector<bool, _Allocator>::__move_assign(vector &__c, false_type) {
  if (__alloc() != __c.__alloc())
    assign(__c.begin(), __c.end());
  else
    __move_assign(__c, true_type());
}

template <class _Allocator>
void vector<bool, _Allocator>::__move_assign(vector &__c, true_type) noexcept(
    is_nothrow_move_assignable<allocator_type>::value) {
  __vdeallocate();
  __move_assign_alloc(__c);
  this->__begin_ = __c.__begin_;
  this->__size_ = __c.__size_;
  this->__cap() = __c.__cap();
  __c.__begin_ = nullptr;
  __c.__cap() = __c.__size_ = 0;
}

template <class _Allocator>
void vector<bool, _Allocator>::assign(size_type __n, const value_type &__x) {
  __size_ = 0;
  if (__n > 0) {
    size_type __c = capacity();
    if (__n <= __c)
      __size_ = __n;
    else {
      vector __v(__alloc());
      __v.reserve(__recommend(__n));
      __v.__size_ = __n;
      swap(__v);
    }
    std::__1::fill_n(begin(), __n, __x);
  }
  __invalidate_all_iterators();
}

template <class _Allocator>
template <class _InputIterator>
typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value &&
                       !__is_cpp17_forward_iterator<_InputIterator>::value,
                   void>::type
vector<bool, _Allocator>::assign(_InputIterator __first,
                                 _InputIterator __last) {
  clear();
  for (; __first != __last; ++__first)
    push_back(*__first);
}

template <class _Allocator>
template <class _ForwardIterator>
typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value,
                   void>::type
vector<bool, _Allocator>::assign(_ForwardIterator __first,
                                 _ForwardIterator __last) {
  clear();
  difference_type __ns = std::__1::distance(__first, __last);
  ((void)0);
  const size_t __n = static_cast<size_type>(__ns);
  if (__n) {
    if (__n > capacity()) {
      __vdeallocate();
      __vallocate(__n);
    }
    __construct_at_end(__first, __last);
  }
}

template <class _Allocator>
void vector<bool, _Allocator>::reserve(size_type __n) {
  if (__n > capacity()) {
    vector __v(this->__alloc());
    __v.__vallocate(__n);
    __v.__construct_at_end(this->begin(), this->end());
    swap(__v);
    __invalidate_all_iterators();
  }
}

template <class _Allocator>
void vector<bool, _Allocator>::shrink_to_fit() noexcept {
  if (__external_cap_to_internal(size()) > __cap()) {

    try {

      vector(*this, allocator_type(__alloc())).swap(*this);

    } catch (...) {
    }
  }
}

template <class _Allocator>
typename vector<bool, _Allocator>::reference
vector<bool, _Allocator>::at(size_type __n) {
  if (__n >= size())
    this->__throw_out_of_range();
  return (*this)[__n];
}

template <class _Allocator>
typename vector<bool, _Allocator>::const_reference
vector<bool, _Allocator>::at(size_type __n) const {
  if (__n >= size())
    this->__throw_out_of_range();
  return (*this)[__n];
}

template <class _Allocator>
void vector<bool, _Allocator>::push_back(const value_type &__x) {
  if (this->__size_ == this->capacity())
    reserve(__recommend(this->__size_ + 1));
  ++this->__size_;
  back() = __x;
}

template <class _Allocator>
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::insert(const_iterator __position,
                                 const value_type &__x) {
  iterator __r;
  if (size() < capacity()) {
    const_iterator __old_end = end();
    ++__size_;
    std::__1::copy_backward(__position, __old_end, end());
    __r = __const_iterator_cast(__position);
  } else {
    vector __v(__alloc());
    __v.reserve(__recommend(__size_ + 1));
    __v.__size_ = __size_ + 1;
    __r = std::__1::copy(cbegin(), __position, __v.begin());
    std::__1::copy_backward(__position, cend(), __v.end());
    swap(__v);
  }
  *__r = __x;
  return __r;
}

template <class _Allocator>
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::insert(const_iterator __position, size_type __n,
                                 const value_type &__x) {
  iterator __r;
  size_type __c = capacity();
  if (__n <= __c && size() <= __c - __n) {
    const_iterator __old_end = end();
    __size_ += __n;
    std::__1::copy_backward(__position, __old_end, end());
    __r = __const_iterator_cast(__position);
  } else {
    vector __v(__alloc());
    __v.reserve(__recommend(__size_ + __n));
    __v.__size_ = __size_ + __n;
    __r = std::__1::copy(cbegin(), __position, __v.begin());
    std::__1::copy_backward(__position, cend(), __v.end());
    swap(__v);
  }
  std::__1::fill_n(__r, __n, __x);
  return __r;
}

template <class _Allocator>
template <class _InputIterator>
typename enable_if<__is_cpp17_input_iterator<_InputIterator>::value &&
                       !__is_cpp17_forward_iterator<_InputIterator>::value,
                   typename vector<bool, _Allocator>::iterator>::type
vector<bool, _Allocator>::insert(const_iterator __position,
                                 _InputIterator __first,
                                 _InputIterator __last) {
  difference_type __off = __position - begin();
  iterator __p = __const_iterator_cast(__position);
  iterator __old_end = end();
  for (; size() != capacity() && __first != __last; ++__first) {
    ++this->__size_;
    back() = *__first;
  }
  vector __v(__alloc());
  if (__first != __last) {

    try {

      __v.assign(__first, __last);
      difference_type __old_size =
          static_cast<difference_type>(__old_end - begin());
      difference_type __old_p = __p - begin();
      reserve(__recommend(size() + __v.size()));
      __p = begin() + __old_p;
      __old_end = begin() + __old_size;

    } catch (...) {
      erase(__old_end, end());
      throw;
    }
  }
  __p = std::__1::rotate(__p, __old_end, end());
  insert(__p, __v.begin(), __v.end());
  return begin() + __off;
}

template <class _Allocator>
template <class _ForwardIterator>
typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value,
                   typename vector<bool, _Allocator>::iterator>::type
vector<bool, _Allocator>::insert(const_iterator __position,
                                 _ForwardIterator __first,
                                 _ForwardIterator __last) {
  const difference_type __n_signed = std::__1::distance(__first, __last);
  ((void)0);
  const size_type __n = static_cast<size_type>(__n_signed);
  iterator __r;
  size_type __c = capacity();
  if (__n <= __c && size() <= __c - __n) {
    const_iterator __old_end = end();
    __size_ += __n;
    std::__1::copy_backward(__position, __old_end, end());
    __r = __const_iterator_cast(__position);
  } else {
    vector __v(__alloc());
    __v.reserve(__recommend(__size_ + __n));
    __v.__size_ = __size_ + __n;
    __r = std::__1::copy(cbegin(), __position, __v.begin());
    std::__1::copy_backward(__position, cend(), __v.end());
    swap(__v);
  }
  std::__1::copy(__first, __last, __r);
  return __r;
}

template <class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::erase(const_iterator __position) {
  iterator __r = __const_iterator_cast(__position);
  std::__1::copy(__position + 1, this->cend(), __r);
  --__size_;
  return __r;
}

template <class _Allocator>
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::erase(const_iterator __first, const_iterator __last) {
  iterator __r = __const_iterator_cast(__first);
  difference_type __d = __last - __first;
  std::__1::copy(__last, this->cend(), __r);
  __size_ -= __d;
  return __r;
}

template <class _Allocator>
void vector<bool, _Allocator>::swap(vector &__x)

    noexcept

{
  std::__1::swap(this->__begin_, __x.__begin_);
  std::__1::swap(this->__size_, __x.__size_);
  std::__1::swap(this->__cap(), __x.__cap());
  __swap_allocator(
      this->__alloc(), __x.__alloc(),
      integral_constant<bool,
                        __alloc_traits::propagate_on_container_swap::value>());
}

template <class _Allocator>
void vector<bool, _Allocator>::resize(size_type __sz, value_type __x) {
  size_type __cs = size();
  if (__cs < __sz) {
    iterator __r;
    size_type __c = capacity();
    size_type __n = __sz - __cs;
    if (__n <= __c && __cs <= __c - __n) {
      __r = end();
      __size_ += __n;
    } else {
      vector __v(__alloc());
      __v.reserve(__recommend(__size_ + __n));
      __v.__size_ = __size_ + __n;
      __r = std::__1::copy(cbegin(), cend(), __v.begin());
      swap(__v);
    }
    std::__1::fill_n(__r, __n, __x);
  } else
    __size_ = __sz;
}

template <class _Allocator> void vector<bool, _Allocator>::flip() noexcept {

  size_type __n = __size_;
  __storage_pointer __p = __begin_;
  for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
    *__p = ~*__p;

  if (__n > 0) {
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
    __storage_type __b = *__p & __m;
    *__p &= ~__m;
    *__p |= ~__b & __m;
  }
}

template <class _Allocator>
bool vector<bool, _Allocator>::__invariants() const {
  if (this->__begin_ == nullptr) {
    if (this->__size_ != 0 || this->__cap() != 0)
      return false;
  } else {
    if (this->__cap() == 0)
      return false;
    if (this->__size_ > this->capacity())
      return false;
  }
  return true;
}

template <class _Allocator>
size_t vector<bool, _Allocator>::__hash_code() const noexcept {
  size_t __h = 0;

  size_type __n = __size_;
  __storage_pointer __p = __begin_;
  for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
    __h ^= *__p;

  if (__n > 0) {
    const __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
    __h ^= *__p & __m;
  }
  return __h;
}

template <class _Allocator>
struct __attribute__((__type_visibility__("default")))
hash<vector<bool, _Allocator>>
    : public unary_function<vector<bool, _Allocator>, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_t
  operator()(const vector<bool, _Allocator> &__vec) const noexcept {
    return __vec.__hash_code();
  }
};

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator==(const vector<_Tp, _Allocator> &__x,
           const vector<_Tp, _Allocator> &__y) {
  const typename vector<_Tp, _Allocator>::size_type __sz = __x.size();
  return __sz == __y.size() &&
         std::__1::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator!=(const vector<_Tp, _Allocator> &__x,
           const vector<_Tp, _Allocator> &__y) {
  return !(__x == __y);
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator<(const vector<_Tp, _Allocator> &__x,
          const vector<_Tp, _Allocator> &__y) {
  return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(),
                                           __y.end());
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator>(const vector<_Tp, _Allocator> &__x,
          const vector<_Tp, _Allocator> &__y) {
  return __y < __x;
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator>=(const vector<_Tp, _Allocator> &__x,
           const vector<_Tp, _Allocator> &__y) {
  return !(__x < __y);
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator<=(const vector<_Tp, _Allocator> &__x,
           const vector<_Tp, _Allocator> &__y) {
  return !(__y < __x);
}

template <class _Tp, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
swap(vector<_Tp, _Allocator> &__x,
     vector<_Tp, _Allocator> &__y) noexcept(noexcept(__x.swap(__y))) {
  __x.swap(__y);
}
# 3402 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/vector" 3
} // namespace __1
} // namespace std
# 55 "/usr/local/include/QtCore/qmetatype.h" 2
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/list" 1 3
# 181 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/list" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 182 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/list" 2 3
# 195 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/list" 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_macros" 1 3
# 199 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/list" 2 3

namespace std {
inline namespace __1 {

template <class _Tp, class _VoidPtr> struct __list_node;
template <class _Tp, class _VoidPtr> struct __list_node_base;

template <class _Tp, class _VoidPtr> struct __list_node_pointer_traits {
  typedef typename __rebind_pointer<_VoidPtr, __list_node<_Tp, _VoidPtr>>::type
      __node_pointer;
  typedef
      typename __rebind_pointer<_VoidPtr, __list_node_base<_Tp, _VoidPtr>>::type
          __base_pointer;

  typedef typename conditional<is_pointer<_VoidPtr>::value, __base_pointer,
                               __node_pointer>::type __link_pointer;

  typedef typename conditional<is_same<__link_pointer, __node_pointer>::value,
                               __base_pointer, __node_pointer>::type
      __non_link_pointer;

  static __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) __link_pointer
  __unsafe_link_pointer_cast(__link_pointer __p) {
    return __p;
  }

  static __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) __link_pointer
  __unsafe_link_pointer_cast(__non_link_pointer __p) {
    return static_cast<__link_pointer>(static_cast<_VoidPtr>(__p));
  }
};

template <class _Tp, class _VoidPtr> struct __list_node_base {
  typedef __list_node_pointer_traits<_Tp, _VoidPtr> _NodeTraits;
  typedef typename _NodeTraits::__node_pointer __node_pointer;
  typedef typename _NodeTraits::__base_pointer __base_pointer;
  typedef typename _NodeTraits::__link_pointer __link_pointer;

  __link_pointer __prev_;
  __link_pointer __next_;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __list_node_base()
      : __prev_(_NodeTraits::__unsafe_link_pointer_cast(__self())),
        __next_(_NodeTraits::__unsafe_link_pointer_cast(__self())) {}

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __base_pointer
  __self() {
    return pointer_traits<__base_pointer>::pointer_to(*this);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __node_pointer
  __as_node() {
    return static_cast<__node_pointer>(__self());
  }
};

template <class _Tp, class _VoidPtr>
struct __list_node : public __list_node_base<_Tp, _VoidPtr> {
  _Tp __value_;

  typedef __list_node_base<_Tp, _VoidPtr> __base;
  typedef typename __base::__link_pointer __link_pointer;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __link_pointer
  __as_link() {
    return static_cast<__link_pointer>(__base::__self());
  }
};

template <class _Tp, class _Alloc = allocator<_Tp>>
class __attribute__((__type_visibility__("default"))) list;
template <class _Tp, class _Alloc> class __list_imp;
template <class _Tp, class _VoidPtr>
class __attribute__((__type_visibility__("default"))) __list_const_iterator;

template <class _Tp, class _VoidPtr>
class __attribute__((__type_visibility__("default"))) __list_iterator {
  typedef __list_node_pointer_traits<_Tp, _VoidPtr> _NodeTraits;
  typedef typename _NodeTraits::__link_pointer __link_pointer;

  __link_pointer __ptr_;
# 302 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/list" 3
  __attribute__((__visibility__("hidden"))) __attribute__((
      internal_linkage)) explicit __list_iterator(__link_pointer __p) noexcept
      : __ptr_(__p) {}

  template <class, class> friend class list;
  template <class, class> friend class __list_imp;
  template <class, class> friend class __list_const_iterator;

public:
  typedef bidirectional_iterator_tag iterator_category;
  typedef _Tp value_type;
  typedef value_type &reference;
  typedef typename __rebind_pointer<_VoidPtr, value_type>::type pointer;
  typedef typename pointer_traits<pointer>::difference_type difference_type;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __list_iterator() noexcept
      : __ptr_(nullptr) {}
# 354 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/list" 3
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reference
  operator*() const {

    return __ptr_->__as_node()->__value_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pointer
  operator->() const {

    return pointer_traits<pointer>::pointer_to(__ptr_->__as_node()->__value_);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __list_iterator &
  operator++() {

    __ptr_ = __ptr_->__next_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __list_iterator
  operator++(int) {
    __list_iterator __t(*this);
    ++(*this);
    return __t;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __list_iterator &
  operator--() {

    __ptr_ = __ptr_->__prev_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __list_iterator
  operator--(int) {
    __list_iterator __t(*this);
    --(*this);
    return __t;
  }

  friend __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator==(const __list_iterator &__x, const __list_iterator &__y) {
    return __x.__ptr_ == __y.__ptr_;
  }
  friend __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator!=(const __list_iterator &__x, const __list_iterator &__y) {
    return !(__x == __y);
  }
};

template <class _Tp, class _VoidPtr>
class __attribute__((__type_visibility__("default"))) __list_const_iterator {
  typedef __list_node_pointer_traits<_Tp, _VoidPtr> _NodeTraits;
  typedef typename _NodeTraits::__link_pointer __link_pointer;

  __link_pointer __ptr_;
# 425 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/list" 3
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit __list_const_iterator(
      __link_pointer __p) noexcept
      : __ptr_(__p) {}

  template <class, class> friend class list;
  template <class, class> friend class __list_imp;

public:
  typedef bidirectional_iterator_tag iterator_category;
  typedef _Tp value_type;
  typedef const value_type &reference;
  typedef typename __rebind_pointer<_VoidPtr, const value_type>::type pointer;
  typedef typename pointer_traits<pointer>::difference_type difference_type;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __list_const_iterator() noexcept
      : __ptr_(nullptr) {}
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __list_const_iterator(const __list_iterator<_Tp, _VoidPtr> &__p) noexcept
      : __ptr_(__p.__ptr_) {}
# 481 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/list" 3
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reference
  operator*() const {

    return __ptr_->__as_node()->__value_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pointer
  operator->() const {

    return pointer_traits<pointer>::pointer_to(__ptr_->__as_node()->__value_);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __list_const_iterator &
  operator++() {

    __ptr_ = __ptr_->__next_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __list_const_iterator
  operator++(int) {
    __list_const_iterator __t(*this);
    ++(*this);
    return __t;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __list_const_iterator &
  operator--() {

    __ptr_ = __ptr_->__prev_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __list_const_iterator
  operator--(int) {
    __list_const_iterator __t(*this);
    --(*this);
    return __t;
  }

  friend __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator==(const __list_const_iterator &__x,
             const __list_const_iterator &__y) {
    return __x.__ptr_ == __y.__ptr_;
  }
  friend __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator!=(const __list_const_iterator &__x,
             const __list_const_iterator &__y) {
    return !(__x == __y);
  }
};

template <class _Tp, class _Alloc> class __list_imp {
  __list_imp(const __list_imp &);
  __list_imp &operator=(const __list_imp &);

public:
  typedef _Alloc allocator_type;
  typedef allocator_traits<allocator_type> __alloc_traits;
  typedef typename __alloc_traits::size_type size_type;

protected:
  typedef _Tp value_type;
  typedef typename __alloc_traits::void_pointer __void_pointer;
  typedef __list_iterator<value_type, __void_pointer> iterator;
  typedef __list_const_iterator<value_type, __void_pointer> const_iterator;
  typedef __list_node_base<value_type, __void_pointer> __node_base;
  typedef __list_node<value_type, __void_pointer> __node;
  typedef typename __rebind_alloc_helper<__alloc_traits, __node>::type
      __node_allocator;
  typedef allocator_traits<__node_allocator> __node_alloc_traits;
  typedef typename __node_alloc_traits::pointer __node_pointer;
  typedef typename __node_alloc_traits::pointer __node_const_pointer;
  typedef __list_node_pointer_traits<value_type, __void_pointer>
      __node_pointer_traits;
  typedef typename __node_pointer_traits::__link_pointer __link_pointer;
  typedef __link_pointer __link_const_pointer;
  typedef typename __alloc_traits::pointer pointer;
  typedef typename __alloc_traits::const_pointer const_pointer;
  typedef typename __alloc_traits::difference_type difference_type;

  typedef typename __rebind_alloc_helper<__alloc_traits, __node_base>::type
      __node_base_allocator;
  typedef typename allocator_traits<__node_base_allocator>::pointer
      __node_base_pointer;
  static_assert((!is_same<allocator_type, __node_allocator>::value),
                "internal allocator type must differ from user-specified "
                "type; otherwise overload resolution breaks");

  __node_base __end_;
  __compressed_pair<size_type, __node_allocator> __size_alloc_;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __link_pointer
  __end_as_link() const noexcept {
    return __node_pointer_traits::__unsafe_link_pointer_cast(
        const_cast<__node_base &>(__end_).__self());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type &
  __sz() noexcept {
    return __size_alloc_.first();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const size_type &
  __sz() const noexcept {
    return __size_alloc_.first();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __node_allocator &
  __node_alloc() noexcept {
    return __size_alloc_.second();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const __node_allocator &
  __node_alloc() const noexcept {
    return __size_alloc_.second();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  __node_alloc_max_size() const noexcept {
    return __node_alloc_traits::max_size(__node_alloc());
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static void
  __unlink_nodes(__link_pointer __f, __link_pointer __l) noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __list_imp() noexcept(
      is_nothrow_default_constructible<__node_allocator>::value);
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __list_imp(const allocator_type &__a);
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __list_imp(const __node_allocator &__a);

  __list_imp(__node_allocator &&__a) noexcept;

  ~__list_imp();
  void clear() noexcept;
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  empty() const noexcept {
    return __sz() == 0;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  begin() noexcept {

    return iterator(__end_.__next_);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_iterator
  begin() const noexcept {

    return const_iterator(__end_.__next_);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  end() noexcept {

    return iterator(__end_as_link());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_iterator
  end() const noexcept {

    return const_iterator(__end_as_link());
  }

  void swap(__list_imp &__c)

      noexcept;

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __copy_assign_alloc(const __list_imp &__c) {
    __copy_assign_alloc(
        __c,
        integral_constant<bool,
                          __node_alloc_traits::
                              propagate_on_container_copy_assignment::value>());
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __move_assign_alloc(__list_imp &__c) noexcept(
      !__node_alloc_traits::propagate_on_container_move_assignment::value ||
      is_nothrow_move_assignable<__node_allocator>::value)

  {
    __move_assign_alloc(
        __c,
        integral_constant<bool,
                          __node_alloc_traits::
                              propagate_on_container_move_assignment::value>());
  }

private:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __copy_assign_alloc(const __list_imp &__c, true_type) {
    if (__node_alloc() != __c.__node_alloc())
      clear();
    __node_alloc() = __c.__node_alloc();
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __copy_assign_alloc(const __list_imp &, false_type) {}

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __move_assign_alloc(__list_imp &__c, true_type) noexcept(
      is_nothrow_move_assignable<__node_allocator>::value) {
    __node_alloc() = std::__1::move(__c.__node_alloc());
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __move_assign_alloc(__list_imp &, false_type) noexcept {}

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __invalidate_all_iterators() {}
};

template <class _Tp, class _Alloc>
inline void
__list_imp<_Tp, _Alloc>::__unlink_nodes(__link_pointer __f,
                                        __link_pointer __l) noexcept {
  __f->__prev_->__next_ = __l->__next_;
  __l->__next_->__prev_ = __f->__prev_;
}

template <class _Tp, class _Alloc>
inline __list_imp<_Tp, _Alloc>::__list_imp() noexcept(
    is_nothrow_default_constructible<__node_allocator>::value)
    : __size_alloc_(0, __default_init_tag()) {}

template <class _Tp, class _Alloc>
inline __list_imp<_Tp, _Alloc>::__list_imp(const allocator_type &__a)
    : __size_alloc_(0, __node_allocator(__a)) {}

template <class _Tp, class _Alloc>
inline __list_imp<_Tp, _Alloc>::__list_imp(const __node_allocator &__a)
    : __size_alloc_(0, __a) {}

template <class _Tp, class _Alloc>
inline __list_imp<_Tp, _Alloc>::__list_imp(__node_allocator &&__a) noexcept
    : __size_alloc_(0, std::move(__a)) {}

template <class _Tp, class _Alloc> __list_imp<_Tp, _Alloc>::~__list_imp() {
  clear();
}

template <class _Tp, class _Alloc>
void __list_imp<_Tp, _Alloc>::clear() noexcept {
  if (!empty()) {
    __node_allocator &__na = __node_alloc();
    __link_pointer __f = __end_.__next_;
    __link_pointer __l = __end_as_link();
    __unlink_nodes(__f, __l->__prev_);
    __sz() = 0;
    while (__f != __l) {
      __node_pointer __np = __f->__as_node();
      __f = __f->__next_;
      __node_alloc_traits::destroy(__na, std::__1::addressof(__np->__value_));
      __node_alloc_traits::deallocate(__na, __np, 1);
    }
    __invalidate_all_iterators();
  }
}

template <class _Tp, class _Alloc>
void __list_imp<_Tp, _Alloc>::swap(__list_imp &__c)

    noexcept

{
  ((void)0);

  using std::__1::swap;
  __swap_allocator(__node_alloc(), __c.__node_alloc());
  swap(__sz(), __c.__sz());
  swap(__end_, __c.__end_);
  if (__sz() == 0)
    __end_.__next_ = __end_.__prev_ = __end_as_link();
  else
    __end_.__prev_->__next_ = __end_.__next_->__prev_ = __end_as_link();
  if (__c.__sz() == 0)
    __c.__end_.__next_ = __c.__end_.__prev_ = __c.__end_as_link();
  else
    __c.__end_.__prev_->__next_ = __c.__end_.__next_->__prev_ =
        __c.__end_as_link();
# 831 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/list" 3
}

template <class _Tp, class _Alloc>
class __attribute__((__type_visibility__("default"))) list
    : private __list_imp<_Tp, _Alloc> {
  typedef __list_imp<_Tp, _Alloc> base;
  typedef typename base::__node __node;
  typedef typename base::__node_allocator __node_allocator;
  typedef typename base::__node_pointer __node_pointer;
  typedef typename base::__node_alloc_traits __node_alloc_traits;
  typedef typename base::__node_base __node_base;
  typedef typename base::__node_base_pointer __node_base_pointer;
  typedef typename base::__link_pointer __link_pointer;

public:
  typedef _Tp value_type;
  typedef _Alloc allocator_type;
  static_assert(
      (is_same<value_type, typename allocator_type::value_type>::value),
      "Invalid allocator::value_type");
  typedef value_type &reference;
  typedef const value_type &const_reference;
  typedef typename base::pointer pointer;
  typedef typename base::const_pointer const_pointer;
  typedef typename base::size_type size_type;
  typedef typename base::difference_type difference_type;
  typedef typename base::iterator iterator;
  typedef typename base::const_iterator const_iterator;
  typedef std::__1::reverse_iterator<iterator> reverse_iterator;
  typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

  typedef void __remove_return_type;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  list() noexcept(is_nothrow_default_constructible<__node_allocator>::value) {}
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit list(const allocator_type &__a)
      : base(__a) {}
  explicit list(size_type __n);

  explicit list(size_type __n, const allocator_type &__a);

  list(size_type __n, const value_type &__x);
  list(size_type __n, const value_type &__x, const allocator_type &__a);
  template <class _InpIter>
  list(_InpIter __f, _InpIter __l,
       typename enable_if<__is_cpp17_input_iterator<_InpIter>::value>::type * =
           0);
  template <class _InpIter>
  list(_InpIter __f, _InpIter __l, const allocator_type &__a,
       typename enable_if<__is_cpp17_input_iterator<_InpIter>::value>::type * =
           0);

  list(const list &__c);
  list(const list &__c, const allocator_type &__a);
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  list &
  operator=(const list &__c);

  list(initializer_list<value_type> __il);
  list(initializer_list<value_type> __il, const allocator_type &__a);

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  list(list &&__c) noexcept(
      is_nothrow_move_constructible<__node_allocator>::value);
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  list(list &&__c, const allocator_type &__a);
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  list &
  operator=(list &&__c) noexcept(
      __node_alloc_traits::propagate_on_container_move_assignment::value
          &&is_nothrow_move_assignable<__node_allocator>::value);

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  list &
  operator=(initializer_list<value_type> __il) {
    assign(__il.begin(), __il.end());
    return *this;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  assign(initializer_list<value_type> __il) {
    assign(__il.begin(), __il.end());
  }

  template <class _InpIter>
  void assign(
      _InpIter __f, _InpIter __l,
      typename enable_if<__is_cpp17_input_iterator<_InpIter>::value>::type * =
          0);
  void assign(size_type __n, const value_type &__x);

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  allocator_type
  get_allocator() const noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  size() const noexcept {
    return base::__sz();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  empty() const noexcept {
    return base::empty();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  max_size() const noexcept {
    return std::min<size_type>(base::__node_alloc_max_size(),
                               numeric_limits<difference_type>::max());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  begin() noexcept {
    return base::begin();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_iterator
  begin() const noexcept {
    return base::begin();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  end() noexcept {
    return base::end();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_iterator
  end() const noexcept {
    return base::end();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_iterator
  cbegin() const noexcept {
    return base::begin();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_iterator
  cend() const noexcept {
    return base::end();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reverse_iterator
  rbegin() noexcept {
    return reverse_iterator(end());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reverse_iterator
  rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reverse_iterator
  rend() noexcept {
    return reverse_iterator(begin());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reverse_iterator
  rend() const noexcept {
    return const_reverse_iterator(begin());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reverse_iterator
  crbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reverse_iterator
  crend() const noexcept {
    return const_reverse_iterator(begin());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reference
  front() {
    ((void)0);
    return base::__end_.__next_->__as_node()->__value_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reference
  front() const {
    ((void)0);
    return base::__end_.__next_->__as_node()->__value_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reference
  back() {
    ((void)0);
    return base::__end_.__prev_->__as_node()->__value_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reference
  back() const {
    ((void)0);
    return base::__end_.__prev_->__as_node()->__value_;
  }

  void push_front(value_type &&__x);
  void push_back(value_type &&__x);

  template <class... _Args>

  void emplace_front(_Args &&...__args);

  template <class... _Args>

  void emplace_back(_Args &&...__args);

  template <class... _Args>
  iterator emplace(const_iterator __p, _Args &&...__args);

  iterator insert(const_iterator __p, value_type &&__x);

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  insert(const_iterator __p, initializer_list<value_type> __il) {
    return insert(__p, __il.begin(), __il.end());
  }

  void push_front(const value_type &__x);
  void push_back(const value_type &__x);

  template <class _Arg>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __emplace_back(_Arg &&__arg) {
    emplace_back(std::__1::forward<_Arg>(__arg));
  }

  iterator insert(const_iterator __p, const value_type &__x);
  iterator insert(const_iterator __p, size_type __n, const value_type &__x);
  template <class _InpIter>
  iterator insert(
      const_iterator __p, _InpIter __f, _InpIter __l,
      typename enable_if<__is_cpp17_input_iterator<_InpIter>::value>::type * =
          0);

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  swap(list &__c)

      noexcept

  {
    base::swap(__c);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  clear() noexcept {
    base::clear();
  }

  void pop_front();
  void pop_back();

  iterator erase(const_iterator __p);
  iterator erase(const_iterator __f, const_iterator __l);

  void resize(size_type __n);
  void resize(size_type __n, const value_type &__x);

  void splice(const_iterator __p, list &__c);

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  splice(const_iterator __p, list &&__c) {
    splice(__p, __c);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  splice(const_iterator __p, list &&__c, const_iterator __i) {
    splice(__p, __c, __i);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  splice(const_iterator __p, list &&__c, const_iterator __f,
         const_iterator __l) {
    splice(__p, __c, __f, __l);
  }

  void splice(const_iterator __p, list &__c, const_iterator __i);
  void splice(const_iterator __p, list &__c, const_iterator __f,
              const_iterator __l);

  __remove_return_type remove(const value_type &__x);
  template <class _Pred> __remove_return_type remove_if(_Pred __pred);
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __remove_return_type
  unique() {
    return unique(__equal_to<value_type>());
  }
  template <class _BinaryPred>
  __remove_return_type unique(_BinaryPred __binary_pred);
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  merge(list &__c);

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  merge(list &&__c) {
    merge(__c);
  }

  template <class _Comp>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  merge(list &&__c, _Comp __comp) {
    merge(__c, __comp);
  }

  template <class _Comp> void merge(list &__c, _Comp __comp);

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  sort();
  template <class _Comp>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  sort(_Comp __comp);

  void reverse() noexcept;

  bool __invariants() const;

  typedef __allocator_destructor<__node_allocator> __node_destructor;
  typedef unique_ptr<__node, __node_destructor> __hold_pointer;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __hold_pointer
  __allocate_node(__node_allocator &__na) {
    __node_pointer __p = __node_alloc_traits::allocate(__na, 1);
    __p->__prev_ = nullptr;
    return __hold_pointer(__p, __node_destructor(__na, 1));
  }
# 1127 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/list" 3
private:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static void
  __link_nodes(__link_pointer __p, __link_pointer __f, __link_pointer __l);
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __link_nodes_at_front(__link_pointer __f, __link_pointer __l);
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __link_nodes_at_back(__link_pointer __f, __link_pointer __l);
  iterator __iterator(size_type __n);
  template <class _Comp>
  static iterator __sort(iterator __f1, iterator __e2, size_type __n,
                         _Comp &__comp);

  void __move_assign(list &__c, true_type) noexcept(
      is_nothrow_move_assignable<__node_allocator>::value);
  void __move_assign(list &__c, false_type);
};
# 1160 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/list" 3
template <class _Tp, class _Alloc>
inline void list<_Tp, _Alloc>::__link_nodes(__link_pointer __p,
                                            __link_pointer __f,
                                            __link_pointer __l) {
  __p->__prev_->__next_ = __f;
  __f->__prev_ = __p->__prev_;
  __p->__prev_ = __l;
  __l->__next_ = __p;
}

template <class _Tp, class _Alloc>
inline void list<_Tp, _Alloc>::__link_nodes_at_front(__link_pointer __f,
                                                     __link_pointer __l) {
  __f->__prev_ = base::__end_as_link();
  __l->__next_ = base::__end_.__next_;
  __l->__next_->__prev_ = __l;
  base::__end_.__next_ = __f;
}

template <class _Tp, class _Alloc>
inline void list<_Tp, _Alloc>::__link_nodes_at_back(__link_pointer __f,
                                                    __link_pointer __l) {
  __l->__next_ = base::__end_as_link();
  __f->__prev_ = base::__end_.__prev_;
  __f->__prev_->__next_ = __f;
  base::__end_.__prev_ = __l;
}

template <class _Tp, class _Alloc>
inline typename list<_Tp, _Alloc>::iterator
list<_Tp, _Alloc>::__iterator(size_type __n) {
  return __n <= base::__sz() / 2 ? std::__1::next(begin(), __n)
                                 : std::__1::prev(end(), base::__sz() - __n);
}

template <class _Tp, class _Alloc> list<_Tp, _Alloc>::list(size_type __n) {

  for (; __n > 0; --__n)

    emplace_back();
}

template <class _Tp, class _Alloc>
list<_Tp, _Alloc>::list(size_type __n, const allocator_type &__a) : base(__a) {

  for (; __n > 0; --__n)
    emplace_back();
}

template <class _Tp, class _Alloc>
list<_Tp, _Alloc>::list(size_type __n, const value_type &__x) {

  for (; __n > 0; --__n)
    push_back(__x);
}

template <class _Tp, class _Alloc>
list<_Tp, _Alloc>::list(size_type __n, const value_type &__x,
                        const allocator_type &__a)
    : base(__a) {

  for (; __n > 0; --__n)
    push_back(__x);
}

template <class _Tp, class _Alloc>
template <class _InpIter>
list<_Tp, _Alloc>::list(
    _InpIter __f, _InpIter __l,
    typename enable_if<__is_cpp17_input_iterator<_InpIter>::value>::type *) {

  for (; __f != __l; ++__f)
    __emplace_back(*__f);
}

template <class _Tp, class _Alloc>
template <class _InpIter>
list<_Tp, _Alloc>::list(
    _InpIter __f, _InpIter __l, const allocator_type &__a,
    typename enable_if<__is_cpp17_input_iterator<_InpIter>::value>::type *)
    : base(__a) {

  for (; __f != __l; ++__f)
    __emplace_back(*__f);
}

template <class _Tp, class _Alloc>
list<_Tp, _Alloc>::list(const list &__c)
    : base(__node_alloc_traits::select_on_container_copy_construction(
          __c.__node_alloc())) {

  for (const_iterator __i = __c.begin(), __e = __c.end(); __i != __e; ++__i)
    push_back(*__i);
}

template <class _Tp, class _Alloc>
list<_Tp, _Alloc>::list(const list &__c, const allocator_type &__a)
    : base(__a) {

  for (const_iterator __i = __c.begin(), __e = __c.end(); __i != __e; ++__i)
    push_back(*__i);
}

template <class _Tp, class _Alloc>
list<_Tp, _Alloc>::list(initializer_list<value_type> __il,
                        const allocator_type &__a)
    : base(__a) {

  for (typename initializer_list<value_type>::const_iterator __i = __il.begin(),
                                                             __e = __il.end();
       __i != __e; ++__i)
    push_back(*__i);
}

template <class _Tp, class _Alloc>
list<_Tp, _Alloc>::list(initializer_list<value_type> __il) {

  for (typename initializer_list<value_type>::const_iterator __i = __il.begin(),
                                                             __e = __il.end();
       __i != __e; ++__i)
    push_back(*__i);
}

template <class _Tp, class _Alloc>
inline list<_Tp, _Alloc>::list(list &&__c) noexcept(
    is_nothrow_move_constructible<__node_allocator>::value)
    : base(std::__1::move(__c.__node_alloc())) {

  splice(end(), __c);
}

template <class _Tp, class _Alloc>
inline list<_Tp, _Alloc>::list(list &&__c, const allocator_type &__a)
    : base(__a) {

  if (__a == __c.get_allocator())
    splice(end(), __c);
  else {
    typedef move_iterator<iterator> _Ip;
    assign(_Ip(__c.begin()), _Ip(__c.end()));
  }
}

template <class _Tp, class _Alloc>
inline list<_Tp, _Alloc> &list<_Tp, _Alloc>::operator=(list &&__c) noexcept(
    __node_alloc_traits::propagate_on_container_move_assignment::value
        &&is_nothrow_move_assignable<__node_allocator>::value)

{
  __move_assign(
      __c,
      integral_constant<bool,
                        __node_alloc_traits::
                            propagate_on_container_move_assignment::value>());
  return *this;
}

template <class _Tp, class _Alloc>
void list<_Tp, _Alloc>::__move_assign(list &__c, false_type) {
  if (base::__node_alloc() != __c.__node_alloc()) {
    typedef move_iterator<iterator> _Ip;
    assign(_Ip(__c.begin()), _Ip(__c.end()));
  } else
    __move_assign(__c, true_type());
}

template <class _Tp, class _Alloc>
void list<_Tp, _Alloc>::__move_assign(list &__c, true_type) noexcept(
    is_nothrow_move_assignable<__node_allocator>::value) {
  clear();
  base::__move_assign_alloc(__c);
  splice(end(), __c);
}

template <class _Tp, class _Alloc>
inline list<_Tp, _Alloc> &list<_Tp, _Alloc>::operator=(const list &__c) {
  if (this != &__c) {
    base::__copy_assign_alloc(__c);
    assign(__c.begin(), __c.end());
  }
  return *this;
}

template <class _Tp, class _Alloc>
template <class _InpIter>
void list<_Tp, _Alloc>::assign(
    _InpIter __f, _InpIter __l,
    typename enable_if<__is_cpp17_input_iterator<_InpIter>::value>::type *) {
  iterator __i = begin();
  iterator __e = end();
  for (; __f != __l && __i != __e; ++__f, ++__i)
    *__i = *__f;
  if (__i == __e)
    insert(__e, __f, __l);
  else
    erase(__i, __e);
}

template <class _Tp, class _Alloc>
void list<_Tp, _Alloc>::assign(size_type __n, const value_type &__x) {
  iterator __i = begin();
  iterator __e = end();
  for (; __n > 0 && __i != __e; --__n, ++__i)
    *__i = __x;
  if (__i == __e)
    insert(__e, __n, __x);
  else
    erase(__i, __e);
}

template <class _Tp, class _Alloc>
inline _Alloc list<_Tp, _Alloc>::get_allocator() const noexcept {
  return allocator_type(base::__node_alloc());
}

template <class _Tp, class _Alloc>
typename list<_Tp, _Alloc>::iterator
list<_Tp, _Alloc>::insert(const_iterator __p, const value_type &__x) {

  __node_allocator &__na = base::__node_alloc();
  __hold_pointer __hold = __allocate_node(__na);
  __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_),
                                 __x);
  __link_nodes(__p.__ptr_, __hold->__as_link(), __hold->__as_link());
  ++base::__sz();

  return iterator(__hold.release()->__as_link());
}

template <class _Tp, class _Alloc>
typename list<_Tp, _Alloc>::iterator
list<_Tp, _Alloc>::insert(const_iterator __p, size_type __n,
                          const value_type &__x) {

  iterator __r(__p.__ptr_);

  if (__n > 0) {
    size_type __ds = 0;
    __node_allocator &__na = base::__node_alloc();
    __hold_pointer __hold = __allocate_node(__na);
    __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_),
                                   __x);
    ++__ds;

    __r = iterator(__hold->__as_link());

    __hold.release();
    iterator __e = __r;

    try {

      for (--__n; __n != 0; --__n, ++__e, ++__ds) {
        __hold.reset(__node_alloc_traits::allocate(__na, 1));
        __node_alloc_traits::construct(
            __na, std::__1::addressof(__hold->__value_), __x);
        __e.__ptr_->__next_ = __hold->__as_link();
        __hold->__prev_ = __e.__ptr_;
        __hold.release();
      }

    } catch (...) {
      while (true) {
        __node_alloc_traits::destroy(__na, std::__1::addressof(*__e));
        __link_pointer __prev = __e.__ptr_->__prev_;
        __node_alloc_traits::deallocate(__na, __e.__ptr_->__as_node(), 1);
        if (__prev == 0)
          break;

        __e = iterator(__prev);
      }
      throw;
    }

    __link_nodes(__p.__ptr_, __r.__ptr_, __e.__ptr_);
    base::__sz() += __ds;
  }
  return __r;
}

template <class _Tp, class _Alloc>
template <class _InpIter>
typename list<_Tp, _Alloc>::iterator list<_Tp, _Alloc>::insert(
    const_iterator __p, _InpIter __f, _InpIter __l,
    typename enable_if<__is_cpp17_input_iterator<_InpIter>::value>::type *) {

  iterator __r(__p.__ptr_);

  if (__f != __l) {
    size_type __ds = 0;
    __node_allocator &__na = base::__node_alloc();
    __hold_pointer __hold = __allocate_node(__na);
    __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_),
                                   *__f);
    ++__ds;

    __r = iterator(__hold.get()->__as_link());

    __hold.release();
    iterator __e = __r;

    try {

      for (++__f; __f != __l; ++__f, (void)++__e, (void)++__ds) {
        __hold.reset(__node_alloc_traits::allocate(__na, 1));
        __node_alloc_traits::construct(
            __na, std::__1::addressof(__hold->__value_), *__f);
        __e.__ptr_->__next_ = __hold.get()->__as_link();
        __hold->__prev_ = __e.__ptr_;
        __hold.release();
      }

    } catch (...) {
      while (true) {
        __node_alloc_traits::destroy(__na, std::__1::addressof(*__e));
        __link_pointer __prev = __e.__ptr_->__prev_;
        __node_alloc_traits::deallocate(__na, __e.__ptr_->__as_node(), 1);
        if (__prev == 0)
          break;

        __e = iterator(__prev);
      }
      throw;
    }

    __link_nodes(__p.__ptr_, __r.__ptr_, __e.__ptr_);
    base::__sz() += __ds;
  }
  return __r;
}

template <class _Tp, class _Alloc>
void list<_Tp, _Alloc>::push_front(const value_type &__x) {
  __node_allocator &__na = base::__node_alloc();
  __hold_pointer __hold = __allocate_node(__na);
  __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_),
                                 __x);
  __link_pointer __nl = __hold->__as_link();
  __link_nodes_at_front(__nl, __nl);
  ++base::__sz();
  __hold.release();
}

template <class _Tp, class _Alloc>
void list<_Tp, _Alloc>::push_back(const value_type &__x) {
  __node_allocator &__na = base::__node_alloc();
  __hold_pointer __hold = __allocate_node(__na);
  __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_),
                                 __x);
  __link_nodes_at_back(__hold.get()->__as_link(), __hold.get()->__as_link());
  ++base::__sz();
  __hold.release();
}

template <class _Tp, class _Alloc>
void list<_Tp, _Alloc>::push_front(value_type &&__x) {
  __node_allocator &__na = base::__node_alloc();
  __hold_pointer __hold = __allocate_node(__na);
  __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_),
                                 std::__1::move(__x));
  __link_nodes_at_front(__hold.get()->__as_link(), __hold.get()->__as_link());
  ++base::__sz();
  __hold.release();
}

template <class _Tp, class _Alloc>
void list<_Tp, _Alloc>::push_back(value_type &&__x) {
  __node_allocator &__na = base::__node_alloc();
  __hold_pointer __hold = __allocate_node(__na);
  __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_),
                                 std::__1::move(__x));
  __link_nodes_at_back(__hold.get()->__as_link(), __hold.get()->__as_link());
  ++base::__sz();
  __hold.release();
}

template <class _Tp, class _Alloc>
template <class... _Args>



void

list<_Tp, _Alloc>::emplace_front(_Args&&... __args)
{
  __node_allocator &__na = base::__node_alloc();
  __hold_pointer __hold = __allocate_node(__na);
  __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_),
                                 std::__1::forward<_Args>(__args)...);
  __link_nodes_at_front(__hold.get()->__as_link(), __hold.get()->__as_link());
  ++base::__sz();

  __hold.release();
}

template <class _Tp, class _Alloc>
template <class... _Args>



void

list<_Tp, _Alloc>::emplace_back(_Args&&... __args)
{
  __node_allocator &__na = base::__node_alloc();
  __hold_pointer __hold = __allocate_node(__na);
  __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_),
                                 std::__1::forward<_Args>(__args)...);
  __link_pointer __nl = __hold->__as_link();
  __link_nodes_at_back(__nl, __nl);
  ++base::__sz();

  __hold.release();
}

template <class _Tp, class _Alloc>
template <class... _Args>
typename list<_Tp, _Alloc>::iterator
list<_Tp, _Alloc>::emplace(const_iterator __p, _Args &&...__args) {

  __node_allocator &__na = base::__node_alloc();
  __hold_pointer __hold = __allocate_node(__na);
  __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_),
                                 std::__1::forward<_Args>(__args)...);
  __link_pointer __nl = __hold.get()->__as_link();
  __link_nodes(__p.__ptr_, __nl, __nl);
  ++base::__sz();
  __hold.release();

  return iterator(__nl);
}

template <class _Tp, class _Alloc>
typename list<_Tp, _Alloc>::iterator
list<_Tp, _Alloc>::insert(const_iterator __p, value_type &&__x) {

  __node_allocator &__na = base::__node_alloc();
  __hold_pointer __hold = __allocate_node(__na);
  __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_),
                                 std::__1::move(__x));
  __link_pointer __nl = __hold->__as_link();
  __link_nodes(__p.__ptr_, __nl, __nl);
  ++base::__sz();
  __hold.release();

  return iterator(__nl);
}

template <class _Tp, class _Alloc> void list<_Tp, _Alloc>::pop_front() {
  ((void)0);
  __node_allocator &__na = base::__node_alloc();
  __link_pointer __n = base::__end_.__next_;
  base::__unlink_nodes(__n, __n);
  --base::__sz();
# 1764 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/list" 3
  __node_pointer __np = __n->__as_node();
  __node_alloc_traits::destroy(__na, std::__1::addressof(__np->__value_));
  __node_alloc_traits::deallocate(__na, __np, 1);
}

template <class _Tp, class _Alloc> void list<_Tp, _Alloc>::pop_back() {
  ((void)0);
  __node_allocator &__na = base::__node_alloc();
  __link_pointer __n = base::__end_.__prev_;
  base::__unlink_nodes(__n, __n);
  --base::__sz();
# 1793 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/list" 3
  __node_pointer __np = __n->__as_node();
  __node_alloc_traits::destroy(__na, std::__1::addressof(__np->__value_));
  __node_alloc_traits::deallocate(__na, __np, 1);
}

template <class _Tp, class _Alloc>
typename list<_Tp, _Alloc>::iterator
list<_Tp, _Alloc>::erase(const_iterator __p) {

  ((void)0);

  __node_allocator &__na = base::__node_alloc();
  __link_pointer __n = __p.__ptr_;
  __link_pointer __r = __n->__next_;
  base::__unlink_nodes(__n, __n);
  --base::__sz();
# 1829 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/list" 3
  __node_pointer __np = __n->__as_node();
  __node_alloc_traits::destroy(__na, std::__1::addressof(__np->__value_));
  __node_alloc_traits::deallocate(__na, __np, 1);

  return iterator(__r);
}

template <class _Tp, class _Alloc>
typename list<_Tp, _Alloc>::iterator
list<_Tp, _Alloc>::erase(const_iterator __f, const_iterator __l) {
# 1851 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/list" 3
  if (__f != __l) {
    __node_allocator &__na = base::__node_alloc();
    base::__unlink_nodes(__f.__ptr_, __l.__ptr_->__prev_);
    while (__f != __l) {
      __link_pointer __n = __f.__ptr_;
      ++__f;
      --base::__sz();
# 1875 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/list" 3
      __node_pointer __np = __n->__as_node();
      __node_alloc_traits::destroy(__na, std::__1::addressof(__np->__value_));
      __node_alloc_traits::deallocate(__na, __np, 1);
    }
  }

  return iterator(__l.__ptr_);
}

template <class _Tp, class _Alloc>
void list<_Tp, _Alloc>::resize(size_type __n) {
  if (__n < base::__sz())
    erase(__iterator(__n), end());
  else if (__n > base::__sz()) {
    __n -= base::__sz();
    size_type __ds = 0;
    __node_allocator &__na = base::__node_alloc();
    __hold_pointer __hold = __allocate_node(__na);
    __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_));
    ++__ds;

    iterator __r = iterator(__hold.release()->__as_link());

    iterator __e = __r;

    try {

      for (--__n; __n != 0; --__n, ++__e, ++__ds) {
        __hold.reset(__node_alloc_traits::allocate(__na, 1));
        __node_alloc_traits::construct(__na,
                                       std::__1::addressof(__hold->__value_));
        __e.__ptr_->__next_ = __hold.get()->__as_link();
        __hold->__prev_ = __e.__ptr_;
        __hold.release();
      }

    } catch (...) {
      while (true) {
        __node_alloc_traits::destroy(__na, std::__1::addressof(*__e));
        __link_pointer __prev = __e.__ptr_->__prev_;
        __node_alloc_traits::deallocate(__na, __e.__ptr_->__as_node(), 1);
        if (__prev == 0)
          break;

        __e = iterator(__prev);
      }
      throw;
    }

    __link_nodes_at_back(__r.__ptr_, __e.__ptr_);
    base::__sz() += __ds;
  }
}

template <class _Tp, class _Alloc>
void list<_Tp, _Alloc>::resize(size_type __n, const value_type &__x) {
  if (__n < base::__sz())
    erase(__iterator(__n), end());
  else if (__n > base::__sz()) {
    __n -= base::__sz();
    size_type __ds = 0;
    __node_allocator &__na = base::__node_alloc();
    __hold_pointer __hold = __allocate_node(__na);
    __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_),
                                   __x);
    ++__ds;
    __link_pointer __nl = __hold.release()->__as_link();

    iterator __r = iterator(__nl);

    iterator __e = __r;

    try {

      for (--__n; __n != 0; --__n, ++__e, ++__ds) {
        __hold.reset(__node_alloc_traits::allocate(__na, 1));
        __node_alloc_traits::construct(
            __na, std::__1::addressof(__hold->__value_), __x);
        __e.__ptr_->__next_ = __hold.get()->__as_link();
        __hold->__prev_ = __e.__ptr_;
        __hold.release();
      }

    } catch (...) {
      while (true) {
        __node_alloc_traits::destroy(__na, std::__1::addressof(*__e));
        __link_pointer __prev = __e.__ptr_->__prev_;
        __node_alloc_traits::deallocate(__na, __e.__ptr_->__as_node(), 1);
        if (__prev == 0)
          break;

        __e = iterator(__prev);
      }
      throw;
    }

    __link_nodes(base::__end_as_link(), __r.__ptr_, __e.__ptr_);
    base::__sz() += __ds;
  }
}

template <class _Tp, class _Alloc>
void list<_Tp, _Alloc>::splice(const_iterator __p, list &__c) {
  ((void)0);

  if (!__c.empty()) {
    __link_pointer __f = __c.__end_.__next_;
    __link_pointer __l = __c.__end_.__prev_;
    base::__unlink_nodes(__f, __l);
    __link_nodes(__p.__ptr_, __f, __l);
    base::__sz() += __c.__sz();
    __c.__sz() = 0;
# 2041 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/list" 3
  }
}

template <class _Tp, class _Alloc>
void list<_Tp, _Alloc>::splice(const_iterator __p, list &__c,
                               const_iterator __i) {
# 2059 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/list" 3
  if (__p.__ptr_ != __i.__ptr_ && __p.__ptr_ != __i.__ptr_->__next_) {
    __link_pointer __f = __i.__ptr_;
    base::__unlink_nodes(__f, __f);
    __link_nodes(__p.__ptr_, __f, __f);
    --__c.__sz();
    ++base::__sz();
# 2086 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/list" 3
  }
}

template <class _Tp, class _Alloc>
void list<_Tp, _Alloc>::splice(const_iterator __p, list &__c,
                               const_iterator __f, const_iterator __l) {
# 2109 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/list" 3
  if (__f != __l) {
    __link_pointer __first = __f.__ptr_;
    --__l;
    __link_pointer __last = __l.__ptr_;
    if (this != &__c) {
      size_type __s = std::__1::distance(__f, __l) + 1;
      __c.__sz() -= __s;
      base::__sz() += __s;
    }
    base::__unlink_nodes(__first, __last);
    __link_nodes(__p.__ptr_, __first, __last);
# 2146 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/list" 3
  }
}

template <class _Tp, class _Alloc>
typename list<_Tp, _Alloc>::__remove_return_type
list<_Tp, _Alloc>::remove(const value_type &__x) {
  list<_Tp, _Alloc> __deleted_nodes(get_allocator());
  for (const_iterator __i = begin(), __e = end(); __i != __e;) {
    if (*__i == __x) {
      const_iterator __j = std::__1::next(__i);
      for (; __j != __e && *__j == __x; ++__j)
        ;
      __deleted_nodes.splice(__deleted_nodes.end(), *this, __i, __j);
      __i = __j;
      if (__i != __e)
        ++__i;
    } else
      ++__i;
  }

  return (__remove_return_type)__deleted_nodes.size();
}

template <class _Tp, class _Alloc>
template <class _Pred>
typename list<_Tp, _Alloc>::__remove_return_type
list<_Tp, _Alloc>::remove_if(_Pred __pred) {
  list<_Tp, _Alloc> __deleted_nodes(get_allocator());
  for (iterator __i = begin(), __e = end(); __i != __e;) {
    if (__pred(*__i)) {
      iterator __j = std::__1::next(__i);
      for (; __j != __e && __pred(*__j); ++__j)
        ;
      __deleted_nodes.splice(__deleted_nodes.end(), *this, __i, __j);
      __i = __j;
      if (__i != __e)
        ++__i;
    } else
      ++__i;
  }

  return (__remove_return_type)__deleted_nodes.size();
}

template <class _Tp, class _Alloc>
template <class _BinaryPred>
typename list<_Tp, _Alloc>::__remove_return_type
list<_Tp, _Alloc>::unique(_BinaryPred __binary_pred) {
  list<_Tp, _Alloc> __deleted_nodes(get_allocator());
  for (iterator __i = begin(), __e = end(); __i != __e;) {
    iterator __j = std::__1::next(__i);
    for (; __j != __e && __binary_pred(*__i, *__j); ++__j)
      ;
    if (++__i != __j) {
      __deleted_nodes.splice(__deleted_nodes.end(), *this, __i, __j);
      __i = __j;
    }
  }

  return (__remove_return_type)__deleted_nodes.size();
}

template <class _Tp, class _Alloc>
inline void list<_Tp, _Alloc>::merge(list &__c) {
  merge(__c, __less<value_type>());
}

template <class _Tp, class _Alloc>
template <class _Comp>
void list<_Tp, _Alloc>::merge(list &__c, _Comp __comp) {
  if (this != std::__1::addressof(__c)) {
    iterator __f1 = begin();
    iterator __e1 = end();
    iterator __f2 = __c.begin();
    iterator __e2 = __c.end();
    while (__f1 != __e1 && __f2 != __e2) {
      if (__comp(*__f2, *__f1)) {
        size_type __ds = 1;
        iterator __m2 = std::__1::next(__f2);
        for (; __m2 != __e2 && __comp(*__m2, *__f1); ++__m2, ++__ds)
          ;
        base::__sz() += __ds;
        __c.__sz() -= __ds;
        __link_pointer __f = __f2.__ptr_;
        __link_pointer __l = __m2.__ptr_->__prev_;
        __f2 = __m2;
        base::__unlink_nodes(__f, __l);
        __m2 = std::__1::next(__f1);
        __link_nodes(__f1.__ptr_, __f, __l);
        __f1 = __m2;
      } else
        ++__f1;
    }
    splice(__e1, __c);
# 2277 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/list" 3
  }
}

template <class _Tp, class _Alloc> inline void list<_Tp, _Alloc>::sort() {
  sort(__less<value_type>());
}

template <class _Tp, class _Alloc>
template <class _Comp>
inline void list<_Tp, _Alloc>::sort(_Comp __comp) {
  __sort(begin(), end(), base::__sz(), __comp);
}

template <class _Tp, class _Alloc>
template <class _Comp>
typename list<_Tp, _Alloc>::iterator
list<_Tp, _Alloc>::__sort(iterator __f1, iterator __e2, size_type __n,
                          _Comp &__comp) {
  switch (__n) {
  case 0:
  case 1:
    return __f1;
  case 2:
    if (__comp(*--__e2, *__f1)) {
      __link_pointer __f = __e2.__ptr_;
      base::__unlink_nodes(__f, __f);
      __link_nodes(__f1.__ptr_, __f, __f);
      return __e2;
    }
    return __f1;
  }
  size_type __n2 = __n / 2;
  iterator __e1 = std::__1::next(__f1, __n2);
  iterator __r = __f1 = __sort(__f1, __e1, __n2, __comp);
  iterator __f2 = __e1 = __sort(__e1, __e2, __n - __n2, __comp);
  if (__comp(*__f2, *__f1)) {
    iterator __m2 = std::__1::next(__f2);
    for (; __m2 != __e2 && __comp(*__m2, *__f1); ++__m2)
      ;
    __link_pointer __f = __f2.__ptr_;
    __link_pointer __l = __m2.__ptr_->__prev_;
    __r = __f2;
    __e1 = __f2 = __m2;
    base::__unlink_nodes(__f, __l);
    __m2 = std::__1::next(__f1);
    __link_nodes(__f1.__ptr_, __f, __l);
    __f1 = __m2;
  } else
    ++__f1;
  while (__f1 != __e1 && __f2 != __e2) {
    if (__comp(*__f2, *__f1)) {
      iterator __m2 = std::__1::next(__f2);
      for (; __m2 != __e2 && __comp(*__m2, *__f1); ++__m2)
        ;
      __link_pointer __f = __f2.__ptr_;
      __link_pointer __l = __m2.__ptr_->__prev_;
      if (__e1 == __f2)
        __e1 = __m2;
      __f2 = __m2;
      base::__unlink_nodes(__f, __l);
      __m2 = std::__1::next(__f1);
      __link_nodes(__f1.__ptr_, __f, __l);
      __f1 = __m2;
    } else
      ++__f1;
  }
  return __r;
}

template <class _Tp, class _Alloc> void list<_Tp, _Alloc>::reverse() noexcept {
  if (base::__sz() > 1) {
    iterator __e = end();
    for (iterator __i = begin(); __i.__ptr_ != __e.__ptr_;) {
      std::__1::swap(__i.__ptr_->__prev_, __i.__ptr_->__next_);
      __i.__ptr_ = __i.__ptr_->__prev_;
    }
    std::__1::swap(__e.__ptr_->__prev_, __e.__ptr_->__next_);
  }
}

template <class _Tp, class _Alloc>
bool list<_Tp, _Alloc>::__invariants() const {
  return size() == std::__1::distance(begin(), end());
}
# 2415 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/list" 3
template <class _Tp, class _Alloc>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator==(const list<_Tp, _Alloc> &__x, const list<_Tp, _Alloc> &__y) {
  return __x.size() == __y.size() &&
         std::__1::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Tp, class _Alloc>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator<(const list<_Tp, _Alloc> &__x, const list<_Tp, _Alloc> &__y) {
  return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(),
                                           __y.end());
}

template <class _Tp, class _Alloc>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator!=(const list<_Tp, _Alloc> &__x, const list<_Tp, _Alloc> &__y) {
  return !(__x == __y);
}

template <class _Tp, class _Alloc>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator>(const list<_Tp, _Alloc> &__x, const list<_Tp, _Alloc> &__y) {
  return __y < __x;
}

template <class _Tp, class _Alloc>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator>=(const list<_Tp, _Alloc> &__x, const list<_Tp, _Alloc> &__y) {
  return !(__x < __y);
}

template <class _Tp, class _Alloc>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator<=(const list<_Tp, _Alloc> &__x, const list<_Tp, _Alloc> &__y) {
  return !(__y < __x);
}

template <class _Tp, class _Alloc>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
swap(list<_Tp, _Alloc> &__x,
     list<_Tp, _Alloc> &__y) noexcept(noexcept(__x.swap(__y))) {
  __x.swap(__y);
}
# 2484 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/list" 3
} // namespace __1
} // namespace std
# 56 "/usr/local/include/QtCore/qmetatype.h" 2
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/map" 1 3
# 478 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/map" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 479 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/map" 2 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__tree" 1 3
# 13 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__tree" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 14 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__tree" 2 3
# 21 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__tree" 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_macros" 1 3
# 25 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__tree" 2 3

namespace std {
inline namespace __1 {
# 36 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__tree" 3
template <class _Tp, class _Compare, class _Allocator> class __tree;
template <class _Tp, class _NodePtr, class _DiffType>
class __attribute__((__type_visibility__("default"))) __tree_iterator;
template <class _Tp, class _ConstNodePtr, class _DiffType>
class __attribute__((__type_visibility__("default"))) __tree_const_iterator;

template <class _Pointer> class __tree_end_node;
template <class _VoidPtr> class __tree_node_base;
template <class _Tp, class _VoidPtr> class __tree_node;

template <class _Key, class _Value> struct __value_type;

template <class _Allocator> class __map_node_destructor;
template <class _TreeIterator>
class __attribute__((__type_visibility__("default"))) __map_iterator;
template <class _TreeIterator>
class __attribute__((__type_visibility__("default"))) __map_const_iterator;
# 76 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__tree" 3
template <class _NodePtr>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
__tree_is_left_child(_NodePtr __x) noexcept {
  return __x == __x->__parent_->__left_;
}

template <class _NodePtr> unsigned __tree_sub_invariant(_NodePtr __x) {
  if (__x == nullptr)
    return 1;

  if (__x->__left_ != nullptr && __x->__left_->__parent_ != __x)
    return 0;

  if (__x->__right_ != nullptr && __x->__right_->__parent_ != __x)
    return 0;

  if (__x->__left_ == __x->__right_ && __x->__left_ != nullptr)
    return 0;

  if (!__x->__is_black_) {
    if (__x->__left_ && !__x->__left_->__is_black_)
      return 0;
    if (__x->__right_ && !__x->__right_->__is_black_)
      return 0;
  }
  unsigned __h = __tree_sub_invariant(__x->__left_);
  if (__h == 0)
    return 0;
  if (__h != __tree_sub_invariant(__x->__right_))
    return 0;
  return __h + __x->__is_black_;
}

template <class _NodePtr> bool __tree_invariant(_NodePtr __root) {
  if (__root == nullptr)
    return true;

  if (__root->__parent_ == nullptr)
    return false;
  if (!__tree_is_left_child(__root))
    return false;

  if (!__root->__is_black_)
    return false;

  return __tree_sub_invariant(__root) != 0;
}

template <class _NodePtr>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _NodePtr
__tree_min(_NodePtr __x) noexcept {
  while (__x->__left_ != nullptr)
    __x = __x->__left_;
  return __x;
}

template <class _NodePtr>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _NodePtr
__tree_max(_NodePtr __x) noexcept {
  while (__x->__right_ != nullptr)
    __x = __x->__right_;
  return __x;
}

template <class _NodePtr> _NodePtr __tree_next(_NodePtr __x) noexcept {
  if (__x->__right_ != nullptr)
    return __tree_min(__x->__right_);
  while (!__tree_is_left_child(__x))
    __x = __x->__parent_unsafe();
  return __x->__parent_unsafe();
}

template <class _EndNodePtr, class _NodePtr>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _EndNodePtr
__tree_next_iter(_NodePtr __x) noexcept {
  if (__x->__right_ != nullptr)
    return static_cast<_EndNodePtr>(__tree_min(__x->__right_));
  while (!__tree_is_left_child(__x))
    __x = __x->__parent_unsafe();
  return static_cast<_EndNodePtr>(__x->__parent_);
}

template <class _NodePtr, class _EndNodePtr>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) _NodePtr
__tree_prev_iter(_EndNodePtr __x) noexcept {
  if (__x->__left_ != nullptr)
    return __tree_max(__x->__left_);
  _NodePtr __xx = static_cast<_NodePtr>(__x);
  while (__tree_is_left_child(__xx))
    __xx = __xx->__parent_unsafe();
  return __xx->__parent_unsafe();
}

template <class _NodePtr> _NodePtr __tree_leaf(_NodePtr __x) noexcept {
  while (true) {
    if (__x->__left_ != nullptr) {
      __x = __x->__left_;
      continue;
    }
    if (__x->__right_ != nullptr) {
      __x = __x->__right_;
      continue;
    }
    break;
  }
  return __x;
}

template <class _NodePtr> void __tree_left_rotate(_NodePtr __x) noexcept {
  _NodePtr __y = __x->__right_;
  __x->__right_ = __y->__left_;
  if (__x->__right_ != nullptr)
    __x->__right_->__set_parent(__x);
  __y->__parent_ = __x->__parent_;
  if (__tree_is_left_child(__x))
    __x->__parent_->__left_ = __y;
  else
    __x->__parent_unsafe()->__right_ = __y;
  __y->__left_ = __x;
  __x->__set_parent(__y);
}

template <class _NodePtr> void __tree_right_rotate(_NodePtr __x) noexcept {
  _NodePtr __y = __x->__left_;
  __x->__left_ = __y->__right_;
  if (__x->__left_ != nullptr)
    __x->__left_->__set_parent(__x);
  __y->__parent_ = __x->__parent_;
  if (__tree_is_left_child(__x))
    __x->__parent_->__left_ = __y;
  else
    __x->__parent_unsafe()->__right_ = __y;
  __y->__right_ = __x;
  __x->__set_parent(__y);
}
# 276 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__tree" 3
template <class _NodePtr>
void __tree_balance_after_insert(_NodePtr __root, _NodePtr __x) noexcept {
  __x->__is_black_ = __x == __root;
  while (__x != __root && !__x->__parent_unsafe()->__is_black_) {

    if (__tree_is_left_child(__x->__parent_unsafe())) {
      _NodePtr __y = __x->__parent_unsafe()->__parent_unsafe()->__right_;
      if (__y != nullptr && !__y->__is_black_) {
        __x = __x->__parent_unsafe();
        __x->__is_black_ = true;
        __x = __x->__parent_unsafe();
        __x->__is_black_ = __x == __root;
        __y->__is_black_ = true;
      } else {
        if (!__tree_is_left_child(__x)) {
          __x = __x->__parent_unsafe();
          __tree_left_rotate(__x);
        }
        __x = __x->__parent_unsafe();
        __x->__is_black_ = true;
        __x = __x->__parent_unsafe();
        __x->__is_black_ = false;
        __tree_right_rotate(__x);
        break;
      }
    } else {
      _NodePtr __y = __x->__parent_unsafe()->__parent_->__left_;
      if (__y != nullptr && !__y->__is_black_) {
        __x = __x->__parent_unsafe();
        __x->__is_black_ = true;
        __x = __x->__parent_unsafe();
        __x->__is_black_ = __x == __root;
        __y->__is_black_ = true;
      } else {
        if (__tree_is_left_child(__x)) {
          __x = __x->__parent_unsafe();
          __tree_right_rotate(__x);
        }
        __x = __x->__parent_unsafe();
        __x->__is_black_ = true;
        __x = __x->__parent_unsafe();
        __x->__is_black_ = false;
        __tree_left_rotate(__x);
        break;
      }
    }
  }
}
# 346 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__tree" 3
template <class _NodePtr>
void __tree_remove(_NodePtr __root, _NodePtr __z) noexcept {

  _NodePtr __y = (__z->__left_ == nullptr || __z->__right_ == nullptr)
                     ? __z
                     : __tree_next(__z);

  _NodePtr __x = __y->__left_ != nullptr ? __y->__left_ : __y->__right_;

  _NodePtr __w = nullptr;

  if (__x != nullptr)
    __x->__parent_ = __y->__parent_;
  if (__tree_is_left_child(__y)) {
    __y->__parent_->__left_ = __x;
    if (__y != __root)
      __w = __y->__parent_unsafe()->__right_;
    else
      __root = __x;
  } else {
    __y->__parent_unsafe()->__right_ = __x;

    __w = __y->__parent_->__left_;
  }
  bool __removed_black = __y->__is_black_;

  if (__y != __z) {

    __y->__parent_ = __z->__parent_;
    if (__tree_is_left_child(__z))
      __y->__parent_->__left_ = __y;
    else
      __y->__parent_unsafe()->__right_ = __y;
    __y->__left_ = __z->__left_;
    __y->__left_->__set_parent(__y);
    __y->__right_ = __z->__right_;
    if (__y->__right_ != nullptr)
      __y->__right_->__set_parent(__y);
    __y->__is_black_ = __z->__is_black_;
    if (__root == __z)
      __root = __y;
  }

  if (__removed_black && __root != nullptr) {
# 413 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__tree" 3
    if (__x != nullptr)
      __x->__is_black_ = true;
    else {

      while (true) {
        if (!__tree_is_left_child(__w)) {
          if (!__w->__is_black_) {
            __w->__is_black_ = true;
            __w->__parent_unsafe()->__is_black_ = false;
            __tree_left_rotate(__w->__parent_unsafe());

            if (__root == __w->__left_)
              __root = __w;

            __w = __w->__left_->__right_;
          }

          if ((__w->__left_ == nullptr || __w->__left_->__is_black_) &&
              (__w->__right_ == nullptr || __w->__right_->__is_black_)) {
            __w->__is_black_ = false;
            __x = __w->__parent_unsafe();

            if (__x == __root || !__x->__is_black_) {
              __x->__is_black_ = true;
              break;
            }

            __w = __tree_is_left_child(__x) ? __x->__parent_unsafe()->__right_
                                            : __x->__parent_->__left_;

          } else {
            if (__w->__right_ == nullptr || __w->__right_->__is_black_) {

              __w->__left_->__is_black_ = true;
              __w->__is_black_ = false;
              __tree_right_rotate(__w);

              __w = __w->__parent_unsafe();
            }

            __w->__is_black_ = __w->__parent_unsafe()->__is_black_;
            __w->__parent_unsafe()->__is_black_ = true;
            __w->__right_->__is_black_ = true;
            __tree_left_rotate(__w->__parent_unsafe());
            break;
          }
        } else {
          if (!__w->__is_black_) {
            __w->__is_black_ = true;
            __w->__parent_unsafe()->__is_black_ = false;
            __tree_right_rotate(__w->__parent_unsafe());

            if (__root == __w->__right_)
              __root = __w;

            __w = __w->__right_->__left_;
          }

          if ((__w->__left_ == nullptr || __w->__left_->__is_black_) &&
              (__w->__right_ == nullptr || __w->__right_->__is_black_)) {
            __w->__is_black_ = false;
            __x = __w->__parent_unsafe();

            if (!__x->__is_black_ || __x == __root) {
              __x->__is_black_ = true;
              break;
            }

            __w = __tree_is_left_child(__x) ? __x->__parent_unsafe()->__right_
                                            : __x->__parent_->__left_;

          } else {
            if (__w->__left_ == nullptr || __w->__left_->__is_black_) {

              __w->__right_->__is_black_ = true;
              __w->__is_black_ = false;
              __tree_left_rotate(__w);

              __w = __w->__parent_unsafe();
            }

            __w->__is_black_ = __w->__parent_unsafe()->__is_black_;
            __w->__parent_unsafe()->__is_black_ = true;
            __w->__left_->__is_black_ = true;
            __tree_right_rotate(__w->__parent_unsafe());
            break;
          }
        }
      }
    }
  }
}

template <class _Tp> struct __is_tree_value_type_imp : false_type {};

template <class _Key, class _Value>
struct __is_tree_value_type_imp<__value_type<_Key, _Value>> : true_type {};

template <class... _Args> struct __is_tree_value_type : false_type {};

template <class _One>
struct __is_tree_value_type<_One>
    : __is_tree_value_type_imp<typename __uncvref<_One>::type> {};

template <class _Tp> struct __tree_key_value_types {
  typedef _Tp key_type;
  typedef _Tp __node_value_type;
  typedef _Tp __container_value_type;
  static const bool __is_map = false;

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static key_type const &
  __get_key(_Tp const &__v) {
    return __v;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static __container_value_type const &
  __get_value(__node_value_type const &__v) {
    return __v;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static __container_value_type *
  __get_ptr(__node_value_type &__n) {
    return std::__1::addressof(__n);
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static __container_value_type &&
  __move(__node_value_type &__v) {
    return std::__1::move(__v);
  }
};

template <class _Key, class _Tp>
struct __tree_key_value_types<__value_type<_Key, _Tp>> {
  typedef _Key key_type;
  typedef _Tp mapped_type;
  typedef __value_type<_Key, _Tp> __node_value_type;
  typedef pair<const _Key, _Tp> __container_value_type;
  typedef __container_value_type __map_value_type;
  static const bool __is_map = true;

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static key_type const &
  __get_key(__node_value_type const &__t) {
    return __t.__get_value().first;
  }

  template <class _Up>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static
      typename enable_if<__is_same_uncvref<_Up, __container_value_type>::value,
                         key_type const &>::type
      __get_key(_Up &__t) {
    return __t.first;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static __container_value_type const &
  __get_value(__node_value_type const &__t) {
    return __t.__get_value();
  }

  template <class _Up>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static
      typename enable_if<__is_same_uncvref<_Up, __container_value_type>::value,
                         __container_value_type const &>::type
      __get_value(_Up &__t) {
    return __t;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static __container_value_type *
  __get_ptr(__node_value_type &__n) {
    return std::__1::addressof(__n.__get_value());
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) static pair<key_type &&, mapped_type &&>
  __move(__node_value_type &__v) {
    return __v.__move();
  }
};

template <class _VoidPtr> struct __tree_node_base_types {
  typedef _VoidPtr __void_pointer;

  typedef __tree_node_base<__void_pointer> __node_base_type;
  typedef typename __rebind_pointer<_VoidPtr, __node_base_type>::type
      __node_base_pointer;

  typedef __tree_end_node<__node_base_pointer> __end_node_type;
  typedef typename __rebind_pointer<_VoidPtr, __end_node_type>::type
      __end_node_pointer;

  typedef typename conditional<is_pointer<__end_node_pointer>::value,
                               __end_node_pointer, __node_base_pointer>::type
      __parent_pointer;

private:
  static_assert(
      (is_same<typename pointer_traits<_VoidPtr>::element_type, void>::value),
      "_VoidPtr does not point to unqualified void type");
};

template <class _Tp, class _AllocPtr,
          class _KVTypes = __tree_key_value_types<_Tp>,
          bool = _KVTypes::__is_map>
struct __tree_map_pointer_types {};

template <class _Tp, class _AllocPtr, class _KVTypes>
struct __tree_map_pointer_types<_Tp, _AllocPtr, _KVTypes, true> {
  typedef typename _KVTypes::__map_value_type _Mv;
  typedef
      typename __rebind_pointer<_AllocPtr, _Mv>::type __map_value_type_pointer;
  typedef typename __rebind_pointer<_AllocPtr, const _Mv>::type
      __const_map_value_type_pointer;
};

template <class _NodePtr,
          class _NodeT = typename pointer_traits<_NodePtr>::element_type>
struct __tree_node_types;

template <class _NodePtr, class _Tp, class _VoidPtr>
struct __tree_node_types<_NodePtr, __tree_node<_Tp, _VoidPtr>>
    : public __tree_node_base_types<_VoidPtr>,
      __tree_key_value_types<_Tp>,
      __tree_map_pointer_types<_Tp, _VoidPtr> {
  typedef __tree_node_base_types<_VoidPtr> __base;
  typedef __tree_key_value_types<_Tp> __key_base;
  typedef __tree_map_pointer_types<_Tp, _VoidPtr> __map_pointer_base;

public:
  typedef typename pointer_traits<_NodePtr>::element_type __node_type;
  typedef _NodePtr __node_pointer;

  typedef _Tp __node_value_type;
  typedef typename __rebind_pointer<_VoidPtr, __node_value_type>::type
      __node_value_type_pointer;
  typedef typename __rebind_pointer<_VoidPtr, const __node_value_type>::type
      __const_node_value_type_pointer;

  typedef typename conditional<is_pointer<__node_pointer>::value,
                               typename __base::__end_node_pointer,
                               __node_pointer>::type __iter_pointer;

private:
  static_assert(!is_const<__node_type>::value,
                "_NodePtr should never be a pointer to const");
  static_assert((is_same<typename __rebind_pointer<_VoidPtr, __node_type>::type,
                         _NodePtr>::value),
                "_VoidPtr does not rebind to _NodePtr.");
};

template <class _ValueTp, class _VoidPtr> struct __make_tree_node_types {
  typedef
      typename __rebind_pointer<_VoidPtr, __tree_node<_ValueTp, _VoidPtr>>::type
          _NodePtr;
  typedef __tree_node_types<_NodePtr> type;
};

template <class _Pointer> class __tree_end_node {
public:
  typedef _Pointer pointer;
  pointer __left_;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __tree_end_node() noexcept
      : __left_() {}
};

template <class _VoidPtr>
class __tree_node_base
    : public __tree_node_base_types<_VoidPtr>::__end_node_type {
  typedef __tree_node_base_types<_VoidPtr> _NodeBaseTypes;

public:
  typedef typename _NodeBaseTypes::__node_base_pointer pointer;
  typedef typename _NodeBaseTypes::__parent_pointer __parent_pointer;

  pointer __right_;
  __parent_pointer __parent_;
  bool __is_black_;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pointer
  __parent_unsafe() const {
    return static_cast<pointer>(__parent_);
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __set_parent(pointer __p) {
    __parent_ = static_cast<__parent_pointer>(__p);
  }

private:
  ~__tree_node_base() = delete;
  __tree_node_base(__tree_node_base const &) = delete;
  __tree_node_base &operator=(__tree_node_base const &) = delete;
};

template <class _Tp, class _VoidPtr>
class __tree_node : public __tree_node_base<_VoidPtr> {
public:
  typedef _Tp __node_value_type;

  __node_value_type __value_;

private:
  ~__tree_node() = delete;
  __tree_node(__tree_node const &) = delete;
  __tree_node &operator=(__tree_node const &) = delete;
};

template <class _Allocator> class __tree_node_destructor {
  typedef _Allocator allocator_type;
  typedef allocator_traits<allocator_type> __alloc_traits;

public:
  typedef typename __alloc_traits::pointer pointer;

private:
  typedef __tree_node_types<pointer> _NodeTypes;
  allocator_type &__na_;

public:
  bool __value_constructed;

  __tree_node_destructor(const __tree_node_destructor &) = default;
  __tree_node_destructor &operator=(const __tree_node_destructor &) = delete;

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit __tree_node_destructor(
      allocator_type &__na, bool __val = false) noexcept
      : __na_(__na), __value_constructed(__val) {}

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  operator()(pointer __p) noexcept {
    if (__value_constructed)
      __alloc_traits::destroy(__na_, _NodeTypes::__get_ptr(__p->__value_));
    if (__p)
      __alloc_traits::deallocate(__na_, __p, 1);
  }

  template <class> friend class __map_node_destructor;
};
# 815 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__tree" 3
template <class _Tp, class _NodePtr, class _DiffType>
class __attribute__((__type_visibility__("default"))) __tree_iterator {
  typedef __tree_node_types<_NodePtr> _NodeTypes;
  typedef _NodePtr __node_pointer;
  typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;
  typedef typename _NodeTypes::__end_node_pointer __end_node_pointer;
  typedef typename _NodeTypes::__iter_pointer __iter_pointer;
  typedef pointer_traits<__node_pointer> __pointer_traits;

  __iter_pointer __ptr_;

public:
  typedef bidirectional_iterator_tag iterator_category;
  typedef _Tp value_type;
  typedef _DiffType difference_type;
  typedef value_type &reference;
  typedef typename _NodeTypes::__node_value_type_pointer pointer;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __tree_iterator() noexcept

      : __ptr_(nullptr)

  {}

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reference
  operator*() const {
    return __get_np()->__value_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pointer
  operator->() const {
    return pointer_traits<pointer>::pointer_to(__get_np()->__value_);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __tree_iterator &
  operator++() {
    __ptr_ = static_cast<__iter_pointer>(__tree_next_iter<__end_node_pointer>(
        static_cast<__node_base_pointer>(__ptr_)));
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __tree_iterator
  operator++(int) {
    __tree_iterator __t(*this);
    ++(*this);
    return __t;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __tree_iterator &
  operator--() {
    __ptr_ = static_cast<__iter_pointer>(__tree_prev_iter<__node_base_pointer>(
        static_cast<__end_node_pointer>(__ptr_)));
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __tree_iterator
  operator--(int) {
    __tree_iterator __t(*this);
    --(*this);
    return __t;
  }

  friend __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator==(const __tree_iterator &__x, const __tree_iterator &__y) {
    return __x.__ptr_ == __y.__ptr_;
  }
  friend __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator!=(const __tree_iterator &__x, const __tree_iterator &__y) {
    return !(__x == __y);
  }

private:
  __attribute__((__visibility__("hidden"))) __attribute__((
      internal_linkage)) explicit __tree_iterator(__node_pointer __p) noexcept
      : __ptr_(__p) {}
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit __tree_iterator(
      __end_node_pointer __p) noexcept
      : __ptr_(__p) {}
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __node_pointer
  __get_np() const {
    return static_cast<__node_pointer>(__ptr_);
  }
  template <class, class, class> friend class __tree;
  template <class, class, class>
  friend class __attribute__((__type_visibility__("default")))
  __tree_const_iterator;
  template <class>
  friend class __attribute__((__type_visibility__("default"))) __map_iterator;
  template <class, class, class, class>
  friend class __attribute__((__type_visibility__("default"))) map;
  template <class, class, class, class>
  friend class __attribute__((__type_visibility__("default"))) multimap;
  template <class, class, class>
  friend class __attribute__((__type_visibility__("default"))) set;
  template <class, class, class>
  friend class __attribute__((__type_visibility__("default"))) multiset;
};

template <class _Tp, class _NodePtr, class _DiffType>
class __attribute__((__type_visibility__("default"))) __tree_const_iterator {
  typedef __tree_node_types<_NodePtr> _NodeTypes;
  typedef typename _NodeTypes::__node_pointer __node_pointer;
  typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;
  typedef typename _NodeTypes::__end_node_pointer __end_node_pointer;
  typedef typename _NodeTypes::__iter_pointer __iter_pointer;
  typedef pointer_traits<__node_pointer> __pointer_traits;

  __iter_pointer __ptr_;

public:
  typedef bidirectional_iterator_tag iterator_category;
  typedef _Tp value_type;
  typedef _DiffType difference_type;
  typedef const value_type &reference;
  typedef typename _NodeTypes::__const_node_value_type_pointer pointer;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __tree_const_iterator() noexcept

      : __ptr_(nullptr)

  {}

private:
  typedef __tree_iterator<value_type, __node_pointer, difference_type>
      __non_const_iterator;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __tree_const_iterator(__non_const_iterator __p) noexcept
      : __ptr_(__p.__ptr_) {}

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reference
  operator*() const {
    return __get_np()->__value_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pointer
  operator->() const {
    return pointer_traits<pointer>::pointer_to(__get_np()->__value_);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __tree_const_iterator &
  operator++() {
    __ptr_ = static_cast<__iter_pointer>(__tree_next_iter<__end_node_pointer>(
        static_cast<__node_base_pointer>(__ptr_)));
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __tree_const_iterator
  operator++(int) {
    __tree_const_iterator __t(*this);
    ++(*this);
    return __t;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __tree_const_iterator &
  operator--() {
    __ptr_ = static_cast<__iter_pointer>(__tree_prev_iter<__node_base_pointer>(
        static_cast<__end_node_pointer>(__ptr_)));
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __tree_const_iterator
  operator--(int) {
    __tree_const_iterator __t(*this);
    --(*this);
    return __t;
  }

  friend __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator==(const __tree_const_iterator &__x,
             const __tree_const_iterator &__y) {
    return __x.__ptr_ == __y.__ptr_;
  }
  friend __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator!=(const __tree_const_iterator &__x,
             const __tree_const_iterator &__y) {
    return !(__x == __y);
  }

private:
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit __tree_const_iterator(
      __node_pointer __p) noexcept
      : __ptr_(__p) {}
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit __tree_const_iterator(
      __end_node_pointer __p) noexcept
      : __ptr_(__p) {}
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __node_pointer
  __get_np() const {
    return static_cast<__node_pointer>(__ptr_);
  }

  template <class, class, class> friend class __tree;
  template <class, class, class, class>
  friend class __attribute__((__type_visibility__("default"))) map;
  template <class, class, class, class>
  friend class __attribute__((__type_visibility__("default"))) multimap;
  template <class, class, class>
  friend class __attribute__((__type_visibility__("default"))) set;
  template <class, class, class>
  friend class __attribute__((__type_visibility__("default"))) multiset;
  template <class>
  friend class __attribute__((__type_visibility__("default")))
  __map_const_iterator;
};

template<class _Tp, class _Compare>

    __attribute__((diagnose_if(!std::__invokable<_Compare const&, _Tp const&, _Tp const&>::value, "the specified comparator type does not provide a viable const call operator", "warning")))


int __diagnose_non_const_comparator();

template <class _Tp, class _Compare, class _Allocator> class __tree {
public:
  typedef _Tp value_type;
  typedef _Compare value_compare;
  typedef _Allocator allocator_type;

private:
  typedef allocator_traits<allocator_type> __alloc_traits;
  typedef typename __make_tree_node_types<
      value_type, typename __alloc_traits::void_pointer>::type _NodeTypes;
  typedef typename _NodeTypes::key_type key_type;

public:
  typedef typename _NodeTypes::__node_value_type __node_value_type;
  typedef typename _NodeTypes::__container_value_type __container_value_type;

  typedef typename __alloc_traits::pointer pointer;
  typedef typename __alloc_traits::const_pointer const_pointer;
  typedef typename __alloc_traits::size_type size_type;
  typedef typename __alloc_traits::difference_type difference_type;

public:
  typedef typename _NodeTypes::__void_pointer __void_pointer;

  typedef typename _NodeTypes::__node_type __node;
  typedef typename _NodeTypes::__node_pointer __node_pointer;

  typedef typename _NodeTypes::__node_base_type __node_base;
  typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;

  typedef typename _NodeTypes::__end_node_type __end_node_t;
  typedef typename _NodeTypes::__end_node_pointer __end_node_ptr;

  typedef typename _NodeTypes::__parent_pointer __parent_pointer;
  typedef typename _NodeTypes::__iter_pointer __iter_pointer;

  typedef typename __rebind_alloc_helper<__alloc_traits, __node>::type
      __node_allocator;
  typedef allocator_traits<__node_allocator> __node_traits;

private:
  static_assert(
      (is_same<__node_pointer, typename __node_traits::pointer>::value),
      "Allocator does not rebind pointers in a sane manner.");
  typedef typename __rebind_alloc_helper<__node_traits, __node_base>::type
      __node_base_allocator;
  typedef allocator_traits<__node_base_allocator> __node_base_traits;
  static_assert((is_same<__node_base_pointer,
                         typename __node_base_traits::pointer>::value),
                "Allocator does not rebind pointers in a sane manner.");

private:
  __iter_pointer __begin_node_;
  __compressed_pair<__end_node_t, __node_allocator> __pair1_;
  __compressed_pair<size_type, value_compare> __pair3_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __iter_pointer
  __end_node() noexcept {
    return static_cast<__iter_pointer>(
        pointer_traits<__end_node_ptr>::pointer_to(__pair1_.first()));
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __iter_pointer
  __end_node() const noexcept {
    return static_cast<__iter_pointer>(
        pointer_traits<__end_node_ptr>::pointer_to(
            const_cast<__end_node_t &>(__pair1_.first())));
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __node_allocator &
  __node_alloc() noexcept {
    return __pair1_.second();
  }

private:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const __node_allocator &
  __node_alloc() const noexcept {
    return __pair1_.second();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __iter_pointer &
  __begin_node() noexcept {
    return __begin_node_;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const __iter_pointer &
  __begin_node() const noexcept {
    return __begin_node_;
  }

public:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  allocator_type
  __alloc() const noexcept {
    return allocator_type(__node_alloc());
  }

private:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type &
  size() noexcept {
    return __pair3_.first();
  }

public:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const size_type &
  size() const noexcept {
    return __pair3_.first();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  value_compare &
  value_comp() noexcept {
    return __pair3_.second();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const value_compare &
  value_comp() const noexcept {
    return __pair3_.second();
  }

public:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __node_pointer
  __root() const noexcept {
    return static_cast<__node_pointer>(__end_node()->__left_);
  }

  __node_base_pointer *__root_ptr() const noexcept {
    return std::__1::addressof(__end_node()->__left_);
  }

  typedef __tree_iterator<value_type, __node_pointer, difference_type> iterator;
  typedef __tree_const_iterator<value_type, __node_pointer, difference_type>
      const_iterator;

  explicit __tree(const value_compare &__comp) noexcept(
      is_nothrow_default_constructible<__node_allocator>::value
          &&is_nothrow_copy_constructible<value_compare>::value);

  explicit __tree(const allocator_type &__a);
  __tree(const value_compare &__comp, const allocator_type &__a);
  __tree(const __tree &__t);
  __tree &operator=(const __tree &__t);
  template <class _ForwardIterator>
  void __assign_unique(_ForwardIterator __first, _ForwardIterator __last);
  template <class _InputIterator>
  void __assign_multi(_InputIterator __first, _InputIterator __last);

  __tree(__tree &&__t) noexcept(
      is_nothrow_move_constructible<__node_allocator>::value
          &&is_nothrow_move_constructible<value_compare>::value);

  __tree(__tree &&__t, const allocator_type &__a);
  __tree &operator=(__tree &&__t) noexcept(
      __node_traits::propagate_on_container_move_assignment::value
          &&is_nothrow_move_assignable<value_compare>::value
              &&is_nothrow_move_assignable<__node_allocator>::value);

  ~__tree();

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  begin() noexcept {
    return iterator(__begin_node());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_iterator
  begin() const noexcept {
    return const_iterator(__begin_node());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  end() noexcept {
    return iterator(__end_node());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_iterator
  end() const noexcept {
    return const_iterator(__end_node());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  max_size() const noexcept {
    return std::min<size_type>(__node_traits::max_size(__node_alloc()),
                               numeric_limits<difference_type>::max());
  }

  void clear() noexcept;

  void swap(__tree &__t)

      noexcept(__is_nothrow_swappable<value_compare>::value);

  template <class _Key, class... _Args>
  pair<iterator, bool> __emplace_unique_key_args(_Key const &,
                                                 _Args &&...__args);
  template <class _Key, class... _Args>
  iterator __emplace_hint_unique_key_args(const_iterator, _Key const &,
                                          _Args &&...);

  template <class... _Args>
  pair<iterator, bool> __emplace_unique_impl(_Args &&...__args);

  template <class... _Args>
  iterator __emplace_hint_unique_impl(const_iterator __p, _Args &&...__args);

  template <class... _Args> iterator __emplace_multi(_Args &&...__args);

  template <class... _Args>
  iterator __emplace_hint_multi(const_iterator __p, _Args &&...__args);

  template <class _Pp>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pair<iterator, bool>
  __emplace_unique(_Pp &&__x) {
    return __emplace_unique_extract_key(std::__1::forward<_Pp>(__x),
                                        __can_extract_key<_Pp, key_type>());
  }

  template <class _First, class _Second>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename enable_if<
      __can_extract_map_key<_First, key_type, __container_value_type>::value,
      pair<iterator, bool>>::type
  __emplace_unique(_First &&__f, _Second &&__s) {
    return __emplace_unique_key_args(__f, std::__1::forward<_First>(__f),
                                     std::__1::forward<_Second>(__s));
  }

  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pair<iterator, bool>
  __emplace_unique(_Args &&...__args) {
    return __emplace_unique_impl(std::__1::forward<_Args>(__args)...);
  }

  template <class _Pp>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pair<iterator, bool>
  __emplace_unique_extract_key(_Pp &&__x, __extract_key_fail_tag) {
    return __emplace_unique_impl(std::__1::forward<_Pp>(__x));
  }

  template <class _Pp>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pair<iterator, bool>
  __emplace_unique_extract_key(_Pp &&__x, __extract_key_self_tag) {
    return __emplace_unique_key_args(__x, std::__1::forward<_Pp>(__x));
  }

  template <class _Pp>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pair<iterator, bool>
  __emplace_unique_extract_key(_Pp &&__x, __extract_key_first_tag) {
    return __emplace_unique_key_args(__x.first, std::__1::forward<_Pp>(__x));
  }

  template <class _Pp>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  __emplace_hint_unique(const_iterator __p, _Pp &&__x) {
    return __emplace_hint_unique_extract_key(
        __p, std::__1::forward<_Pp>(__x), __can_extract_key<_Pp, key_type>());
  }

  template <class _First, class _Second>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename enable_if<
      __can_extract_map_key<_First, key_type, __container_value_type>::value,
      iterator>::type
  __emplace_hint_unique(const_iterator __p, _First &&__f, _Second &&__s) {
    return __emplace_hint_unique_key_args(__p, __f,
                                          std::__1::forward<_First>(__f),
                                          std::__1::forward<_Second>(__s));
  }

  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  __emplace_hint_unique(const_iterator __p, _Args &&...__args) {
    return __emplace_hint_unique_impl(__p, std::__1::forward<_Args>(__args)...);
  }

  template <class _Pp>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  __emplace_hint_unique_extract_key(const_iterator __p, _Pp &&__x,
                                    __extract_key_fail_tag) {
    return __emplace_hint_unique_impl(__p, std::__1::forward<_Pp>(__x));
  }

  template <class _Pp>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  __emplace_hint_unique_extract_key(const_iterator __p, _Pp &&__x,
                                    __extract_key_self_tag) {
    return __emplace_hint_unique_key_args(__p, __x,
                                          std::__1::forward<_Pp>(__x));
  }

  template <class _Pp>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  __emplace_hint_unique_extract_key(const_iterator __p, _Pp &&__x,
                                    __extract_key_first_tag) {
    return __emplace_hint_unique_key_args(__p, __x.first,
                                          std::__1::forward<_Pp>(__x));
  }
# 1267 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__tree" 3
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pair<iterator, bool>
  __insert_unique(const __container_value_type &__v) {
    return __emplace_unique_key_args(_NodeTypes::__get_key(__v), __v);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  __insert_unique(const_iterator __p, const __container_value_type &__v) {
    return __emplace_hint_unique_key_args(__p, _NodeTypes::__get_key(__v), __v);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pair<iterator, bool>
  __insert_unique(__container_value_type &&__v) {
    return __emplace_unique_key_args(_NodeTypes::__get_key(__v),
                                     std::__1::move(__v));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  __insert_unique(const_iterator __p, __container_value_type &&__v) {
    return __emplace_hint_unique_key_args(__p, _NodeTypes::__get_key(__v),
                                          std::__1::move(__v));
  }

  template <class _Vp, class = typename enable_if<
                           !is_same<typename __unconstref<_Vp>::type,
                                    __container_value_type>::value>::type>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pair<iterator, bool>
  __insert_unique(_Vp &&__v) {
    return __emplace_unique(std::__1::forward<_Vp>(__v));
  }

  template <class _Vp, class = typename enable_if<
                           !is_same<typename __unconstref<_Vp>::type,
                                    __container_value_type>::value>::type>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  __insert_unique(const_iterator __p, _Vp &&__v) {
    return __emplace_hint_unique(__p, std::__1::forward<_Vp>(__v));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  __insert_multi(__container_value_type &&__v) {
    return __emplace_multi(std::__1::move(__v));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  __insert_multi(const_iterator __p, __container_value_type &&__v) {
    return __emplace_hint_multi(__p, std::__1::move(__v));
  }

  template <class _Vp>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  __insert_multi(_Vp &&__v) {
    return __emplace_multi(std::__1::forward<_Vp>(__v));
  }

  template <class _Vp>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  __insert_multi(const_iterator __p, _Vp &&__v) {
    return __emplace_hint_multi(__p, std::__1::forward<_Vp>(__v));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pair<iterator, bool>
  __node_assign_unique(const __container_value_type &__v,
                       __node_pointer __dest);

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  __node_insert_multi(__node_pointer __nd);
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  __node_insert_multi(const_iterator __p, __node_pointer __nd);

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator __remove_node_pointer(__node_pointer) noexcept;
# 1379 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__tree" 3
  iterator erase(const_iterator __p);
  iterator erase(const_iterator __f, const_iterator __l);
  template <class _Key> size_type __erase_unique(const _Key &__k);
  template <class _Key> size_type __erase_multi(const _Key &__k);

  void __insert_node_at(__parent_pointer __parent, __node_base_pointer &__child,
                        __node_base_pointer __new_node) noexcept;

  template <class _Key> iterator find(const _Key &__v);
  template <class _Key> const_iterator find(const _Key &__v) const;

  template <class _Key> size_type __count_unique(const _Key &__k) const;
  template <class _Key> size_type __count_multi(const _Key &__k) const;

  template <class _Key>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  lower_bound(const _Key &__v) {
    return __lower_bound(__v, __root(), __end_node());
  }
  template <class _Key>
  iterator __lower_bound(const _Key &__v, __node_pointer __root,
                         __iter_pointer __result);
  template <class _Key>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_iterator
  lower_bound(const _Key &__v) const {
    return __lower_bound(__v, __root(), __end_node());
  }
  template <class _Key>
  const_iterator __lower_bound(const _Key &__v, __node_pointer __root,
                               __iter_pointer __result) const;
  template <class _Key>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  upper_bound(const _Key &__v) {
    return __upper_bound(__v, __root(), __end_node());
  }
  template <class _Key>
  iterator __upper_bound(const _Key &__v, __node_pointer __root,
                         __iter_pointer __result);
  template <class _Key>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_iterator
  upper_bound(const _Key &__v) const {
    return __upper_bound(__v, __root(), __end_node());
  }
  template <class _Key>
  const_iterator __upper_bound(const _Key &__v, __node_pointer __root,
                               __iter_pointer __result) const;
  template <class _Key>
  pair<iterator, iterator> __equal_range_unique(const _Key &__k);
  template <class _Key>
  pair<const_iterator, const_iterator>
  __equal_range_unique(const _Key &__k) const;

  template <class _Key>
  pair<iterator, iterator> __equal_range_multi(const _Key &__k);
  template <class _Key>
  pair<const_iterator, const_iterator>
  __equal_range_multi(const _Key &__k) const;

  typedef __tree_node_destructor<__node_allocator> _Dp;
  typedef unique_ptr<__node, _Dp> __node_holder;

  __node_holder remove(const_iterator __p) noexcept;

private:
  __node_base_pointer &__find_leaf_low(__parent_pointer &__parent,
                                       const key_type &__v);
  __node_base_pointer &__find_leaf_high(__parent_pointer &__parent,
                                        const key_type &__v);
  __node_base_pointer &__find_leaf(const_iterator __hint,
                                   __parent_pointer &__parent,
                                   const key_type &__v);

  template <class _Key>
  __node_base_pointer &__find_equal(__parent_pointer &__parent,
                                    const _Key &__v);
  template <class _Key>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __node_base_pointer &
  __find_equal(__parent_pointer &__parent, const _Key &__v) const {
    return const_cast<__tree *>(this)->__find_equal(__parent, __v);
  }
  template <class _Key>
  __node_base_pointer &
  __find_equal(const_iterator __hint, __parent_pointer &__parent,
               __node_base_pointer &__dummy, const _Key &__v);

  template <class... _Args> __node_holder __construct_node(_Args &&...__args);

  void destroy(__node_pointer __nd) noexcept;

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __copy_assign_alloc(const __tree &__t) {
    __copy_assign_alloc(
        __t,
        integral_constant<
            bool,
            __node_traits::propagate_on_container_copy_assignment::value>());
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __copy_assign_alloc(const __tree &__t, true_type) {
    if (__node_alloc() != __t.__node_alloc())
      clear();
    __node_alloc() = __t.__node_alloc();
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __copy_assign_alloc(const __tree &, false_type) {}

  void __move_assign(__tree &__t, false_type);
  void __move_assign(__tree &__t, true_type) noexcept(
      is_nothrow_move_assignable<value_compare>::value
          &&is_nothrow_move_assignable<__node_allocator>::value);

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __move_assign_alloc(__tree &__t) noexcept(
      !__node_traits::propagate_on_container_move_assignment::value ||
      is_nothrow_move_assignable<__node_allocator>::value)

  {
    __move_assign_alloc(
        __t,
        integral_constant<
            bool,
            __node_traits::propagate_on_container_move_assignment::value>());
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __move_assign_alloc(__tree &__t, true_type) noexcept(
      is_nothrow_move_assignable<__node_allocator>::value) {
    __node_alloc() = std::__1::move(__t.__node_alloc());
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  __move_assign_alloc(__tree &, false_type) noexcept {}

  struct _DetachedTreeCache {
    __attribute__((__visibility__("hidden"))) __attribute__((
        internal_linkage)) explicit _DetachedTreeCache(__tree *__t) noexcept
        : __t_(__t), __cache_root_(__detach_from_tree(__t)) {
      __advance();
    }

    __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
    __node_pointer
    __get() const noexcept {
      return __cache_elem_;
    }

    __attribute__((__visibility__("hidden")))
    __attribute__((internal_linkage)) void
    __advance() noexcept {
      __cache_elem_ = __cache_root_;
      if (__cache_root_) {
        __cache_root_ = __detach_next(__cache_root_);
      }
    }

    __attribute__((__visibility__("hidden")))
    __attribute__((internal_linkage)) ~_DetachedTreeCache() {
      __t_->destroy(__cache_elem_);
      if (__cache_root_) {
        while (__cache_root_->__parent_ != nullptr)
          __cache_root_ = static_cast<__node_pointer>(__cache_root_->__parent_);
        __t_->destroy(__cache_root_);
      }
    }

    _DetachedTreeCache(_DetachedTreeCache const &) = delete;
    _DetachedTreeCache &operator=(_DetachedTreeCache const &) = delete;

  private:
    __attribute__((__visibility__("hidden")))
    __attribute__((internal_linkage)) static __node_pointer
    __detach_from_tree(__tree *__t) noexcept;
    __attribute__((__visibility__("hidden")))
    __attribute__((internal_linkage)) static __node_pointer
        __detach_next(__node_pointer) noexcept;

    __tree *__t_;
    __node_pointer __cache_root_;
    __node_pointer __cache_elem_;
  };

  template <class, class, class, class>
  friend class __attribute__((__type_visibility__("default"))) map;
  template <class, class, class, class>
  friend class __attribute__((__type_visibility__("default"))) multimap;
};

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare &__comp) noexcept(
    is_nothrow_default_constructible<__node_allocator>::value
        &&is_nothrow_copy_constructible<value_compare>::value)

    : __pair3_(0, __comp) {
  __begin_node() = __end_node();
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const allocator_type &__a)
    : __begin_node_(__iter_pointer()),
      __pair1_(__default_init_tag(), __node_allocator(__a)),
      __pair3_(0, __default_init_tag()) {
  __begin_node() = __end_node();
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare &__comp,
                                          const allocator_type &__a)
    : __begin_node_(__iter_pointer()),
      __pair1_(__default_init_tag(), __node_allocator(__a)),
      __pair3_(0, __comp) {
  __begin_node() = __end_node();
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_pointer
__tree<_Tp, _Compare, _Allocator>::_DetachedTreeCache::__detach_from_tree(
    __tree *__t) noexcept {
  __node_pointer __cache = static_cast<__node_pointer>(__t->__begin_node());
  __t->__begin_node() = __t->__end_node();
  __t->__end_node()->__left_->__parent_ = nullptr;
  __t->__end_node()->__left_ = nullptr;
  __t->size() = 0;

  if (__cache->__right_ != nullptr)
    __cache = static_cast<__node_pointer>(__cache->__right_);

  return __cache;
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_pointer
__tree<_Tp, _Compare, _Allocator>::_DetachedTreeCache::__detach_next(
    __node_pointer __cache) noexcept {
  if (__cache->__parent_ == nullptr)
    return nullptr;
  if (__tree_is_left_child(static_cast<__node_base_pointer>(__cache))) {
    __cache->__parent_->__left_ = nullptr;
    __cache = static_cast<__node_pointer>(__cache->__parent_);
    if (__cache->__right_ == nullptr)
      return __cache;
    return static_cast<__node_pointer>(__tree_leaf(__cache->__right_));
  }

  __cache->__parent_unsafe()->__right_ = nullptr;
  __cache = static_cast<__node_pointer>(__cache->__parent_);
  if (__cache->__left_ == nullptr)
    return __cache;
  return static_cast<__node_pointer>(__tree_leaf(__cache->__left_));
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator> &
__tree<_Tp, _Compare, _Allocator>::operator=(const __tree &__t) {
  if (this != &__t) {
    value_comp() = __t.value_comp();
    __copy_assign_alloc(__t);
    __assign_multi(__t.begin(), __t.end());
  }
  return *this;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _ForwardIterator>
void __tree<_Tp, _Compare, _Allocator>::__assign_unique(
    _ForwardIterator __first, _ForwardIterator __last) {
  typedef iterator_traits<_ForwardIterator> _ITraits;
  typedef typename _ITraits::value_type _ItValueType;
  static_assert(
      (is_same<_ItValueType, __container_value_type>::value),
      "__assign_unique may only be called with the containers value type");
  static_assert(__is_cpp17_forward_iterator<_ForwardIterator>::value,
                "__assign_unique requires a forward iterator");
  if (size() != 0) {
    _DetachedTreeCache __cache(this);
    for (; __cache.__get() != nullptr && __first != __last; ++__first) {
      if (__node_assign_unique(*__first, __cache.__get()).second)
        __cache.__advance();
    }
  }
  for (; __first != __last; ++__first)
    __insert_unique(*__first);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _InputIterator>
void __tree<_Tp, _Compare, _Allocator>::__assign_multi(_InputIterator __first,
                                                       _InputIterator __last) {
  typedef iterator_traits<_InputIterator> _ITraits;
  typedef typename _ITraits::value_type _ItValueType;
  static_assert(
      (is_same<_ItValueType, __container_value_type>::value ||
       is_same<_ItValueType, __node_value_type>::value),
      "__assign_multi may only be called with the containers value type"
      " or the nodes value type");
  if (size() != 0) {
    _DetachedTreeCache __cache(this);
    for (; __cache.__get() && __first != __last; ++__first) {
      __cache.__get()->__value_ = *__first;
      __node_insert_multi(__cache.__get());
      __cache.__advance();
    }
  }
  for (; __first != __last; ++__first)
    __insert_multi(_NodeTypes::__get_value(*__first));
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const __tree &__t)
    : __begin_node_(__iter_pointer()),
      __pair1_(__default_init_tag(),
               __node_traits::select_on_container_copy_construction(
                   __t.__node_alloc())),
      __pair3_(0, __t.value_comp()) {
  __begin_node() = __end_node();
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(__tree &&__t) noexcept(
    is_nothrow_move_constructible<__node_allocator>::value
        &&is_nothrow_move_constructible<value_compare>::value)

    : __begin_node_(std::__1::move(__t.__begin_node_)),
      __pair1_(std::__1::move(__t.__pair1_)),
      __pair3_(std::__1::move(__t.__pair3_)) {
  if (size() == 0)
    __begin_node() = __end_node();
  else {
    __end_node()->__left_->__parent_ =
        static_cast<__parent_pointer>(__end_node());
    __t.__begin_node() = __t.__end_node();
    __t.__end_node()->__left_ = nullptr;
    __t.size() = 0;
  }
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(__tree &&__t,
                                          const allocator_type &__a)
    : __pair1_(__default_init_tag(), __node_allocator(__a)),
      __pair3_(0, std::__1::move(__t.value_comp())) {
  if (__a == __t.__alloc()) {
    if (__t.size() == 0)
      __begin_node() = __end_node();
    else {
      __begin_node() = __t.__begin_node();
      __end_node()->__left_ = __t.__end_node()->__left_;
      __end_node()->__left_->__parent_ =
          static_cast<__parent_pointer>(__end_node());
      size() = __t.size();
      __t.__begin_node() = __t.__end_node();
      __t.__end_node()->__left_ = nullptr;
      __t.size() = 0;
    }
  } else {
    __begin_node() = __end_node();
  }
}

template <class _Tp, class _Compare, class _Allocator>
void __tree<_Tp, _Compare, _Allocator>::__move_assign(
    __tree &__t,
    true_type) noexcept(is_nothrow_move_assignable<value_compare>::value &&
                            is_nothrow_move_assignable<__node_allocator>::value)

{
  destroy(static_cast<__node_pointer>(__end_node()->__left_));
  __begin_node_ = __t.__begin_node_;
  __pair1_.first() = __t.__pair1_.first();
  __move_assign_alloc(__t);
  __pair3_ = std::__1::move(__t.__pair3_);
  if (size() == 0)
    __begin_node() = __end_node();
  else {
    __end_node()->__left_->__parent_ =
        static_cast<__parent_pointer>(__end_node());
    __t.__begin_node() = __t.__end_node();
    __t.__end_node()->__left_ = nullptr;
    __t.size() = 0;
  }
}

template <class _Tp, class _Compare, class _Allocator>
void __tree<_Tp, _Compare, _Allocator>::__move_assign(__tree &__t, false_type) {
  if (__node_alloc() == __t.__node_alloc())
    __move_assign(__t, true_type());
  else {
    value_comp() = std::__1::move(__t.value_comp());
    const_iterator __e = end();
    if (size() != 0) {
      _DetachedTreeCache __cache(this);
      while (__cache.__get() != nullptr && __t.size() != 0) {
        __cache.__get()->__value_ =
            std::__1::move(__t.remove(__t.begin())->__value_);
        __node_insert_multi(__cache.__get());
        __cache.__advance();
      }
    }
    while (__t.size() != 0)
      __insert_multi(__e,
                     _NodeTypes::__move(__t.remove(__t.begin())->__value_));
  }
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator> &
__tree<_Tp, _Compare, _Allocator>::operator=(__tree &&__t) noexcept(
    __node_traits::propagate_on_container_move_assignment::value
        &&is_nothrow_move_assignable<value_compare>::value
            &&is_nothrow_move_assignable<__node_allocator>::value)

{
  __move_assign(
      __t, integral_constant<
               bool,
               __node_traits::propagate_on_container_move_assignment::value>());
  return *this;
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::~__tree() {
  static_assert((is_copy_constructible<value_compare>::value),
                "Comparator must be copy-constructible.");
  destroy(__root());
}

template <class _Tp, class _Compare, class _Allocator>
void __tree<_Tp, _Compare, _Allocator>::destroy(__node_pointer __nd) noexcept {
  if (__nd != nullptr) {
    destroy(static_cast<__node_pointer>(__nd->__left_));
    destroy(static_cast<__node_pointer>(__nd->__right_));
    __node_allocator &__na = __node_alloc();
    __node_traits::destroy(__na, _NodeTypes::__get_ptr(__nd->__value_));
    __node_traits::deallocate(__na, __nd, 1);
  }
}

template <class _Tp, class _Compare, class _Allocator>
void __tree<_Tp, _Compare, _Allocator>::swap(__tree &__t)

    noexcept(__is_nothrow_swappable<value_compare>::value)

{
  using std::__1::swap;
  swap(__begin_node_, __t.__begin_node_);
  swap(__pair1_.first(), __t.__pair1_.first());
  __swap_allocator(__node_alloc(), __t.__node_alloc());
  __pair3_.swap(__t.__pair3_);
  if (size() == 0)
    __begin_node() = __end_node();
  else
    __end_node()->__left_->__parent_ =
        static_cast<__parent_pointer>(__end_node());
  if (__t.size() == 0)
    __t.__begin_node() = __t.__end_node();
  else
    __t.__end_node()->__left_->__parent_ =
        static_cast<__parent_pointer>(__t.__end_node());
}

template <class _Tp, class _Compare, class _Allocator>
void __tree<_Tp, _Compare, _Allocator>::clear() noexcept {
  destroy(__root());
  size() = 0;
  __begin_node() = __end_node();
  __end_node()->__left_ = nullptr;
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer &
__tree<_Tp, _Compare, _Allocator>::__find_leaf_low(__parent_pointer &__parent,
                                                   const key_type &__v) {
  __node_pointer __nd = __root();
  if (__nd != nullptr) {
    while (true) {
      if (value_comp()(__nd->__value_, __v)) {
        if (__nd->__right_ != nullptr)
          __nd = static_cast<__node_pointer>(__nd->__right_);
        else {
          __parent = static_cast<__parent_pointer>(__nd);
          return __nd->__right_;
        }
      } else {
        if (__nd->__left_ != nullptr)
          __nd = static_cast<__node_pointer>(__nd->__left_);
        else {
          __parent = static_cast<__parent_pointer>(__nd);
          return __parent->__left_;
        }
      }
    }
  }
  __parent = static_cast<__parent_pointer>(__end_node());
  return __parent->__left_;
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer &
__tree<_Tp, _Compare, _Allocator>::__find_leaf_high(__parent_pointer &__parent,
                                                    const key_type &__v) {
  __node_pointer __nd = __root();
  if (__nd != nullptr) {
    while (true) {
      if (value_comp()(__v, __nd->__value_)) {
        if (__nd->__left_ != nullptr)
          __nd = static_cast<__node_pointer>(__nd->__left_);
        else {
          __parent = static_cast<__parent_pointer>(__nd);
          return __parent->__left_;
        }
      } else {
        if (__nd->__right_ != nullptr)
          __nd = static_cast<__node_pointer>(__nd->__right_);
        else {
          __parent = static_cast<__parent_pointer>(__nd);
          return __nd->__right_;
        }
      }
    }
  }
  __parent = static_cast<__parent_pointer>(__end_node());
  return __parent->__left_;
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer &
__tree<_Tp, _Compare, _Allocator>::__find_leaf(const_iterator __hint,
                                               __parent_pointer &__parent,
                                               const key_type &__v) {
  if (__hint == end() || !value_comp()(*__hint, __v)) {

    const_iterator __prior = __hint;
    if (__prior == begin() || !value_comp()(__v, *--__prior)) {

      if (__hint.__ptr_->__left_ == nullptr) {
        __parent = static_cast<__parent_pointer>(__hint.__ptr_);
        return __parent->__left_;
      } else {
        __parent = static_cast<__parent_pointer>(__prior.__ptr_);
        return static_cast<__node_base_pointer>(__prior.__ptr_)->__right_;
      }
    }

    return __find_leaf_high(__parent, __v);
  }

  return __find_leaf_low(__parent, __v);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer &
__tree<_Tp, _Compare, _Allocator>::__find_equal(__parent_pointer &__parent,
                                                const _Key &__v) {
  __node_pointer __nd = __root();
  __node_base_pointer *__nd_ptr = __root_ptr();
  if (__nd != nullptr) {
    while (true) {
      if (value_comp()(__v, __nd->__value_)) {
        if (__nd->__left_ != nullptr) {
          __nd_ptr = std::__1::addressof(__nd->__left_);
          __nd = static_cast<__node_pointer>(__nd->__left_);
        } else {
          __parent = static_cast<__parent_pointer>(__nd);
          return __parent->__left_;
        }
      } else if (value_comp()(__nd->__value_, __v)) {
        if (__nd->__right_ != nullptr) {
          __nd_ptr = std::__1::addressof(__nd->__right_);
          __nd = static_cast<__node_pointer>(__nd->__right_);
        } else {
          __parent = static_cast<__parent_pointer>(__nd);
          return __nd->__right_;
        }
      } else {
        __parent = static_cast<__parent_pointer>(__nd);
        return *__nd_ptr;
      }
    }
  }
  __parent = static_cast<__parent_pointer>(__end_node());
  return __parent->__left_;
}
# 2048 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__tree" 3
template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer &
__tree<_Tp, _Compare, _Allocator>::__find_equal(const_iterator __hint,
                                                __parent_pointer &__parent,
                                                __node_base_pointer &__dummy,
                                                const _Key &__v) {
  if (__hint == end() || value_comp()(__v, *__hint)) {

    const_iterator __prior = __hint;
    if (__prior == begin() || value_comp()(*--__prior, __v)) {

      if (__hint.__ptr_->__left_ == nullptr) {
        __parent = static_cast<__parent_pointer>(__hint.__ptr_);
        return __parent->__left_;
      } else {
        __parent = static_cast<__parent_pointer>(__prior.__ptr_);
        return static_cast<__node_base_pointer>(__prior.__ptr_)->__right_;
      }
    }

    return __find_equal(__parent, __v);
  } else if (value_comp()(*__hint, __v)) {

    const_iterator __next = std::__1::next(__hint);
    if (__next == end() || value_comp()(__v, *__next)) {

      if (__hint.__get_np()->__right_ == nullptr) {
        __parent = static_cast<__parent_pointer>(__hint.__ptr_);
        return static_cast<__node_base_pointer>(__hint.__ptr_)->__right_;
      } else {
        __parent = static_cast<__parent_pointer>(__next.__ptr_);
        return __parent->__left_;
      }
    }

    return __find_equal(__parent, __v);
  }

  __parent = static_cast<__parent_pointer>(__hint.__ptr_);
  __dummy = static_cast<__node_base_pointer>(__hint.__ptr_);
  return __dummy;
}

template <class _Tp, class _Compare, class _Allocator>
void __tree<_Tp, _Compare, _Allocator>::__insert_node_at(
    __parent_pointer __parent, __node_base_pointer &__child,
    __node_base_pointer __new_node) noexcept {
  __new_node->__left_ = nullptr;
  __new_node->__right_ = nullptr;
  __new_node->__parent_ = __parent;

  __child = __new_node;
  if (__begin_node()->__left_ != nullptr)
    __begin_node() = static_cast<__iter_pointer>(__begin_node()->__left_);
  __tree_balance_after_insert(__end_node()->__left_, __child);
  ++size();
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key, class... _Args>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>
__tree<_Tp, _Compare, _Allocator>::__emplace_unique_key_args(_Key const &__k,
                                                             _Args &&...__args)

{
  __parent_pointer __parent;
  __node_base_pointer &__child = __find_equal(__parent, __k);
  __node_pointer __r = static_cast<__node_pointer>(__child);
  bool __inserted = false;
  if (__child == nullptr) {

    __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);

    __insert_node_at(__parent, __child,
                     static_cast<__node_base_pointer>(__h.get()));
    __r = __h.release();
    __inserted = true;
  }
  return pair<iterator, bool>(iterator(__r), __inserted);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key, class... _Args>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique_key_args(
    const_iterator __p, _Key const &__k, _Args &&...__args)

{
  __parent_pointer __parent;
  __node_base_pointer __dummy;
  __node_base_pointer &__child = __find_equal(__p, __parent, __dummy, __k);
  __node_pointer __r = static_cast<__node_pointer>(__child);
  if (__child == nullptr) {

    __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);

    __insert_node_at(__parent, __child,
                     static_cast<__node_base_pointer>(__h.get()));
    __r = __h.release();
  }
  return iterator(__r);
}

template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
typename __tree<_Tp, _Compare, _Allocator>::__node_holder
__tree<_Tp, _Compare, _Allocator>::__construct_node(_Args &&...__args) {
  static_assert(!__is_tree_value_type<_Args...>::value,
                "Cannot construct from __value_type");
  __node_allocator &__na = __node_alloc();
  __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));
  __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_),
                           std::__1::forward<_Args>(__args)...);
  __h.get_deleter().__value_constructed = true;
  return __h;
}

template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>
__tree<_Tp, _Compare, _Allocator>::__emplace_unique_impl(_Args &&...__args) {
  __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);
  __parent_pointer __parent;
  __node_base_pointer &__child = __find_equal(__parent, __h->__value_);
  __node_pointer __r = static_cast<__node_pointer>(__child);
  bool __inserted = false;
  if (__child == nullptr) {
    __insert_node_at(__parent, __child,
                     static_cast<__node_base_pointer>(__h.get()));
    __r = __h.release();
    __inserted = true;
  }
  return pair<iterator, bool>(iterator(__r), __inserted);
}

template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique_impl(
    const_iterator __p, _Args &&...__args) {
  __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);
  __parent_pointer __parent;
  __node_base_pointer __dummy;
  __node_base_pointer &__child =
      __find_equal(__p, __parent, __dummy, __h->__value_);
  __node_pointer __r = static_cast<__node_pointer>(__child);
  if (__child == nullptr) {
    __insert_node_at(__parent, __child,
                     static_cast<__node_base_pointer>(__h.get()));
    __r = __h.release();
  }
  return iterator(__r);
}

template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__emplace_multi(_Args &&...__args) {
  __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);
  __parent_pointer __parent;
  __node_base_pointer &__child =
      __find_leaf_high(__parent, _NodeTypes::__get_key(__h->__value_));
  __insert_node_at(__parent, __child,
                   static_cast<__node_base_pointer>(__h.get()));
  return iterator(static_cast<__node_pointer>(__h.release()));
}

template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__emplace_hint_multi(const_iterator __p,
                                                        _Args &&...__args) {
  __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);
  __parent_pointer __parent;
  __node_base_pointer &__child =
      __find_leaf(__p, __parent, _NodeTypes::__get_key(__h->__value_));
  __insert_node_at(__parent, __child,
                   static_cast<__node_base_pointer>(__h.get()));
  return iterator(static_cast<__node_pointer>(__h.release()));
}
# 2302 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__tree" 3
template <class _Tp, class _Compare, class _Allocator>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>
__tree<_Tp, _Compare, _Allocator>::__node_assign_unique(
    const __container_value_type &__v, __node_pointer __nd) {
  __parent_pointer __parent;
  __node_base_pointer &__child =
      __find_equal(__parent, _NodeTypes::__get_key(__v));
  __node_pointer __r = static_cast<__node_pointer>(__child);
  bool __inserted = false;
  if (__child == nullptr) {
    __nd->__value_ = __v;
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));
    __r = __nd;
    __inserted = true;
  }
  return pair<iterator, bool>(iterator(__r), __inserted);
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(__node_pointer __nd) {
  __parent_pointer __parent;
  __node_base_pointer &__child =
      __find_leaf_high(__parent, _NodeTypes::__get_key(__nd->__value_));
  __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));
  return iterator(__nd);
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(const_iterator __p,
                                                       __node_pointer __nd) {
  __parent_pointer __parent;
  __node_base_pointer &__child =
      __find_leaf(__p, __parent, _NodeTypes::__get_key(__nd->__value_));
  __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));
  return iterator(__nd);
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__remove_node_pointer(
    __node_pointer __ptr) noexcept {
  iterator __r(__ptr);
  ++__r;
  if (__begin_node() == __ptr)
    __begin_node() = __r.__ptr_;
  --size();
  __tree_remove(__end_node()->__left_, static_cast<__node_base_pointer>(__ptr));
  return __r;
}
# 2515 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__tree" 3
template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __p) {
  __node_pointer __np = __p.__get_np();
  iterator __r = __remove_node_pointer(__np);
  __node_allocator &__na = __node_alloc();
  __node_traits::destroy(
      __na, _NodeTypes::__get_ptr(const_cast<__node_value_type &>(*__p)));
  __node_traits::deallocate(__na, __np, 1);
  return __r;
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __f,
                                         const_iterator __l) {
  while (__f != __l)
    __f = erase(__f);
  return iterator(__l.__ptr_);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__erase_unique(const _Key &__k) {
  iterator __i = find(__k);
  if (__i == end())
    return 0;
  erase(__i);
  return 1;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__erase_multi(const _Key &__k) {
  pair<iterator, iterator> __p = __equal_range_multi(__k);
  size_type __r = 0;
  for (; __p.first != __p.second; ++__r)
    __p.first = erase(__p.first);
  return __r;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::find(const _Key &__v) {
  iterator __p = __lower_bound(__v, __root(), __end_node());
  if (__p != end() && !value_comp()(__v, *__p))
    return __p;
  return end();
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::const_iterator
__tree<_Tp, _Compare, _Allocator>::find(const _Key &__v) const {
  const_iterator __p = __lower_bound(__v, __root(), __end_node());
  if (__p != end() && !value_comp()(__v, *__p))
    return __p;
  return end();
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__count_unique(const _Key &__k) const {
  __node_pointer __rt = __root();
  while (__rt != nullptr) {
    if (value_comp()(__k, __rt->__value_)) {
      __rt = static_cast<__node_pointer>(__rt->__left_);
    } else if (value_comp()(__rt->__value_, __k))
      __rt = static_cast<__node_pointer>(__rt->__right_);
    else
      return 1;
  }
  return 0;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__count_multi(const _Key &__k) const {
  __iter_pointer __result = __end_node();
  __node_pointer __rt = __root();
  while (__rt != nullptr) {
    if (value_comp()(__k, __rt->__value_)) {
      __result = static_cast<__iter_pointer>(__rt);
      __rt = static_cast<__node_pointer>(__rt->__left_);
    } else if (value_comp()(__rt->__value_, __k))
      __rt = static_cast<__node_pointer>(__rt->__right_);
    else
      return std::__1::distance(
          __lower_bound(__k, static_cast<__node_pointer>(__rt->__left_),
                        static_cast<__iter_pointer>(__rt)),
          __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_),
                        __result));
  }
  return 0;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key &__v,
                                                 __node_pointer __root,
                                                 __iter_pointer __result) {
  while (__root != nullptr) {
    if (!value_comp()(__root->__value_, __v)) {
      __result = static_cast<__iter_pointer>(__root);
      __root = static_cast<__node_pointer>(__root->__left_);
    } else
      __root = static_cast<__node_pointer>(__root->__right_);
  }
  return iterator(__result);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::const_iterator
__tree<_Tp, _Compare, _Allocator>::__lower_bound(
    const _Key &__v, __node_pointer __root, __iter_pointer __result) const {
  while (__root != nullptr) {
    if (!value_comp()(__root->__value_, __v)) {
      __result = static_cast<__iter_pointer>(__root);
      __root = static_cast<__node_pointer>(__root->__left_);
    } else
      __root = static_cast<__node_pointer>(__root->__right_);
  }
  return const_iterator(__result);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key &__v,
                                                 __node_pointer __root,
                                                 __iter_pointer __result) {
  while (__root != nullptr) {
    if (value_comp()(__v, __root->__value_)) {
      __result = static_cast<__iter_pointer>(__root);
      __root = static_cast<__node_pointer>(__root->__left_);
    } else
      __root = static_cast<__node_pointer>(__root->__right_);
  }
  return iterator(__result);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::const_iterator
__tree<_Tp, _Compare, _Allocator>::__upper_bound(
    const _Key &__v, __node_pointer __root, __iter_pointer __result) const {
  while (__root != nullptr) {
    if (value_comp()(__v, __root->__value_)) {
      __result = static_cast<__iter_pointer>(__root);
      __root = static_cast<__node_pointer>(__root->__left_);
    } else
      __root = static_cast<__node_pointer>(__root->__right_);
  }
  return const_iterator(__result);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator,
     typename __tree<_Tp, _Compare, _Allocator>::iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key &__k) {
  typedef pair<iterator, iterator> _Pp;
  __iter_pointer __result = __end_node();
  __node_pointer __rt = __root();
  while (__rt != nullptr) {
    if (value_comp()(__k, __rt->__value_)) {
      __result = static_cast<__iter_pointer>(__rt);
      __rt = static_cast<__node_pointer>(__rt->__left_);
    } else if (value_comp()(__rt->__value_, __k))
      __rt = static_cast<__node_pointer>(__rt->__right_);
    else
      return _Pp(iterator(__rt), iterator(__rt->__right_ != nullptr
                                              ? static_cast<__iter_pointer>(
                                                    __tree_min(__rt->__right_))
                                              : __result));
  }
  return _Pp(iterator(__result), iterator(__result));
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,
     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key &__k) const {
  typedef pair<const_iterator, const_iterator> _Pp;
  __iter_pointer __result = __end_node();
  __node_pointer __rt = __root();
  while (__rt != nullptr) {
    if (value_comp()(__k, __rt->__value_)) {
      __result = static_cast<__iter_pointer>(__rt);
      __rt = static_cast<__node_pointer>(__rt->__left_);
    } else if (value_comp()(__rt->__value_, __k))
      __rt = static_cast<__node_pointer>(__rt->__right_);
    else
      return _Pp(const_iterator(__rt),
                 const_iterator(__rt->__right_ != nullptr
                                    ? static_cast<__iter_pointer>(
                                          __tree_min(__rt->__right_))
                                    : __result));
  }
  return _Pp(const_iterator(__result), const_iterator(__result));
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator,
     typename __tree<_Tp, _Compare, _Allocator>::iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key &__k) {
  typedef pair<iterator, iterator> _Pp;
  __iter_pointer __result = __end_node();
  __node_pointer __rt = __root();
  while (__rt != nullptr) {
    if (value_comp()(__k, __rt->__value_)) {
      __result = static_cast<__iter_pointer>(__rt);
      __rt = static_cast<__node_pointer>(__rt->__left_);
    } else if (value_comp()(__rt->__value_, __k))
      __rt = static_cast<__node_pointer>(__rt->__right_);
    else
      return _Pp(__lower_bound(__k, static_cast<__node_pointer>(__rt->__left_),
                               static_cast<__iter_pointer>(__rt)),
                 __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_),
                               __result));
  }
  return _Pp(iterator(__result), iterator(__result));
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,
     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key &__k) const {
  typedef pair<const_iterator, const_iterator> _Pp;
  __iter_pointer __result = __end_node();
  __node_pointer __rt = __root();
  while (__rt != nullptr) {
    if (value_comp()(__k, __rt->__value_)) {
      __result = static_cast<__iter_pointer>(__rt);
      __rt = static_cast<__node_pointer>(__rt->__left_);
    } else if (value_comp()(__rt->__value_, __k))
      __rt = static_cast<__node_pointer>(__rt->__right_);
    else
      return _Pp(__lower_bound(__k, static_cast<__node_pointer>(__rt->__left_),
                               static_cast<__iter_pointer>(__rt)),
                 __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_),
                               __result));
  }
  return _Pp(const_iterator(__result), const_iterator(__result));
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_holder
__tree<_Tp, _Compare, _Allocator>::remove(const_iterator __p) noexcept {
  __node_pointer __np = __p.__get_np();
  if (__begin_node() == __p.__ptr_) {
    if (__np->__right_ != nullptr)
      __begin_node() = static_cast<__iter_pointer>(__np->__right_);
    else
      __begin_node() = static_cast<__iter_pointer>(__np->__parent_);
  }
  --size();
  __tree_remove(__end_node()->__left_, static_cast<__node_base_pointer>(__np));
  return __node_holder(__np, _Dp(__node_alloc(), true));
}

template <class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
swap(__tree<_Tp, _Compare, _Allocator> &__x,
     __tree<_Tp, _Compare, _Allocator> &__y) noexcept(noexcept(__x.swap(__y))) {
  __x.swap(__y);
}

} // namespace __1
} // namespace std
# 480 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/map" 2 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__node_handle" 1 3
# 13 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__node_handle" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 14 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__node_handle" 2 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/optional" 1 3
# 149 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/optional" 3
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 150 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/optional" 2 3
# 162 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/optional" 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_macros" 1 3
# 166 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/optional" 2 3

namespace std {

class __attribute__((__visibility__("default")))
__attribute__((availability(macosx, strict, introduced = 10.14)))
__attribute__((availability(ios, strict, introduced = 12.0)))
__attribute__((availability(tvos, strict, introduced = 12.0)))
__attribute__((availability(watchos, strict, introduced = 5.0)))
bad_optional_access : public exception {
public:
  virtual ~bad_optional_access() noexcept;
  virtual const char *what() const noexcept;
};

} // namespace std
# 16 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__node_handle" 2 3
# 19 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__node_handle" 3

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_macros" 1 3
# 23 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__node_handle" 2 3

namespace std {
inline namespace __1 {
# 205 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__node_handle" 3
}
} // namespace std
# 481 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/map" 2 3
# 491 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/map" 3

namespace std {
inline namespace __1 {

template <class _Key, class _CP, class _Compare,
          bool =
              is_empty<_Compare>::value && !__libcpp_is_final<_Compare>::value>
class __map_value_compare : private _Compare {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __map_value_compare() noexcept(
      is_nothrow_default_constructible<_Compare>::value)
      : _Compare() {}
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __map_value_compare(_Compare c) noexcept(
      is_nothrow_copy_constructible<_Compare>::value)
      : _Compare(c) {}
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const _Compare &
  key_comp() const noexcept {
    return *this;
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator()(const _CP &__x, const _CP &__y) const {
    return static_cast<const _Compare &>(*this)(__x.__get_value().first,
                                                __y.__get_value().first);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator()(const _CP &__x, const _Key &__y) const {
    return static_cast<const _Compare &>(*this)(__x.__get_value().first, __y);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator()(const _Key &__x, const _CP &__y) const {
    return static_cast<const _Compare &>(*this)(__x, __y.__get_value().first);
  }
  void swap(__map_value_compare &__y) noexcept(
      __is_nothrow_swappable<_Compare>::value) {
    using std::__1::swap;
    swap(static_cast<_Compare &>(*this), static_cast<_Compare &>(__y));
  }

  template <typename _K2>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type
  operator()(const _K2 &__x, const _CP &__y) const {
    return static_cast<const _Compare &>(*this)(__x, __y.__get_value().first);
  }

  template <typename _K2>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type
  operator()(const _CP &__x, const _K2 &__y) const {
    return static_cast<const _Compare &>(*this)(__x.__get_value().first, __y);
  }
};

template <class _Key, class _CP, class _Compare>
class __map_value_compare<_Key, _CP, _Compare, false> {
  _Compare comp;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __map_value_compare() noexcept(
      is_nothrow_default_constructible<_Compare>::value)
      : comp() {}
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __map_value_compare(_Compare c) noexcept(
      is_nothrow_copy_constructible<_Compare>::value)
      : comp(c) {}
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const _Compare &
  key_comp() const noexcept {
    return comp;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator()(const _CP &__x, const _CP &__y) const {
    return comp(__x.__get_value().first, __y.__get_value().first);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator()(const _CP &__x, const _Key &__y) const {
    return comp(__x.__get_value().first, __y);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator()(const _Key &__x, const _CP &__y) const {
    return comp(__x, __y.__get_value().first);
  }
  void swap(__map_value_compare &__y) noexcept(
      __is_nothrow_swappable<_Compare>::value) {
    using std::__1::swap;
    swap(comp, __y.comp);
  }

  template <typename _K2>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type
  operator()(const _K2 &__x, const _CP &__y) const {
    return comp(__x, __y.__get_value().first);
  }

  template <typename _K2>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type
  operator()(const _CP &__x, const _K2 &__y) const {
    return comp(__x.__get_value().first, __y);
  }
};

template <class _Key, class _CP, class _Compare, bool __b>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
swap(__map_value_compare<_Key, _CP, _Compare, __b> &__x,
     __map_value_compare<_Key, _CP, _Compare, __b>
         &__y) noexcept(noexcept(__x.swap(__y))) {
  __x.swap(__y);
}

template <class _Allocator> class __map_node_destructor {
  typedef _Allocator allocator_type;
  typedef allocator_traits<allocator_type> __alloc_traits;

public:
  typedef typename __alloc_traits::pointer pointer;

private:
  allocator_type &__na_;

  __map_node_destructor &operator=(const __map_node_destructor &);

public:
  bool __first_constructed;
  bool __second_constructed;

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit __map_node_destructor(
      allocator_type &__na) noexcept
      : __na_(__na), __first_constructed(false), __second_constructed(false) {}

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __map_node_destructor(__tree_node_destructor<allocator_type> &&__x) noexcept
      : __na_(__x.__na_), __first_constructed(__x.__value_constructed),
        __second_constructed(__x.__value_constructed) {
    __x.__value_constructed = false;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  operator()(pointer __p) noexcept {
    if (__second_constructed)
      __alloc_traits::destroy(
          __na_, std::__1::addressof(__p->__value_.__get_value().second));
    if (__first_constructed)
      __alloc_traits::destroy(
          __na_, std::__1::addressof(__p->__value_.__get_value().first));
    if (__p)
      __alloc_traits::deallocate(__na_, __p, 1);
  }
};

template <class _Key, class _Tp, class _Compare, class _Allocator> class map;
template <class _Key, class _Tp, class _Compare, class _Allocator>
class multimap;
template <class _TreeIterator> class __map_const_iterator;

template <class _Key, class _Tp> struct __value_type {
  typedef _Key key_type;
  typedef _Tp mapped_type;
  typedef pair<const key_type, mapped_type> value_type;
  typedef pair<key_type &, mapped_type &> __nc_ref_pair_type;
  typedef pair<key_type &&, mapped_type &&> __nc_rref_pair_type;

private:
  value_type __cc;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  value_type &
  __get_value() {

    return __cc;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const value_type &
  __get_value() const {

    return __cc;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __nc_ref_pair_type
  __ref() {
    value_type &__v = __get_value();
    return __nc_ref_pair_type(const_cast<key_type &>(__v.first), __v.second);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __nc_rref_pair_type
  __move() {
    value_type &__v = __get_value();
    return __nc_rref_pair_type(
        std::__1::move(const_cast<key_type &>(__v.first)),
        std::__1::move(__v.second));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __value_type &
  operator=(const __value_type &__v) {
    __ref() = __v.__get_value();
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __value_type &
  operator=(__value_type &&__v) {
    __ref() = __v.__move();
    return *this;
  }

  template <class _ValueTp, class = typename enable_if<__is_same_uncvref<
                                _ValueTp, value_type>::value>::type>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __value_type &
  operator=(_ValueTp &&__v) {
    __ref() = std::__1::forward<_ValueTp>(__v);
    return *this;
  }

private:
  __value_type() = delete;
  ~__value_type() = delete;
  __value_type(const __value_type &__v) = delete;
  __value_type(__value_type &&__v) = delete;
};
# 765 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/map" 3
template <class _Tp> struct __extract_key_value_types;

template <class _Key, class _Tp>
struct __extract_key_value_types<__value_type<_Key, _Tp>> {
  typedef _Key const __key_type;
  typedef _Tp __mapped_type;
};

template <class _TreeIterator>
class __attribute__((__type_visibility__("default"))) __map_iterator {
  typedef typename _TreeIterator::_NodeTypes _NodeTypes;
  typedef typename _TreeIterator::__pointer_traits __pointer_traits;

  _TreeIterator __i_;

public:
  typedef bidirectional_iterator_tag iterator_category;
  typedef typename _NodeTypes::__map_value_type value_type;
  typedef typename _TreeIterator::difference_type difference_type;
  typedef value_type &reference;
  typedef typename _NodeTypes::__map_value_type_pointer pointer;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __map_iterator() noexcept {}

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __map_iterator(_TreeIterator __i) noexcept
      : __i_(__i) {}

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reference
  operator*() const {
    return __i_->__get_value();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pointer
  operator->() const {
    return pointer_traits<pointer>::pointer_to(__i_->__get_value());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __map_iterator &
  operator++() {
    ++__i_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __map_iterator
  operator++(int) {
    __map_iterator __t(*this);
    ++(*this);
    return __t;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __map_iterator &
  operator--() {
    --__i_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __map_iterator
  operator--(int) {
    __map_iterator __t(*this);
    --(*this);
    return __t;
  }

  friend __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator==(const __map_iterator &__x, const __map_iterator &__y) {
    return __x.__i_ == __y.__i_;
  }
  friend __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator!=(const __map_iterator &__x, const __map_iterator &__y) {
    return __x.__i_ != __y.__i_;
  }

  template <class, class, class, class>
  friend class __attribute__((__type_visibility__("default"))) map;
  template <class, class, class, class>
  friend class __attribute__((__type_visibility__("default"))) multimap;
  template <class>
  friend class __attribute__((__type_visibility__("default")))
  __map_const_iterator;
};

template <class _TreeIterator>
class __attribute__((__type_visibility__("default"))) __map_const_iterator {
  typedef typename _TreeIterator::_NodeTypes _NodeTypes;
  typedef typename _TreeIterator::__pointer_traits __pointer_traits;

  _TreeIterator __i_;

public:
  typedef bidirectional_iterator_tag iterator_category;
  typedef typename _NodeTypes::__map_value_type value_type;
  typedef typename _TreeIterator::difference_type difference_type;
  typedef const value_type &reference;
  typedef typename _NodeTypes::__const_map_value_type_pointer pointer;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __map_const_iterator() noexcept {}

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __map_const_iterator(_TreeIterator __i) noexcept
      : __i_(__i) {}
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __map_const_iterator(
      __map_iterator<typename _TreeIterator::__non_const_iterator> __i) noexcept
      : __i_(__i.__i_) {}

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reference
  operator*() const {
    return __i_->__get_value();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pointer
  operator->() const {
    return pointer_traits<pointer>::pointer_to(__i_->__get_value());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __map_const_iterator &
  operator++() {
    ++__i_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __map_const_iterator
  operator++(int) {
    __map_const_iterator __t(*this);
    ++(*this);
    return __t;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __map_const_iterator &
  operator--() {
    --__i_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  __map_const_iterator
  operator--(int) {
    __map_const_iterator __t(*this);
    --(*this);
    return __t;
  }

  friend __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator==(const __map_const_iterator &__x, const __map_const_iterator &__y) {
    return __x.__i_ == __y.__i_;
  }
  friend __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  operator!=(const __map_const_iterator &__x, const __map_const_iterator &__y) {
    return __x.__i_ != __y.__i_;
  }

  template <class, class, class, class>
  friend class __attribute__((__type_visibility__("default"))) map;
  template <class, class, class, class>
  friend class __attribute__((__type_visibility__("default"))) multimap;
  template <class, class, class>
  friend class __attribute__((__type_visibility__("default")))
  __tree_const_iterator;
};

template <class _Key, class _Tp, class _Compare = less<_Key>,
          class _Allocator = allocator<pair<const _Key, _Tp>>>
class __attribute__((__type_visibility__("default"))) map {
public:
  typedef _Key key_type;
  typedef _Tp mapped_type;
  typedef pair<const key_type, mapped_type> value_type;
  typedef typename __identity<_Compare>::type key_compare;
  typedef typename __identity<_Allocator>::type allocator_type;
  typedef value_type &reference;
  typedef const value_type &const_reference;

  static_assert(
      (is_same<typename allocator_type::value_type, value_type>::value),
      "Allocator::value_type must be same type as value_type");

  class __attribute__((__type_visibility__("default"))) value_compare
      : public binary_function<value_type, value_type, bool> {
    friend class map;

  protected:
    key_compare comp;

    __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
    value_compare(key_compare c)
        : comp(c) {}

  public:
    __attribute__((__visibility__("hidden")))
    __attribute__((internal_linkage)) bool
    operator()(const value_type &__x, const value_type &__y) const {
      return comp(__x.first, __y.first);
    }
  };

private:
  typedef std::__1::__value_type<key_type, mapped_type> __value_type;
  typedef __map_value_compare<key_type, __value_type, key_compare> __vc;
  typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,
                                         __value_type>::type __allocator_type;
  typedef __tree<__value_type, __vc, __allocator_type> __base;
  typedef typename __base::__node_traits __node_traits;
  typedef allocator_traits<allocator_type> __alloc_traits;

  __base __tree_;

public:
  typedef typename __alloc_traits::pointer pointer;
  typedef typename __alloc_traits::const_pointer const_pointer;
  typedef typename __alloc_traits::size_type size_type;
  typedef typename __alloc_traits::difference_type difference_type;
  typedef __map_iterator<typename __base::iterator> iterator;
  typedef __map_const_iterator<typename __base::const_iterator> const_iterator;
  typedef std::__1::reverse_iterator<iterator> reverse_iterator;
  typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

  template <class _Key2, class _Value2, class _Comp2, class _Alloc2>
  friend class __attribute__((__type_visibility__("default"))) map;
  template <class _Key2, class _Value2, class _Comp2, class _Alloc2>
  friend class __attribute__((__type_visibility__("default"))) multimap;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  map() noexcept(is_nothrow_default_constructible<allocator_type>::value
                     &&is_nothrow_default_constructible<key_compare>::value
                         &&is_nothrow_copy_constructible<key_compare>::value)

      : __tree_(__vc(key_compare())) {}

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit map(
      const key_compare
          &__comp) noexcept(is_nothrow_default_constructible<allocator_type>::
                                value &&is_nothrow_copy_constructible<
                                    key_compare>::value)

      : __tree_(__vc(__comp)) {}

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit map(const key_compare &__comp,
                                                 const allocator_type &__a)
      : __tree_(__vc(__comp), typename __base::allocator_type(__a)) {}

  template <class _InputIterator>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  map(_InputIterator __f, _InputIterator __l,
      const key_compare &__comp = key_compare())
      : __tree_(__vc(__comp)) {
    insert(__f, __l);
  }

  template <class _InputIterator>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  map(_InputIterator __f, _InputIterator __l, const key_compare &__comp,
      const allocator_type &__a)
      : __tree_(__vc(__comp), typename __base::allocator_type(__a)) {
    insert(__f, __l);
  }

  template <class _InputIterator>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  map(_InputIterator __f, _InputIterator __l, const allocator_type &__a)
      : map(__f, __l, key_compare(), __a) {}

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  map(const map &__m)
      : __tree_(__m.__tree_) {
    insert(__m.begin(), __m.end());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  map &
  operator=(const map &__m) {

    __tree_ = __m.__tree_;
# 1023 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/map" 3
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  map(map &&__m) noexcept(is_nothrow_move_constructible<__base>::value)
      : __tree_(std::__1::move(__m.__tree_)) {}

  map(map &&__m, const allocator_type &__a);

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  map &
  operator=(map &&__m) noexcept(is_nothrow_move_assignable<__base>::value) {
    __tree_ = std::__1::move(__m.__tree_);
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  map(initializer_list<value_type> __il,
      const key_compare &__comp = key_compare())
      : __tree_(__vc(__comp)) {
    insert(__il.begin(), __il.end());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  map(initializer_list<value_type> __il, const key_compare &__comp,
      const allocator_type &__a)
      : __tree_(__vc(__comp), typename __base::allocator_type(__a)) {
    insert(__il.begin(), __il.end());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  map(initializer_list<value_type> __il, const allocator_type &__a)
      : map(__il, key_compare(), __a) {}

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  map &
  operator=(initializer_list<value_type> __il) {
    __tree_.__assign_unique(__il.begin(), __il.end());
    return *this;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit map(const allocator_type &__a)
      : __tree_(typename __base::allocator_type(__a)) {}

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  map(const map &__m, const allocator_type &__a)
      : __tree_(__m.__tree_.value_comp(),
                typename __base::allocator_type(__a)) {
    insert(__m.begin(), __m.end());
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) ~map() {
    static_assert(sizeof(__diagnose_non_const_comparator<_Key, _Compare>()),
                  "");
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  begin() noexcept {
    return __tree_.begin();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_iterator
  begin() const noexcept {
    return __tree_.begin();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  end() noexcept {
    return __tree_.end();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_iterator
  end() const noexcept {
    return __tree_.end();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reverse_iterator
  rbegin() noexcept {
    return reverse_iterator(end());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reverse_iterator
  rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reverse_iterator
  rend() noexcept {
    return reverse_iterator(begin());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reverse_iterator
  rend() const noexcept {
    return const_reverse_iterator(begin());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_iterator
  cbegin() const noexcept {
    return begin();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_iterator
  cend() const noexcept {
    return end();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reverse_iterator
  crbegin() const noexcept {
    return rbegin();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reverse_iterator
  crend() const noexcept {
    return rend();
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  empty() const noexcept {
    return __tree_.size() == 0;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  size() const noexcept {
    return __tree_.size();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  max_size() const noexcept {
    return __tree_.max_size();
  }

  mapped_type &operator[](const key_type &__k);

  mapped_type &operator[](key_type &&__k);

  mapped_type &at(const key_type &__k);
  const mapped_type &at(const key_type &__k) const;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  allocator_type
  get_allocator() const noexcept {
    return allocator_type(__tree_.__alloc());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  key_compare
  key_comp() const {
    return __tree_.value_comp().key_comp();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  value_compare
  value_comp() const {
    return value_compare(__tree_.value_comp().key_comp());
  }

  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pair<iterator, bool>
  emplace(_Args &&...__args) {
    return __tree_.__emplace_unique(std::__1::forward<_Args>(__args)...);
  }

  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  emplace_hint(const_iterator __p, _Args &&...__args) {
    return __tree_.__emplace_hint_unique(__p.__i_,
                                         std::__1::forward<_Args>(__args)...);
  }

  template <class _Pp, class = typename enable_if<
                           is_constructible<value_type, _Pp>::value>::type>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pair<iterator, bool>
  insert(_Pp &&__p) {
    return __tree_.__insert_unique(std::__1::forward<_Pp>(__p));
  }

  template <class _Pp, class = typename enable_if<
                           is_constructible<value_type, _Pp>::value>::type>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  insert(const_iterator __pos, _Pp &&__p) {
    return __tree_.__insert_unique(__pos.__i_, std::__1::forward<_Pp>(__p));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pair<iterator, bool>
  insert(const value_type &__v) {
    return __tree_.__insert_unique(__v);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  insert(const_iterator __p, const value_type &__v) {
    return __tree_.__insert_unique(__p.__i_, __v);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pair<iterator, bool>
  insert(value_type &&__v) {
    return __tree_.__insert_unique(std::__1::move(__v));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  insert(const_iterator __p, value_type &&__v) {
    return __tree_.__insert_unique(__p.__i_, std::__1::move(__v));
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  insert(initializer_list<value_type> __il) {
    insert(__il.begin(), __il.end());
  }

  template <class _InputIterator>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  insert(_InputIterator __f, _InputIterator __l) {
    for (const_iterator __e = cend(); __f != __l; ++__f)
      insert(__e.__i_, *__f);
  }
# 1298 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/map" 3
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  erase(const_iterator __p) {
    return __tree_.erase(__p.__i_);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  erase(iterator __p) {
    return __tree_.erase(__p.__i_);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  erase(const key_type &__k) {
    return __tree_.__erase_unique(__k);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  erase(const_iterator __f, const_iterator __l) {
    return __tree_.erase(__f.__i_, __l.__i_);
  }
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  clear() noexcept {
    __tree_.clear();
  }
# 1372 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/map" 3
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  swap(map &__m) noexcept(__is_nothrow_swappable<__base>::value) {
    __tree_.swap(__m.__tree_);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  find(const key_type &__k) {
    return __tree_.find(__k);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_iterator
  find(const key_type &__k) const {
    return __tree_.find(__k);
  }

  template <typename _K2>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename enable_if<__is_transparent<_Compare, _K2>::value, iterator>::type
  find(const _K2 &__k) {
    return __tree_.find(__k);
  }
  template <typename _K2>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename enable_if<__is_transparent<_Compare, _K2>::value,
                     const_iterator>::type
  find(const _K2 &__k) const {
    return __tree_.find(__k);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  count(const key_type &__k) const {
    return __tree_.__count_unique(__k);
  }

  template <typename _K2>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename enable_if<__is_transparent<_Compare, _K2>::value, size_type>::type
  count(const _K2 &__k) const {
    return __tree_.__count_multi(__k);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  lower_bound(const key_type &__k) {
    return __tree_.lower_bound(__k);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_iterator
  lower_bound(const key_type &__k) const {
    return __tree_.lower_bound(__k);
  }

  template <typename _K2>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename enable_if<__is_transparent<_Compare, _K2>::value, iterator>::type
  lower_bound(const _K2 &__k) {
    return __tree_.lower_bound(__k);
  }

  template <typename _K2>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename enable_if<__is_transparent<_Compare, _K2>::value,
                     const_iterator>::type
  lower_bound(const _K2 &__k) const {
    return __tree_.lower_bound(__k);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  upper_bound(const key_type &__k) {
    return __tree_.upper_bound(__k);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_iterator
  upper_bound(const key_type &__k) const {
    return __tree_.upper_bound(__k);
  }

  template <typename _K2>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename enable_if<__is_transparent<_Compare, _K2>::value, iterator>::type
  upper_bound(const _K2 &__k) {
    return __tree_.upper_bound(__k);
  }
  template <typename _K2>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename enable_if<__is_transparent<_Compare, _K2>::value,
                     const_iterator>::type
  upper_bound(const _K2 &__k) const {
    return __tree_.upper_bound(__k);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pair<iterator, iterator>
  equal_range(const key_type &__k) {
    return __tree_.__equal_range_unique(__k);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pair<const_iterator, const_iterator>
  equal_range(const key_type &__k) const {
    return __tree_.__equal_range_unique(__k);
  }

  template <typename _K2>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename enable_if<__is_transparent<_Compare, _K2>::value,
                     pair<iterator, iterator>>::type
  equal_range(const _K2 &__k) {
    return __tree_.__equal_range_multi(__k);
  }
  template <typename _K2>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename enable_if<__is_transparent<_Compare, _K2>::value,
                     pair<const_iterator, const_iterator>>::type
  equal_range(const _K2 &__k) const {
    return __tree_.__equal_range_multi(__k);
  }

private:
  typedef typename __base::__node __node;
  typedef typename __base::__node_allocator __node_allocator;
  typedef typename __base::__node_pointer __node_pointer;
  typedef typename __base::__node_base_pointer __node_base_pointer;
  typedef typename __base::__parent_pointer __parent_pointer;

  typedef __map_node_destructor<__node_allocator> _Dp;
  typedef unique_ptr<__node, _Dp> __node_holder;
};
# 1502 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/map" 3
template <class _Key, class _Tp, class _Compare, class _Allocator>
map<_Key, _Tp, _Compare, _Allocator>::map(map &&__m, const allocator_type &__a)
    : __tree_(std::__1::move(__m.__tree_),
              typename __base::allocator_type(__a)) {
  if (__a != __m.get_allocator()) {
    const_iterator __e = cend();
    while (!__m.empty())
      __tree_.__insert_unique(
          __e.__i_, __m.__tree_.remove(__m.begin().__i_)->__value_.__move());
  }
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
_Tp &map<_Key, _Tp, _Compare, _Allocator>::operator[](const key_type &__k) {
  return __tree_
      .__emplace_unique_key_args(__k, std::__1::piecewise_construct,
                                 std::__1::forward_as_tuple(__k),
                                 std::__1::forward_as_tuple())
      .first->__get_value()
      .second;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
_Tp &map<_Key, _Tp, _Compare, _Allocator>::operator[](key_type &&__k) {
  return __tree_
      .__emplace_unique_key_args(
          __k, std::__1::piecewise_construct,
          std::__1::forward_as_tuple(std::__1::move(__k)),
          std::__1::forward_as_tuple())
      .first->__get_value()
      .second;
}
# 1568 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/map" 3
template <class _Key, class _Tp, class _Compare, class _Allocator>
_Tp &map<_Key, _Tp, _Compare, _Allocator>::at(const key_type &__k) {
  __parent_pointer __parent;
  __node_base_pointer &__child = __tree_.__find_equal(__parent, __k);
  if (__child == nullptr)
    __throw_out_of_range("map::at:  key not found");
  return static_cast<__node_pointer>(__child)->__value_.__get_value().second;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
const _Tp &map<_Key, _Tp, _Compare, _Allocator>::at(const key_type &__k) const {
  __parent_pointer __parent;
  __node_base_pointer __child = __tree_.__find_equal(__parent, __k);
  if (__child == nullptr)
    __throw_out_of_range("map::at:  key not found");
  return static_cast<__node_pointer>(__child)->__value_.__get_value().second;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator==(const map<_Key, _Tp, _Compare, _Allocator> &__x,
           const map<_Key, _Tp, _Compare, _Allocator> &__y) {
  return __x.size() == __y.size() &&
         std::__1::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator<(const map<_Key, _Tp, _Compare, _Allocator> &__x,
          const map<_Key, _Tp, _Compare, _Allocator> &__y) {
  return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(),
                                           __y.end());
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator!=(const map<_Key, _Tp, _Compare, _Allocator> &__x,
           const map<_Key, _Tp, _Compare, _Allocator> &__y) {
  return !(__x == __y);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator>(const map<_Key, _Tp, _Compare, _Allocator> &__x,
          const map<_Key, _Tp, _Compare, _Allocator> &__y) {
  return __y < __x;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator>=(const map<_Key, _Tp, _Compare, _Allocator> &__x,
           const map<_Key, _Tp, _Compare, _Allocator> &__y) {
  return !(__x < __y);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator<=(const map<_Key, _Tp, _Compare, _Allocator> &__x,
           const map<_Key, _Tp, _Compare, _Allocator> &__y) {
  return !(__y < __x);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
swap(map<_Key, _Tp, _Compare, _Allocator> &__x,
     map<_Key, _Tp, _Compare, _Allocator>
         &__y) noexcept(noexcept(__x.swap(__y))) {
  __x.swap(__y);
}
# 1663 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/map" 3
template <class _Key, class _Tp, class _Compare = less<_Key>,
          class _Allocator = allocator<pair<const _Key, _Tp>>>
class __attribute__((__type_visibility__("default"))) multimap {
public:
  typedef _Key key_type;
  typedef _Tp mapped_type;
  typedef pair<const key_type, mapped_type> value_type;
  typedef typename __identity<_Compare>::type key_compare;
  typedef typename __identity<_Allocator>::type allocator_type;
  typedef value_type &reference;
  typedef const value_type &const_reference;

  static_assert(
      (is_same<typename allocator_type::value_type, value_type>::value),
      "Allocator::value_type must be same type as value_type");

  class __attribute__((__type_visibility__("default"))) value_compare
      : public binary_function<value_type, value_type, bool> {
    friend class multimap;

  protected:
    key_compare comp;

    __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
    value_compare(key_compare c)
        : comp(c) {}

  public:
    __attribute__((__visibility__("hidden")))
    __attribute__((internal_linkage)) bool
    operator()(const value_type &__x, const value_type &__y) const {
      return comp(__x.first, __y.first);
    }
  };

private:
  typedef std::__1::__value_type<key_type, mapped_type> __value_type;
  typedef __map_value_compare<key_type, __value_type, key_compare> __vc;
  typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,
                                         __value_type>::type __allocator_type;
  typedef __tree<__value_type, __vc, __allocator_type> __base;
  typedef typename __base::__node_traits __node_traits;
  typedef allocator_traits<allocator_type> __alloc_traits;

  __base __tree_;

public:
  typedef typename __alloc_traits::pointer pointer;
  typedef typename __alloc_traits::const_pointer const_pointer;
  typedef typename __alloc_traits::size_type size_type;
  typedef typename __alloc_traits::difference_type difference_type;
  typedef __map_iterator<typename __base::iterator> iterator;
  typedef __map_const_iterator<typename __base::const_iterator> const_iterator;
  typedef std::__1::reverse_iterator<iterator> reverse_iterator;
  typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

  template <class _Key2, class _Value2, class _Comp2, class _Alloc2>
  friend class __attribute__((__type_visibility__("default"))) map;
  template <class _Key2, class _Value2, class _Comp2, class _Alloc2>
  friend class __attribute__((__type_visibility__("default"))) multimap;

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  multimap() noexcept(
      is_nothrow_default_constructible<allocator_type>::value
          &&is_nothrow_default_constructible<key_compare>::value
              &&is_nothrow_copy_constructible<key_compare>::value)

      : __tree_(__vc(key_compare())) {}

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit multimap(
      const key_compare
          &__comp) noexcept(is_nothrow_default_constructible<allocator_type>::
                                value &&is_nothrow_copy_constructible<
                                    key_compare>::value)

      : __tree_(__vc(__comp)) {}

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit multimap(const key_compare &__comp,
                                                      const allocator_type &__a)
      : __tree_(__vc(__comp), typename __base::allocator_type(__a)) {}

  template <class _InputIterator>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  multimap(_InputIterator __f, _InputIterator __l,
           const key_compare &__comp = key_compare())
      : __tree_(__vc(__comp)) {
    insert(__f, __l);
  }

  template <class _InputIterator>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  multimap(_InputIterator __f, _InputIterator __l, const key_compare &__comp,
           const allocator_type &__a)
      : __tree_(__vc(__comp), typename __base::allocator_type(__a)) {
    insert(__f, __l);
  }

  template <class _InputIterator>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  multimap(_InputIterator __f, _InputIterator __l, const allocator_type &__a)
      : multimap(__f, __l, key_compare(), __a) {}

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  multimap(const multimap &__m)
      : __tree_(__m.__tree_.value_comp(),
                __alloc_traits::select_on_container_copy_construction(
                    __m.__tree_.__alloc())) {
    insert(__m.begin(), __m.end());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  multimap &
  operator=(const multimap &__m) {

    __tree_ = __m.__tree_;
# 1791 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/map" 3
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  multimap(multimap &&__m) noexcept(
      is_nothrow_move_constructible<__base>::value)
      : __tree_(std::__1::move(__m.__tree_)) {}

  multimap(multimap &&__m, const allocator_type &__a);

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  multimap &
  operator=(multimap &&__m) noexcept(
      is_nothrow_move_assignable<__base>::value) {
    __tree_ = std::__1::move(__m.__tree_);
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  multimap(initializer_list<value_type> __il,
           const key_compare &__comp = key_compare())
      : __tree_(__vc(__comp)) {
    insert(__il.begin(), __il.end());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  multimap(initializer_list<value_type> __il, const key_compare &__comp,
           const allocator_type &__a)
      : __tree_(__vc(__comp), typename __base::allocator_type(__a)) {
    insert(__il.begin(), __il.end());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  multimap(initializer_list<value_type> __il, const allocator_type &__a)
      : multimap(__il, key_compare(), __a) {}

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  multimap &
  operator=(initializer_list<value_type> __il) {
    __tree_.__assign_multi(__il.begin(), __il.end());
    return *this;
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) explicit multimap(const allocator_type &__a)
      : __tree_(typename __base::allocator_type(__a)) {}

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  multimap(const multimap &__m, const allocator_type &__a)
      : __tree_(__m.__tree_.value_comp(),
                typename __base::allocator_type(__a)) {
    insert(__m.begin(), __m.end());
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) ~multimap() {
    static_assert(sizeof(__diagnose_non_const_comparator<_Key, _Compare>()),
                  "");
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  begin() noexcept {
    return __tree_.begin();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_iterator
  begin() const noexcept {
    return __tree_.begin();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  end() noexcept {
    return __tree_.end();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_iterator
  end() const noexcept {
    return __tree_.end();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reverse_iterator
  rbegin() noexcept {
    return reverse_iterator(end());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reverse_iterator
  rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  reverse_iterator
  rend() noexcept {
    return reverse_iterator(begin());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reverse_iterator
  rend() const noexcept {
    return const_reverse_iterator(begin());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_iterator
  cbegin() const noexcept {
    return begin();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_iterator
  cend() const noexcept {
    return end();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reverse_iterator
  crbegin() const noexcept {
    return rbegin();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_reverse_iterator
  crend() const noexcept {
    return rend();
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) bool
  empty() const noexcept {
    return __tree_.size() == 0;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  size() const noexcept {
    return __tree_.size();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  max_size() const noexcept {
    return __tree_.max_size();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  allocator_type
  get_allocator() const noexcept {
    return allocator_type(__tree_.__alloc());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  key_compare
  key_comp() const {
    return __tree_.value_comp().key_comp();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  value_compare
  value_comp() const {
    return value_compare(__tree_.value_comp().key_comp());
  }

  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  emplace(_Args &&...__args) {
    return __tree_.__emplace_multi(std::__1::forward<_Args>(__args)...);
  }

  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  emplace_hint(const_iterator __p, _Args &&...__args) {
    return __tree_.__emplace_hint_multi(__p.__i_,
                                        std::__1::forward<_Args>(__args)...);
  }

  template <class _Pp, class = typename enable_if<
                           is_constructible<value_type, _Pp>::value>::type>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  insert(_Pp &&__p) {
    return __tree_.__insert_multi(std::__1::forward<_Pp>(__p));
  }

  template <class _Pp, class = typename enable_if<
                           is_constructible<value_type, _Pp>::value>::type>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  insert(const_iterator __pos, _Pp &&__p) {
    return __tree_.__insert_multi(__pos.__i_, std::__1::forward<_Pp>(__p));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  insert(value_type &&__v) {
    return __tree_.__insert_multi(std::__1::move(__v));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  insert(const_iterator __p, value_type &&__v) {
    return __tree_.__insert_multi(__p.__i_, std::__1::move(__v));
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  insert(initializer_list<value_type> __il) {
    insert(__il.begin(), __il.end());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  insert(const value_type &__v) {
    return __tree_.__insert_multi(__v);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  insert(const_iterator __p, const value_type &__v) {
    return __tree_.__insert_multi(__p.__i_, __v);
  }

  template <class _InputIterator>
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  insert(_InputIterator __f, _InputIterator __l) {
    for (const_iterator __e = cend(); __f != __l; ++__f)
      __tree_.__insert_multi(__e.__i_, *__f);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  erase(const_iterator __p) {
    return __tree_.erase(__p.__i_);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  erase(iterator __p) {
    return __tree_.erase(__p.__i_);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  erase(const key_type &__k) {
    return __tree_.__erase_multi(__k);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  erase(const_iterator __f, const_iterator __l) {
    return __tree_.erase(__f.__i_, __l.__i_);
  }
# 2032 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/map" 3
  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  clear() noexcept {
    __tree_.clear();
  }

  __attribute__((__visibility__("hidden")))
  __attribute__((internal_linkage)) void
  swap(multimap &__m) noexcept(__is_nothrow_swappable<__base>::value) {
    __tree_.swap(__m.__tree_);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  find(const key_type &__k) {
    return __tree_.find(__k);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_iterator
  find(const key_type &__k) const {
    return __tree_.find(__k);
  }

  template <typename _K2>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename enable_if<__is_transparent<_Compare, _K2>::value, iterator>::type
  find(const _K2 &__k) {
    return __tree_.find(__k);
  }
  template <typename _K2>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename enable_if<__is_transparent<_Compare, _K2>::value,
                     const_iterator>::type
  find(const _K2 &__k) const {
    return __tree_.find(__k);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  size_type
  count(const key_type &__k) const {
    return __tree_.__count_multi(__k);
  }

  template <typename _K2>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename enable_if<__is_transparent<_Compare, _K2>::value, size_type>::type
  count(const _K2 &__k) const {
    return __tree_.__count_multi(__k);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  lower_bound(const key_type &__k) {
    return __tree_.lower_bound(__k);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_iterator
  lower_bound(const key_type &__k) const {
    return __tree_.lower_bound(__k);
  }

  template <typename _K2>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename enable_if<__is_transparent<_Compare, _K2>::value, iterator>::type
  lower_bound(const _K2 &__k) {
    return __tree_.lower_bound(__k);
  }

  template <typename _K2>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename enable_if<__is_transparent<_Compare, _K2>::value,
                     const_iterator>::type
  lower_bound(const _K2 &__k) const {
    return __tree_.lower_bound(__k);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  iterator
  upper_bound(const key_type &__k) {
    return __tree_.upper_bound(__k);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  const_iterator
  upper_bound(const key_type &__k) const {
    return __tree_.upper_bound(__k);
  }

  template <typename _K2>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename enable_if<__is_transparent<_Compare, _K2>::value, iterator>::type
  upper_bound(const _K2 &__k) {
    return __tree_.upper_bound(__k);
  }
  template <typename _K2>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename enable_if<__is_transparent<_Compare, _K2>::value,
                     const_iterator>::type
  upper_bound(const _K2 &__k) const {
    return __tree_.upper_bound(__k);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pair<iterator, iterator>
  equal_range(const key_type &__k) {
    return __tree_.__equal_range_multi(__k);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  pair<const_iterator, const_iterator>
  equal_range(const key_type &__k) const {
    return __tree_.__equal_range_multi(__k);
  }

  template <typename _K2>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename enable_if<__is_transparent<_Compare, _K2>::value,
                     pair<iterator, iterator>>::type
  equal_range(const _K2 &__k) {
    return __tree_.__equal_range_multi(__k);
  }
  template <typename _K2>
  __attribute__((__visibility__("hidden"))) __attribute__((internal_linkage))
  typename enable_if<__is_transparent<_Compare, _K2>::value,
                     pair<const_iterator, const_iterator>>::type
  equal_range(const _K2 &__k) const {
    return __tree_.__equal_range_multi(__k);
  }

private:
  typedef typename __base::__node __node;
  typedef typename __base::__node_allocator __node_allocator;
  typedef typename __base::__node_pointer __node_pointer;

  typedef __map_node_destructor<__node_allocator> _Dp;
  typedef unique_ptr<__node, _Dp> __node_holder;
};
# 2159 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/map" 3
template <class _Key, class _Tp, class _Compare, class _Allocator>
multimap<_Key, _Tp, _Compare, _Allocator>::multimap(multimap &&__m,
                                                    const allocator_type &__a)
    : __tree_(std::__1::move(__m.__tree_),
              typename __base::allocator_type(__a)) {
  if (__a != __m.get_allocator()) {
    const_iterator __e = cend();
    while (!__m.empty())
      __tree_.__insert_multi(
          __e.__i_,
          std::__1::move(
              __m.__tree_.remove(__m.begin().__i_)->__value_.__move()));
  }
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator==(const multimap<_Key, _Tp, _Compare, _Allocator> &__x,
           const multimap<_Key, _Tp, _Compare, _Allocator> &__y) {
  return __x.size() == __y.size() &&
         std::__1::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator<(const multimap<_Key, _Tp, _Compare, _Allocator> &__x,
          const multimap<_Key, _Tp, _Compare, _Allocator> &__y) {
  return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(),
                                           __y.end());
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator!=(const multimap<_Key, _Tp, _Compare, _Allocator> &__x,
           const multimap<_Key, _Tp, _Compare, _Allocator> &__y) {
  return !(__x == __y);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator>(const multimap<_Key, _Tp, _Compare, _Allocator> &__x,
          const multimap<_Key, _Tp, _Compare, _Allocator> &__y) {
  return __y < __x;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator>=(const multimap<_Key, _Tp, _Compare, _Allocator> &__x,
           const multimap<_Key, _Tp, _Compare, _Allocator> &__y) {
  return !(__x < __y);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) bool
operator<=(const multimap<_Key, _Tp, _Compare, _Allocator> &__x,
           const multimap<_Key, _Tp, _Compare, _Allocator> &__y) {
  return !(__y < __x);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden")))
__attribute__((internal_linkage)) void
swap(multimap<_Key, _Tp, _Compare, _Allocator> &__x,
     multimap<_Key, _Tp, _Compare, _Allocator>
         &__y) noexcept(noexcept(__x.swap(__y))) {
  __x.swap(__y);
}
# 2244 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/map" 3
} // namespace __1
} // namespace std
# 57 "/usr/local/include/QtCore/qmetatype.h" 2

enum class QCborSimpleType : quint8;

template <typename T> struct QMetaTypeId2;

template <typename T> inline constexpr int qMetaTypeId();
# 239 "/usr/local/include/QtCore/qmetatype.h"
class QDataStream;
class QMetaTypeInterface;
struct QMetaObject;

namespace QtPrivate {

template <typename From, typename To> To convertImplicit(const From &from) {
  return from;
}

struct AbstractDebugStreamFunction {
  typedef void (*Stream)(const AbstractDebugStreamFunction *, QDebug &,
                         const void *);
  typedef void (*Destroy)(AbstractDebugStreamFunction *);
  explicit AbstractDebugStreamFunction(Stream s = nullptr, Destroy d = nullptr)
      : stream(s), destroy(d) {}
  AbstractDebugStreamFunction(const AbstractDebugStreamFunction &) = delete;
  AbstractDebugStreamFunction &
  operator=(const AbstractDebugStreamFunction &) = delete;
  Stream stream;
  Destroy destroy;
};

template <typename T>
struct BuiltInDebugStreamFunction : public AbstractDebugStreamFunction {
  BuiltInDebugStreamFunction() : AbstractDebugStreamFunction(stream, destroy) {}
  static void stream(const AbstractDebugStreamFunction *, QDebug &dbg,
                     const void *r) {
    const T *rhs = static_cast<const T *>(r);
    operator<<(dbg, *rhs);
  }

  static void destroy(AbstractDebugStreamFunction *_this) {
    delete static_cast<BuiltInDebugStreamFunction *>(_this);
  }
};

struct AbstractComparatorFunction {
  typedef bool (*LessThan)(const AbstractComparatorFunction *, const void *,
                           const void *);
  typedef bool (*Equals)(const AbstractComparatorFunction *, const void *,
                         const void *);
  typedef void (*Destroy)(AbstractComparatorFunction *);
  explicit AbstractComparatorFunction(LessThan lt = nullptr, Equals e = nullptr,
                                      Destroy d = nullptr)
      : lessThan(lt), equals(e), destroy(d) {}
  AbstractComparatorFunction(const AbstractComparatorFunction &) = delete;
  AbstractComparatorFunction &
  operator=(const AbstractComparatorFunction &) = delete;
  LessThan lessThan;
  Equals equals;
  Destroy destroy;
};

template <typename T>
struct BuiltInComparatorFunction : public AbstractComparatorFunction {
  BuiltInComparatorFunction()
      : AbstractComparatorFunction(lessThan, equals, destroy) {}
  static bool lessThan(const AbstractComparatorFunction *, const void *l,
                       const void *r) {
    const T *lhs = static_cast<const T *>(l);
    const T *rhs = static_cast<const T *>(r);
    return *lhs < *rhs;
  }

  static bool equals(const AbstractComparatorFunction *, const void *l,
                     const void *r) {
    const T *lhs = static_cast<const T *>(l);
    const T *rhs = static_cast<const T *>(r);
    return *lhs == *rhs;
  }

  static void destroy(AbstractComparatorFunction *_this) {
    delete static_cast<BuiltInComparatorFunction *>(_this);
  }
};

template <typename T>
struct BuiltInEqualsComparatorFunction : public AbstractComparatorFunction {
  BuiltInEqualsComparatorFunction()
      : AbstractComparatorFunction(nullptr, equals, destroy) {}
  static bool equals(const AbstractComparatorFunction *, const void *l,
                     const void *r) {
    const T *lhs = static_cast<const T *>(l);
    const T *rhs = static_cast<const T *>(r);
    return *lhs == *rhs;
  }

  static void destroy(AbstractComparatorFunction *_this) {
    delete static_cast<BuiltInEqualsComparatorFunction *>(_this);
  }
};

struct AbstractConverterFunction {
  typedef bool (*Converter)(const AbstractConverterFunction *, const void *,
                            void *);
  explicit AbstractConverterFunction(Converter c = nullptr) : convert(c) {}
  AbstractConverterFunction(const AbstractConverterFunction &) = delete;
  AbstractConverterFunction &
  operator=(const AbstractConverterFunction &) = delete;
  Converter convert;
};

template <typename From, typename To>
struct ConverterMemberFunction : public AbstractConverterFunction {
  explicit ConverterMemberFunction(To (From::*function)() const)
      : AbstractConverterFunction(convert), m_function(function) {}
  ~ConverterMemberFunction();
  static bool convert(const AbstractConverterFunction *_this, const void *in,
                      void *out) {
    const From *f = static_cast<const From *>(in);
    To *t = static_cast<To *>(out);
    const ConverterMemberFunction *_typedThis =
        static_cast<const ConverterMemberFunction *>(_this);
    *t = (f->*_typedThis->m_function)();
    return true;
  }

  To (From::*const m_function)() const;
};

template <typename From, typename To>
struct ConverterMemberFunctionOk : public AbstractConverterFunction {
  explicit ConverterMemberFunctionOk(To (From::*function)(bool *) const)
      : AbstractConverterFunction(convert), m_function(function) {}
  ~ConverterMemberFunctionOk();
  static bool convert(const AbstractConverterFunction *_this, const void *in,
                      void *out) {
    const From *f = static_cast<const From *>(in);
    To *t = static_cast<To *>(out);
    bool ok = false;
    const ConverterMemberFunctionOk *_typedThis =
        static_cast<const ConverterMemberFunctionOk *>(_this);
    *t = (f->*_typedThis->m_function)(&ok);
    if (!ok)
      *t = To();
    return ok;
  }

  To (From::*const m_function)(bool *) const;
};

template <typename From, typename To, typename UnaryFunction>
struct ConverterFunctor : public AbstractConverterFunction {
  explicit ConverterFunctor(UnaryFunction function)
      : AbstractConverterFunction(convert), m_function(function) {}
  ~ConverterFunctor();
  static bool convert(const AbstractConverterFunction *_this, const void *in,
                      void *out) {
    const From *f = static_cast<const From *>(in);
    To *t = static_cast<To *>(out);
    const ConverterFunctor *_typedThis =
        static_cast<const ConverterFunctor *>(_this);
    *t = _typedThis->m_function(*f);
    return true;
  }

  UnaryFunction m_function;
};

template <typename T, bool> struct ValueTypeIsMetaType;
template <typename T, bool> struct AssociativeValueTypeIsMetaType;
template <typename T, bool> struct IsMetaTypePair;
template <typename, typename> struct MetaTypeSmartPointerHelper;
} // namespace QtPrivate

class __attribute__((visibility("default"))) QMetaType {
  enum ExtensionFlag {
    NoExtensionFlags,
    CreateEx = 0x1,
    DestroyEx = 0x2,
    ConstructEx = 0x4,
    DestructEx = 0x8,
    NameEx = 0x10,
    SizeEx = 0x20,
    CtorEx = 0x40,
    DtorEx = 0x80,
    FlagsEx = 0x100,
    MetaObjectEx = 0x200
  };

public:
  enum Type {

    Void = 43,
    Bool = 1,
    Int = 2,
    UInt = 3,
    LongLong = 4,
    ULongLong = 5,
    Double = 6,
    Long = 32,
    Short = 33,
    Char = 34,
    ULong = 35,
    UShort = 36,
    UChar = 37,
    Float = 38,
    SChar = 40,
    Nullptr = 51,
    QCborSimpleType = 52,
    VoidStar = 31,
    QChar = 7,
    QString = 10,
    QStringList = 11,
    QByteArray = 12,
    QBitArray = 13,
    QDate = 14,
    QTime = 15,
    QDateTime = 16,
    QUrl = 17,
    QLocale = 18,
    QRect = 19,
    QRectF = 20,
    QSize = 21,
    QSizeF = 22,
    QLine = 23,
    QLineF = 24,
    QPoint = 25,
    QPointF = 26,
    QRegExp = 27,
    QEasingCurve = 29,
    QUuid = 30,
    QVariant = 41,
    QRegularExpression = 44,
    QJsonValue = 45,
    QJsonObject = 46,
    QJsonArray = 47,
    QJsonDocument = 48,
    QCborValue = 53,
    QCborArray = 54,
    QCborMap = 55,
    QModelIndex = 42,
    QPersistentModelIndex = 50,
    QObjectStar = 39,
    QVariantMap = 8,
    QVariantList = 9,
    QVariantHash = 28,
    QByteArrayList = 49,
    QFont = 64,
    QPixmap = 65,
    QBrush = 66,
    QColor = 67,
    QPalette = 68,
    QIcon = 69,
    QImage = 70,
    QPolygon = 71,
    QRegion = 72,
    QBitmap = 73,
    QCursor = 74,
    QKeySequence = 75,
    QPen = 76,
    QTextLength = 77,
    QTextFormat = 78,
    QMatrix = 79,
    QTransform = 80,
    QMatrix4x4 = 81,
    QVector2D = 82,
    QVector3D = 83,
    QVector4D = 84,
    QQuaternion = 85,
    QPolygonF = 86,
    QColorSpace = 87,
    QSizePolicy = 121,

    FirstCoreType = Bool,
    LastCoreType = QCborMap,
    FirstGuiType = QFont,
    LastGuiType = QColorSpace,
    FirstWidgetsType = QSizePolicy,
    LastWidgetsType = QSizePolicy,
    HighestInternalId = LastWidgetsType,

    QReal = sizeof(qreal) == sizeof(double) ? Double : Float,

    UnknownType = 0,
    User = 1024
  };
# 486 "/usr/local/include/QtCore/qmetatype.h"
  enum TypeFlag {
    NeedsConstruction = 0x1,
    NeedsDestruction = 0x2,
    MovableType = 0x4,
    PointerToQObject = 0x8,
    IsEnumeration = 0x10,
    SharedPointerToQObject = 0x20,
    WeakPointerToQObject = 0x40,
    TrackingPointerToQObject = 0x80,
    WasDeclaredAsMetaType = 0x100,
    IsGadget = 0x200,
    PointerToGadget = 0x400
  };
  typedef QFlags<TypeFlag> TypeFlags;

  typedef void (*Deleter)(void *);
  typedef void *(*Creator)(const void *);

  typedef void (*Destructor)(void *);
  typedef void *(*Constructor)(void *, const void *);

  typedef void (*TypedDestructor)(int, void *);
  typedef void *(*TypedConstructor)(int, void *, const void *);

  typedef void (*SaveOperator)(QDataStream &, const void *);
  typedef void (*LoadOperator)(QDataStream &, void *);

  static void registerStreamOperators(const char *typeName, SaveOperator saveOp,
                                      LoadOperator loadOp);
  static void registerStreamOperators(int type, SaveOperator saveOp,
                                      LoadOperator loadOp);

  static int registerType(const char *typeName, Deleter deleter,
                          Creator creator);
  static int registerType(const char *typeName, Deleter deleter,
                          Creator creator, Destructor destructor,
                          Constructor constructor, int size,
                          QMetaType::TypeFlags flags,
                          const QMetaObject *metaObject);
  static int registerType(const char *typeName, TypedDestructor destructor,
                          TypedConstructor constructor, int size,
                          QMetaType::TypeFlags flags,
                          const QMetaObject *metaObject);
  static bool unregisterType(int type);
  static int registerNormalizedType(const ::QByteArray &normalizedTypeName,
                                    Deleter deleter, Creator creator,
                                    Destructor destructor,
                                    Constructor constructor, int size,
                                    QMetaType::TypeFlags flags,
                                    const QMetaObject *metaObject);
  static int registerNormalizedType(const ::QByteArray &normalizedTypeName,
                                    Destructor destructor,
                                    Constructor constructor, int size,
                                    QMetaType::TypeFlags flags,
                                    const QMetaObject *metaObject);
  static int registerNormalizedType(const ::QByteArray &normalizedTypeName,
                                    TypedDestructor destructor,
                                    TypedConstructor constructor, int size,
                                    QMetaType::TypeFlags flags,
                                    const QMetaObject *metaObject);
  static int registerTypedef(const char *typeName, int aliasId);
  static int registerNormalizedTypedef(const ::QByteArray &normalizedTypeName,
                                       int aliasId);
  static int type(const char *typeName);

  static int type(const ::QByteArray &typeName);
  static const char *typeName(int type);
  static int sizeOf(int type);
  static TypeFlags typeFlags(int type);
  static const QMetaObject *metaObjectForType(int type);
  static bool isRegistered(int type);
  static void *create(int type, const void *copy = nullptr);

  static void destroy(int type, void *data);
  static void *construct(int type, void *where, const void *copy);
  static void destruct(int type, void *where);

  static bool save(QDataStream &stream, int type, const void *data);
  static bool load(QDataStream &stream, int type, void *data);

  explicit QMetaType(const int type = QMetaType::UnknownType);
  inline ~QMetaType();

  inline bool isValid() const;
  inline bool isRegistered() const;
  inline int id() const;
  inline int sizeOf() const;
  inline TypeFlags flags() const;
  inline const QMetaObject *metaObject() const;
  ::QByteArray name() const;

  inline void *create(const void *copy = nullptr) const;
  inline void destroy(void *data) const;
  inline void *construct(void *where, const void *copy = nullptr) const;
  inline void destruct(void *data) const;

  template <typename T> static QMetaType fromType() {
    return QMetaType(qMetaTypeId<T>());
  }

  friend bool operator==(const QMetaType &a, const QMetaType &b) {
    return a.m_typeId == b.m_typeId;
  }

  friend bool operator!=(const QMetaType &a, const QMetaType &b) {
    return a.m_typeId != b.m_typeId;
  }

public:
  template <typename T> static bool registerComparators() {
    static_assert(
        bool((!QMetaTypeId2<T>::IsBuiltIn)),
        "QMetaType::registerComparators: The type must be a custom type.");

    const int typeId = qMetaTypeId<T>();
    static const QtPrivate::BuiltInComparatorFunction<T> f;
    return registerComparatorFunction(&f, typeId);
  }
  template <typename T> static bool registerEqualsComparator() {
    static_assert(
        bool((!QMetaTypeId2<T>::IsBuiltIn)),
        "QMetaType::registerEqualsComparator: The type must be a custom type.");

    const int typeId = qMetaTypeId<T>();
    static const QtPrivate::BuiltInEqualsComparatorFunction<T> f;
    return registerComparatorFunction(&f, typeId);
  }

  template <typename T> static bool hasRegisteredComparators() {
    return hasRegisteredComparators(qMetaTypeId<T>());
  }
  static bool hasRegisteredComparators(int typeId);

  template <typename T> static bool registerDebugStreamOperator() {
    static_assert(bool((!QMetaTypeId2<T>::IsBuiltIn)),
                  "QMetaType::registerDebugStreamOperator: The type must be a "
                  "custom type.");

    const int typeId = qMetaTypeId<T>();
    static const QtPrivate::BuiltInDebugStreamFunction<T> f;
    return registerDebugStreamOperatorFunction(&f, typeId);
  }
  template <typename T> static bool hasRegisteredDebugStreamOperator() {
    return hasRegisteredDebugStreamOperator(qMetaTypeId<T>());
  }
  static bool hasRegisteredDebugStreamOperator(int typeId);

  template <typename From, typename To> static bool registerConverter() {
    return registerConverter<From, To>(QtPrivate::convertImplicit<From, To>);
  }
# 667 "/usr/local/include/QtCore/qmetatype.h"
  template <typename From, typename To>
  static bool registerConverter(To (From::*function)() const) {
    static_assert(
        bool((!QMetaTypeId2<To>::IsBuiltIn || !QMetaTypeId2<From>::IsBuiltIn)),
        "QMetaType::registerConverter: At least one of the types must be a "
        "custom type.");

    const int fromTypeId = qMetaTypeId<From>();
    const int toTypeId = qMetaTypeId<To>();
    static const QtPrivate::ConverterMemberFunction<From, To> f(function);
    return registerConverterFunction(&f, fromTypeId, toTypeId);
  }

  template <typename From, typename To>
  static bool registerConverter(To (From::*function)(bool *) const) {
    static_assert(
        bool((!QMetaTypeId2<To>::IsBuiltIn || !QMetaTypeId2<From>::IsBuiltIn)),
        "QMetaType::registerConverter: At least one of the types must be a "
        "custom type.");

    const int fromTypeId = qMetaTypeId<From>();
    const int toTypeId = qMetaTypeId<To>();
    static const QtPrivate::ConverterMemberFunctionOk<From, To> f(function);
    return registerConverterFunction(&f, fromTypeId, toTypeId);
  }

  template <typename From, typename To, typename UnaryFunction>
  static bool registerConverter(UnaryFunction function) {
    static_assert(
        bool((!QMetaTypeId2<To>::IsBuiltIn || !QMetaTypeId2<From>::IsBuiltIn)),
        "QMetaType::registerConverter: At least one of the types must be a "
        "custom type.");

    const int fromTypeId = qMetaTypeId<From>();
    const int toTypeId = qMetaTypeId<To>();
    static const QtPrivate::ConverterFunctor<From, To, UnaryFunction> f(
        function);
    return registerConverterFunction(&f, fromTypeId, toTypeId);
  }

  static bool convert(const void *from, int fromTypeId, void *to, int toTypeId);
  static bool compare(const void *lhs, const void *rhs, int typeId,
                      int *result);
  static bool equals(const void *lhs, const void *rhs, int typeId, int *result);
  static bool debugStream(QDebug &dbg, const void *rhs, int typeId);

  template <typename From, typename To>
  static bool hasRegisteredConverterFunction() {
    return hasRegisteredConverterFunction(qMetaTypeId<From>(),
                                          qMetaTypeId<To>());
  }

  static bool hasRegisteredConverterFunction(int fromTypeId, int toTypeId);

private:
  static QMetaType typeInfo(const int type);
  inline QMetaType(const ExtensionFlag extensionFlags,
                   const QMetaTypeInterface *info, TypedConstructor creator,
                   TypedDestructor deleter, SaveOperator saveOp,
                   LoadOperator loadOp, Constructor constructor,
                   Destructor destructor, uint sizeOf, uint theTypeFlags,
                   int typeId, const QMetaObject *metaObject);
  QMetaType(const QMetaType &other);
  QMetaType &operator=(const QMetaType &);
  inline bool isExtended(const ExtensionFlag flag) const {
    return m_extensionFlags & flag;
  }

  void ctor(const QMetaTypeInterface *info);
  void dtor();
  uint sizeExtended() const;
  QMetaType::TypeFlags flagsExtended() const;
  const QMetaObject *metaObjectExtended() const;
  void *createExtended(const void *copy = nullptr) const;
  void destroyExtended(void *data) const;
  void *constructExtended(void *where, const void *copy = nullptr) const;
  void destructExtended(void *data) const;

  static bool
  registerComparatorFunction(const QtPrivate::AbstractComparatorFunction *f,
                             int type);

  static bool registerDebugStreamOperatorFunction(
      const QtPrivate::AbstractDebugStreamFunction *f, int type);

  template <typename, bool> friend struct QtPrivate::ValueTypeIsMetaType;
  template <typename, typename>
  friend struct QtPrivate::ConverterMemberFunction;
  template <typename, typename>
  friend struct QtPrivate::ConverterMemberFunctionOk;
  template <typename, typename, typename>
  friend struct QtPrivate::ConverterFunctor;
  template <typename, bool>
  friend struct QtPrivate::AssociativeValueTypeIsMetaType;
  template <typename, bool> friend struct QtPrivate::IsMetaTypePair;
  template <typename, typename>
  friend struct QtPrivate::MetaTypeSmartPointerHelper;

  static bool
  registerConverterFunction(const QtPrivate::AbstractConverterFunction *f,
                            int from, int to);
  static void unregisterConverterFunction(int from, int to);

private:
  TypedConstructor m_typedConstructor;
  TypedDestructor m_typedDestructor;
  SaveOperator m_saveOp;
  LoadOperator m_loadOp;
  Constructor m_constructor;
  Destructor m_destructor;
  void *m_extension;
  uint m_size;
  uint m_typeFlags;
  uint m_extensionFlags;
  int m_typeId;
  const QMetaObject *m_metaObject;
};

constexpr inline QFlags<QMetaType::TypeFlags::enum_type>
operator|(QMetaType::TypeFlags::enum_type f1,
          QMetaType::TypeFlags::enum_type f2) noexcept {
  return QFlags<QMetaType::TypeFlags::enum_type>(f1) | f2;
}
constexpr inline QFlags<QMetaType::TypeFlags::enum_type>
operator|(QMetaType::TypeFlags::enum_type f1,
          QFlags<QMetaType::TypeFlags::enum_type> f2) noexcept {
  return f2 | f1;
}
constexpr inline QIncompatibleFlag operator|(QMetaType::TypeFlags::enum_type f1,
                                             int f2) noexcept {
  return QIncompatibleFlag(int(f1) | f2);
}

namespace QtPrivate {

template <typename From, typename To>
ConverterMemberFunction<From, To>::~ConverterMemberFunction() {
  QMetaType::unregisterConverterFunction(qMetaTypeId<From>(),
                                         qMetaTypeId<To>());
}
template <typename From, typename To>
ConverterMemberFunctionOk<From, To>::~ConverterMemberFunctionOk() {
  QMetaType::unregisterConverterFunction(qMetaTypeId<From>(),
                                         qMetaTypeId<To>());
}
template <typename From, typename To, typename UnaryFunction>
ConverterFunctor<From, To, UnaryFunction>::~ConverterFunctor() {
  QMetaType::unregisterConverterFunction(qMetaTypeId<From>(),
                                         qMetaTypeId<To>());
}

} // namespace QtPrivate

namespace QtMetaTypePrivate {
template <typename T, bool Accepted = true> struct QMetaTypeFunctionHelper {
  static void Destruct(void *t) {
    (void)t;
    static_cast<T *>(t)->~T();
  }

  static void *Construct(void *where, const void *t) {
    if (t)
      return new (where) T(*static_cast<const T *>(t));
    return new (where) T;
  }

  static void Save(QDataStream &stream, const void *t) {
    stream << *static_cast<const T *>(t);
  }

  static void Load(QDataStream &stream, void *t) {
    stream >> *static_cast<T *>(t);
  }
};

template <typename T> struct QMetaTypeFunctionHelper<T, false> {
  static void Destruct(void *) {}
  static void *Construct(void *, const void *) { return nullptr; }

  static void Save(QDataStream &, const void *) {}
  static void Load(QDataStream &, void *) {}
};
template <>
struct QMetaTypeFunctionHelper<void, true>
    : public QMetaTypeFunctionHelper<void, false> {};

struct VariantData {
  VariantData(const int metaTypeId_, const void *data_, const uint flags_)
      : metaTypeId(metaTypeId_), data(data_), flags(flags_) {}
  VariantData(const VariantData &other)
      : metaTypeId(other.metaTypeId), data(other.data), flags(other.flags) {}
  const int metaTypeId;
  const void *data;
  const uint flags;

private:
  VariantData &operator=(const VariantData &) = delete;
};

template <typename const_iterator> struct IteratorOwnerCommon {
  static void assign(void **ptr, const_iterator iterator) {
    *ptr = new const_iterator(iterator);
  }
  static void assign(void **ptr, void *const *src) {
    *ptr = new const_iterator(*static_cast<const_iterator *>(*src));
  }

  static void advance(void **iterator, int step) {
    const_iterator &it = *static_cast<const_iterator *>(*iterator);
    std::advance(it, step);
  }

  static void destroy(void **ptr) {
    delete static_cast<const_iterator *>(*ptr);
  }

  static bool equal(void *const *it, void *const *other) {
    return *static_cast<const_iterator *>(*it) ==
           *static_cast<const_iterator *>(*other);
  }
};

template <typename const_iterator>
struct IteratorOwner : IteratorOwnerCommon<const_iterator> {
  static const void *getData(void *const *iterator) {
    return &**static_cast<const_iterator *>(*iterator);
  }

  static const void *getData(const_iterator it) { return &*it; }
};

struct __attribute__((visibility("default"))) VectorBoolElements {
  static const bool true_element;
  static const bool false_element;
};

template <>
struct IteratorOwner<std::vector<bool>::const_iterator>
    : IteratorOwnerCommon<std::vector<bool>::const_iterator> {
public:
  static const void *getData(void *const *iterator) {
    return **static_cast<std::vector<bool>::const_iterator *>(*iterator)
               ? &VectorBoolElements::true_element
               : &VectorBoolElements::false_element;
  }

  static const void *getData(const std::vector<bool>::const_iterator &it) {
    return *it ? &VectorBoolElements::true_element
               : &VectorBoolElements::false_element;
  }
};

template <typename value_type> struct IteratorOwner<const value_type *> {
private:
  struct Dummy {};
  typedef
      typename std::conditional<std::is_same<value_type, void *>::value, Dummy,
                                value_type>::type value_type_OR_Dummy;

public:
  static void assign(void **ptr, const value_type_OR_Dummy *iterator) {
    *ptr = const_cast<value_type *>(iterator);
  }
  static void assign(void **ptr, void *const *src) {
    *ptr = static_cast<value_type *>(*src);
  }

  static void advance(void **iterator, int step) {
    value_type *it = static_cast<value_type *>(*iterator);
    std::advance(it, step);
    *iterator = it;
  }

  static void destroy(void **) {}

  static const void *getData(void *const *iterator) { return *iterator; }

  static const void *getData(const value_type_OR_Dummy *it) { return it; }

  static bool equal(void *const *it, void *const *other) {
    return static_cast<value_type *>(*it) == static_cast<value_type *>(*other);
  }
};

enum IteratorCapability {
  ForwardCapability = 1,
  BiDirectionalCapability = 2,
  RandomAccessCapability = 4
};

enum ContainerCapability { ContainerIsAppendable = 1 };

template <typename Container, typename T = void>
struct ContainerCapabilitiesImpl {
  enum { ContainerCapabilities = 0 };
  using appendFunction = void (*)(const void *container,
                                  const void *newElement);
  static constexpr const appendFunction appendImpl = nullptr;
};

template <typename Container>
struct ContainerCapabilitiesImpl<
    Container, decltype(std::declval<Container>().push_back(
                   std::declval<typename Container::value_type>()))> {
  enum { ContainerCapabilities = ContainerIsAppendable };

  static void appendImpl(const void *container, const void *value) {
    static_cast<Container *>(const_cast<void *>(container))
        ->push_back(
            *static_cast<const typename Container::value_type *>(value));
  }
};

namespace QtPrivate {
namespace ContainerCapabilitiesMetaProgrammingHelper {
template <typename... Ts> using void_t = void;
}
} // namespace QtPrivate

template <typename Container>
struct ContainerCapabilitiesImpl<
    Container, QtPrivate::ContainerCapabilitiesMetaProgrammingHelper::void_t<
                   decltype(std::declval<Container>().insert(
                       std::declval<typename Container::value_type>())),
                   decltype(std::declval<typename Container::value_type>() ==
                            std::declval<typename Container::value_type>())>> {
  enum { ContainerCapabilities = ContainerIsAppendable };

  static void appendImpl(const void *container, const void *value) {
    static_cast<Container *>(const_cast<void *>(container))
        ->insert(*static_cast<const typename Container::value_type *>(value));
  }
};

template <typename T, typename Category = typename std::iterator_traits<
                          typename T::const_iterator>::iterator_category>
struct CapabilitiesImpl;

template <typename T> struct CapabilitiesImpl<T, std::forward_iterator_tag> {
  enum { IteratorCapabilities = ForwardCapability };
};
template <typename T>
struct CapabilitiesImpl<T, std::bidirectional_iterator_tag> {
  enum { IteratorCapabilities = BiDirectionalCapability | ForwardCapability };
};
template <typename T>
struct CapabilitiesImpl<T, std::random_access_iterator_tag> {
  enum {
    IteratorCapabilities =
        RandomAccessCapability | BiDirectionalCapability | ForwardCapability
  };
};

template <typename T> struct ContainerAPI : CapabilitiesImpl<T> {
  static int size(const T *t) {
    return int(std::distance(t->begin(), t->end()));
  }
};

template <typename T>
struct ContainerAPI<QList<T>> : CapabilitiesImpl<QList<T>> {
  static int size(const QList<T> *t) { return t->size(); }
};

template <typename T>
struct ContainerAPI<QVector<T>> : CapabilitiesImpl<QVector<T>> {
  static int size(const QVector<T> *t) { return t->size(); }
};

template <typename T>
struct ContainerAPI<std::vector<T>> : CapabilitiesImpl<std::vector<T>> {
  static int size(const std::vector<T> *t) { return int(t->size()); }
};

template <typename T>
struct ContainerAPI<std::list<T>> : CapabilitiesImpl<std::list<T>> {
  static int size(const std::list<T> *t) { return int(t->size()); }
};

class QSequentialIterableImpl {
public:
  const void *_iterable;
  void *_iterator;
  int _metaType_id;
  uint _metaType_flags;
  uint _iteratorCapabilities;

  typedef int (*sizeFunc)(const void *p);
  typedef const void *(*atFunc)(const void *p, int);
  typedef void (*moveIteratorFunc)(const void *p, void **);
  enum Position { ToBegin, ToEnd };
  typedef void (*moveIteratorFunc2)(const void *p, void **, Position position);
  typedef void (*advanceFunc)(void **p, int);
  typedef VariantData (*getFunc)(void *const *p, int metaTypeId, uint flags);
  typedef void (*destroyIterFunc)(void **p);
  typedef bool (*equalIterFunc)(void *const *p, void *const *other);
  typedef void (*copyIterFunc)(void **, void *const *);
  typedef void (*appendFunction)(const void *container, const void *newElement);

  IteratorCapability iteratorCapabilities() {
    return static_cast<IteratorCapability>(_iteratorCapabilities & 0xF);
  }
  uint revision() { return _iteratorCapabilities >> 4 & 0x7; }
  uint containerCapabilities() { return _iteratorCapabilities >> 7 & 0xF; }

  sizeFunc _size;
  atFunc _at;
  union {
    moveIteratorFunc _moveToBegin;
    moveIteratorFunc2 _moveTo;
  };
  union {
    moveIteratorFunc _moveToEnd;
    appendFunction _append;
  };
  advanceFunc _advance;
  getFunc _get;
  destroyIterFunc _destroyIter;
  equalIterFunc _equalIter;
  copyIterFunc _copyIter;

  template <class T> static int sizeImpl(const void *p) {
    return ContainerAPI<T>::size(static_cast<const T *>(p));
  }

  template <class T> static const void *atImpl(const void *p, int idx) {
    typename T::const_iterator i = static_cast<const T *>(p)->begin();
    std::advance(i, idx);
    return IteratorOwner<typename T::const_iterator>::getData(i);
  }

  template <class T>
  static void moveToBeginImpl(const void *container, void **iterator) {
    IteratorOwner<typename T::const_iterator>::assign(
        iterator, static_cast<const T *>(container)->begin());
  }

  template <class T>
  static void moveToEndImpl(const void *container, void **iterator) {
    IteratorOwner<typename T::const_iterator>::assign(
        iterator, static_cast<const T *>(container)->end());
  }

  template <class Container>
  static void moveToImpl(const void *container, void **iterator,
                         Position position) {
    if (position == ToBegin)
      moveToBeginImpl<Container>(container, iterator);
    else
      moveToEndImpl<Container>(container, iterator);
  }

  template <class T>
  static VariantData getImpl(void *const *iterator, int metaTypeId,
                             uint flags) {
    return VariantData(
        metaTypeId,
        IteratorOwner<typename T::const_iterator>::getData(iterator), flags);
  }

public:
  template <class T>
  QSequentialIterableImpl(const T *p)
      : _iterable(p), _iterator(nullptr),
        _metaType_id(qMetaTypeId<typename T::value_type>()),
        _metaType_flags(QTypeInfo<typename T::value_type>::isPointer),
        _iteratorCapabilities(
            ContainerAPI<T>::IteratorCapabilities | (1 << 4) |
            (ContainerCapabilitiesImpl<T>::ContainerCapabilities << (4 + 3))),
        _size(sizeImpl<T>), _at(atImpl<T>), _moveTo(moveToImpl<T>),
        _append(ContainerCapabilitiesImpl<T>::appendImpl),
        _advance(IteratorOwner<typename T::const_iterator>::advance),
        _get(getImpl<T>),
        _destroyIter(IteratorOwner<typename T::const_iterator>::destroy),
        _equalIter(IteratorOwner<typename T::const_iterator>::equal),
        _copyIter(IteratorOwner<typename T::const_iterator>::assign) {}

  QSequentialIterableImpl()
      : _iterable(nullptr), _iterator(nullptr),
        _metaType_id(QMetaType::UnknownType), _metaType_flags(0),
        _iteratorCapabilities(0 | (1 << 4)), _size(nullptr), _at(nullptr),
        _moveToBegin(nullptr), _moveToEnd(nullptr), _advance(nullptr),
        _get(nullptr), _destroyIter(nullptr), _equalIter(nullptr),
        _copyIter(nullptr) {}

  inline void moveToBegin() {
    if (revision() == 0)
      _moveToBegin(_iterable, &_iterator);
    else
      _moveTo(_iterable, &_iterator, ToBegin);
  }
  inline void moveToEnd() {
    if (revision() == 0)
      _moveToEnd(_iterable, &_iterator);
    else
      _moveTo(_iterable, &_iterator, ToEnd);
  }
  inline bool equal(const QSequentialIterableImpl &other) const {
    return _equalIter(&_iterator, &other._iterator);
  }
  inline QSequentialIterableImpl &advance(int i) {
    ((i > 0 || _iteratorCapabilities & BiDirectionalCapability)
         ? static_cast<void>(0)
         : qt_assert("i > 0 || _iteratorCapabilities & BiDirectionalCapability",
                     "/usr/local/include/QtCore/qmetatype.h", 1205));
    _advance(&_iterator, i);
    return *this;
  }

  inline void append(const void *newElement) {
    if (containerCapabilities() & ContainerIsAppendable)
      _append(_iterable, newElement);
  }

  inline VariantData getCurrent() const {
    return _get(&_iterator, _metaType_id, _metaType_flags);
  }

  VariantData at(int idx) const {
    return VariantData(_metaType_id, _at(_iterable, idx), _metaType_flags);
  }

  int size() const {
    ((_iterable) ? static_cast<void>(0)
                 : qt_assert("_iterable",
                             "/usr/local/include/QtCore/qmetatype.h", 1220));
    return _size(_iterable);
  }

  inline void destroyIter() { _destroyIter(&_iterator); }

  void copy(const QSequentialIterableImpl &other) {
    *this = other;
    _copyIter(&_iterator, &other._iterator);
  }
};
} // namespace QtMetaTypePrivate
template <> class QTypeInfo<QtMetaTypePrivate::QSequentialIterableImpl> {
public:
  enum {
    isSpecialized = true,
    isComplex = ((((Q_MOVABLE_TYPE)) & Q_PRIMITIVE_TYPE) == 0) &&
                !qIsTrivial<QtMetaTypePrivate::QSequentialIterableImpl>(),
    isStatic =
        ((((Q_MOVABLE_TYPE)) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0),
    isRelocatable =
        !isStatic || (((Q_MOVABLE_TYPE)) & Q_RELOCATABLE_TYPE) ||
        qIsRelocatable<QtMetaTypePrivate::QSequentialIterableImpl>(),
    isLarge =
        (sizeof(QtMetaTypePrivate::QSequentialIterableImpl) > sizeof(void *)),
    isPointer = false,
    isIntegral =
        std::is_integral<QtMetaTypePrivate::QSequentialIterableImpl>::value,
    isDummy = ((((Q_MOVABLE_TYPE)) & Q_DUMMY_TYPE) != 0),
    sizeOf = sizeof(QtMetaTypePrivate::QSequentialIterableImpl)
  };
  static inline const char *name() {
    return "QtMetaTypePrivate:: QSequentialIterableImpl";
  }
};
namespace QtMetaTypePrivate {

template <typename From> struct QSequentialIterableConvertFunctor {
  QSequentialIterableImpl operator()(const From &f) const {
    return QSequentialIterableImpl(&f);
  }
};
} // namespace QtMetaTypePrivate

namespace QtMetaTypePrivate {
template <typename T,
          bool = std::is_same<typename T::const_iterator::value_type,
                              typename T::mapped_type>::value>
struct AssociativeContainerAccessor {
  static const typename T::key_type &
  getKey(const typename T::const_iterator &it) {
    return it.key();
  }

  static const typename T::mapped_type &
  getValue(const typename T::const_iterator &it) {
    return it.value();
  }
};

template <typename T,
          bool = std::is_same<typename T::const_iterator::value_type,
                              std::pair<const typename T::key_type,
                                        typename T::mapped_type>>::value>
struct StlStyleAssociativeContainerAccessor;

template <typename T> struct StlStyleAssociativeContainerAccessor<T, true> {
  static const typename T::key_type &
  getKey(const typename T::const_iterator &it) {
    return it->first;
  }

  static const typename T::mapped_type &
  getValue(const typename T::const_iterator &it) {
    return it->second;
  }
};

template <typename T>
struct AssociativeContainerAccessor<T, false>
    : public StlStyleAssociativeContainerAccessor<T> {};

class QAssociativeIterableImpl {
public:
  const void *_iterable;
  void *_iterator;
  int _metaType_id_key;
  uint _metaType_flags_key;
  int _metaType_id_value;
  uint _metaType_flags_value;
  typedef int (*sizeFunc)(const void *p);
  typedef void (*findFunc)(const void *container, const void *p,
                           void **iterator);
  typedef void (*beginFunc)(const void *p, void **);
  typedef void (*advanceFunc)(void **p, int);
  typedef VariantData (*getFunc)(void *const *p, int metaTypeId, uint flags);
  typedef void (*destroyIterFunc)(void **p);
  typedef bool (*equalIterFunc)(void *const *p, void *const *other);
  typedef void (*copyIterFunc)(void **, void *const *);

  sizeFunc _size;
  findFunc _find;
  beginFunc _begin;
  beginFunc _end;
  advanceFunc _advance;
  getFunc _getKey;
  getFunc _getValue;
  destroyIterFunc _destroyIter;
  equalIterFunc _equalIter;
  copyIterFunc _copyIter;

  template <class T> static int sizeImpl(const void *p) {
    return int(std::distance(static_cast<const T *>(p)->begin(),
                             static_cast<const T *>(p)->end()));
  }

  template <class T>
  static void findImpl(const void *container, const void *p, void **iterator) {
    IteratorOwner<typename T::const_iterator>::assign(
        iterator, static_cast<const T *>(container)->find(
                      *static_cast<const typename T::key_type *>(p)));
  }

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
  template <class T> static void advanceImpl(void **p, int step) {
    std::advance(*static_cast<typename T::const_iterator *>(*p), step);
  }
#pragma clang diagnostic pop

  template <class T>
  static void beginImpl(const void *container, void **iterator) {
    IteratorOwner<typename T::const_iterator>::assign(
        iterator, static_cast<const T *>(container)->begin());
  }

  template <class T>
  static void endImpl(const void *container, void **iterator) {
    IteratorOwner<typename T::const_iterator>::assign(
        iterator, static_cast<const T *>(container)->end());
  }

  template <class T>
  static VariantData getKeyImpl(void *const *iterator, int metaTypeId,
                                uint flags) {
    return VariantData(
        metaTypeId,
        &AssociativeContainerAccessor<T>::getKey(
            *static_cast<typename T::const_iterator *>(*iterator)),
        flags);
  }

  template <class T>
  static VariantData getValueImpl(void *const *iterator, int metaTypeId,
                                  uint flags) {
    return VariantData(
        metaTypeId,
        &AssociativeContainerAccessor<T>::getValue(
            *static_cast<typename T::const_iterator *>(*iterator)),
        flags);
  }

public:
  template <class T>
  QAssociativeIterableImpl(const T *p)
      : _iterable(p), _iterator(nullptr),
        _metaType_id_key(qMetaTypeId<typename T::key_type>()),
        _metaType_flags_key(QTypeInfo<typename T::key_type>::isPointer),
        _metaType_id_value(qMetaTypeId<typename T::mapped_type>()),
        _metaType_flags_value(QTypeInfo<typename T::mapped_type>::isPointer),
        _size(sizeImpl<T>), _find(findImpl<T>), _begin(beginImpl<T>),
        _end(endImpl<T>), _advance(advanceImpl<T>), _getKey(getKeyImpl<T>),
        _getValue(getValueImpl<T>),
        _destroyIter(IteratorOwner<typename T::const_iterator>::destroy),
        _equalIter(IteratorOwner<typename T::const_iterator>::equal),
        _copyIter(IteratorOwner<typename T::const_iterator>::assign) {}

  QAssociativeIterableImpl()
      : _iterable(nullptr), _iterator(nullptr),
        _metaType_id_key(QMetaType::UnknownType), _metaType_flags_key(0),
        _metaType_id_value(QMetaType::UnknownType), _metaType_flags_value(0),
        _size(nullptr), _find(nullptr), _begin(nullptr), _end(nullptr),
        _advance(nullptr), _getKey(nullptr), _getValue(nullptr),
        _destroyIter(nullptr), _equalIter(nullptr), _copyIter(nullptr) {}

  inline void begin() { _begin(_iterable, &_iterator); }
  inline void end() { _end(_iterable, &_iterator); }
  inline bool equal(const QAssociativeIterableImpl &other) const {
    return _equalIter(&_iterator, &other._iterator);
  }
  inline QAssociativeIterableImpl &advance(int i) {
    _advance(&_iterator, i);
    return *this;
  }

  inline void destroyIter() { _destroyIter(&_iterator); }

  inline VariantData getCurrentKey() const {
    return _getKey(&_iterator, _metaType_id_key, _metaType_flags_key);
  }
  inline VariantData getCurrentValue() const {
    return _getValue(&_iterator, _metaType_id_value, _metaType_flags_value);
  }

  inline void find(const VariantData &key) {
    _find(_iterable, key.data, &_iterator);
  }

  int size() const {
    ((_iterable) ? static_cast<void>(0)
                 : qt_assert("_iterable",
                             "/usr/local/include/QtCore/qmetatype.h", 1395));
    return _size(_iterable);
  }

  void copy(const QAssociativeIterableImpl &other) {
    *this = other;
    _copyIter(&_iterator, &other._iterator);
  }
};
} // namespace QtMetaTypePrivate
template <> class QTypeInfo<QtMetaTypePrivate::QAssociativeIterableImpl> {
public:
  enum {
    isSpecialized = true,
    isComplex = ((((Q_MOVABLE_TYPE)) & Q_PRIMITIVE_TYPE) == 0) &&
                !qIsTrivial<QtMetaTypePrivate::QAssociativeIterableImpl>(),
    isStatic =
        ((((Q_MOVABLE_TYPE)) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0),
    isRelocatable =
        !isStatic || (((Q_MOVABLE_TYPE)) & Q_RELOCATABLE_TYPE) ||
        qIsRelocatable<QtMetaTypePrivate::QAssociativeIterableImpl>(),
    isLarge =
        (sizeof(QtMetaTypePrivate::QAssociativeIterableImpl) > sizeof(void *)),
    isPointer = false,
    isIntegral =
        std::is_integral<QtMetaTypePrivate::QAssociativeIterableImpl>::value,
    isDummy = ((((Q_MOVABLE_TYPE)) & Q_DUMMY_TYPE) != 0),
    sizeOf = sizeof(QtMetaTypePrivate::QAssociativeIterableImpl)
  };
  static inline const char *name() {
    return "QtMetaTypePrivate:: QAssociativeIterableImpl";
  }
};
namespace QtMetaTypePrivate {

template <typename From> struct QAssociativeIterableConvertFunctor {
  QAssociativeIterableImpl operator()(const From &f) const {
    return QAssociativeIterableImpl(&f);
  }
};

class QPairVariantInterfaceImpl {
  const void *_pair;
  int _metaType_id_first;
  uint _metaType_flags_first;
  int _metaType_id_second;
  uint _metaType_flags_second;

  typedef VariantData (*getFunc)(const void *const *p, int metaTypeId,
                                 uint flags);

  getFunc _getFirst;
  getFunc _getSecond;

  template <class T>
  static VariantData getFirstImpl(const void *const *pair, int metaTypeId,
                                  uint flags) {
    return VariantData(metaTypeId, &static_cast<const T *>(*pair)->first,
                       flags);
  }
  template <class T>
  static VariantData getSecondImpl(const void *const *pair, int metaTypeId,
                                   uint flags) {
    return VariantData(metaTypeId, &static_cast<const T *>(*pair)->second,
                       flags);
  }

public:
  template <class T>
  QPairVariantInterfaceImpl(const T *p)
      : _pair(p), _metaType_id_first(qMetaTypeId<typename T::first_type>()),
        _metaType_flags_first(QTypeInfo<typename T::first_type>::isPointer),
        _metaType_id_second(qMetaTypeId<typename T::second_type>()),
        _metaType_flags_second(QTypeInfo<typename T::second_type>::isPointer),
        _getFirst(getFirstImpl<T>), _getSecond(getSecondImpl<T>) {}

  QPairVariantInterfaceImpl()
      : _pair(nullptr), _metaType_id_first(QMetaType::UnknownType),
        _metaType_flags_first(0), _metaType_id_second(QMetaType::UnknownType),
        _metaType_flags_second(0), _getFirst(nullptr), _getSecond(nullptr) {}

  inline VariantData first() const {
    return _getFirst(&_pair, _metaType_id_first, _metaType_flags_first);
  }
  inline VariantData second() const {
    return _getSecond(&_pair, _metaType_id_second, _metaType_flags_second);
  }
};
} // namespace QtMetaTypePrivate
template <> class QTypeInfo<QtMetaTypePrivate::QPairVariantInterfaceImpl> {
public:
  enum {
    isSpecialized = true,
    isComplex = ((((Q_MOVABLE_TYPE)) & Q_PRIMITIVE_TYPE) == 0) &&
                !qIsTrivial<QtMetaTypePrivate::QPairVariantInterfaceImpl>(),
    isStatic =
        ((((Q_MOVABLE_TYPE)) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0),
    isRelocatable =
        !isStatic || (((Q_MOVABLE_TYPE)) & Q_RELOCATABLE_TYPE) ||
        qIsRelocatable<QtMetaTypePrivate::QPairVariantInterfaceImpl>(),
    isLarge =
        (sizeof(QtMetaTypePrivate::QPairVariantInterfaceImpl) > sizeof(void *)),
    isPointer = false,
    isIntegral =
        std::is_integral<QtMetaTypePrivate::QPairVariantInterfaceImpl>::value,
    isDummy = ((((Q_MOVABLE_TYPE)) & Q_DUMMY_TYPE) != 0),
    sizeOf = sizeof(QtMetaTypePrivate::QPairVariantInterfaceImpl)
  };
  static inline const char *name() {
    return "QtMetaTypePrivate:: QPairVariantInterfaceImpl";
  }
};
namespace QtMetaTypePrivate {

template <typename From> struct QPairVariantInterfaceConvertFunctor;

template <typename T, typename U>
struct QPairVariantInterfaceConvertFunctor<QPair<T, U>> {
  QPairVariantInterfaceImpl operator()(const QPair<T, U> &f) const {
    return QPairVariantInterfaceImpl(&f);
  }
};

template <typename T, typename U>
struct QPairVariantInterfaceConvertFunctor<std::pair<T, U>> {
  QPairVariantInterfaceImpl operator()(const std::pair<T, U> &f) const {
    return QPairVariantInterfaceImpl(&f);
  }
};

} // namespace QtMetaTypePrivate

class QObject;
class QWidget;

template <class T> class QSharedPointer;
template <class T> class QWeakPointer;
template <class T> class QPointer;

namespace QtPrivate {
template <typename T> struct IsPointerToTypeDerivedFromQObject {
  enum { Value = false };
};

template <> struct IsPointerToTypeDerivedFromQObject<void *> {
  enum { Value = false };
};
template <> struct IsPointerToTypeDerivedFromQObject<const void *> {
  enum { Value = false };
};
template <> struct IsPointerToTypeDerivedFromQObject<QObject *> {
  enum { Value = true };
};

template <typename T> struct IsPointerToTypeDerivedFromQObject<T *> {
  typedef qint8 yes_type;
  typedef qint64 no_type;

  static yes_type checkType(QObject *);

  static no_type checkType(...);
  static_assert(
      bool(sizeof(T)),
      "Type argument of Q_DECLARE_METATYPE(T*) must be fully defined");
  enum {
    Value = sizeof(checkType(static_cast<T *>(nullptr))) == sizeof(yes_type)
  };
};

template <typename T, typename Enable = void> struct IsGadgetHelper {
  enum { IsRealGadget = false, IsGadgetOrDerivedFrom = false };
};

template <typename T> struct IsGadgetHelper<T, typename T::QtGadgetHelper> {
  template <typename X> static char checkType(void (X::*)());
  static void *checkType(void (T::*)());
  enum {
    IsRealGadget =
        sizeof(checkType(&T::qt_check_for_QGADGET_macro)) == sizeof(void *),
    IsGadgetOrDerivedFrom = true
  };
};

template <typename T, typename Enable = void> struct IsPointerToGadgetHelper {
  enum { IsRealGadget = false, IsGadgetOrDerivedFrom = false };
};

template <typename T>
struct IsPointerToGadgetHelper<T *, typename T::QtGadgetHelper> {
  using BaseType = T;
  template <typename X> static char checkType(void (X::*)());
  static void *checkType(void (T::*)());
  enum {
    IsRealGadget =
        !IsPointerToTypeDerivedFromQObject<T *>::Value &&
        sizeof(checkType(&T::qt_check_for_QGADGET_macro)) == sizeof(void *),
    IsGadgetOrDerivedFrom = !IsPointerToTypeDerivedFromQObject<T *>::Value
  };
};

template <typename T> char qt_getEnumMetaObject(const T &);

template <typename T> struct IsQEnumHelper {
  static const T &declval();

  enum {
    Value = sizeof(qt_getEnumMetaObject(declval())) == sizeof(QMetaObject *)
  };
};
template <> struct IsQEnumHelper<void> {
  enum { Value = false };
};

template <typename T, typename Enable = void> struct MetaObjectForType {
  static inline const QMetaObject *value() { return nullptr; }
};
template <> struct MetaObjectForType<void> {
  static inline const QMetaObject *value() { return nullptr; }
};
template <typename T>
struct MetaObjectForType<
    T *, typename std::enable_if<
             IsPointerToTypeDerivedFromQObject<T *>::Value>::type> {
  static inline const QMetaObject *value() { return &T::staticMetaObject; }
};
template <typename T>
struct MetaObjectForType<
    T,
    typename std::enable_if<IsGadgetHelper<T>::IsGadgetOrDerivedFrom>::type> {
  static inline const QMetaObject *value() { return &T::staticMetaObject; }
};
template <typename T>
struct MetaObjectForType<T, typename std::enable_if<IsPointerToGadgetHelper<
                                T>::IsGadgetOrDerivedFrom>::type> {
  static inline const QMetaObject *value() {
    return &IsPointerToGadgetHelper<T>::BaseType::staticMetaObject;
  }
};
template <typename T>
struct MetaObjectForType<
    T, typename std::enable_if<IsQEnumHelper<T>::Value>::type> {
  static inline const QMetaObject *value() { return qt_getEnumMetaObject(T()); }
};

template <typename T> struct IsSharedPointerToTypeDerivedFromQObject {
  enum { Value = false };
};

template <typename T>
struct IsSharedPointerToTypeDerivedFromQObject<QSharedPointer<T>>
    : IsPointerToTypeDerivedFromQObject<T *> {};

template <typename T> struct IsWeakPointerToTypeDerivedFromQObject {
  enum { Value = false };
};

template <typename T>
struct IsWeakPointerToTypeDerivedFromQObject<QWeakPointer<T>>
    : IsPointerToTypeDerivedFromQObject<T *> {};

template <typename T> struct IsTrackingPointerToTypeDerivedFromQObject {
  enum { Value = false };
};

template <typename T>
struct IsTrackingPointerToTypeDerivedFromQObject<QPointer<T>> {
  enum { Value = true };
};

template <typename T> struct IsSequentialContainer {
  enum { Value = false };
};

template <typename T> struct IsAssociativeContainer {
  enum { Value = false };
};

template <typename T, bool = QtPrivate::IsSequentialContainer<T>::Value>
struct SequentialContainerConverterHelper {
  static bool registerConverter(int) { return false; }
};

template <typename T, bool = QMetaTypeId2<typename T::value_type>::Defined>
struct ValueTypeIsMetaType {
  static bool registerConverter(int) { return false; }
};

template <typename T>
struct SequentialContainerConverterHelper<T, true> : ValueTypeIsMetaType<T> {};

template <typename T, bool = QtPrivate::IsAssociativeContainer<T>::Value>
struct AssociativeContainerConverterHelper {
  static bool registerConverter(int) { return false; }
};

template <typename T, bool = QMetaTypeId2<typename T::mapped_type>::Defined>
struct AssociativeValueTypeIsMetaType {
  static bool registerConverter(int) { return false; }
};

template <typename T, bool = QMetaTypeId2<typename T::key_type>::Defined>
struct KeyAndValueTypeIsMetaType {
  static bool registerConverter(int) { return false; }
};

template <typename T>
struct KeyAndValueTypeIsMetaType<T, true> : AssociativeValueTypeIsMetaType<T> {
};

template <typename T>
struct AssociativeContainerConverterHelper<T, true>
    : KeyAndValueTypeIsMetaType<T> {};

template <typename T, bool = QMetaTypeId2<typename T::first_type>::Defined
                          &&QMetaTypeId2<typename T::second_type>::Defined>
struct IsMetaTypePair {
  static bool registerConverter(int) { return false; }
};

template <typename T> struct IsMetaTypePair<T, true> {
  inline static bool registerConverter(int id);
};

template <typename T> struct IsPair {
  static bool registerConverter(int) { return false; }
};
template <typename T, typename U>
struct IsPair<QPair<T, U>> : IsMetaTypePair<QPair<T, U>> {};
template <typename T, typename U>
struct IsPair<std::pair<T, U>> : IsMetaTypePair<std::pair<T, U>> {};

template <typename T> struct MetaTypePairHelper : IsPair<T> {};

template <typename T, typename = void> struct MetaTypeSmartPointerHelper {
  static bool registerConverter(int) { return false; }
};

__attribute__((visibility("default"))) bool
isBuiltinType(const QByteArray &type);
} // namespace QtPrivate

template <typename T,
          int = QtPrivate::IsPointerToTypeDerivedFromQObject<T>::Value
                    ? QMetaType::PointerToQObject
                : QtPrivate::IsGadgetHelper<T>::IsRealGadget
                    ? QMetaType::IsGadget
                : QtPrivate::IsPointerToGadgetHelper<T>::IsRealGadget
                    ? QMetaType::PointerToGadget
                : QtPrivate::IsQEnumHelper<T>::Value ? QMetaType::IsEnumeration
                                                     : 0>
struct QMetaTypeIdQObject {
  enum { Defined = 0 };
};

template <typename T> struct QMetaTypeId : public QMetaTypeIdQObject<T> {};

template <typename T> struct QMetaTypeId2 {
  enum { Defined = QMetaTypeId<T>::Defined, IsBuiltIn = false };
  static inline constexpr int qt_metatype_id() {
    return QMetaTypeId<T>::qt_metatype_id();
  }
};

template <typename T> struct QMetaTypeId2<const T &> : QMetaTypeId2<T> {};

template <typename T> struct QMetaTypeId2<T &> {
  enum { Defined = false };
};

namespace QtPrivate {
template <typename T, bool Defined = QMetaTypeId2<T>::Defined>
struct QMetaTypeIdHelper {
  static inline constexpr int qt_metatype_id() {
    return QMetaTypeId2<T>::qt_metatype_id();
  }
};
template <typename T> struct QMetaTypeIdHelper<T, false> {
  static inline constexpr int qt_metatype_id() { return -1; }
};

template <typename Result, typename... Args>
struct IsPointerToTypeDerivedFromQObject<Result (*)(Args...)> {
  enum { Value = false };
};

template <typename T> struct QMetaTypeTypeFlags {
  enum {
    Flags =
        (QTypeInfoQuery<T>::isRelocatable ? QMetaType::MovableType : 0) |
        (QTypeInfo<T>::isComplex ? QMetaType::NeedsConstruction : 0) |
        (QTypeInfo<T>::isComplex ? QMetaType::NeedsDestruction : 0) |
        (IsPointerToTypeDerivedFromQObject<T>::Value
             ? QMetaType::PointerToQObject
             : 0) |
        (IsSharedPointerToTypeDerivedFromQObject<T>::Value
             ? QMetaType::SharedPointerToQObject
             : 0) |
        (IsWeakPointerToTypeDerivedFromQObject<T>::Value
             ? QMetaType::WeakPointerToQObject
             : 0) |
        (IsTrackingPointerToTypeDerivedFromQObject<T>::Value
             ? QMetaType::TrackingPointerToQObject
             : 0) |
        (std::is_enum<T>::value ? QMetaType::IsEnumeration : 0) |
        (IsGadgetHelper<T>::IsGadgetOrDerivedFrom ? QMetaType::IsGadget : 0) |
        (IsPointerToGadgetHelper<T>::IsGadgetOrDerivedFrom
             ? QMetaType::PointerToGadget
             : 0)
  };
};

template <typename T, bool defined> struct MetaTypeDefinedHelper {
  enum DefinedType { Defined = defined };
};

template <typename SmartPointer> struct QSmartPointerConvertFunctor {
  QObject *operator()(const SmartPointer &p) const { return p.operator->(); }
};

template <typename T> struct EnableInternalDataWrap;

template <typename T> struct QSmartPointerConvertFunctor<QWeakPointer<T>> {
  QObject *operator()(const QWeakPointer<T> &p) const {
    return QtPrivate::EnableInternalDataWrap<T>::internalData(p);
  }
};
} // namespace QtPrivate

template <typename T>
int qRegisterNormalizedMetaType(
    const ::QByteArray &normalizedTypeName

    ,
    T *dummy = 0,
    typename QtPrivate::MetaTypeDefinedHelper<
        T, QMetaTypeId2<T>::Defined && !QMetaTypeId2<T>::IsBuiltIn>::DefinedType
        defined = QtPrivate::MetaTypeDefinedHelper<
            T, QMetaTypeId2<T>::Defined && !QMetaTypeId2<T>::IsBuiltIn>::Defined

) {

  ((normalizedTypeName ==
    QMetaObject::normalizedType(normalizedTypeName.constData()))
       ? static_cast<void>(0)
       : qt_assert_x(
             "qRegisterNormalizedMetaType",
             "qRegisterNormalizedMetaType was called with a not normalized "
             "type name, please call qRegisterMetaType instead.",
             "/usr/local/include/QtCore/qmetatype.h", 1855));

  const int typedefOf =
      dummy ? -1 : QtPrivate::QMetaTypeIdHelper<T>::qt_metatype_id();
  if (typedefOf != -1)
    return QMetaType::registerNormalizedTypedef(normalizedTypeName, typedefOf);

  QMetaType::TypeFlags flags(QtPrivate::QMetaTypeTypeFlags<T>::Flags);

  if (defined)
    flags |= QMetaType::WasDeclaredAsMetaType;

  const int id = QMetaType::registerNormalizedType(
      normalizedTypeName,
      QtMetaTypePrivate::QMetaTypeFunctionHelper<T>::Destruct,
      QtMetaTypePrivate::QMetaTypeFunctionHelper<T>::Construct, int(sizeof(T)),
      flags, QtPrivate::MetaObjectForType<T>::value());

  if (id > 0) {
    QtPrivate::SequentialContainerConverterHelper<T>::registerConverter(id);
    QtPrivate::AssociativeContainerConverterHelper<T>::registerConverter(id);
    QtPrivate::MetaTypePairHelper<T>::registerConverter(id);
    QtPrivate::MetaTypeSmartPointerHelper<T>::registerConverter(id);
  }

  return id;
}

template <typename T>
int qRegisterMetaType(
    const char *typeName

    ,
    T *dummy = nullptr,
    typename QtPrivate::MetaTypeDefinedHelper<
        T, QMetaTypeId2<T>::Defined && !QMetaTypeId2<T>::IsBuiltIn>::DefinedType
        defined = QtPrivate::MetaTypeDefinedHelper<
            T, QMetaTypeId2<T>::Defined && !QMetaTypeId2<T>::IsBuiltIn>::Defined

) {

  ::QByteArray normalizedTypeName = QMetaObject::normalizedType(typeName);

  return qRegisterNormalizedMetaType<T>(normalizedTypeName, dummy, defined);
}

template <typename T>
void qRegisterMetaTypeStreamOperators(const char *typeName

                                      ,
                                      T * = nullptr

) {
  qRegisterMetaType<T>(typeName);
  QMetaType::registerStreamOperators(
      typeName, QtMetaTypePrivate::QMetaTypeFunctionHelper<T>::Save,
      QtMetaTypePrivate::QMetaTypeFunctionHelper<T>::Load);
}

template <typename T> inline constexpr int qMetaTypeId() {
  static_assert(bool(QMetaTypeId2<T>::Defined),
                "Type is not registered, please use the Q_DECLARE_METATYPE "
                "macro to make it known to Qt's meta-object system");
  return QMetaTypeId2<T>::qt_metatype_id();
}

template <typename T> inline constexpr int qRegisterMetaType() {
  return qMetaTypeId<T>();
}

template <typename T>
__attribute__((__deprecated__)) inline constexpr int qMetaTypeId(T *) {
  return qMetaTypeId<T>();
}

template <typename T>
__attribute__((__deprecated__)) inline constexpr int qRegisterMetaType(T *) {
  return qRegisterMetaType<T>();
}

template <typename T>
struct QMetaTypeIdQObject<T *, QMetaType::PointerToQObject> {
  enum { Defined = 1 };

  static int qt_metatype_id() {
    static QBasicAtomicInt metatype_id = {0};
    if (const int id = metatype_id.loadAcquire())
      return id;
    const char *const cName = T::staticMetaObject.className();
    QByteArray typeName;
    typeName.reserve(int(strlen(cName)) + 1);
    typeName.append(cName).append('*');
    const int newId = qRegisterNormalizedMetaType<T *>(
        typeName, reinterpret_cast<T **>(quintptr(-1)));
    metatype_id.storeRelease(newId);
    return newId;
  }
};

template <typename T> struct QMetaTypeIdQObject<T, QMetaType::IsGadget> {
  enum { Defined = std::is_default_constructible<T>::value };

  static int qt_metatype_id() {
    static QBasicAtomicInt metatype_id = {0};
    if (const int id = metatype_id.loadAcquire())
      return id;
    const char *const cName = T::staticMetaObject.className();
    const int newId = qRegisterNormalizedMetaType<T>(
        cName, reinterpret_cast<T *>(quintptr(-1)));
    metatype_id.storeRelease(newId);
    return newId;
  }
};

template <typename T>
struct QMetaTypeIdQObject<T *, QMetaType::PointerToGadget> {
  enum { Defined = 1 };

  static int qt_metatype_id() {
    static QBasicAtomicInt metatype_id = {0};
    if (const int id = metatype_id.loadAcquire())
      return id;
    const char *const cName = T::staticMetaObject.className();
    QByteArray typeName;
    typeName.reserve(int(strlen(cName)) + 1);
    typeName.append(cName).append('*');
    const int newId = qRegisterNormalizedMetaType<T *>(
        typeName, reinterpret_cast<T **>(quintptr(-1)));
    metatype_id.storeRelease(newId);
    return newId;
  }
};

template <typename T> struct QMetaTypeIdQObject<T, QMetaType::IsEnumeration> {
  enum { Defined = 1 };

  static int qt_metatype_id() {
    static QBasicAtomicInt metatype_id = {0};
    if (const int id = metatype_id.loadAcquire())
      return id;
    const char *eName = qt_getEnumName(T());
    const char *cName = qt_getEnumMetaObject(T())->className();
    QByteArray typeName;
    typeName.reserve(int(strlen(cName) + 2 + strlen(eName)));
    typeName.append(cName).append("::").append(eName);
    const int newId = qRegisterNormalizedMetaType<T>(
        typeName, reinterpret_cast<T *>(quintptr(-1)));
    metatype_id.storeRelease(newId);
    return newId;
  }
};

template <typename T> inline int qRegisterMetaTypeStreamOperators() {
  int id = qMetaTypeId<T>();
  QMetaType::registerStreamOperators(
      id, QtMetaTypePrivate::QMetaTypeFunctionHelper<T>::Save,
      QtMetaTypePrivate::QMetaTypeFunctionHelper<T>::Load);
  return id;
}
# 2089 "/usr/local/include/QtCore/qmetatype.h"
class QChar;
class QString;
class QStringList;
class QByteArray;
class QBitArray;
class QDate;
class QTime;
class QDateTime;
class QUrl;
class QLocale;
class QRect;
class QRectF;
class QSize;
class QSizeF;
class QLine;
class QLineF;
class QPoint;
class QPointF;
class QRegExp;
class QEasingCurve;
class QUuid;
class QVariant;
class QRegularExpression;
class QJsonValue;
class QJsonObject;
class QJsonArray;
class QJsonDocument;
class QCborValue;
class QCborArray;
class QCborMap;
class QModelIndex;
class QPersistentModelIndex;
class QFont;
class QPixmap;
class QBrush;
class QColor;
class QPalette;
class QIcon;
class QImage;
class QPolygon;
class QRegion;
class QBitmap;
class QCursor;
class QKeySequence;
class QPen;
class QTextLength;
class QTextFormat;
class QMatrix;
class QTransform;
class QMatrix4x4;
class QVector2D;
class QVector3D;
class QVector4D;
class QQuaternion;
class QPolygonF;
class QColorSpace;
class QSizePolicy;

typedef QList<QVariant> QVariantList;
typedef QMap<QString, QVariant> QVariantMap;
typedef QHash<QString, QVariant> QVariantHash;

typedef QList<QByteArray> QByteArrayList;
# 2178 "/usr/local/include/QtCore/qmetatype.h"
namespace QtPrivate {

template <typename T, bool = false> struct SharedPointerMetaTypeIdHelper {
  enum { Defined = 0 };
  static int qt_metatype_id() { return -1; }
};

} // namespace QtPrivate
# 2254 "/usr/local/include/QtCore/qmetatype.h"
template <class T> class QList;
template <typename T> struct QMetaTypeId<QList<T>> {
  enum { Defined = QMetaTypeId2<T>::Defined };
  static int qt_metatype_id() {
    static QBasicAtomicInt metatype_id = {0};
    if (const int id = metatype_id.loadRelaxed())
      return id;
    const char *tName = QMetaType::typeName(qMetaTypeId<T>());
    ((tName)
         ? static_cast<void>(0)
         : qt_assert("tName", "/usr/local/include/QtCore/qmetatype.h", 2254));
    const int tNameLen = int(qstrlen(tName));
    QByteArray typeName;
    typeName.reserve(int(sizeof("QList")) + 1 + tNameLen + 1 + 1);
    typeName.append("QList", int(sizeof("QList")) - 1)
        .append('<')
        .append(tName, tNameLen);
    if (typeName.endsWith('>'))
      typeName.append(' ');
    typeName.append('>');
    const int newId = qRegisterNormalizedMetaType<QList<T>>(
        typeName, reinterpret_cast<QList<T> *>(quintptr(-1)));
    metatype_id.storeRelease(newId);
    return newId;
  }
};
namespace QtPrivate {
template <typename T> struct IsSequentialContainer<QList<T>> {
  enum { Value = true };
};
} // namespace QtPrivate
template <class T> class QVector;
template <typename T> struct QMetaTypeId<QVector<T>> {
  enum { Defined = QMetaTypeId2<T>::Defined };
  static int qt_metatype_id() {
    static QBasicAtomicInt metatype_id = {0};
    if (const int id = metatype_id.loadRelaxed())
      return id;
    const char *tName = QMetaType::typeName(qMetaTypeId<T>());
    ((tName)
         ? static_cast<void>(0)
         : qt_assert("tName", "/usr/local/include/QtCore/qmetatype.h", 2254));
    const int tNameLen = int(qstrlen(tName));
    QByteArray typeName;
    typeName.reserve(int(sizeof("QVector")) + 1 + tNameLen + 1 + 1);
    typeName.append("QVector", int(sizeof("QVector")) - 1)
        .append('<')
        .append(tName, tNameLen);
    if (typeName.endsWith('>'))
      typeName.append(' ');
    typeName.append('>');
    const int newId = qRegisterNormalizedMetaType<QVector<T>>(
        typeName, reinterpret_cast<QVector<T> *>(quintptr(-1)));
    metatype_id.storeRelease(newId);
    return newId;
  }
};
namespace QtPrivate {
template <typename T> struct IsSequentialContainer<QVector<T>> {
  enum { Value = true };
};
} // namespace QtPrivate
template <class T> class QQueue;
template <typename T> struct QMetaTypeId<QQueue<T>> {
  enum { Defined = QMetaTypeId2<T>::Defined };
  static int qt_metatype_id() {
    static QBasicAtomicInt metatype_id = {0};
    if (const int id = metatype_id.loadRelaxed())
      return id;
    const char *tName = QMetaType::typeName(qMetaTypeId<T>());
    ((tName)
         ? static_cast<void>(0)
         : qt_assert("tName", "/usr/local/include/QtCore/qmetatype.h", 2254));
    const int tNameLen = int(qstrlen(tName));
    QByteArray typeName;
    typeName.reserve(int(sizeof("QQueue")) + 1 + tNameLen + 1 + 1);
    typeName.append("QQueue", int(sizeof("QQueue")) - 1)
        .append('<')
        .append(tName, tNameLen);
    if (typeName.endsWith('>'))
      typeName.append(' ');
    typeName.append('>');
    const int newId = qRegisterNormalizedMetaType<QQueue<T>>(
        typeName, reinterpret_cast<QQueue<T> *>(quintptr(-1)));
    metatype_id.storeRelease(newId);
    return newId;
  }
};
namespace QtPrivate {
template <typename T> struct IsSequentialContainer<QQueue<T>> {
  enum { Value = true };
};
} // namespace QtPrivate
template <class T> class QStack;
template <typename T> struct QMetaTypeId<QStack<T>> {
  enum { Defined = QMetaTypeId2<T>::Defined };
  static int qt_metatype_id() {
    static QBasicAtomicInt metatype_id = {0};
    if (const int id = metatype_id.loadRelaxed())
      return id;
    const char *tName = QMetaType::typeName(qMetaTypeId<T>());
    ((tName)
         ? static_cast<void>(0)
         : qt_assert("tName", "/usr/local/include/QtCore/qmetatype.h", 2254));
    const int tNameLen = int(qstrlen(tName));
    QByteArray typeName;
    typeName.reserve(int(sizeof("QStack")) + 1 + tNameLen + 1 + 1);
    typeName.append("QStack", int(sizeof("QStack")) - 1)
        .append('<')
        .append(tName, tNameLen);
    if (typeName.endsWith('>'))
      typeName.append(' ');
    typeName.append('>');
    const int newId = qRegisterNormalizedMetaType<QStack<T>>(
        typeName, reinterpret_cast<QStack<T> *>(quintptr(-1)));
    metatype_id.storeRelease(newId);
    return newId;
  }
};
namespace QtPrivate {
template <typename T> struct IsSequentialContainer<QStack<T>> {
  enum { Value = true };
};
} // namespace QtPrivate
template <class T> class QSet;
template <typename T> struct QMetaTypeId<QSet<T>> {
  enum { Defined = QMetaTypeId2<T>::Defined };
  static int qt_metatype_id() {
    static QBasicAtomicInt metatype_id = {0};
    if (const int id = metatype_id.loadRelaxed())
      return id;
    const char *tName = QMetaType::typeName(qMetaTypeId<T>());
    ((tName)
         ? static_cast<void>(0)
         : qt_assert("tName", "/usr/local/include/QtCore/qmetatype.h", 2254));
    const int tNameLen = int(qstrlen(tName));
    QByteArray typeName;
    typeName.reserve(int(sizeof("QSet")) + 1 + tNameLen + 1 + 1);
    typeName.append("QSet", int(sizeof("QSet")) - 1)
        .append('<')
        .append(tName, tNameLen);
    if (typeName.endsWith('>'))
      typeName.append(' ');
    typeName.append('>');
    const int newId = qRegisterNormalizedMetaType<QSet<T>>(
        typeName, reinterpret_cast<QSet<T> *>(quintptr(-1)));
    metatype_id.storeRelease(newId);
    return newId;
  }
};
namespace QtPrivate {
template <typename T> struct IsSequentialContainer<QSet<T>> {
  enum { Value = true };
};
} // namespace QtPrivate

template <typename T> struct QMetaTypeId<std::vector<T>> {
  enum { Defined = QMetaTypeId2<T>::Defined };
  static int qt_metatype_id() {
    static QBasicAtomicInt metatype_id = {0};
    if (const int id = metatype_id.loadRelaxed())
      return id;
    const char *tName = QMetaType::typeName(qMetaTypeId<T>());
    ((tName)
         ? static_cast<void>(0)
         : qt_assert("tName", "/usr/local/include/QtCore/qmetatype.h", 2260));
    const int tNameLen = int(qstrlen(tName));
    QByteArray typeName;
    typeName.reserve(int(sizeof("std::vector")) + 1 + tNameLen + 1 + 1);
    typeName.append("std::vector", int(sizeof("std::vector")) - 1)
        .append('<')
        .append(tName, tNameLen);
    if (typeName.endsWith('>'))
      typeName.append(' ');
    typeName.append('>');
    const int newId = qRegisterNormalizedMetaType<std::vector<T>>(
        typeName, reinterpret_cast<std::vector<T> *>(quintptr(-1)));
    metatype_id.storeRelease(newId);
    return newId;
  }
};
namespace QtPrivate {
template <typename T> struct IsSequentialContainer<std::vector<T>> {
  enum { Value = true };
};
} // namespace QtPrivate
template <typename T> struct QMetaTypeId<std::list<T>> {
  enum { Defined = QMetaTypeId2<T>::Defined };
  static int qt_metatype_id() {
    static QBasicAtomicInt metatype_id = {0};
    if (const int id = metatype_id.loadRelaxed())
      return id;
    const char *tName = QMetaType::typeName(qMetaTypeId<T>());
    ((tName)
         ? static_cast<void>(0)
         : qt_assert("tName", "/usr/local/include/QtCore/qmetatype.h", 2261));
    const int tNameLen = int(qstrlen(tName));
    QByteArray typeName;
    typeName.reserve(int(sizeof("std::list")) + 1 + tNameLen + 1 + 1);
    typeName.append("std::list", int(sizeof("std::list")) - 1)
        .append('<')
        .append(tName, tNameLen);
    if (typeName.endsWith('>'))
      typeName.append(' ');
    typeName.append('>');
    const int newId = qRegisterNormalizedMetaType<std::list<T>>(
        typeName, reinterpret_cast<std::list<T> *>(quintptr(-1)));
    metatype_id.storeRelease(newId);
    return newId;
  }
};
namespace QtPrivate {
template <typename T> struct IsSequentialContainer<std::list<T>> {
  enum { Value = true };
};
} // namespace QtPrivate

template <class T1, class T2> class QHash;
template <class T1, class T2> class QMap;
template <class T1, class T2> struct QPair;
# 2284 "/usr/local/include/QtCore/qmetatype.h"
namespace QtPrivate {
template <typename T, typename U> struct IsAssociativeContainer<QHash<T, U>> {
  enum { Value = true };
};
} // namespace QtPrivate
template <typename T, typename U> struct QMetaTypeId<QHash<T, U>> {
  enum { Defined = QMetaTypeId2<T>::Defined && QMetaTypeId2<U>::Defined };
  static int qt_metatype_id() {
    static QBasicAtomicInt metatype_id = {0};
    if (const int id = metatype_id.loadAcquire())
      return id;
    const char *tName = QMetaType::typeName(qMetaTypeId<T>());
    const char *uName = QMetaType::typeName(qMetaTypeId<U>());
    ((tName)
         ? static_cast<void>(0)
         : qt_assert("tName", "/usr/local/include/QtCore/qmetatype.h", 2284));
    ((uName)
         ? static_cast<void>(0)
         : qt_assert("uName", "/usr/local/include/QtCore/qmetatype.h", 2284));
    const int tNameLen = int(qstrlen(tName));
    const int uNameLen = int(qstrlen(uName));
    QByteArray typeName;
    typeName.reserve(int(sizeof("QHash")) + 1 + tNameLen + 1 + uNameLen + 1 +
                     1);
    typeName.append("QHash", int(sizeof("QHash")) - 1)
        .append('<')
        .append(tName, tNameLen)
        .append(',')
        .append(uName, uNameLen);
    if (typeName.endsWith('>'))
      typeName.append(' ');
    typeName.append('>');
    const int newId = qRegisterNormalizedMetaType<QHash<T, U>>(
        typeName, reinterpret_cast<QHash<T, U> *>(quintptr(-1)));
    metatype_id.storeRelease(newId);
    return newId;
  }
};
namespace QtPrivate {
template <typename T, typename U> struct IsAssociativeContainer<QMap<T, U>> {
  enum { Value = true };
};
} // namespace QtPrivate
template <typename T, typename U> struct QMetaTypeId<QMap<T, U>> {
  enum { Defined = QMetaTypeId2<T>::Defined && QMetaTypeId2<U>::Defined };
  static int qt_metatype_id() {
    static QBasicAtomicInt metatype_id = {0};
    if (const int id = metatype_id.loadAcquire())
      return id;
    const char *tName = QMetaType::typeName(qMetaTypeId<T>());
    const char *uName = QMetaType::typeName(qMetaTypeId<U>());
    ((tName)
         ? static_cast<void>(0)
         : qt_assert("tName", "/usr/local/include/QtCore/qmetatype.h", 2285));
    ((uName)
         ? static_cast<void>(0)
         : qt_assert("uName", "/usr/local/include/QtCore/qmetatype.h", 2285));
    const int tNameLen = int(qstrlen(tName));
    const int uNameLen = int(qstrlen(uName));
    QByteArray typeName;
    typeName.reserve(int(sizeof("QMap")) + 1 + tNameLen + 1 + uNameLen + 1 + 1);
    typeName.append("QMap", int(sizeof("QMap")) - 1)
        .append('<')
        .append(tName, tNameLen)
        .append(',')
        .append(uName, uNameLen);
    if (typeName.endsWith('>'))
      typeName.append(' ');
    typeName.append('>');
    const int newId = qRegisterNormalizedMetaType<QMap<T, U>>(
        typeName, reinterpret_cast<QMap<T, U> *>(quintptr(-1)));
    metatype_id.storeRelease(newId);
    return newId;
  }
};
namespace QtPrivate {
template <typename T, typename U>
struct IsAssociativeContainer<std::map<T, U>> {
  enum { Value = true };
};
} // namespace QtPrivate
template <typename T, typename U> struct QMetaTypeId<std::map<T, U>> {
  enum { Defined = QMetaTypeId2<T>::Defined && QMetaTypeId2<U>::Defined };
  static int qt_metatype_id() {
    static QBasicAtomicInt metatype_id = {0};
    if (const int id = metatype_id.loadAcquire())
      return id;
    const char *tName = QMetaType::typeName(qMetaTypeId<T>());
    const char *uName = QMetaType::typeName(qMetaTypeId<U>());
    ((tName)
         ? static_cast<void>(0)
         : qt_assert("tName", "/usr/local/include/QtCore/qmetatype.h", 2286));
    ((uName)
         ? static_cast<void>(0)
         : qt_assert("uName", "/usr/local/include/QtCore/qmetatype.h", 2286));
    const int tNameLen = int(qstrlen(tName));
    const int uNameLen = int(qstrlen(uName));
    QByteArray typeName;
    typeName.reserve(int(sizeof("std::map")) + 1 + tNameLen + 1 + uNameLen + 1 +
                     1);
    typeName.append("std::map", int(sizeof("std::map")) - 1)
        .append('<')
        .append(tName, tNameLen)
        .append(',')
        .append(uName, uNameLen);
    if (typeName.endsWith('>'))
      typeName.append(' ');
    typeName.append('>');
    const int newId = qRegisterNormalizedMetaType<std::map<T, U>>(
        typeName, reinterpret_cast<std::map<T, U> *>(quintptr(-1)));
    metatype_id.storeRelease(newId);
    return newId;
  }
};

template <typename T, typename U> struct QMetaTypeId<QPair<T, U>> {
  enum { Defined = QMetaTypeId2<T>::Defined && QMetaTypeId2<U>::Defined };
  static int qt_metatype_id() {
    static QBasicAtomicInt metatype_id = {0};
    if (const int id = metatype_id.loadAcquire())
      return id;
    const char *tName = QMetaType::typeName(qMetaTypeId<T>());
    const char *uName = QMetaType::typeName(qMetaTypeId<U>());
    ((tName)
         ? static_cast<void>(0)
         : qt_assert("tName", "/usr/local/include/QtCore/qmetatype.h", 2288));
    ((uName)
         ? static_cast<void>(0)
         : qt_assert("uName", "/usr/local/include/QtCore/qmetatype.h", 2288));
    const int tNameLen = int(qstrlen(tName));
    const int uNameLen = int(qstrlen(uName));
    QByteArray typeName;
    typeName.reserve(int(sizeof("QPair")) + 1 + tNameLen + 1 + uNameLen + 1 +
                     1);
    typeName.append("QPair", int(sizeof("QPair")) - 1)
        .append('<')
        .append(tName, tNameLen)
        .append(',')
        .append(uName, uNameLen);
    if (typeName.endsWith('>'))
      typeName.append(' ');
    typeName.append('>');
    const int newId = qRegisterNormalizedMetaType<QPair<T, U>>(
        typeName, reinterpret_cast<QPair<T, U> *>(quintptr(-1)));
    metatype_id.storeRelease(newId);
    return newId;
  }
};
template <typename T, typename U> struct QMetaTypeId<std::pair<T, U>> {
  enum { Defined = QMetaTypeId2<T>::Defined && QMetaTypeId2<U>::Defined };
  static int qt_metatype_id() {
    static QBasicAtomicInt metatype_id = {0};
    if (const int id = metatype_id.loadAcquire())
      return id;
    const char *tName = QMetaType::typeName(qMetaTypeId<T>());
    const char *uName = QMetaType::typeName(qMetaTypeId<U>());
    ((tName)
         ? static_cast<void>(0)
         : qt_assert("tName", "/usr/local/include/QtCore/qmetatype.h", 2289));
    ((uName)
         ? static_cast<void>(0)
         : qt_assert("uName", "/usr/local/include/QtCore/qmetatype.h", 2289));
    const int tNameLen = int(qstrlen(tName));
    const int uNameLen = int(qstrlen(uName));
    QByteArray typeName;
    typeName.reserve(int(sizeof("std::pair")) + 1 + tNameLen + 1 + uNameLen +
                     1 + 1);
    typeName.append("std::pair", int(sizeof("std::pair")) - 1)
        .append('<')
        .append(tName, tNameLen)
        .append(',')
        .append(uName, uNameLen);
    if (typeName.endsWith('>'))
      typeName.append(' ');
    typeName.append('>');
    const int newId = qRegisterNormalizedMetaType<std::pair<T, U>>(
        typeName, reinterpret_cast<std::pair<T, U> *>(quintptr(-1)));
    metatype_id.storeRelease(newId);
    return newId;
  }
};

namespace QtPrivate {
template <typename T>
struct SharedPointerMetaTypeIdHelper<QSharedPointer<T>, true> {
  enum { Defined = 1 };
  static int qt_metatype_id() {
    static QBasicAtomicInt metatype_id = {0};
    if (const int id = metatype_id.loadAcquire())
      return id;
    const char *const cName = T::staticMetaObject.className();
    QByteArray typeName;
    typeName.reserve(int(sizeof("QSharedPointer") + 1 + strlen(cName) + 1));
    typeName.append("QSharedPointer", int(sizeof("QSharedPointer")) - 1)
        .append('<')
        .append(cName)
        .append('>');
    const int newId = qRegisterNormalizedMetaType<QSharedPointer<T>>(
        typeName, reinterpret_cast<QSharedPointer<T> *>(quintptr(-1)));
    metatype_id.storeRelease(newId);
    return newId;
  }
};
template <typename T>
struct MetaTypeSmartPointerHelper<
    QSharedPointer<T>,
    typename std::enable_if<
        IsPointerToTypeDerivedFromQObject<T *>::Value>::type> {
  static bool registerConverter(int id) {
    const int toId = QMetaType::QObjectStar;
    if (!QMetaType::hasRegisteredConverterFunction(id, toId)) {
      QtPrivate::QSmartPointerConvertFunctor<QSharedPointer<T>> o;
      static const QtPrivate::ConverterFunctor<
          QSharedPointer<T>, QObject *,
          QSmartPointerConvertFunctor<QSharedPointer<T>>>
          f(o);
      return QMetaType::registerConverterFunction(&f, id, toId);
    }
    return true;
  }
};
} // namespace QtPrivate
template <typename T>
struct QMetaTypeId<QSharedPointer<T>>
    : QtPrivate::SharedPointerMetaTypeIdHelper<
          QSharedPointer<T>,
          QtPrivate::IsPointerToTypeDerivedFromQObject<T *>::Value> {};
namespace QtPrivate {
template <typename T>
struct SharedPointerMetaTypeIdHelper<QWeakPointer<T>, true> {
  enum { Defined = 1 };
  static int qt_metatype_id() {
    static QBasicAtomicInt metatype_id = {0};
    if (const int id = metatype_id.loadAcquire())
      return id;
    const char *const cName = T::staticMetaObject.className();
    QByteArray typeName;
    typeName.reserve(int(sizeof("QWeakPointer") + 1 + strlen(cName) + 1));
    typeName.append("QWeakPointer", int(sizeof("QWeakPointer")) - 1)
        .append('<')
        .append(cName)
        .append('>');
    const int newId = qRegisterNormalizedMetaType<QWeakPointer<T>>(
        typeName, reinterpret_cast<QWeakPointer<T> *>(quintptr(-1)));
    metatype_id.storeRelease(newId);
    return newId;
  }
};
template <typename T>
struct MetaTypeSmartPointerHelper<
    QWeakPointer<T>, typename std::enable_if<
                         IsPointerToTypeDerivedFromQObject<T *>::Value>::type> {
  static bool registerConverter(int id) {
    const int toId = QMetaType::QObjectStar;
    if (!QMetaType::hasRegisteredConverterFunction(id, toId)) {
      QtPrivate::QSmartPointerConvertFunctor<QWeakPointer<T>> o;
      static const QtPrivate::ConverterFunctor<
          QWeakPointer<T>, QObject *,
          QSmartPointerConvertFunctor<QWeakPointer<T>>>
          f(o);
      return QMetaType::registerConverterFunction(&f, id, toId);
    }
    return true;
  }
};
} // namespace QtPrivate
template <typename T>
struct QMetaTypeId<QWeakPointer<T>>
    : QtPrivate::SharedPointerMetaTypeIdHelper<
          QWeakPointer<T>,
          QtPrivate::IsPointerToTypeDerivedFromQObject<T *>::Value> {};
namespace QtPrivate {
template <typename T> struct SharedPointerMetaTypeIdHelper<QPointer<T>, true> {
  enum { Defined = 1 };
  static int qt_metatype_id() {
    static QBasicAtomicInt metatype_id = {0};
    if (const int id = metatype_id.loadAcquire())
      return id;
    const char *const cName = T::staticMetaObject.className();
    QByteArray typeName;
    typeName.reserve(int(sizeof("QPointer") + 1 + strlen(cName) + 1));
    typeName.append("QPointer", int(sizeof("QPointer")) - 1)
        .append('<')
        .append(cName)
        .append('>');
    const int newId = qRegisterNormalizedMetaType<QPointer<T>>(
        typeName, reinterpret_cast<QPointer<T> *>(quintptr(-1)));
    metatype_id.storeRelease(newId);
    return newId;
  }
};
template <typename T>
struct MetaTypeSmartPointerHelper<
    QPointer<T>, typename std::enable_if<
                     IsPointerToTypeDerivedFromQObject<T *>::Value>::type> {
  static bool registerConverter(int id) {
    const int toId = QMetaType::QObjectStar;
    if (!QMetaType::hasRegisteredConverterFunction(id, toId)) {
      QtPrivate::QSmartPointerConvertFunctor<QPointer<T>> o;
      static const QtPrivate::ConverterFunctor<
          QPointer<T>, QObject *, QSmartPointerConvertFunctor<QPointer<T>>>
          f(o);
      return QMetaType::registerConverterFunction(&f, id, toId);
    }
    return true;
  }
};
} // namespace QtPrivate
template <typename T>
struct QMetaTypeId<QPointer<T>>
    : QtPrivate::SharedPointerMetaTypeIdHelper<
          QPointer<T>,
          QtPrivate::IsPointerToTypeDerivedFromQObject<T *>::Value> {};

inline QMetaType::QMetaType(const ExtensionFlag extensionFlags,
                            const QMetaTypeInterface *info,
                            TypedConstructor creator, TypedDestructor deleter,
                            SaveOperator saveOp, LoadOperator loadOp,
                            Constructor constructor, Destructor destructor,
                            uint size, uint theTypeFlags, int typeId,
                            const QMetaObject *_metaObject)
    : m_typedConstructor(creator), m_typedDestructor(deleter), m_saveOp(saveOp),
      m_loadOp(loadOp), m_constructor(constructor), m_destructor(destructor),
      m_extension(nullptr), m_size(size), m_typeFlags(theTypeFlags),
      m_extensionFlags(extensionFlags), m_typeId(typeId),
      m_metaObject(_metaObject) {
  if (__builtin_expect(!!(isExtended(CtorEx) || typeId == QMetaType::Void),
                       false))
    ctor(info);
}

inline QMetaType::~QMetaType() {
  if (__builtin_expect(!!(isExtended(DtorEx)), false))
    dtor();
}

inline bool QMetaType::isValid() const { return m_typeId != UnknownType; }

inline bool QMetaType::isRegistered() const { return isValid(); }

inline int QMetaType::id() const { return m_typeId; }

inline void *QMetaType::create(const void *copy) const {

  return createExtended(copy);
}

inline void QMetaType::destroy(void *data) const { destroyExtended(data); }

inline void *QMetaType::construct(void *where, const void *copy) const {
  if (__builtin_expect(!!(isExtended(ConstructEx)), false))
    return constructExtended(where, copy);
  return m_constructor(where, copy);
}

inline void QMetaType::destruct(void *data) const {
  if (__builtin_expect(!!(isExtended(DestructEx)), false))
    return destructExtended(data);
  if (__builtin_expect(!!(!data), false))
    return;
  m_destructor(data);
}

inline int QMetaType::sizeOf() const {
  if (__builtin_expect(!!(isExtended(SizeEx)), false))
    return sizeExtended();
  return m_size;
}

inline QMetaType::TypeFlags QMetaType::flags() const {
  if (__builtin_expect(!!(isExtended(FlagsEx)), false))
    return flagsExtended();
  return QMetaType::TypeFlags(m_typeFlags);
}

inline const QMetaObject *QMetaType::metaObject() const {
  if (__builtin_expect(!!(isExtended(MetaObjectEx)), false))
    return metaObjectExtended();
  return m_metaObject;
}

template <> struct QMetaTypeId2<void> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 43 };
  static inline constexpr int qt_metatype_id() { return 43; }
};
template <> struct QMetaTypeId2<bool> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 1 };
  static inline constexpr int qt_metatype_id() { return 1; }
};
template <> struct QMetaTypeId2<int> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 2 };
  static inline constexpr int qt_metatype_id() { return 2; }
};
template <> struct QMetaTypeId2<uint> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 3 };
  static inline constexpr int qt_metatype_id() { return 3; }
};
template <> struct QMetaTypeId2<qlonglong> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 4 };
  static inline constexpr int qt_metatype_id() { return 4; }
};
template <> struct QMetaTypeId2<qulonglong> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 5 };
  static inline constexpr int qt_metatype_id() { return 5; }
};
template <> struct QMetaTypeId2<double> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 6 };
  static inline constexpr int qt_metatype_id() { return 6; }
};
template <> struct QMetaTypeId2<long> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 32 };
  static inline constexpr int qt_metatype_id() { return 32; }
};
template <> struct QMetaTypeId2<short> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 33 };
  static inline constexpr int qt_metatype_id() { return 33; }
};
template <> struct QMetaTypeId2<char> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 34 };
  static inline constexpr int qt_metatype_id() { return 34; }
};
template <> struct QMetaTypeId2<ulong> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 35 };
  static inline constexpr int qt_metatype_id() { return 35; }
};
template <> struct QMetaTypeId2<ushort> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 36 };
  static inline constexpr int qt_metatype_id() { return 36; }
};
template <> struct QMetaTypeId2<uchar> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 37 };
  static inline constexpr int qt_metatype_id() { return 37; }
};
template <> struct QMetaTypeId2<float> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 38 };
  static inline constexpr int qt_metatype_id() { return 38; }
};
template <> struct QMetaTypeId2<signed char> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 40 };
  static inline constexpr int qt_metatype_id() { return 40; }
};
template <> struct QMetaTypeId2<std::nullptr_t> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 51 };
  static inline constexpr int qt_metatype_id() { return 51; }
};
template <> struct QMetaTypeId2<QCborSimpleType> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 52 };
  static inline constexpr int qt_metatype_id() { return 52; }
};
template <> struct QMetaTypeId2<void *> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 31 };
  static inline constexpr int qt_metatype_id() { return 31; }
};
template <> struct QMetaTypeId2<QChar> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 7 };
  static inline constexpr int qt_metatype_id() { return 7; }
};
template <> struct QMetaTypeId2<QString> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 10 };
  static inline constexpr int qt_metatype_id() { return 10; }
};
template <> struct QMetaTypeId2<QStringList> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 11 };
  static inline constexpr int qt_metatype_id() { return 11; }
};
template <> struct QMetaTypeId2<QByteArray> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 12 };
  static inline constexpr int qt_metatype_id() { return 12; }
};
template <> struct QMetaTypeId2<QBitArray> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 13 };
  static inline constexpr int qt_metatype_id() { return 13; }
};
template <> struct QMetaTypeId2<QDate> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 14 };
  static inline constexpr int qt_metatype_id() { return 14; }
};
template <> struct QMetaTypeId2<QTime> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 15 };
  static inline constexpr int qt_metatype_id() { return 15; }
};
template <> struct QMetaTypeId2<QDateTime> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 16 };
  static inline constexpr int qt_metatype_id() { return 16; }
};
template <> struct QMetaTypeId2<QUrl> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 17 };
  static inline constexpr int qt_metatype_id() { return 17; }
};
template <> struct QMetaTypeId2<QLocale> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 18 };
  static inline constexpr int qt_metatype_id() { return 18; }
};
template <> struct QMetaTypeId2<QRect> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 19 };
  static inline constexpr int qt_metatype_id() { return 19; }
};
template <> struct QMetaTypeId2<QRectF> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 20 };
  static inline constexpr int qt_metatype_id() { return 20; }
};
template <> struct QMetaTypeId2<QSize> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 21 };
  static inline constexpr int qt_metatype_id() { return 21; }
};
template <> struct QMetaTypeId2<QSizeF> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 22 };
  static inline constexpr int qt_metatype_id() { return 22; }
};
template <> struct QMetaTypeId2<QLine> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 23 };
  static inline constexpr int qt_metatype_id() { return 23; }
};
template <> struct QMetaTypeId2<QLineF> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 24 };
  static inline constexpr int qt_metatype_id() { return 24; }
};
template <> struct QMetaTypeId2<QPoint> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 25 };
  static inline constexpr int qt_metatype_id() { return 25; }
};
template <> struct QMetaTypeId2<QPointF> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 26 };
  static inline constexpr int qt_metatype_id() { return 26; }
};
template <> struct QMetaTypeId2<QRegExp> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 27 };
  static inline constexpr int qt_metatype_id() { return 27; }
};
template <> struct QMetaTypeId2<QEasingCurve> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 29 };
  static inline constexpr int qt_metatype_id() { return 29; }
};
template <> struct QMetaTypeId2<QUuid> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 30 };
  static inline constexpr int qt_metatype_id() { return 30; }
};
template <> struct QMetaTypeId2<QVariant> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 41 };
  static inline constexpr int qt_metatype_id() { return 41; }
};
template <> struct QMetaTypeId2<QRegularExpression> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 44 };
  static inline constexpr int qt_metatype_id() { return 44; }
};
template <> struct QMetaTypeId2<QJsonValue> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 45 };
  static inline constexpr int qt_metatype_id() { return 45; }
};
template <> struct QMetaTypeId2<QJsonObject> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 46 };
  static inline constexpr int qt_metatype_id() { return 46; }
};
template <> struct QMetaTypeId2<QJsonArray> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 47 };
  static inline constexpr int qt_metatype_id() { return 47; }
};
template <> struct QMetaTypeId2<QJsonDocument> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 48 };
  static inline constexpr int qt_metatype_id() { return 48; }
};
template <> struct QMetaTypeId2<QCborValue> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 53 };
  static inline constexpr int qt_metatype_id() { return 53; }
};
template <> struct QMetaTypeId2<QCborArray> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 54 };
  static inline constexpr int qt_metatype_id() { return 54; }
};
template <> struct QMetaTypeId2<QCborMap> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 55 };
  static inline constexpr int qt_metatype_id() { return 55; }
};
template <> struct QMetaTypeId2<QModelIndex> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 42 };
  static inline constexpr int qt_metatype_id() { return 42; }
};
template <> struct QMetaTypeId2<QPersistentModelIndex> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 50 };
  static inline constexpr int qt_metatype_id() { return 50; }
};
template <> struct QMetaTypeId2<QObject *> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 39 };
  static inline constexpr int qt_metatype_id() { return 39; }
};
template <> struct QMetaTypeId2<QVariantMap> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 8 };
  static inline constexpr int qt_metatype_id() { return 8; }
};
template <> struct QMetaTypeId2<QVariantList> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 9 };
  static inline constexpr int qt_metatype_id() { return 9; }
};
template <> struct QMetaTypeId2<QVariantHash> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 28 };
  static inline constexpr int qt_metatype_id() { return 28; }
};
template <> struct QMetaTypeId2<QByteArrayList> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 49 };
  static inline constexpr int qt_metatype_id() { return 49; }
};
template <> struct QMetaTypeId2<QFont> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 64 };
  static inline constexpr int qt_metatype_id() { return 64; }
};
template <> struct QMetaTypeId2<QPixmap> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 65 };
  static inline constexpr int qt_metatype_id() { return 65; }
};
template <> struct QMetaTypeId2<QBrush> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 66 };
  static inline constexpr int qt_metatype_id() { return 66; }
};
template <> struct QMetaTypeId2<QColor> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 67 };
  static inline constexpr int qt_metatype_id() { return 67; }
};
template <> struct QMetaTypeId2<QPalette> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 68 };
  static inline constexpr int qt_metatype_id() { return 68; }
};
template <> struct QMetaTypeId2<QIcon> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 69 };
  static inline constexpr int qt_metatype_id() { return 69; }
};
template <> struct QMetaTypeId2<QImage> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 70 };
  static inline constexpr int qt_metatype_id() { return 70; }
};
template <> struct QMetaTypeId2<QPolygon> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 71 };
  static inline constexpr int qt_metatype_id() { return 71; }
};
template <> struct QMetaTypeId2<QRegion> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 72 };
  static inline constexpr int qt_metatype_id() { return 72; }
};
template <> struct QMetaTypeId2<QBitmap> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 73 };
  static inline constexpr int qt_metatype_id() { return 73; }
};
template <> struct QMetaTypeId2<QCursor> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 74 };
  static inline constexpr int qt_metatype_id() { return 74; }
};
template <> struct QMetaTypeId2<QKeySequence> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 75 };
  static inline constexpr int qt_metatype_id() { return 75; }
};
template <> struct QMetaTypeId2<QPen> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 76 };
  static inline constexpr int qt_metatype_id() { return 76; }
};
template <> struct QMetaTypeId2<QTextLength> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 77 };
  static inline constexpr int qt_metatype_id() { return 77; }
};
template <> struct QMetaTypeId2<QTextFormat> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 78 };
  static inline constexpr int qt_metatype_id() { return 78; }
};
template <> struct QMetaTypeId2<QMatrix> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 79 };
  static inline constexpr int qt_metatype_id() { return 79; }
};
template <> struct QMetaTypeId2<QTransform> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 80 };
  static inline constexpr int qt_metatype_id() { return 80; }
};
template <> struct QMetaTypeId2<QMatrix4x4> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 81 };
  static inline constexpr int qt_metatype_id() { return 81; }
};
template <> struct QMetaTypeId2<QVector2D> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 82 };
  static inline constexpr int qt_metatype_id() { return 82; }
};
template <> struct QMetaTypeId2<QVector3D> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 83 };
  static inline constexpr int qt_metatype_id() { return 83; }
};
template <> struct QMetaTypeId2<QVector4D> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 84 };
  static inline constexpr int qt_metatype_id() { return 84; }
};
template <> struct QMetaTypeId2<QQuaternion> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 85 };
  static inline constexpr int qt_metatype_id() { return 85; }
};
template <> struct QMetaTypeId2<QPolygonF> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 86 };
  static inline constexpr int qt_metatype_id() { return 86; }
};
template <> struct QMetaTypeId2<QColorSpace> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 87 };
  static inline constexpr int qt_metatype_id() { return 87; }
};
template <> struct QMetaTypeId2<QSizePolicy> {
  enum { Defined = 1, IsBuiltIn = true, MetaType = 121 };
  static inline constexpr int qt_metatype_id() { return 121; }
};

template <> struct QMetaTypeId<QtMetaTypePrivate::QSequentialIterableImpl> {
  enum { Defined = 1 };
  static int qt_metatype_id() {
    static QBasicAtomicInt metatype_id = {0};
    if (const int id = metatype_id.loadAcquire())
      return id;
    const int newId =
        qRegisterMetaType<QtMetaTypePrivate::QSequentialIterableImpl>(
            "QtMetaTypePrivate::QSequentialIterableImpl",
            reinterpret_cast<QtMetaTypePrivate::QSequentialIterableImpl *>(
                quintptr(-1)));
    metatype_id.storeRelease(newId);
    return newId;
  }
};
template <> struct QMetaTypeId<QtMetaTypePrivate::QAssociativeIterableImpl> {
  enum { Defined = 1 };
  static int qt_metatype_id() {
    static QBasicAtomicInt metatype_id = {0};
    if (const int id = metatype_id.loadAcquire())
      return id;
    const int newId =
        qRegisterMetaType<QtMetaTypePrivate::QAssociativeIterableImpl>(
            "QtMetaTypePrivate::QAssociativeIterableImpl",
            reinterpret_cast<QtMetaTypePrivate::QAssociativeIterableImpl *>(
                quintptr(-1)));
    metatype_id.storeRelease(newId);
    return newId;
  }
};
template <> struct QMetaTypeId<QtMetaTypePrivate::QPairVariantInterfaceImpl> {
  enum { Defined = 1 };
  static int qt_metatype_id() {
    static QBasicAtomicInt metatype_id = {0};
    if (const int id = metatype_id.loadAcquire())
      return id;
    const int newId =
        qRegisterMetaType<QtMetaTypePrivate::QPairVariantInterfaceImpl>(
            "QtMetaTypePrivate::QPairVariantInterfaceImpl",
            reinterpret_cast<QtMetaTypePrivate::QPairVariantInterfaceImpl *>(
                quintptr(-1)));
    metatype_id.storeRelease(newId);
    return newId;
  }
};

template <typename T>
inline bool QtPrivate::IsMetaTypePair<T, true>::registerConverter(int id) {
  const int toId = qMetaTypeId<QtMetaTypePrivate::QPairVariantInterfaceImpl>();
  if (!QMetaType::hasRegisteredConverterFunction(id, toId)) {
    QtMetaTypePrivate::QPairVariantInterfaceConvertFunctor<T> o;
    static const QtPrivate::ConverterFunctor<
        T, QtMetaTypePrivate::QPairVariantInterfaceImpl,
        QtMetaTypePrivate::QPairVariantInterfaceConvertFunctor<T>>
        f(o);
    return QMetaType::registerConverterFunction(&f, id, toId);
  }
  return true;
}

namespace QtPrivate {
template <typename T> struct ValueTypeIsMetaType<T, true> {
  static bool registerConverter(int id) {
    const int toId = qMetaTypeId<QtMetaTypePrivate::QSequentialIterableImpl>();
    if (!QMetaType::hasRegisteredConverterFunction(id, toId)) {
      QtMetaTypePrivate::QSequentialIterableConvertFunctor<T> o;
      static const QtPrivate::ConverterFunctor<
          T, QtMetaTypePrivate::QSequentialIterableImpl,
          QtMetaTypePrivate::QSequentialIterableConvertFunctor<T>>
          f(o);
      return QMetaType::registerConverterFunction(&f, id, toId);
    }
    return true;
  }
};

template <typename T> struct AssociativeValueTypeIsMetaType<T, true> {
  static bool registerConverter(int id) {
    const int toId = qMetaTypeId<QtMetaTypePrivate::QAssociativeIterableImpl>();
    if (!QMetaType::hasRegisteredConverterFunction(id, toId)) {
      QtMetaTypePrivate::QAssociativeIterableConvertFunctor<T> o;
      static const QtPrivate::ConverterFunctor<
          T, QtMetaTypePrivate::QAssociativeIterableImpl,
          QtMetaTypePrivate::QAssociativeIterableConvertFunctor<T>>
          f(o);
      return QMetaType::registerConverterFunction(&f, id, toId);
    }
    return true;
  }
};
} // namespace QtPrivate
# 29 "./verdigris/wobjectdefs.h" 2

namespace w_internal {
using std::index_sequence;
# 52 "./verdigris/wobjectdefs.h"
using std::make_index_sequence;

struct IndexBase {};
template <size_t> struct Index : IndexBase {};
template <size_t I> constexpr auto index = Index<I>{};

template <typename... Args> constexpr void ordered(Args...) {}
template <class T> constexpr void ordered2(std::initializer_list<T>) {}

template <typename... Args> constexpr int sums(Args... args) {

  auto r = int{};
  ordered2<int>({(r += args)...});
  return r;
}

template <int... args> constexpr int summed = sums(args...);

struct StringView {
  const char *b{};
  const char *e{};

  constexpr auto size() const -> qptrdiff { return e - b; }
  constexpr auto begin() const { return b; }
  constexpr auto end() const { return e; }
};

template <size_t N>
constexpr auto viewLiteral(const char (&d)[N]) -> StringView {
  return {&d[0], &d[N - 1]};
}

template <size_t N = 0> struct StringViewArray {
  StringView data[(N > 0 ? N : 1)]{};

  constexpr auto operator[](size_t i) const { return data[i]; }
};

template <size_t SN> constexpr auto countParsedLiterals(const char (&s)[SN]) {
  auto r = size_t{};
  auto i = 0u;
  while (true) {
    while (true) {
      if (i >= SN - 1)
        return r;
      if (s[i] != ' ' && s[i] != ',')
        break;
      i++;
    }
    r++;
    i++;
    while (true) {
      if (i >= SN - 1)
        return r;
      if (s[i] == ',')
        break;
      i++;
    }
    i++;
  }
}

template <size_t N, size_t SN>
constexpr auto viewParsedLiterals(const char (&s)[SN]) -> StringViewArray<N> {

  auto r = StringViewArray<N>{};
  auto ri = size_t{};
  auto i = 0u;
  while (true) {
    while (true) {
      if (i >= SN - 1)
        return r;
      if (s[i] != ' ' && s[i] != ',')
        break;
      i++;
    }
    r.data[ri].b = &s[i];
    i++;
    while (true) {
      if (i >= SN - 1) {
        r.data[ri].e = &s[i];
        return r;
      }
      if (s[i] == ' ') {
        if (i + 1 >= SN - 1) {
          r.data[ri].e = &s[i];
          return r;
        }
        if (s[i + 1] == ',') {
          r.data[ri].e = &s[i];
          i += 2;
          break;
        }
        i += 2;
        continue;
      }
      if (s[i] == ',') {
        r.data[ri].e = &s[i];
        i++;
        break;
      }
      i++;
    }
    ri++;
  }
}

template <size_t N, size_t SN>
constexpr auto viewScopedLiterals(const char (&s)[SN]) -> StringViewArray<N> {
  auto r = StringViewArray<N>{};
  auto ri = size_t{};
  auto i = 0u;
  while (true) {
    while (true) {
      if (i >= SN - 1)
        return r;
      if (s[i] != ' ' && s[i] != ',' && s[i] != ':')
        break;
      i++;
    }
    r.data[ri].b = &s[i];
    i++;
    while (true) {
      if (i >= SN - 1) {
        r.data[ri].e = &s[i];
        return r;
      }
      if (s[i] == ':') {
        i++;
        if (s[i] == ' ')
          i++;
        r.data[ri].b = &s[i];
        continue;
      }
      if (s[i] == ' ') {
        if (i + 1 >= SN - 1) {
          r.data[ri].e = &s[i];
          return r;
        }
        if (s[i + 1] == ',') {
          r.data[ri].e = &s[i];
          i += 2;
          break;
        }
        i += 2;
        continue;
      }
      if (s[i] == ',') {
        r.data[ri].e = &s[i];
        i++;
        break;
      }
      i++;
    }
    ri++;
  }
}

enum class PropertyFlags {
  Invalid = 0x00000000,
  Readable = 0x00000001,
  Writable = 0x00000002,
  Resettable = 0x00000004,
  EnumOrFlag = 0x00000008,
  StdCppSet = 0x00000100,

  Constant = 0x00000400,
  Final = 0x00000800,
  Designable = 0x00001000,
  ResolveDesignable = 0x00002000,
  Scriptable = 0x00004000,
  ResolveScriptable = 0x00008000,
  Stored = 0x00010000,
  ResolveStored = 0x00020000,
  Editable = 0x00040000,
  ResolveEditable = 0x00080000,
  User = 0x00100000,
  ResolveUser = 0x00200000,
  Notify = 0x00400000,
  Revisioned = 0x00800000
};
constexpr uint operator|(uint a, PropertyFlags b) { return a | uint(b); }

template <int N> struct W_MethodFlags { static constexpr int value = N; };
constexpr W_MethodFlags<0> W_EmptyFlag{};

} // namespace w_internal

namespace W_Access {

constexpr w_internal::W_MethodFlags<0x1000> Private{};
constexpr w_internal::W_MethodFlags<0x01> Protected{};
constexpr w_internal::W_MethodFlags<0x02> Public{};
} // namespace W_Access

namespace W_MethodType {

constexpr w_internal::W_MethodFlags<0x00> Method{};
constexpr w_internal::W_MethodFlags<0x04> Signal{};
constexpr w_internal::W_MethodFlags<0x08> Slot{};
constexpr w_internal::W_MethodFlags<0x0c> Constructor{};
} // namespace W_MethodType

constexpr w_internal::W_MethodFlags<0x10> W_Compat{};
constexpr w_internal::W_MethodFlags<0x40> W_Scriptable{};
constexpr struct {
} W_Notify{};
constexpr struct {
} W_Reset{};
constexpr std::integral_constant<int, int(w_internal::PropertyFlags::Constant)>
    W_Constant{};
constexpr std::integral_constant<int, int(w_internal::PropertyFlags::Final)>
    W_Final{};

namespace w_internal {

template <typename F, int Flags, typename IC, typename ParamTypes,
          typename ParamNames = StringViewArray<>>
struct MetaMethodInfo {
  F func;
  StringView name;
  ParamTypes paramTypes;
  ParamNames paramNames;
  static constexpr int argCount = QtPrivate::FunctionPointer<F>::ArgumentCount;
  static constexpr auto argSequence = make_index_sequence<argCount>{};
  static constexpr int flags = Flags;
  using IntegralConstant = IC;
};

template <typename F, typename ParamTypes, int... Flags,
          typename IntegralConstant>
constexpr MetaMethodInfo<F, summed<Flags...> | W_MethodType::Slot.value,
                         IntegralConstant, ParamTypes>
makeMetaSlotInfo(F f, StringView name, IntegralConstant,
                 const ParamTypes &paramTypes, W_MethodFlags<Flags>...) {
  return {f, name, paramTypes, {}};
}

template <typename F, typename ParamTypes, int... Flags,
          typename IntegralConstant>
constexpr MetaMethodInfo<F, summed<Flags...> | W_MethodType::Method.value,
                         IntegralConstant, ParamTypes>
makeMetaMethodInfo(F f, StringView name, IntegralConstant,
                   const ParamTypes &paramTypes, W_MethodFlags<Flags>...) {
  return {f, name, paramTypes, {}};
}

template <typename F, typename ParamTypes, typename ParamNames, int... Flags,
          typename IntegralConstant>
constexpr MetaMethodInfo<F, summed<Flags...> | W_MethodType::Signal.value,
                         IntegralConstant, ParamTypes, ParamNames>
makeMetaSignalInfo(F f, StringView name, IntegralConstant,
                   const ParamTypes &paramTypes, const ParamNames &paramNames,
                   W_MethodFlags<Flags>...) {
  return {f, name, paramTypes, paramNames};
}

template <typename... Args> struct MetaConstructorInfo {
  static constexpr std::size_t argCount = sizeof...(Args);
  static constexpr auto argSequence = make_index_sequence<argCount>{};
  static constexpr int flags =
      W_MethodType::Constructor.value | W_Access::Public.value;
  using IntegralConstant = void *;
  StringView name;
};

template <typename... Args>
constexpr MetaConstructorInfo<Args...>
makeMetaConstructorInfo(StringView name) {
  return {name};
}

struct Empty {
  constexpr operator bool() const { return false; }
};

template <typename Type, typename Getter = Empty, typename Setter = Empty,
          typename Member = Empty, typename Notify = Empty,
          typename Reset = Empty, int Flags = 0>
struct MetaPropertyInfo {
  using PropertyType = Type;
  StringView name;
  StringView typeStr;
  Getter getter;
  Setter setter;
  Member member;
  Notify notify;
  Reset reset;
  static constexpr uint flags = Flags;

  template <typename S> constexpr auto setGetter(const S &s) const {
    return MetaPropertyInfo<Type, S, Setter, Member, Notify, Reset,
                            Flags | PropertyFlags::Readable>{
        name, typeStr, s, setter, member, notify, reset};
  }
  template <typename S> constexpr auto setSetter(const S &s) const {
    return MetaPropertyInfo<Type, Getter, S, Member, Notify, Reset,
                            Flags | PropertyFlags::Writable>{
        name, typeStr, getter, s, member, notify, reset};
  }
  template <typename S> constexpr auto setMember(const S &s) const {
    return MetaPropertyInfo<Type, Getter, Setter, S, Notify, Reset,
                            Flags | PropertyFlags::Writable |
                                PropertyFlags::Readable>{
        name, typeStr, getter, setter, s, notify, reset};
  }
  template <typename S> constexpr auto setNotify(const S &s) const {
    return MetaPropertyInfo<Type, Getter, Setter, Member, S, Reset,
                            Flags | PropertyFlags::Notify>{
        name, typeStr, getter, setter, member, s, reset};
  }
  template <typename S> constexpr auto setReset(const S &s) const {
    return MetaPropertyInfo<Type, Getter, Setter, Member, Notify, S,
                            Flags | PropertyFlags::Resettable>{
        name, typeStr, getter, setter, member, notify, s};
  }
  template <int Flag> constexpr auto addFlag() const {
    return MetaPropertyInfo<Type, Getter, Setter, Member, Notify, Reset,
                            Flags | Flag>{name,   typeStr, getter, setter,
                                          member, notify,  reset};
  }
};

template <typename PropInfo> constexpr auto parseProperty(const PropInfo &p) {
  return p;
}

template <typename PropInfo, typename Obj, typename Arg, typename Ret,
          typename... Tail>
constexpr auto parseProperty(const PropInfo &p, Ret (Obj::*s)(Arg), Tail... t) {
  return parseProperty(p.setSetter(s), t...);
}

template <typename PropInfo, typename Obj, typename Ret, typename... Tail>
constexpr auto parseProperty(const PropInfo &p, Ret (Obj::*s)(), Tail... t) {
  return parseProperty(p.setGetter(s), t...);
}
template <typename PropInfo, typename Obj, typename Ret, typename... Tail>
constexpr auto parseProperty(const PropInfo &p, Ret (Obj::*s)() const,
                             Tail... t) {
  return parseProperty(p.setGetter(s), t...);
}
# 418 "./verdigris/wobjectdefs.h"
template <typename PropInfo, typename Obj, typename Ret, typename... Tail>
constexpr auto parseProperty(const PropInfo &p, Ret Obj::*s, Tail... t) {
  return parseProperty(p.setMember(s), t...);
}

template <typename PropInfo, typename F, typename... Tail>
constexpr auto parseProperty(const PropInfo &p, decltype(W_Notify), F f,
                             Tail... t) {
  return parseProperty(p.setNotify(f), t...);
}

template <typename PropInfo, typename Obj, typename Ret, typename... Tail>
constexpr auto parseProperty(const PropInfo &p, decltype(W_Reset),
                             Ret (Obj::*s)(), Tail... t) {
  return parseProperty(p.setReset(s), t...);
}

template <typename PropInfo, int Flag, typename... Tail>
constexpr auto parseProperty(const PropInfo &p,
                             std::integral_constant<int, Flag>, Tail... t) {
  return parseProperty(p.template addFlag<Flag>(), t...);
}

template <typename T, typename... Args>
constexpr auto makeMetaPropertyInfo(StringView name, StringView type,
                                    Args... args) {
  auto meta = MetaPropertyInfo<T>{name, type, {}, {}, {}, {}, {}};
  return parseProperty(meta, args...);
}

template <typename T, typename = void> struct EnumIsScoped {
  enum { Value = std::is_convertible<T, int>::value ? 0 : 2 };
};
template <typename T>
struct EnumIsScoped<QFlags<T>, void>
    : EnumIsScoped<typename QFlags<T>::enum_type> {};

template <typename T> struct QEnumOrQFlags { using Type = T; };
template <typename T> struct QEnumOrQFlags<QFlags<T>> { using Type = T; };

template <bool HasAlias, typename Values_, typename Names, int Flags>
struct MetaEnumInfo {
  StringView name;
  StringView alias;
  Names names;
  using Values = Values_;
  static constexpr uint flags = Flags;
  static constexpr auto count = Values::size();
  static constexpr auto sequence = make_index_sequence<count>{};
  static constexpr auto hasAlias = HasAlias;
};
template <typename Enum, Enum... Value> struct enum_sequence {};

template <typename Enum, int Flag, Enum... Values, typename Names>
constexpr auto makeMetaEnumInfo(StringView name, int,
                                enum_sequence<Enum, Values...>, Names names)
    -> MetaEnumInfo<false, index_sequence<size_t(Values)...>, Names,
                    Flag | EnumIsScoped<Enum>::Value> {
  return {name, viewLiteral(""), names};
}
template <typename Enum, int Flag, Enum... Values, typename Names>
constexpr auto makeMetaEnumInfo(StringView name, StringView alias,
                                enum_sequence<Enum, Values...>, Names names)
    -> MetaEnumInfo<true, index_sequence<size_t(Values)...>, Names,
                    Flag | EnumIsScoped<Enum>::Value> {
  return {name, alias, names};
}

template <int N> constexpr int removedScopeSize(const char (&name)[N]) {

  int p = N - 1;
  while (p > 0 && name[p] != ':')
    p--;
  if (name[p] == ':')
    p++;
  return N - p;
}
# 500 "./verdigris/wobjectdefs.h"
template <typename Func, int Idx> struct SignalImplementation {};
template <typename Obj, typename Ret, typename... Args, int Idx>
struct SignalImplementation<Ret (Obj::*)(Args...), Idx> {
  Obj *this_;
  Ret operator()(Args... args, int) const {
    Ret r{};
    const void *a[] = {std::addressof(r), std::addressof(args)...};
    QMetaObject::activate(this_, &Obj::staticMetaObject, Idx,
                          const_cast<void **>(a));
    return r;
  }
};
template <typename Obj, typename... Args, int Idx>
struct SignalImplementation<void (Obj::*)(Args...), Idx> {
  Obj *this_;
  void operator()(Args... args, int) {
    const void *a[] = {nullptr, std::addressof(args)...};
    QMetaObject::activate(this_, &Obj::staticMetaObject, Idx,
                          const_cast<void **>(a));
  }
};
template <typename Obj, typename Ret, typename... Args, int Idx>
struct SignalImplementation<Ret (Obj::*)(Args...) const, Idx> {
  const Obj *this_;
  Ret operator()(Args... args, int) const {
    Ret r{};
    const void *a[] = {std::addressof(r), std::addressof(args)...};
    QMetaObject::activate(const_cast<Obj *>(this_), &Obj::staticMetaObject, Idx,
                          const_cast<void **>(a));
    return r;
  }
};
template <typename Obj, typename... Args, int Idx>
struct SignalImplementation<void (Obj::*)(Args...) const, Idx> {
  const Obj *this_;
  void operator()(Args... args, int) {
    const void *a[] = {nullptr, std::addressof(args)...};
    QMetaObject::activate(const_cast<Obj *>(this_), &Obj::staticMetaObject, Idx,
                          const_cast<void **>(a));
  }
};
# 545 "./verdigris/wobjectdefs.h"
template <typename T> T &getParentObjectHelper(void *(T::*)(const char *));

struct FriendHelper;

inline namespace w_ShouldBeInQt {

template <typename... Args> struct QNonConstOverload {
  template <typename R, typename T>
  constexpr auto operator()(R (T::*ptr)(Args...)) const {
    return ptr;
  }
};
template <typename... Args> struct QConstOverload {
  template <typename R, typename T>
  constexpr auto operator()(R (T::*ptr)(Args...) const) const {
    return ptr;
  }
};
template <typename... Args>
struct QOverload : QConstOverload<Args...>, QNonConstOverload<Args...> {
  using QConstOverload<Args...>::operator();
  using QNonConstOverload<Args...>::operator();

  template <typename R> constexpr auto operator()(R (*ptr)(Args...)) const {
    return ptr;
  }
};
template <typename... Args> constexpr QOverload<Args...> qOverload = {};

} // namespace w_ShouldBeInQt

} // namespace w_internal
# 662 "./verdigris/wobjectdefs.h"
namespace w_internal {

template <class State, class TPP> void w_state(IndexBase, State, TPP);
# 698 "./verdigris/wobjectdefs.h"
template <size_t L, class State, class TPP, size_t N, size_t M,
          size_t X = (N + M) / 2,
          bool noX = std::is_same<void, decltype(w_state(index<X>, State{},
                                                         TPP{}))>::value,
          bool up = N == X>
struct CountBetween;

template <size_t L, class State, class TPP, size_t N, size_t M, size_t X>
struct CountBetween<L, State, TPP, N, M, X, true, true> {
  static constexpr auto value = N;
};
template <size_t L, class State, class TPP, size_t N, size_t M, size_t X>
struct CountBetween<L, State, TPP, N, M, X, false, true> {
  static constexpr auto value = M;
};
template <size_t L, class State, class TPP, size_t N, size_t M, size_t X>
struct CountBetween<L, State, TPP, N, M, X, true, false> {
  static constexpr auto value = CountBetween<L, State, TPP, N, X>::value;
};
template <size_t L, class State, class TPP, size_t N, size_t M, size_t X>
struct CountBetween<L, State, TPP, N, M, X, false, false> {
  static constexpr auto value = CountBetween<L, State, TPP, X, M>::value;
};

template <size_t L, class State, class TPP, size_t N = 1,
          bool noX = std::is_same<void, decltype(w_state(index<N>, State{},
                                                         TPP{}))>::value>
struct Count;

template <size_t L, class State, class TPP, size_t N>
struct Count<L, State, TPP, N, true> {
  static constexpr auto value = CountBetween<L, State, TPP, N / 2, N>::value;
};
template <size_t L, class State, class TPP, size_t N>
struct Count<L, State, TPP, N, false> {
  static constexpr auto value = Count<L, State, TPP, N * 2>::value;
};

template <size_t L, class State, class TPP>
constexpr auto stateCount = Count<L, State, TPP>::value;

struct SlotStateTag {};
struct SignalStateTag {};
struct MethodStateTag {};
struct ConstructorStateTag {};
struct PropertyStateTag {};
struct EnumStateTag {};
struct ClassInfoStateTag {};
struct InterfaceStateTag {};

} // namespace w_internal
# 985 "./verdigris/wobjectdefs.h"
namespace w_internal {
template <typename T> struct W_TypeRegistery {
  enum { registered = false };
};
} // namespace w_internal

namespace w_internal {
template <> struct W_TypeRegistery<char *> {
  enum { registered = true };
  static constexpr auto name = viewLiteral("char*");
};
} // namespace w_internal
namespace w_internal {
template <> struct W_TypeRegistery<const char *> {
  enum { registered = true };
  static constexpr auto name = viewLiteral("const char*");
};
} // namespace w_internal
# 27 "./example.h" 2
# 1 "/usr/local//include/QtCore/QObject" 1
# 1 "/usr/local//include/QtCore/qobject.h" 1
# 49 "/usr/local//include/QtCore/qobject.h"
# 1 "/usr/local/include/QtCore/qlist.h" 1
# 44 "/usr/local/include/QtCore/qlist.h"
# 1 "/usr/local/include/QtCore/qiterator.h" 1
# 191 "/usr/local/include/QtCore/qiterator.h"
template <typename Key, typename T, class Iterator> class QKeyValueIterator {
public:
  typedef typename Iterator::iterator_category iterator_category;
  typedef typename Iterator::difference_type difference_type;
  typedef std::pair<Key, T> value_type;
  typedef const value_type &reference;

  QKeyValueIterator() = default;
  constexpr explicit QKeyValueIterator(Iterator o) noexcept(
      std::is_nothrow_move_constructible<Iterator>::value)
      : i(std::move(o)) {}

  std::pair<Key, T> operator*() const {
    return std::pair<Key, T>(i.key(), i.value());
  }

  struct pointer {
    pointer(value_type &&r_) : r(std::move(r_)) {}

    pointer() = default;
    pointer(const pointer &other) = default;
    pointer(pointer &&other) = default;
    pointer &operator=(const pointer &other) = default;
    pointer &operator=(pointer &&other) = default;

    value_type &operator*() const { return r; }

    value_type r;
    const value_type *operator->() const { return &r; }
  };

  pointer operator->() const {
    return pointer(std::pair<Key, T>(i.key(), i.value()));
  }

  friend bool operator==(QKeyValueIterator lhs,
                         QKeyValueIterator rhs) noexcept {
    return lhs.i == rhs.i;
  }
  friend bool operator!=(QKeyValueIterator lhs,
                         QKeyValueIterator rhs) noexcept {
    return lhs.i != rhs.i;
  }

  inline QKeyValueIterator &operator++() {
    ++i;
    return *this;
  }
  inline QKeyValueIterator operator++(int) { return QKeyValueIterator(i++); }
  inline QKeyValueIterator &operator--() {
    --i;
    return *this;
  }
  inline QKeyValueIterator operator--(int) { return QKeyValueIterator(i--); }
  Iterator base() const { return i; }

private:
  Iterator i;
};
# 45 "/usr/local/include/QtCore/qlist.h" 2

# 1 "/usr/local/include/QtCore/qvector.h" 1
# 48 "/usr/local/include/QtCore/qvector.h"
# 1 "/usr/local/include/QtCore/qcontainertools_impl.h" 1
# 49 "/usr/local/include/QtCore/qvector.h" 2

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/stdlib.h" 1 3
# 56 "/usr/local/include/QtCore/qvector.h" 2

template <typename T> class QVector {
  typedef QTypedArrayData<T> Data;
  Data *d;

public:
  inline QVector() noexcept : d(Data::sharedNull()) {}
  explicit QVector(int size);
  QVector(int size, const T &t);
  inline QVector(const QVector<T> &v);
  inline ~QVector() {
    if (!d->ref.deref())
      freeData(d);
  }
  QVector<T> &operator=(const QVector<T> &v);
  QVector(QVector<T> &&other) noexcept : d(other.d) {
    other.d = Data::sharedNull();
  }
  QVector<T> &operator=(QVector<T> &&other) noexcept {
    QVector moved(std::move(other));
    swap(moved);
    return *this;
  }
  void swap(QVector<T> &other) noexcept { qSwap(d, other.d); }
  inline QVector(std::initializer_list<T> args);
  QVector<T> &operator=(std::initializer_list<T> args);
  template <typename InputIterator,
            QtPrivate::IfIsInputIterator<InputIterator> = true>
  inline QVector(InputIterator first, InputIterator last);
  explicit QVector(QArrayDataPointerRef<T> ref) noexcept : d(ref.ptr) {}

  bool operator==(const QVector<T> &v) const;
  inline bool operator!=(const QVector<T> &v) const { return !(*this == v); }

  inline int size() const { return d->size; }

  inline bool isEmpty() const { return d->size == 0; }

  void resize(int size);

  inline int capacity() const { return int(d->alloc); }
  void reserve(int size);
  inline void squeeze() {
    if (d->size < int(d->alloc)) {
      if (!d->size) {
        *this = QVector<T>();
        return;
      }
      realloc(d->size);
    }
    if (d->capacityReserved) {

      d->capacityReserved = 0;
    }
  }

  inline void detach();
  inline bool isDetached() const { return !d->ref.isShared(); }

  inline void setSharable(bool sharable) {
    if (sharable == d->ref.isSharable())
      return;
    if (!sharable)
      detach();

    if (d == Data::unsharableEmpty()) {
      if (sharable)
        d = Data::sharedNull();
    } else {
      d->ref.setSharable(sharable);
    }
    ((d->ref.isSharable() == sharable)
         ? static_cast<void>(0)
         : qt_assert("d->ref.isSharable() == sharable",
                     "/usr/local/include/QtCore/qvector.h", 128));
  }

  inline bool isSharedWith(const QVector<T> &other) const {
    return d == other.d;
  }

  inline T *data() {
    detach();
    return d->begin();
  }
  inline const T *data() const { return d->begin(); }
  inline const T *constData() const { return d->begin(); }
  void clear();

  const T &at(int i) const;
  T &operator[](int i);
  const T &operator[](int i) const;
  void append(const T &t);
  void append(T &&t);
  inline void append(const QVector<T> &l) { *this += l; }
  void prepend(T &&t);
  void prepend(const T &t);
  void insert(int i, T &&t);
  void insert(int i, const T &t);
  void insert(int i, int n, const T &t);
  void replace(int i, const T &t);
  void remove(int i);
  void remove(int i, int n);
  inline void removeFirst() {
    ((!isEmpty())
         ? static_cast<void>(0)
         : qt_assert("!isEmpty()", "/usr/local/include/QtCore/qvector.h", 153));
    erase(d->begin());
  }
  inline void removeLast();
  T takeFirst() {
    ((!isEmpty())
         ? static_cast<void>(0)
         : qt_assert("!isEmpty()", "/usr/local/include/QtCore/qvector.h", 155));
    T r = std::move(first());
    removeFirst();
    return r;
  }
  T takeLast() {
    ((!isEmpty())
         ? static_cast<void>(0)
         : qt_assert("!isEmpty()", "/usr/local/include/QtCore/qvector.h", 156));
    T r = std::move(last());
    removeLast();
    return r;
  }

  QVector<T> &fill(const T &t, int size = -1);

  int indexOf(const T &t, int from = 0) const;
  int lastIndexOf(const T &t, int from = -1) const;
  bool contains(const T &t) const;
  int count(const T &t) const;

  void removeAt(int i) { remove(i); }
  int removeAll(const T &t) {
    const const_iterator ce = this->cend(),
                         cit = std::find(this->cbegin(), ce, t);
    if (cit == ce)
      return 0;

    const T tCopy = t;
    const int firstFoundIdx = std::distance(this->cbegin(), cit);
    const iterator e = end(),
                   it = std::remove(begin() + firstFoundIdx, e, tCopy);
    const int result = std::distance(it, e);
    erase(it, e);
    return result;
  }
  bool removeOne(const T &t) {
    const int i = indexOf(t);
    if (i < 0)
      return false;
    remove(i);
    return true;
  }
  int length() const { return size(); }
  T takeAt(int i) {
    T t = std::move((*this)[i]);
    remove(i);
    return t;
  }
  void move(int from, int to) {
    ((from >= 0 && from < size())
         ? static_cast<void>(0)
         : qt_assert_x("QVector::move(int,int)", "'from' is out-of-range",
                       "/usr/local/include/QtCore/qvector.h", 192));
    ((to >= 0 && to < size())
         ? static_cast<void>(0)
         : qt_assert_x("QVector::move(int,int)", "'to' is out-of-range",
                       "/usr/local/include/QtCore/qvector.h", 193));
    if (from == to)
      return;
    detach();
    T *const b = d->begin();
    if (from < to)
      std::rotate(b + from, b + from + 1, b + to + 1);
    else
      std::rotate(b + to, b + from, b + from + 1);
  }

  typedef typename Data::iterator iterator;
  typedef typename Data::const_iterator const_iterator;
  typedef std::reverse_iterator<iterator> reverse_iterator;
  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

  inline iterator begin() {
    detach();
    return d->begin();
  }
  inline const_iterator begin() const noexcept { return d->constBegin(); }
  inline const_iterator cbegin() const noexcept { return d->constBegin(); }
  inline const_iterator constBegin() const noexcept { return d->constBegin(); }
  inline iterator end() {
    detach();
    return d->end();
  }
  inline const_iterator end() const noexcept { return d->constEnd(); }
  inline const_iterator cend() const noexcept { return d->constEnd(); }
  inline const_iterator constEnd() const noexcept { return d->constEnd(); }
# 228 "/usr/local/include/QtCore/qvector.h"
  reverse_iterator rbegin() { return reverse_iterator(end()); }
  reverse_iterator rend() { return reverse_iterator(begin()); }
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }
  const_reverse_iterator crbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator crend() const noexcept {
    return const_reverse_iterator(begin());
  }
  iterator insert(iterator before, int n, const T &x);
  inline iterator insert(iterator before, const T &x) {
    return insert(before, 1, x);
  }
  inline iterator insert(iterator before, T &&x);
  iterator erase(iterator begin, iterator end);
  inline iterator erase(iterator pos) { return erase(pos, pos + 1); }

  inline int count() const { return d->size; }
  inline T &first() {
    ((!isEmpty())
         ? static_cast<void>(0)
         : qt_assert("!isEmpty()", "/usr/local/include/QtCore/qvector.h", 242));
    return *begin();
  }
  inline const T &first() const {
    ((!isEmpty())
         ? static_cast<void>(0)
         : qt_assert("!isEmpty()", "/usr/local/include/QtCore/qvector.h", 243));
    return *begin();
  }
  inline const T &constFirst() const {
    ((!isEmpty())
         ? static_cast<void>(0)
         : qt_assert("!isEmpty()", "/usr/local/include/QtCore/qvector.h", 244));
    return *begin();
  }
  inline T &last() {
    ((!isEmpty())
         ? static_cast<void>(0)
         : qt_assert("!isEmpty()", "/usr/local/include/QtCore/qvector.h", 245));
    return *(end() - 1);
  }
  inline const T &last() const {
    ((!isEmpty())
         ? static_cast<void>(0)
         : qt_assert("!isEmpty()", "/usr/local/include/QtCore/qvector.h", 246));
    return *(end() - 1);
  }
  inline const T &constLast() const {
    ((!isEmpty())
         ? static_cast<void>(0)
         : qt_assert("!isEmpty()", "/usr/local/include/QtCore/qvector.h", 247));
    return *(end() - 1);
  }
  inline bool startsWith(const T &t) const {
    return !isEmpty() && first() == t;
  }
  inline bool endsWith(const T &t) const { return !isEmpty() && last() == t; }
  QVector<T> mid(int pos, int len = -1) const;

  T value(int i) const;
  T value(int i, const T &defaultValue) const;

  void swapItemsAt(int i, int j) {
    ((i >= 0 && i < size() && j >= 0 && j < size())
         ? static_cast<void>(0)
         : qt_assert_x("QVector<T>::swap", "index out of range",
                       "/usr/local/include/QtCore/qvector.h", 257));

    detach();
    qSwap(d->begin()[i], d->begin()[j]);
  }

  typedef T value_type;
  typedef value_type *pointer;
  typedef const value_type *const_pointer;
  typedef value_type &reference;
  typedef const value_type &const_reference;
  typedef qptrdiff difference_type;
  typedef iterator Iterator;
  typedef const_iterator ConstIterator;
  typedef int size_type;
  inline void push_back(const T &t) { append(t); }
  void push_back(T &&t) { append(std::move(t)); }
  void push_front(T &&t) { prepend(std::move(t)); }
  inline void push_front(const T &t) { prepend(t); }
  void pop_back() { removeLast(); }
  void pop_front() { removeFirst(); }
  inline bool empty() const { return d->size == 0; }
  inline T &front() { return first(); }
  inline const_reference front() const { return first(); }
  inline reference back() { return last(); }
  inline const_reference back() const { return last(); }
  void shrink_to_fit() { squeeze(); }

  QVector<T> &operator+=(const QVector<T> &l);
  inline QVector<T> operator+(const QVector<T> &l) const {
    QVector n = *this;
    n += l;
    return n;
  }
  inline QVector<T> &operator+=(const T &t) {
    append(t);
    return *this;
  }
  inline QVector<T> &operator<<(const T &t) {
    append(t);
    return *this;
  }
  inline QVector<T> &operator<<(const QVector<T> &l) {
    *this += l;
    return *this;
  }
  inline QVector<T> &operator+=(T &&t) {
    append(std::move(t));
    return *this;
  }
  inline QVector<T> &operator<<(T &&t) {
    append(std::move(t));
    return *this;
  }

  static QVector<T> fromList(const QList<T> &list);
  QList<T> toList() const;

  __attribute__((__deprecated__("Use QVector<T>(vector.begin(), vector.end()) "
                                "instead."))) static inline QVector<T>
  fromStdVector(const std::vector<T> &vector) {
    return QVector<T>(vector.begin(), vector.end());
  }
  __attribute__((
      __deprecated__("Use std::vector<T>(vector.begin(), vector.end()) "
                     "instead."))) inline std::vector<T>
  toStdVector() const {
    return std::vector<T>(d->begin(), d->end());
  }

private:
  void reallocData(const int size, const int alloc,
                   QArrayData::AllocationOptions options = QArrayData::Default);
  void reallocData(const int sz) { reallocData(sz, d->alloc); }
  void realloc(int alloc,
               QArrayData::AllocationOptions options = QArrayData::Default);
  void freeData(Data *d);
  void defaultConstruct(T *from, T *to);
  void copyConstruct(const T *srcFrom, const T *srcTo, T *dstFrom);
  void destruct(T *from, T *to);
  bool isValidIterator(const iterator &i) const {
    const std::less<const T *> less = {};
    return !less(d->end(), i) && !less(i, d->begin());
  }
  class AlignmentDummy {
    Data header;
    T array[1];
  };
};
# 344 "/usr/local/include/QtCore/qvector.h"
template <typename T> void QVector<T>::defaultConstruct(T *from, T *to) {
  if (QTypeInfo<T>::isComplex) {
    while (from != to) {
      new (from++) T();
    }
  } else {
    ::memset(static_cast<void *>(from), 0, (to - from) * sizeof(T));
  }
}

template <typename T>
void QVector<T>::copyConstruct(const T *srcFrom, const T *srcTo, T *dstFrom) {
  if (QTypeInfo<T>::isComplex) {
    while (srcFrom != srcTo)
      new (dstFrom++) T(*srcFrom++);
  } else {
    ::memcpy(static_cast<void *>(dstFrom), static_cast<const void *>(srcFrom),
             (srcTo - srcFrom) * sizeof(T));
  }
}

template <typename T> void QVector<T>::destruct(T *from, T *to) {
  if (QTypeInfo<T>::isComplex) {
    while (from != to) {
      from++->~T();
    }
  }
}

template <typename T> inline QVector<T>::QVector(const QVector<T> &v) {
  if (v.d->ref.ref()) {
    d = v.d;
  } else {
    if (v.d->capacityReserved) {
      d = Data::allocate(v.d->alloc);
      do {
        if (!(d))
          qBadAlloc();
      } while (false);
      d->capacityReserved = true;
    } else {
      d = Data::allocate(v.d->size);
      do {
        if (!(d))
          qBadAlloc();
      } while (false);
    }
    if (d->alloc) {
      copyConstruct(v.d->begin(), v.d->end(), d->begin());
      d->size = v.d->size;
    }
  }
}

template <typename T> void QVector<T>::detach() {
  if (!isDetached()) {

    if (!d->alloc)
      d = Data::unsharableEmpty();
    else

      realloc(int(d->alloc));
  }
  ((isDetached())
       ? static_cast<void>(0)
       : qt_assert("isDetached()", "/usr/local/include/QtCore/qvector.h", 413));
}

template <typename T> void QVector<T>::reserve(int asize) {
  if (asize > int(d->alloc))
    realloc(asize);
  if (isDetached()

      && d != Data::unsharableEmpty()

  )
    d->capacityReserved = 1;
  ((capacity() >= asize)
       ? static_cast<void>(0)
       : qt_assert("capacity() >= asize", "/usr/local/include/QtCore/qvector.h",
                   427));
}

template <typename T> void QVector<T>::resize(int asize) {
  if (asize == d->size)
    return detach();
  if (asize > int(d->alloc) || !isDetached()) {
    QArrayData::AllocationOptions opt =
        asize > int(d->alloc) ? QArrayData::Grow : QArrayData::Default;
    realloc(qMax(int(d->alloc), asize), opt);
  }
  if (asize < d->size)
    destruct(begin() + asize, end());
  else
    defaultConstruct(end(), begin() + asize);
  d->size = asize;
}
template <typename T> inline void QVector<T>::clear() {
  if (!d->size)
    return;
  destruct(begin(), end());
  d->size = 0;
}
template <typename T> inline const T &QVector<T>::at(int i) const {
  ((i >= 0 && i < d->size)
       ? static_cast<void>(0)
       : qt_assert_x("QVector<T>::at", "index out of range",
                     "/usr/local/include/QtCore/qvector.h", 455));
  return d->begin()[i];
}
template <typename T> inline const T &QVector<T>::operator[](int i) const {
  ((i >= 0 && i < d->size)
       ? static_cast<void>(0)
       : qt_assert_x("QVector<T>::operator[]", "index out of range",
                     "/usr/local/include/QtCore/qvector.h", 459));
  return d->begin()[i];
}
template <typename T> inline T &QVector<T>::operator[](int i) {
  ((i >= 0 && i < d->size)
       ? static_cast<void>(0)
       : qt_assert_x("QVector<T>::operator[]", "index out of range",
                     "/usr/local/include/QtCore/qvector.h", 463));
  return data()[i];
}
template <typename T> inline void QVector<T>::insert(int i, const T &t) {
  ((i >= 0 && i <= d->size)
       ? static_cast<void>(0)
       : qt_assert_x("QVector<T>::insert", "index out of range",
                     "/usr/local/include/QtCore/qvector.h", 467));
  insert(begin() + i, 1, t);
}
template <typename T> inline void QVector<T>::insert(int i, int n, const T &t) {
  ((i >= 0 && i <= d->size)
       ? static_cast<void>(0)
       : qt_assert_x("QVector<T>::insert", "index out of range",
                     "/usr/local/include/QtCore/qvector.h", 471));
  insert(begin() + i, n, t);
}
template <typename T> inline void QVector<T>::insert(int i, T &&t) {
  ((i >= 0 && i <= d->size)
       ? static_cast<void>(0)
       : qt_assert_x("QVector<T>::insert", "index out of range",
                     "/usr/local/include/QtCore/qvector.h", 475));
  insert(begin() + i, std::move(t));
}
template <typename T> inline void QVector<T>::remove(int i, int n) {
  ((i >= 0 && n >= 0 && i + n <= d->size)
       ? static_cast<void>(0)
       : qt_assert_x("QVector<T>::remove", "index out of range",
                     "/usr/local/include/QtCore/qvector.h", 479));
  erase(d->begin() + i, d->begin() + i + n);
}
template <typename T> inline void QVector<T>::remove(int i) {
  ((i >= 0 && i < d->size)
       ? static_cast<void>(0)
       : qt_assert_x("QVector<T>::remove", "index out of range",
                     "/usr/local/include/QtCore/qvector.h", 483));
  erase(d->begin() + i, d->begin() + i + 1);
}
template <typename T> inline void QVector<T>::prepend(const T &t) {
  insert(begin(), 1, t);
}
template <typename T> inline void QVector<T>::prepend(T &&t) {
  insert(begin(), std::move(t));
}

template <typename T> inline void QVector<T>::replace(int i, const T &t) {
  ((i >= 0 && i < d->size)
       ? static_cast<void>(0)
       : qt_assert_x("QVector<T>::replace", "index out of range",
                     "/usr/local/include/QtCore/qvector.h", 495));
  const T copy(t);
  data()[i] = copy;
}

template <typename T> QVector<T> &QVector<T>::operator=(const QVector<T> &v) {
  if (v.d != d) {
    QVector<T> tmp(v);
    tmp.swap(*this);
  }
  return *this;
}

template <typename T> QVector<T>::QVector(int asize) {
  ((asize >= 0) ? static_cast<void>(0)
                : qt_assert_x("QVector::QVector",
                              "Size must be greater than or equal to 0.",
                              "/usr/local/include/QtCore/qvector.h", 513));
  if (__builtin_expect(!!(asize > 0), true)) {
    d = Data::allocate(asize);
    do {
      if (!(d))
        qBadAlloc();
    } while (false);
    d->size = asize;
    defaultConstruct(d->begin(), d->end());
  } else {
    d = Data::sharedNull();
  }
}

template <typename T> QVector<T>::QVector(int asize, const T &t) {
  ((asize >= 0) ? static_cast<void>(0)
                : qt_assert_x("QVector::QVector",
                              "Size must be greater than or equal to 0.",
                              "/usr/local/include/QtCore/qvector.h", 527));
  if (asize > 0) {
    d = Data::allocate(asize);
    do {
      if (!(d))
        qBadAlloc();
    } while (false);
    d->size = asize;
    T *i = d->end();
    while (i != d->begin())
      new (--i) T(t);
  } else {
    d = Data::sharedNull();
  }
}

template <typename T> QVector<T>::QVector(std::initializer_list<T> args) {
  if (args.size() > 0) {
    d = Data::allocate(args.size());
    do {
      if (!(d))
        qBadAlloc();
    } while (false);

    copyConstruct(args.begin(), args.end(), d->begin());
    d->size = int(args.size());
  } else {
    d = Data::sharedNull();
  }
}

template <typename T>
QVector<T> &QVector<T>::operator=(std::initializer_list<T> args) {
  QVector<T> tmp(args);
  tmp.swap(*this);
  return *this;
}

template <typename T>
template <typename InputIterator, QtPrivate::IfIsInputIterator<InputIterator>>
QVector<T>::QVector(InputIterator first, InputIterator last) : QVector() {
  QtPrivate::reserveIfForwardIterator(this, first, last);
  std::copy(first, last, std::back_inserter(*this));
}

template <typename T> void QVector<T>::freeData(Data *x) {
  destruct(x->begin(), x->end());
  Data::deallocate(x);
}

template <typename T>
void QVector<T>::reallocData(const int asize, const int aalloc,
                             QArrayData::AllocationOptions options) {
  ((asize >= 0 && asize <= aalloc)
       ? static_cast<void>(0)
       : qt_assert("asize >= 0 && asize <= aalloc",
                   "/usr/local/include/QtCore/qvector.h", 596));
  Data *x = d;

  const bool isShared = d->ref.isShared();

  if (aalloc != 0) {
    if (aalloc != int(d->alloc) || isShared) {
      try {

        x = Data::allocate(aalloc, options);
        do {
          if (!(x))
            qBadAlloc();
        } while (false);

        ((x->ref.isSharable() || options.testFlag(QArrayData::Unsharable))
             ? static_cast<void>(0)
             : qt_assert("x->ref.isSharable() || "
                         "options.testFlag(QArrayData::Unsharable)",
                         "/usr/local/include/QtCore/qvector.h", 609));

        ((!x->ref.isStatic())
             ? static_cast<void>(0)
             : qt_assert("!x->ref.isStatic()",
                         "/usr/local/include/QtCore/qvector.h", 611));
        x->size = asize;

        T *srcBegin = d->begin();
        T *srcEnd = asize > d->size ? d->end() : d->begin() + asize;
        T *dst = x->begin();

        if (!QTypeInfoQuery<T>::isRelocatable ||
            (isShared && QTypeInfo<T>::isComplex)) {
          try {
            if (isShared || !std::is_nothrow_move_constructible<T>::value) {

              while (srcBegin != srcEnd)
                new (dst++) T(*srcBegin++);
            } else {
              while (srcBegin != srcEnd)
                new (dst++) T(std::move(*srcBegin++));
            }
          } catch (...) {

            destruct(x->begin(), dst);
            throw;
          }
        } else {
          ::memcpy(static_cast<void *>(dst), static_cast<void *>(srcBegin),
                   (srcEnd - srcBegin) * sizeof(T));
          dst += srcEnd - srcBegin;

          if (asize < d->size)
            destruct(d->begin() + asize, d->end());
        }

        if (asize > d->size) {

          if (!QTypeInfo<T>::isComplex) {
            ::memset(static_cast<void *>(dst), 0,
                     (static_cast<T *>(x->end()) - dst) * sizeof(T));
          } else {
            try {
              while (dst != x->end())
                new (dst++) T();
            } catch (...) {

              destruct(x->begin(), dst);
              throw;
            }
          }
        }
      } catch (...) {
        Data::deallocate(x);
        throw;
      }
      x->capacityReserved = d->capacityReserved;
    } else {
      ((int(d->alloc) == aalloc)
           ? static_cast<void>(0)
           : qt_assert("int(d->alloc) == aalloc",
                       "/usr/local/include/QtCore/qvector.h", 663));
      ((isDetached()) ? static_cast<void>(0)
                      : qt_assert("isDetached()",
                                  "/usr/local/include/QtCore/qvector.h", 664));
      ((x == d)
           ? static_cast<void>(0)
           : qt_assert("x == d", "/usr/local/include/QtCore/qvector.h", 665));
      if (asize <= d->size) {
        destruct(x->begin() + asize, x->end());
      } else {
        defaultConstruct(x->end(), x->begin() + asize);
      }
      x->size = asize;
    }
  } else {
    x = Data::sharedNull();
  }
  if (d != x) {
    if (!d->ref.deref()) {
      if (!QTypeInfoQuery<T>::isRelocatable || !aalloc ||
          (isShared && QTypeInfo<T>::isComplex)) {

        freeData(d);
      } else {
        Data::deallocate(d);
      }
    }
    d = x;
  }

  ((d->data())
       ? static_cast<void>(0)
       : qt_assert("d->data()", "/usr/local/include/QtCore/qvector.h", 689));
  ((uint(d->size) <= d->alloc)
       ? static_cast<void>(0)
       : qt_assert("uint(d->size) <= d->alloc",
                   "/usr/local/include/QtCore/qvector.h", 690));

  ((d != Data::unsharableEmpty())
       ? static_cast<void>(0)
       : qt_assert("d != Data::unsharableEmpty()",
                   "/usr/local/include/QtCore/qvector.h", 692));

  ((aalloc ? d != Data::sharedNull() : d == Data::sharedNull())
       ? static_cast<void>(0)
       : qt_assert("aalloc ? d != Data::sharedNull() : d == Data::sharedNull()",
                   "/usr/local/include/QtCore/qvector.h", 694));
  ((d->alloc >= uint(aalloc))
       ? static_cast<void>(0)
       : qt_assert("d->alloc >= uint(aalloc)",
                   "/usr/local/include/QtCore/qvector.h", 695));
  ((d->size == asize) ? static_cast<void>(0)
                      : qt_assert("d->size == asize",
                                  "/usr/local/include/QtCore/qvector.h", 696));
}

template <typename T>
void QVector<T>::realloc(int aalloc, QArrayData::AllocationOptions options) {
  ((aalloc >= d->size) ? static_cast<void>(0)
                       : qt_assert("aalloc >= d->size",
                                   "/usr/local/include/QtCore/qvector.h", 702));
  Data *x = d;

  const bool isShared = d->ref.isShared();

  try {

    x = Data::allocate(aalloc, options);
    do {
      if (!(x))
        qBadAlloc();
    } while (false);

    ((x->ref.isSharable() || options.testFlag(QArrayData::Unsharable))
         ? static_cast<void>(0)
         : qt_assert("x->ref.isSharable() || "
                     "options.testFlag(QArrayData::Unsharable)",
                     "/usr/local/include/QtCore/qvector.h", 713));

    ((!x->ref.isStatic())
         ? static_cast<void>(0)
         : qt_assert("!x->ref.isStatic()",
                     "/usr/local/include/QtCore/qvector.h", 715));
    x->size = d->size;

    T *srcBegin = d->begin();
    T *srcEnd = d->end();
    T *dst = x->begin();

    if (!QTypeInfoQuery<T>::isRelocatable ||
        (isShared && QTypeInfo<T>::isComplex)) {
      try {
        if (isShared || !std::is_nothrow_move_constructible<T>::value) {

          while (srcBegin != srcEnd)
            new (dst++) T(*srcBegin++);
        } else {
          while (srcBegin != srcEnd)
            new (dst++) T(std::move(*srcBegin++));
        }
      } catch (...) {

        destruct(x->begin(), dst);
        throw;
      }
    } else {
      ::memcpy(static_cast<void *>(dst), static_cast<void *>(srcBegin),
               (srcEnd - srcBegin) * sizeof(T));
      dst += srcEnd - srcBegin;
    }

  } catch (...) {
    Data::deallocate(x);
    throw;
  }
  x->capacityReserved = d->capacityReserved;

  ((d != x) ? static_cast<void>(0)
            : qt_assert("d != x", "/usr/local/include/QtCore/qvector.h", 748));
  if (!d->ref.deref()) {
    if (!QTypeInfoQuery<T>::isRelocatable || !aalloc ||
        (isShared && QTypeInfo<T>::isComplex)) {

      freeData(d);
    } else {
      Data::deallocate(d);
    }
  }
  d = x;

  ((d->data())
       ? static_cast<void>(0)
       : qt_assert("d->data()", "/usr/local/include/QtCore/qvector.h", 760));
  ((uint(d->size) <= d->alloc)
       ? static_cast<void>(0)
       : qt_assert("uint(d->size) <= d->alloc",
                   "/usr/local/include/QtCore/qvector.h", 761));

  ((d != Data::unsharableEmpty())
       ? static_cast<void>(0)
       : qt_assert("d != Data::unsharableEmpty()",
                   "/usr/local/include/QtCore/qvector.h", 763));

  ((d != Data::sharedNull())
       ? static_cast<void>(0)
       : qt_assert("d != Data::sharedNull()",
                   "/usr/local/include/QtCore/qvector.h", 765));
  ((d->alloc >= uint(aalloc))
       ? static_cast<void>(0)
       : qt_assert("d->alloc >= uint(aalloc)",
                   "/usr/local/include/QtCore/qvector.h", 766));
}

template <typename T> T QVector<T>::value(int i) const {
  if (uint(i) >= uint(d->size)) {
    return T();
  }
  return d->begin()[i];
}
template <typename T> T QVector<T>::value(int i, const T &defaultValue) const {
  return uint(i) >= uint(d->size) ? defaultValue : d->begin()[i];
}

template <typename T> void QVector<T>::append(const T &t) {
  const bool isTooSmall = uint(d->size + 1) > d->alloc;
  if (!isDetached() || isTooSmall) {
    T copy(t);
    QArrayData::AllocationOptions opt(isTooSmall ? QArrayData::Grow
                                                 : QArrayData::Default);
    realloc(isTooSmall ? d->size + 1 : d->alloc, opt);

    if (QTypeInfo<T>::isComplex)
      new (d->end()) T(std::move(copy));
    else
      *d->end() = std::move(copy);

  } else {
    if (QTypeInfo<T>::isComplex)
      new (d->end()) T(t);
    else
      *d->end() = t;
  }
  ++d->size;
}

template <typename T> void QVector<T>::append(T &&t) {
  const bool isTooSmall = uint(d->size + 1) > d->alloc;
  if (!isDetached() || isTooSmall) {
    QArrayData::AllocationOptions opt(isTooSmall ? QArrayData::Grow
                                                 : QArrayData::Default);
    realloc(isTooSmall ? d->size + 1 : d->alloc, opt);
  }

  new (d->end()) T(std::move(t));

  ++d->size;
}

template <typename T> void QVector<T>::removeLast() {
  ((!isEmpty())
       ? static_cast<void>(0)
       : qt_assert("!isEmpty()", "/usr/local/include/QtCore/qvector.h", 827));
  ((d->alloc)
       ? static_cast<void>(0)
       : qt_assert("d->alloc", "/usr/local/include/QtCore/qvector.h", 828));

  if (d->ref.isShared())
    detach();
  --d->size;
  if (QTypeInfo<T>::isComplex)
    (d->data() + d->size)->~T();
}

template <typename T>
typename QVector<T>::iterator QVector<T>::insert(iterator before, size_type n,
                                                 const T &t) {
  ((isValidIterator(before))
       ? static_cast<void>(0)
       : qt_assert_x("QVector::insert",
                     "The specified iterator argument 'before' is invalid",
                     "/usr/local/include/QtCore/qvector.h", 840));

  const auto offset = std::distance(d->begin(), before);
  if (n != 0) {
    const T copy(t);
    if (!isDetached() || d->size + n > int(d->alloc))
      realloc(d->size + n, QArrayData::Grow);
    if (!QTypeInfoQuery<T>::isRelocatable) {
      T *b = d->end();
      T *i = d->end() + n;
      while (i != b)
        new (--i) T;
      i = d->end();
      T *j = i + n;
      b = d->begin() + offset;
      while (i != b)
        *--j = *--i;
      i = b + n;
      while (i != b)
        *--i = copy;
    } else {
      T *b = d->begin() + offset;
      T *i = b + n;
      memmove(static_cast<void *>(i), static_cast<const void *>(b),
              (d->size - offset) * sizeof(T));
      while (i != b)
        new (--i) T(copy);
    }
    d->size += n;
  }
  return d->begin() + offset;
}

template <typename T>
typename QVector<T>::iterator QVector<T>::insert(iterator before, T &&t) {
  ((isValidIterator(before))
       ? static_cast<void>(0)
       : qt_assert_x("QVector::insert",
                     "The specified iterator argument 'before' is invalid",
                     "/usr/local/include/QtCore/qvector.h", 875));

  const auto offset = std::distance(d->begin(), before);
  if (!isDetached() || d->size + 1 > int(d->alloc))
    realloc(d->size + 1, QArrayData::Grow);
  if (!QTypeInfoQuery<T>::isRelocatable) {
    T *i = d->end();
    T *j = i + 1;
    T *b = d->begin() + offset;

    if (i != b) {
      new (--j) T(std::move(*--i));
      while (i != b)
        *--j = std::move(*--i);
      *b = std::move(t);
    } else {
      new (b) T(std::move(t));
    }
  } else {
    T *b = d->begin() + offset;
    memmove(static_cast<void *>(b + 1), static_cast<const void *>(b),
            (d->size - offset) * sizeof(T));
    new (b) T(std::move(t));
  }
  d->size += 1;
  return d->begin() + offset;
}

template <typename T>
typename QVector<T>::iterator QVector<T>::erase(iterator abegin,
                                                iterator aend) {
  ((isValidIterator(abegin))
       ? static_cast<void>(0)
       : qt_assert_x("QVector::erase",
                     "The specified iterator argument 'abegin' is invalid",
                     "/usr/local/include/QtCore/qvector.h", 905));
  ((isValidIterator(aend))
       ? static_cast<void>(0)
       : qt_assert_x("QVector::erase",
                     "The specified iterator argument 'aend' is invalid",
                     "/usr/local/include/QtCore/qvector.h", 906));

  const auto itemsToErase = aend - abegin;

  if (!itemsToErase)
    return abegin;

  ((abegin >= d->begin())
       ? static_cast<void>(0)
       : qt_assert("abegin >= d->begin()",
                   "/usr/local/include/QtCore/qvector.h", 913));
  ((aend <= d->end()) ? static_cast<void>(0)
                      : qt_assert("aend <= d->end()",
                                  "/usr/local/include/QtCore/qvector.h", 914));
  ((abegin <= aend) ? static_cast<void>(0)
                    : qt_assert("abegin <= aend",
                                "/usr/local/include/QtCore/qvector.h", 915));

  const auto itemsUntouched = abegin - d->begin();

  if (d->alloc) {
    detach();
    abegin = d->begin() + itemsUntouched;
    aend = abegin + itemsToErase;
    if (!QTypeInfoQuery<T>::isRelocatable) {
      iterator moveBegin = abegin + itemsToErase;
      iterator moveEnd = d->end();
      while (moveBegin != moveEnd) {
        if (QTypeInfo<T>::isComplex)
          static_cast<T *>(abegin)->~T();
        new (abegin++) T(*moveBegin++);
      }
      if (abegin < d->end()) {

        destruct(abegin, d->end());
      }
    } else {
      destruct(abegin, aend);

      memmove(static_cast<void *>(abegin), static_cast<void *>(aend),
              (d->size - itemsToErase - itemsUntouched) * sizeof(T));
    }
    d->size -= int(itemsToErase);
  }
  return d->begin() + itemsUntouched;
}

template <typename T> bool QVector<T>::operator==(const QVector<T> &v) const {
  if (d == v.d)
    return true;
  if (d->size != v.d->size)
    return false;
  const T *vb = v.d->begin();
  const T *b = d->begin();
  const T *e = d->end();
  return std::equal(b, e, (vb));
}

template <typename T> QVector<T> &QVector<T>::fill(const T &from, int asize) {
  const T copy(from);
  resize(asize < 0 ? d->size : asize);
  if (d->size) {
    T *i = d->end();
    T *b = d->begin();
    while (i != b)
      *--i = copy;
  }
  return *this;
}

template <typename T> QVector<T> &QVector<T>::operator+=(const QVector &l) {
  if (d->size == 0) {
    *this = l;
  } else {
    uint newSize = d->size + l.d->size;
    const bool isTooSmall = newSize > d->alloc;
    if (!isDetached() || isTooSmall) {
      QArrayData::AllocationOptions opt(isTooSmall ? QArrayData::Grow
                                                   : QArrayData::Default);
      realloc(isTooSmall ? newSize : d->alloc, opt);
    }

    if (d->alloc) {
      T *w = d->begin() + newSize;
      T *i = l.d->end();
      T *b = l.d->begin();
      while (i != b) {
        if (QTypeInfo<T>::isComplex)
          new (--w) T(*--i);
        else
          *--w = *--i;
      }
      d->size = newSize;
    }
  }
  return *this;
}

template <typename T> int QVector<T>::indexOf(const T &t, int from) const {
  if (from < 0)
    from = qMax(from + d->size, 0);
  if (from < d->size) {
    T *n = d->begin() + from - 1;
    T *e = d->end();
    while (++n != e)
      if (*n == t)
        return n - d->begin();
  }
  return -1;
}

template <typename T> int QVector<T>::lastIndexOf(const T &t, int from) const {
  if (from < 0)
    from += d->size;
  else if (from >= d->size)
    from = d->size - 1;
  if (from >= 0) {
    T *b = d->begin();
    T *n = d->begin() + from + 1;
    while (n != b) {
      if (*--n == t)
        return n - b;
    }
  }
  return -1;
}

template <typename T> bool QVector<T>::contains(const T &t) const {
  const T *b = d->begin();
  const T *e = d->end();
  return std::find(b, e, t) != e;
}

template <typename T> int QVector<T>::count(const T &t) const {
  const T *b = d->begin();
  const T *e = d->end();
  return int(std::count(b, e, t));
}

template <typename T> QVector<T> QVector<T>::mid(int pos, int len) const {
  using namespace QtPrivate;
  switch (QContainerImplHelper::mid(d->size, &pos, &len)) {
  case QContainerImplHelper::Null:
  case QContainerImplHelper::Empty:
    return QVector<T>();
  case QContainerImplHelper::Full:
    return *this;
  case QContainerImplHelper::Subset:
    break;
  }

  QVector<T> midResult;
  midResult.realloc(len);
  T *srcFrom = d->begin() + pos;
  T *srcTo = d->begin() + pos + len;
  midResult.copyConstruct(srcFrom, srcTo, midResult.data());
  midResult.d->size = len;
  return midResult;
}

template <class T> class QVectorIterator {
  typedef typename QVector<T>::const_iterator const_iterator;
  QVector<T> c;
  const_iterator i;
public:
  inline QVectorIterator(const QVector<T> &container)
      : c(container), i(c.constBegin()) {}
  inline QVectorIterator &operator=(const QVector<T> &container) {
    c = container;
    i = c.constBegin();
    return *this;
  }
  inline void toFront() { i = c.constBegin(); }
  inline void toBack() { i = c.constEnd(); }
  inline bool hasNext() const { return i != c.constEnd(); }
  inline const T &next() { return *i++; }
  inline const T &peekNext() const { return *i; }
  inline bool hasPrevious() const { return i != c.constBegin(); }
  inline const T &previous() { return *--i; }
  inline const T &peekPrevious() const {
    const_iterator p = i;
    return *--p;
  }
  inline bool findNext(const T &t) {
    while (i != c.constEnd())
      if (*i++ == t)
        return true;
    return false;
  }
  inline bool findPrevious(const T &t) {
    while (i != c.constBegin())
      if (*(--i) == t)
        return true;
    return false;
  }
};
template <class T> class QMutableVectorIterator {
  typedef typename QVector<T>::iterator iterator;
  typedef typename QVector<T>::const_iterator const_iterator;
  QVector<T> *c;
  iterator i, n;
  inline bool item_exists() const { return const_iterator(n) != c->constEnd(); }
public:
  inline QMutableVectorIterator(QVector<T> &container) : c(&container) {
    i = c->begin();
    n = c->end();
  }
  inline QMutableVectorIterator &operator=(QVector<T> &container) {
    c = &container;
    i = c->begin();
    n = c->end();
    return *this;
  }
  inline void toFront() {
    i = c->begin();
    n = c->end();
  }
  inline void toBack() {
    i = c->end();
    n = i;
  }
  inline bool hasNext() const { return c->constEnd() != const_iterator(i); }
  inline T &next() {
    n = i++;
    return *n;
  }
  inline T &peekNext() const { return *i; }
  inline bool hasPrevious() const {
    return c->constBegin() != const_iterator(i);
  }
  inline T &previous() {
    n = --i;
    return *n;
  }
  inline T &peekPrevious() const {
    iterator p = i;
    return *--p;
  }
  inline void remove() {
    if (c->constEnd() != const_iterator(n)) {
      i = c->erase(n);
      n = c->end();
    }
  }
  inline void setValue(const T &t) const {
    if (c->constEnd() != const_iterator(n))
      *n = t;
  }
  inline T &value() {
    ((item_exists()) ? static_cast<void>(0)
                     : qt_assert("item_exists()",
                                 "/usr/local/include/QtCore/qvector.h", 1080));
    return *n;
  }
  inline const T &value() const {
    ((item_exists()) ? static_cast<void>(0)
                     : qt_assert("item_exists()",
                                 "/usr/local/include/QtCore/qvector.h", 1080));
    return *n;
  }
  inline void insert(const T &t) {
    n = i = c->insert(i, t);
    ++i;
  }
  inline bool findNext(const T &t) {
    while (c->constEnd() != const_iterator(n = i))
      if (*i++ == t)
        return true;
    return false;
  }
  inline bool findPrevious(const T &t) {
    while (c->constBegin() != const_iterator(i))
      if (*(n = --i) == t)
        return true;
    n = c->end();
    return false;
  }
};

template <typename T>
uint qHash(const QVector<T> &key,
           uint seed = 0) noexcept(noexcept(qHashRange(key.cbegin(), key.cend(),
                                                       seed))) {
  return qHashRange(key.cbegin(), key.cend(), seed);
}

template <typename T>
bool operator<(const QVector<T> &lhs, const QVector<T> &rhs) noexcept(
    noexcept(std::lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(),
                                          rhs.end()))) {
  return std::lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(),
                                      rhs.end());
}

template <typename T>
inline bool operator>(const QVector<T> &lhs,
                      const QVector<T> &rhs) noexcept(noexcept(lhs < rhs)) {
  return rhs < lhs;
}

template <typename T>
inline bool operator<=(const QVector<T> &lhs,
                       const QVector<T> &rhs) noexcept(noexcept(lhs < rhs)) {
  return !(lhs > rhs);
}

template <typename T>
inline bool operator>=(const QVector<T> &lhs,
                       const QVector<T> &rhs) noexcept(noexcept(lhs < rhs)) {
  return !(lhs < rhs);
}
# 1134 "/usr/local/include/QtCore/qvector.h"
QVector<uint> QStringView::toUcs4() const {
  return QtPrivate::convertToUcs4(*this);
}
# 49 "/usr/local/include/QtCore/qlist.h" 2
# 1 "/usr/local/include/QtCore/qcontainertools_impl.h" 1
# 50 "/usr/local/include/QtCore/qlist.h" 2

# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/stdlib.h" 1 3
# 59 "/usr/local/include/QtCore/qlist.h" 2
# 71 "/usr/local/include/QtCore/qlist.h"
template <typename T> class QVector;
template <typename T> class QSet;

template <typename T> struct QListSpecialMethods {
protected:
  ~QListSpecialMethods() = default;
};
template <> struct QListSpecialMethods<QByteArray>;
template <> struct QListSpecialMethods<QString>;

struct __attribute__((visibility("default"))) QListData {

  struct NotArrayCompatibleLayout {};
  struct NotIndirectLayout {};
  struct ArrayCompatibleLayout : NotIndirectLayout {};
  struct InlineWithPaddingLayout : NotArrayCompatibleLayout,
                                   NotIndirectLayout {};
  struct IndirectLayout : NotArrayCompatibleLayout {};

  struct Data {
    QtPrivate::RefCount ref;
    int alloc, begin, end;
    void *array[1];
  };
  enum { DataHeaderSize = sizeof(Data) - sizeof(void *) };

  Data *detach(int alloc);
  Data *detach_grow(int *i, int n);
  void realloc(int alloc);
  void realloc_grow(int growth);
  inline void dispose() { dispose(d); }
  static void dispose(Data *d);
  static const Data shared_null;
  Data *d;
  void **erase(void **xi);
  void **append(int n);
  void **append();
  void **append(const QListData &l);
  void **prepend();
  void **insert(int i);
  void remove(int i);
  void remove(int i, int n);
  void move(int from, int to);
  inline int size() const noexcept { return int(d->end - d->begin); }
  inline bool isEmpty() const noexcept { return d->end == d->begin; }
  inline void **at(int i) const noexcept { return d->array + d->begin + i; }
  inline void **begin() const noexcept { return d->array + d->begin; }
  inline void **end() const noexcept { return d->array + d->end; }
};

namespace QtPrivate {
template <typename V, typename U>
int indexOf(const QList<V> &list, const U &u, int from);
template <typename V, typename U>
int lastIndexOf(const QList<V> &list, const U &u, int from);
} // namespace QtPrivate

template <typename T>
class QList

    : public QListSpecialMethods<T>

{
public:
  struct MemoryLayout
      : std::conditional<

            QTypeInfo<T>::isStatic || QTypeInfo<T>::isLarge,
            QListData::IndirectLayout,
            typename std::conditional<
                sizeof(T) == sizeof(void *), QListData::ArrayCompatibleLayout,
                QListData::InlineWithPaddingLayout>::type>::type {};

private:
  template <typename V, typename U>
  friend int QtPrivate::indexOf(const QList<V> &list, const U &u, int from);
  template <typename V, typename U>
  friend int QtPrivate::lastIndexOf(const QList<V> &list, const U &u, int from);
  struct Node {
    void *v;

    inline T &t() {
      return *reinterpret_cast<T *>(
          QTypeInfo<T>::isLarge || QTypeInfo<T>::isStatic ? v : this);
    }
  };

  union {
    QListData p;
    QListData::Data *d;
  };

public:
  inline QList() noexcept
      : d(const_cast<QListData::Data *>(&QListData::shared_null)) {}
  QList(const QList<T> &l);
  ~QList();
  QList<T> &operator=(const QList<T> &l);
  inline QList(QList<T> &&other) noexcept : d(other.d) {
    other.d = const_cast<QListData::Data *>(&QListData::shared_null);
  }
  inline QList &operator=(QList<T> &&other) noexcept {
    QList moved(std::move(other));
    swap(moved);
    return *this;
  }
  inline void swap(QList<T> &other) noexcept { qSwap(d, other.d); }
  inline QList(std::initializer_list<T> args)
      : QList(args.begin(), args.end()) {}
  template <typename InputIterator,
            QtPrivate::IfIsInputIterator<InputIterator> = true>
  QList(InputIterator first, InputIterator last);
  bool operator==(const QList<T> &l) const;
  inline bool operator!=(const QList<T> &l) const { return !(*this == l); }

  inline int size() const noexcept { return p.size(); }

  inline void detach() {
    if (d->ref.isShared())
      detach_helper();
  }

  inline void detachShared() {

    if (d->ref.isShared() && this->d != &QListData::shared_null)
      detach_helper();
  }

  inline bool isDetached() const { return !d->ref.isShared(); }

  inline void setSharable(bool sharable) {
    if (sharable == d->ref.isSharable())
      return;
    if (!sharable)
      detach();
    if (d != &QListData::shared_null)
      d->ref.setSharable(sharable);
  }

  inline bool isSharedWith(const QList<T> &other) const noexcept {
    return d == other.d;
  }

  inline bool isEmpty() const noexcept { return p.isEmpty(); }

  void clear();

  const T &at(int i) const;
  const T &operator[](int i) const;
  T &operator[](int i);

  void reserve(int size);
  void append(const T &t);
  void append(const QList<T> &t);
  void prepend(const T &t);
  void insert(int i, const T &t);
  void replace(int i, const T &t);
  void removeAt(int i);
  int removeAll(const T &t);
  bool removeOne(const T &t);
  T takeAt(int i);
  T takeFirst();
  T takeLast();
  void move(int from, int to);
  void swapItemsAt(int i, int j);

  __attribute__((__deprecated__("Use QList<T>::swapItemsAt()"))) void
  swap(int i, int j) {
    swapItemsAt(i, j);
  }

  int indexOf(const T &t, int from = 0) const;
  int lastIndexOf(const T &t, int from = -1) const;
  bool contains(const T &t) const;
  int count(const T &t) const;

  class const_iterator;

  class iterator {
  public:
    Node *i;
    typedef std::random_access_iterator_tag iterator_category;

    typedef qptrdiff difference_type;
    typedef T value_type;
    typedef T *pointer;
    typedef T &reference;

    inline iterator() noexcept : i(nullptr) {}
    inline iterator(Node *n) noexcept : i(n) {}

    inline iterator(const iterator &o) noexcept : i(o.i) {}
    inline iterator &operator=(const iterator &o) noexcept {
      i = o.i;
      return *this;
    }

    inline T &operator*() const { return i->t(); }
    inline T *operator->() const { return &i->t(); }
    inline T &operator[](difference_type j) const { return i[j].t(); }
    inline bool operator==(const iterator &o) const noexcept {
      return i == o.i;
    }
    inline bool operator!=(const iterator &o) const noexcept {
      return i != o.i;
    }
    inline bool operator<(const iterator &other) const noexcept {
      return i < other.i;
    }
    inline bool operator<=(const iterator &other) const noexcept {
      return i <= other.i;
    }
    inline bool operator>(const iterator &other) const noexcept {
      return i > other.i;
    }
    inline bool operator>=(const iterator &other) const noexcept {
      return i >= other.i;
    }

    inline bool operator==(const const_iterator &o) const noexcept {
      return i == o.i;
    }
    inline bool operator!=(const const_iterator &o) const noexcept {
      return i != o.i;
    }
    inline bool operator<(const const_iterator &other) const noexcept {
      return i < other.i;
    }
    inline bool operator<=(const const_iterator &other) const noexcept {
      return i <= other.i;
    }
    inline bool operator>(const const_iterator &other) const noexcept {
      return i > other.i;
    }
    inline bool operator>=(const const_iterator &other) const noexcept {
      return i >= other.i;
    }

    inline iterator &operator++() {
      ++i;
      return *this;
    }
    inline iterator operator++(int) {
      Node *n = i;
      ++i;
      return n;
    }
    inline iterator &operator--() {
      i--;
      return *this;
    }
    inline iterator operator--(int) {
      Node *n = i;
      i--;
      return n;
    }
    inline iterator &operator+=(difference_type j) {
      i += j;
      return *this;
    }
    inline iterator &operator-=(difference_type j) {
      i -= j;
      return *this;
    }
    inline iterator operator+(difference_type j) const {
      return iterator(i + j);
    }
    inline iterator operator-(difference_type j) const {
      return iterator(i - j);
    }
    friend inline iterator operator+(difference_type j, iterator k) {
      return k + j;
    }
    inline int operator-(iterator j) const { return int(i - j.i); }
  };
  friend class iterator;

  class const_iterator {
  public:
    Node *i;
    typedef std::random_access_iterator_tag iterator_category;

    typedef qptrdiff difference_type;
    typedef T value_type;
    typedef const T *pointer;
    typedef const T &reference;

    inline const_iterator() noexcept : i(nullptr) {}
    inline const_iterator(Node *n) noexcept : i(n) {}

    inline const_iterator(const const_iterator &o) noexcept : i(o.i) {}
    inline const_iterator &operator=(const const_iterator &o) noexcept {
      i = o.i;
      return *this;
    }

    inline const_iterator(const iterator &o) noexcept : i(o.i) {}

    inline const T &operator*() const { return i->t(); }
    inline const T *operator->() const { return &i->t(); }
    inline const T &operator[](difference_type j) const { return i[j].t(); }
    inline bool operator==(const const_iterator &o) const noexcept {
      return i == o.i;
    }
    inline bool operator!=(const const_iterator &o) const noexcept {
      return i != o.i;
    }
    inline bool operator<(const const_iterator &other) const noexcept {
      return i < other.i;
    }
    inline bool operator<=(const const_iterator &other) const noexcept {
      return i <= other.i;
    }
    inline bool operator>(const const_iterator &other) const noexcept {
      return i > other.i;
    }
    inline bool operator>=(const const_iterator &other) const noexcept {
      return i >= other.i;
    }
    inline const_iterator &operator++() {
      ++i;
      return *this;
    }
    inline const_iterator operator++(int) {
      Node *n = i;
      ++i;
      return n;
    }
    inline const_iterator &operator--() {
      i--;
      return *this;
    }
    inline const_iterator operator--(int) {
      Node *n = i;
      i--;
      return n;
    }
    inline const_iterator &operator+=(difference_type j) {
      i += j;
      return *this;
    }
    inline const_iterator &operator-=(difference_type j) {
      i -= j;
      return *this;
    }
    inline const_iterator operator+(difference_type j) const {
      return const_iterator(i + j);
    }
    inline const_iterator operator-(difference_type j) const {
      return const_iterator(i - j);
    }
    friend inline const_iterator operator+(difference_type j,
                                           const_iterator k) {
      return k + j;
    }
    inline int operator-(const_iterator j) const { return int(i - j.i); }
  };
  friend class const_iterator;

  typedef std::reverse_iterator<iterator> reverse_iterator;
  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
  inline iterator begin() {
    detach();
    return reinterpret_cast<Node *>(p.begin());
  }
  inline const_iterator begin() const noexcept {
    return reinterpret_cast<Node *>(p.begin());
  }
  inline const_iterator cbegin() const noexcept {
    return reinterpret_cast<Node *>(p.begin());
  }
  inline const_iterator constBegin() const noexcept {
    return reinterpret_cast<Node *>(p.begin());
  }
  inline iterator end() {
    detach();
    return reinterpret_cast<Node *>(p.end());
  }
  inline const_iterator end() const noexcept {
    return reinterpret_cast<Node *>(p.end());
  }
  inline const_iterator cend() const noexcept {
    return reinterpret_cast<Node *>(p.end());
  }
  inline const_iterator constEnd() const noexcept {
    return reinterpret_cast<Node *>(p.end());
  }
  reverse_iterator rbegin() { return reverse_iterator(end()); }
  reverse_iterator rend() { return reverse_iterator(begin()); }
  const_reverse_iterator rbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator rend() const noexcept {
    return const_reverse_iterator(begin());
  }
  const_reverse_iterator crbegin() const noexcept {
    return const_reverse_iterator(end());
  }
  const_reverse_iterator crend() const noexcept {
    return const_reverse_iterator(begin());
  }
  iterator insert(iterator before, const T &t);
  iterator erase(iterator pos);
  iterator erase(iterator first, iterator last);

  typedef iterator Iterator;
  typedef const_iterator ConstIterator;
  inline int count() const { return p.size(); }
  inline int length() const { return p.size(); }
  inline T &first() {
    ((!isEmpty())
         ? static_cast<void>(0)
         : qt_assert("!isEmpty()", "/usr/local/include/QtCore/qlist.h", 361));
    return *begin();
  }
  inline const T &constFirst() const { return first(); }
  inline const T &first() const {
    ((!isEmpty())
         ? static_cast<void>(0)
         : qt_assert("!isEmpty()", "/usr/local/include/QtCore/qlist.h", 363));
    return at(0);
  }
  T &last() {
    ((!isEmpty())
         ? static_cast<void>(0)
         : qt_assert("!isEmpty()", "/usr/local/include/QtCore/qlist.h", 364));
    return *(--end());
  }
  const T &last() const {
    ((!isEmpty())
         ? static_cast<void>(0)
         : qt_assert("!isEmpty()", "/usr/local/include/QtCore/qlist.h", 365));
    return at(count() - 1);
  }
  inline const T &constLast() const { return last(); }
  inline void removeFirst() {
    ((!isEmpty())
         ? static_cast<void>(0)
         : qt_assert("!isEmpty()", "/usr/local/include/QtCore/qlist.h", 367));
    erase(begin());
  }
  inline void removeLast() {
    ((!isEmpty())
         ? static_cast<void>(0)
         : qt_assert("!isEmpty()", "/usr/local/include/QtCore/qlist.h", 368));
    erase(--end());
  }
  inline bool startsWith(const T &t) const {
    return !isEmpty() && first() == t;
  }
  inline bool endsWith(const T &t) const { return !isEmpty() && last() == t; }
  QList<T> mid(int pos, int length = -1) const;

  T value(int i) const;
  T value(int i, const T &defaultValue) const;

  inline void push_back(const T &t) { append(t); }
  inline void push_front(const T &t) { prepend(t); }
  inline T &front() { return first(); }
  inline const T &front() const { return first(); }
  inline T &back() { return last(); }
  inline const T &back() const { return last(); }
  inline void pop_front() { removeFirst(); }
  inline void pop_back() { removeLast(); }
  inline bool empty() const { return isEmpty(); }
  typedef int size_type;
  typedef T value_type;
  typedef value_type *pointer;
  typedef const value_type *const_pointer;
  typedef value_type &reference;
  typedef const value_type &const_reference;

  typedef qptrdiff difference_type;

  QList<T> &operator+=(const QList<T> &l);
  inline QList<T> operator+(const QList<T> &l) const {
    QList n = *this;
    n += l;
    return n;
  }
  inline QList<T> &operator+=(const T &t) {
    append(t);
    return *this;
  }
  inline QList<T> &operator<<(const T &t) {
    append(t);
    return *this;
  }
  inline QList<T> &operator<<(const QList<T> &l) {
    *this += l;
    return *this;
  }

  static QList<T> fromVector(const QVector<T> &vector);
  QVector<T> toVector() const;

  __attribute__((__deprecated__(
      "Use QList<T>(set.begin(), set.end()) instead."))) static QList<T>
  fromSet(const QSet<T> &set);
  __attribute__((
      __deprecated__("Use QSet<T>(list.begin(), list.end()) instead."))) QSet<T>
  toSet() const;

  __attribute__((__deprecated__("Use QList<T>(list.begin(), list.end()) "
                                "instead."))) static inline QList<T>
  fromStdList(const std::list<T> &list) {
    return QList<T>(list.begin(), list.end());
  }
  __attribute__((__deprecated__(
      "Use std::list<T>(list.begin(), list.end()) instead."))) inline std::
      list<T>
      toStdList() const {
    return std::list<T>(begin(), end());
  }

private:
  Node *detach_helper_grow(int i, int n);
  void detach_helper(int alloc);
  void detach_helper();
  void dealloc(QListData::Data *d);

  void node_construct(Node *n, const T &t);
  void node_destruct(Node *n);
  void node_copy(Node *from, Node *to, Node *src);
  void node_destruct(Node *from, Node *to);

  bool isValidIterator(const iterator &i) const noexcept {
    const std::less<const Node *> less = {};
    return !less(i.i, cbegin().i) && !less(cend().i, i.i);
  }

private:
  inline bool op_eq_impl(const QList &other,
                         QListData::NotArrayCompatibleLayout) const;
  inline bool op_eq_impl(const QList &other,
                         QListData::ArrayCompatibleLayout) const;
  inline bool contains_impl(const T &,
                            QListData::NotArrayCompatibleLayout) const;
  inline bool contains_impl(const T &, QListData::ArrayCompatibleLayout) const;
  inline int count_impl(const T &, QListData::NotArrayCompatibleLayout) const;
  inline int count_impl(const T &, QListData::ArrayCompatibleLayout) const;
};
# 462 "/usr/local/include/QtCore/qlist.h"
template <typename T>
inline void QList<T>::node_construct(Node *n, const T &t) {
  if (QTypeInfo<T>::isLarge || QTypeInfo<T>::isStatic)
    n->v = new T(t);
  else if (QTypeInfo<T>::isComplex)
    new (n) T(t);

  else
    ::memcpy(n, static_cast<const void *>(&t), sizeof(T));
}

template <typename T> inline void QList<T>::node_destruct(Node *n) {
  if (QTypeInfo<T>::isLarge || QTypeInfo<T>::isStatic)
    delete reinterpret_cast<T *>(n->v);
  else if (QTypeInfo<T>::isComplex)
    reinterpret_cast<T *>(n)->~T();
}

template <typename T>
inline void QList<T>::node_copy(Node *from, Node *to, Node *src) {
  Node *current = from;
  if (QTypeInfo<T>::isLarge || QTypeInfo<T>::isStatic) {
    try {
      while (current != to) {
        current->v = new T(*reinterpret_cast<T *>(src->v));
        ++current;
        ++src;
      }
    } catch (...) {
      while (current-- != from)
        delete reinterpret_cast<T *>(current->v);
      throw;
    }

  } else if (QTypeInfo<T>::isComplex) {
    try {
      while (current != to) {
        new (current) T(*reinterpret_cast<T *>(src));
        ++current;
        ++src;
      }
    } catch (...) {
      while (current-- != from)
        (reinterpret_cast<T *>(current))->~T();
      throw;
    }
  } else {
    if (src != from && to - from > 0)
      memcpy(from, src, (to - from) * sizeof(Node));
  }
}

template <typename T>
inline void QList<T>::node_destruct(Node *from, Node *to) {
  if (QTypeInfo<T>::isLarge || QTypeInfo<T>::isStatic)
    while (from != to)
      --to, delete reinterpret_cast<T *>(to->v);
  else if (QTypeInfo<T>::isComplex)
    while (from != to)
      --to, reinterpret_cast<T *>(to)->~T();
}

template <typename T> inline QList<T> &QList<T>::operator=(const QList<T> &l) {
  if (d != l.d) {
    QList<T> tmp(l);
    tmp.swap(*this);
  }
  return *this;
}
template <typename T>
inline typename QList<T>::iterator QList<T>::insert(iterator before,
                                                    const T &t) {
  ((isValidIterator(before))
       ? static_cast<void>(0)
       : qt_assert_x("QList::insert",
                     "The specified iterator argument 'before' is invalid",
                     "/usr/local/include/QtCore/qlist.h", 541));

  int iBefore = int(before.i - reinterpret_cast<Node *>(p.begin()));
  Node *n = nullptr;
  if (d->ref.isShared())
    n = detach_helper_grow(iBefore, 1);
  else
    n = reinterpret_cast<Node *>(p.insert(iBefore));
  try {
    node_construct(n, t);
  } catch (...) {
    p.remove(iBefore);
    throw;
  }
  return n;
}
template <typename T>
inline typename QList<T>::iterator QList<T>::erase(iterator it) {
  ((isValidIterator(it))
       ? static_cast<void>(0)
       : qt_assert_x("QList::erase",
                     "The specified iterator argument 'it' is invalid",
                     "/usr/local/include/QtCore/qlist.h", 560));
  if (d->ref.isShared()) {
    int offset = int(it.i - reinterpret_cast<Node *>(p.begin()));
    it = begin();
    it += offset;
  }
  node_destruct(it.i);
  return reinterpret_cast<Node *>(p.erase(reinterpret_cast<void **>(it.i)));
}
template <typename T> inline const T &QList<T>::at(int i) const {
  ((i >= 0 && i < p.size())
       ? static_cast<void>(0)
       : qt_assert_x("QList<T>::at", "index out of range",
                     "/usr/local/include/QtCore/qlist.h", 571));
  return reinterpret_cast<Node *>(p.at(i))->t();
}
template <typename T> inline const T &QList<T>::operator[](int i) const {
  ((i >= 0 && i < p.size())
       ? static_cast<void>(0)
       : qt_assert_x("QList<T>::operator[]", "index out of range",
                     "/usr/local/include/QtCore/qlist.h", 575));
  return reinterpret_cast<Node *>(p.at(i))->t();
}
template <typename T> inline T &QList<T>::operator[](int i) {
  ((i >= 0 && i < p.size())
       ? static_cast<void>(0)
       : qt_assert_x("QList<T>::operator[]", "index out of range",
                     "/usr/local/include/QtCore/qlist.h", 579));
  detach();
  return reinterpret_cast<Node *>(p.at(i))->t();
}
template <typename T> inline void QList<T>::removeAt(int i) {

  if (i < 0 || i >= p.size()) {

    QMessageLogger(
        static_cast<const char *>("/usr/local/include/QtCore/qlist.h"), 589,
        static_cast<const char *>(__PRETTY_FUNCTION__))
        .warning("QList::removeAt(): Index out of range.");

    return;
  }
  detach();
  node_destruct(reinterpret_cast<Node *>(p.at(i)));
  p.remove(i);
}
template <typename T> inline T QList<T>::takeAt(int i) {
  ((i >= 0 && i < p.size())
       ? static_cast<void>(0)
       : qt_assert_x("QList<T>::take", "index out of range",
                     "/usr/local/include/QtCore/qlist.h", 598));
  detach();
  Node *n = reinterpret_cast<Node *>(p.at(i));
  T t = std::move(n->t());
  node_destruct(n);
  p.remove(i);
  return t;
}
template <typename T> inline T QList<T>::takeFirst() {
  T t = std::move(first());
  removeFirst();
  return t;
}
template <typename T> inline T QList<T>::takeLast() {
  T t = std::move(last());
  removeLast();
  return t;
}

template <typename T> void QList<T>::reserve(int alloc) {
  if (d->alloc < alloc) {
    if (d->ref.isShared())
      detach_helper(alloc);
    else
      p.realloc(alloc);
  }
}

template <typename T> void QList<T>::append(const T &t) {
  if (d->ref.isShared()) {
    Node *n = detach_helper_grow(2147483647, 1);
    try {
      node_construct(n, t);
    } catch (...) {
      --d->end;
      throw;
    }
  } else {
    if (QTypeInfo<T>::isLarge || QTypeInfo<T>::isStatic) {
      Node *n = reinterpret_cast<Node *>(p.append());
      try {
        node_construct(n, t);
      } catch (...) {
        --d->end;
        throw;
      }
    } else {
      Node *n, copy;
      node_construct(&copy, t);
      try {
        n = reinterpret_cast<Node *>(p.append());
        ;
      } catch (...) {
        node_destruct(&copy);
        throw;
      }
      *n = copy;
    }
  }
}

template <typename T> inline void QList<T>::prepend(const T &t) {
  if (d->ref.isShared()) {
    Node *n = detach_helper_grow(0, 1);
    try {
      node_construct(n, t);
    } catch (...) {
      ++d->begin;
      throw;
    }
  } else {
    if (QTypeInfo<T>::isLarge || QTypeInfo<T>::isStatic) {
      Node *n = reinterpret_cast<Node *>(p.prepend());
      try {
        node_construct(n, t);
      } catch (...) {
        ++d->begin;
        throw;
      }
    } else {
      Node *n, copy;
      node_construct(&copy, t);
      try {
        n = reinterpret_cast<Node *>(p.prepend());
        ;
      } catch (...) {
        node_destruct(&copy);
        throw;
      }
      *n = copy;
    }
  }
}

template <typename T> inline void QList<T>::insert(int i, const T &t) {

  if (i < 0 || i > p.size())
    QMessageLogger(
        static_cast<const char *>("/usr/local/include/QtCore/qlist.h"), 694,
        static_cast<const char *>(__PRETTY_FUNCTION__))
        .warning("QList::insert(): Index out of range.");

  if (d->ref.isShared()) {
    Node *n = detach_helper_grow(i, 1);
    try {
      node_construct(n, t);
    } catch (...) {
      p.remove(i);
      throw;
    }
  } else {
    if (QTypeInfo<T>::isLarge || QTypeInfo<T>::isStatic) {
      Node *n = reinterpret_cast<Node *>(p.insert(i));
      try {
        node_construct(n, t);
      } catch (...) {
        p.remove(i);
        throw;
      }
    } else {
      Node *n, copy;
      node_construct(&copy, t);
      try {
        n = reinterpret_cast<Node *>(p.insert(i));
        ;
      } catch (...) {
        node_destruct(&copy);
        throw;
      }
      *n = copy;
    }
  }
}

template <typename T> inline void QList<T>::replace(int i, const T &t) {
  ((i >= 0 && i < p.size())
       ? static_cast<void>(0)
       : qt_assert_x("QList<T>::replace", "index out of range",
                     "/usr/local/include/QtCore/qlist.h", 730));
  detach();
  reinterpret_cast<Node *>(p.at(i))->t() = t;
}

template <typename T> inline void QList<T>::swapItemsAt(int i, int j) {
  ((i >= 0 && i < p.size() && j >= 0 && j < p.size())
       ? static_cast<void>(0)
       : qt_assert_x("QList<T>::swap", "index out of range",
                     "/usr/local/include/QtCore/qlist.h", 739));

  detach();
  qSwap(d->array[d->begin + i], d->array[d->begin + j]);
}

template <typename T> inline void QList<T>::move(int from, int to) {
  ((from >= 0 && from < p.size() && to >= 0 && to < p.size())
       ? static_cast<void>(0)
       : qt_assert_x("QList<T>::move", "index out of range",
                     "/usr/local/include/QtCore/qlist.h", 748));

  detach();
  p.move(from, to);
}

template <typename T> QList<T> QList<T>::mid(int pos, int alength) const {
  using namespace QtPrivate;
  switch (QContainerImplHelper::mid(size(), &pos, &alength)) {
  case QContainerImplHelper::Null:
  case QContainerImplHelper::Empty:
    return QList<T>();
  case QContainerImplHelper::Full:
    return *this;
  case QContainerImplHelper::Subset:
    break;
  }

  QList<T> cpy;
  if (alength <= 0)
    return cpy;
  cpy.reserve(alength);
  cpy.d->end = alength;
  try {
    cpy.node_copy(reinterpret_cast<Node *>(cpy.p.begin()),
                  reinterpret_cast<Node *>(cpy.p.end()),
                  reinterpret_cast<Node *>(p.begin() + pos));
  } catch (...) {

    cpy.d->end = 0;
    throw;
  }
  return cpy;
}

template <typename T> T QList<T>::value(int i) const {
  if (i < 0 || i >= p.size()) {
    return T();
  }
  return reinterpret_cast<Node *>(p.at(i))->t();
}

template <typename T> T QList<T>::value(int i, const T &defaultValue) const {
  return ((i < 0 || i >= p.size()) ? defaultValue
                                   : reinterpret_cast<Node *>(p.at(i))->t());
}

template <typename T>
typename QList<T>::Node *QList<T>::detach_helper_grow(int i, int c) {
  Node *n = reinterpret_cast<Node *>(p.begin());
  QListData::Data *x = p.detach_grow(&i, c);
  try {
    node_copy(reinterpret_cast<Node *>(p.begin()),
              reinterpret_cast<Node *>(p.begin() + i), n);
  } catch (...) {
    p.dispose();
    d = x;
    throw;
  }
  try {
    node_copy(reinterpret_cast<Node *>(p.begin() + i + c),
              reinterpret_cast<Node *>(p.end()), n + i);
  } catch (...) {
    node_destruct(reinterpret_cast<Node *>(p.begin()),
                  reinterpret_cast<Node *>(p.begin() + i));
    p.dispose();
    d = x;
    throw;
  }

  if (!x->ref.deref())
    dealloc(x);

  return reinterpret_cast<Node *>(p.begin() + i);
}

template <typename T> void QList<T>::detach_helper(int alloc) {
  Node *n = reinterpret_cast<Node *>(p.begin());
  QListData::Data *x = p.detach(alloc);
  try {
    node_copy(reinterpret_cast<Node *>(p.begin()),
              reinterpret_cast<Node *>(p.end()), n);
  } catch (...) {
    p.dispose();
    d = x;
    throw;
  }

  if (!x->ref.deref())
    dealloc(x);
}

template <typename T> void QList<T>::detach_helper() {
  detach_helper(d->alloc);
}

template <typename T>
QList<T>::QList(const QList<T> &l) : QListSpecialMethods<T>(l), d(l.d) {
  if (!d->ref.ref()) {
    p.detach(d->alloc);

    try {
      node_copy(reinterpret_cast<Node *>(p.begin()),
                reinterpret_cast<Node *>(p.end()),
                reinterpret_cast<Node *>(l.p.begin()));
    } catch (...) {
      QListData::dispose(d);
      throw;
    }
  }
}

template <typename T> QList<T>::~QList() {
  if (!d->ref.deref())
    dealloc(d);
}

template <typename T>
template <typename InputIterator, QtPrivate::IfIsInputIterator<InputIterator>>
QList<T>::QList(InputIterator first, InputIterator last) : QList() {
  QtPrivate::reserveIfForwardIterator(this, first, last);
  std::copy(first, last, std::back_inserter(*this));
}

template <typename T> bool QList<T>::operator==(const QList<T> &l) const {
  if (d == l.d)
    return true;
  if (p.size() != l.p.size())
    return false;
  return this->op_eq_impl(l, MemoryLayout());
}

template <typename T>
inline bool QList<T>::op_eq_impl(const QList &l,
                                 QListData::NotArrayCompatibleLayout) const {
  Node *i = reinterpret_cast<Node *>(p.begin());
  Node *e = reinterpret_cast<Node *>(p.end());
  Node *li = reinterpret_cast<Node *>(l.p.begin());
  for (; i != e; ++i, ++li) {
    if (!(i->t() == li->t()))
      return false;
  }
  return true;
}

template <typename T>
inline bool QList<T>::op_eq_impl(const QList &l,
                                 QListData::ArrayCompatibleLayout) const {
  const T *lb = reinterpret_cast<const T *>(l.p.begin());
  const T *b = reinterpret_cast<const T *>(p.begin());
  const T *e = reinterpret_cast<const T *>(p.end());
  return std::equal(b, e, (lb));
}

template <typename T> void QList<T>::dealloc(QListData::Data *data) {
  node_destruct(reinterpret_cast<Node *>(data->array + data->begin),
                reinterpret_cast<Node *>(data->array + data->end));
  QListData::dispose(data);
}

template <typename T> void QList<T>::clear() { *this = QList<T>(); }

template <typename T> int QList<T>::removeAll(const T &_t) {
  int index = indexOf(_t);
  if (index == -1)
    return 0;

  const T t = _t;
  detach();

  Node *i = reinterpret_cast<Node *>(p.at(index));
  Node *e = reinterpret_cast<Node *>(p.end());
  Node *n = i;
  node_destruct(i);
  while (++i != e) {
    if (i->t() == t)
      node_destruct(i);
    else
      *n++ = *i;
  }

  int removedCount = int(e - n);
  d->end -= removedCount;
  return removedCount;
}

template <typename T> bool QList<T>::removeOne(const T &_t) {
  int index = indexOf(_t);
  if (index != -1) {
    removeAt(index);
    return true;
  }
  return false;
}

template <typename T>
typename QList<T>::iterator QList<T>::erase(typename QList<T>::iterator afirst,
                                            typename QList<T>::iterator alast) {
  ((isValidIterator(afirst))
       ? static_cast<void>(0)
       : qt_assert_x("QList::erase",
                     "The specified iterator argument 'afirst' is invalid",
                     "/usr/local/include/QtCore/qlist.h", 974));
  ((isValidIterator(alast))
       ? static_cast<void>(0)
       : qt_assert_x("QList::erase",
                     "The specified iterator argument 'alast' is invalid",
                     "/usr/local/include/QtCore/qlist.h", 975));

  if (d->ref.isShared()) {

    int offsetfirst = int(afirst.i - reinterpret_cast<Node *>(p.begin()));
    int offsetlast = int(alast.i - reinterpret_cast<Node *>(p.begin()));
    afirst = begin();
    alast = afirst;
    afirst += offsetfirst;
    alast += offsetlast;
  }

  for (Node *n = afirst.i; n < alast.i; ++n)
    node_destruct(n);
  int idx = afirst - begin();
  p.remove(idx, alast - afirst);
  return begin() + idx;
}

template <typename T> QList<T> &QList<T>::operator+=(const QList<T> &l) {
  if (!l.isEmpty()) {
    if (d == &QListData::shared_null) {
      *this = l;
    } else {
      Node *n = (d->ref.isShared()) ? detach_helper_grow(2147483647, l.size())
                                    : reinterpret_cast<Node *>(p.append(l.p));
      try {
        node_copy(n, reinterpret_cast<Node *>(p.end()),
                  reinterpret_cast<Node *>(l.p.begin()));
      } catch (...) {

        d->end -= int(reinterpret_cast<Node *>(p.end()) - n);
        throw;
      }
    }
  }
  return *this;
}

template <typename T> inline void QList<T>::append(const QList<T> &t) {
  *this += t;
}

template <typename T> int QList<T>::indexOf(const T &t, int from) const {
  return QtPrivate::indexOf<T, T>(*this, t, from);
}

namespace QtPrivate {
template <typename T, typename U>
int indexOf(const QList<T> &list, const U &u, int from) {
  typedef typename QList<T>::Node Node;

  if (from < 0)
    from = qMax(from + list.p.size(), 0);
  if (from < list.p.size()) {
    Node *n = reinterpret_cast<Node *>(list.p.at(from - 1));
    Node *e = reinterpret_cast<Node *>(list.p.end());
    while (++n != e)
      if (n->t() == u)
        return int(n - reinterpret_cast<Node *>(list.p.begin()));
  }
  return -1;
}
} // namespace QtPrivate

template <typename T> int QList<T>::lastIndexOf(const T &t, int from) const {
  return QtPrivate::lastIndexOf<T, T>(*this, t, from);
}

namespace QtPrivate {
template <typename T, typename U>
int lastIndexOf(const QList<T> &list, const U &u, int from) {
  typedef typename QList<T>::Node Node;

  if (from < 0)
    from += list.p.size();
  else if (from >= list.p.size())
    from = list.p.size() - 1;
  if (from >= 0) {
    Node *b = reinterpret_cast<Node *>(list.p.begin());
    Node *n = reinterpret_cast<Node *>(list.p.at(from + 1));
    while (n-- != b) {
      if (n->t() == u)
        return int(n - b);
    }
  }
  return -1;
}
} // namespace QtPrivate

template <typename T> bool QList<T>::contains(const T &t) const {
  return contains_impl(t, MemoryLayout());
}

template <typename T>
inline bool QList<T>::contains_impl(const T &t,
                                    QListData::NotArrayCompatibleLayout) const {
  Node *e = reinterpret_cast<Node *>(p.end());
  Node *i = reinterpret_cast<Node *>(p.begin());
  for (; i != e; ++i)
    if (i->t() == t)
      return true;
  return false;
}

template <typename T>
inline bool QList<T>::contains_impl(const T &t,
                                    QListData::ArrayCompatibleLayout) const {
  const T *b = reinterpret_cast<const T *>(p.begin());
  const T *e = reinterpret_cast<const T *>(p.end());
  return std::find(b, e, t) != e;
}

template <typename T> int QList<T>::count(const T &t) const {
  return this->count_impl(t, MemoryLayout());
}

template <typename T>
inline int QList<T>::count_impl(const T &t,
                                QListData::NotArrayCompatibleLayout) const {
  int c = 0;
  Node *e = reinterpret_cast<Node *>(p.end());
  Node *i = reinterpret_cast<Node *>(p.begin());
  for (; i != e; ++i)
    if (i->t() == t)
      ++c;
  return c;
}

template <typename T>
inline int QList<T>::count_impl(const T &t,
                                QListData::ArrayCompatibleLayout) const {
  return int(std::count(reinterpret_cast<const T *>(p.begin()),
                        reinterpret_cast<const T *>(p.end()), t));
}

template <typename T> QVector<T> QList<T>::toVector() const {
  return QVector<T>(begin(), end());
}

template <typename T> QList<T> QList<T>::fromVector(const QVector<T> &vector) {
  return vector.toList();
}

template <typename T> QList<T> QVector<T>::toList() const {
  return QList<T>(begin(), end());
}

template <typename T> QVector<T> QVector<T>::fromList(const QList<T> &list) {
  return list.toVector();
}

template <class T> class QListIterator {
  typedef typename QList<T>::const_iterator const_iterator;
  QList<T> c;
  const_iterator i;
public:
  inline QListIterator(const QList<T> &container)
      : c(container), i(c.constBegin()) {}
  inline QListIterator &operator=(const QList<T> &container) {
    c = container;
    i = c.constBegin();
    return *this;
  }
  inline void toFront() { i = c.constBegin(); }
  inline void toBack() { i = c.constEnd(); }
  inline bool hasNext() const { return i != c.constEnd(); }
  inline const T &next() { return *i++; }
  inline const T &peekNext() const { return *i; }
  inline bool hasPrevious() const { return i != c.constBegin(); }
  inline const T &previous() { return *--i; }
  inline const T &peekPrevious() const {
    const_iterator p = i;
    return *--p;
  }
  inline bool findNext(const T &t) {
    while (i != c.constEnd())
      if (*i++ == t)
        return true;
    return false;
  }
  inline bool findPrevious(const T &t) {
    while (i != c.constBegin())
      if (*(--i) == t)
        return true;
    return false;
  }
};
template <class T> class QMutableListIterator {
  typedef typename QList<T>::iterator iterator;
  typedef typename QList<T>::const_iterator const_iterator;
  QList<T> *c;
  iterator i, n;
  inline bool item_exists() const { return const_iterator(n) != c->constEnd(); }
public:
  inline QMutableListIterator(QList<T> &container) : c(&container) {
    i = c->begin();
    n = c->end();
  }
  inline QMutableListIterator &operator=(QList<T> &container) {
    c = &container;
    i = c->begin();
    n = c->end();
    return *this;
  }
  inline void toFront() {
    i = c->begin();
    n = c->end();
  }
  inline void toBack() {
    i = c->end();
    n = i;
  }
  inline bool hasNext() const { return c->constEnd() != const_iterator(i); }
  inline T &next() {
    n = i++;
    return *n;
  }
  inline T &peekNext() const { return *i; }
  inline bool hasPrevious() const {
    return c->constBegin() != const_iterator(i);
  }
  inline T &previous() {
    n = --i;
    return *n;
  }
  inline T &peekPrevious() const {
    iterator p = i;
    return *--p;
  }
  inline void remove() {
    if (c->constEnd() != const_iterator(n)) {
      i = c->erase(n);
      n = c->end();
    }
  }
  inline void setValue(const T &t) const {
    if (c->constEnd() != const_iterator(n))
      *n = t;
  }
  inline T &value() {
    ((item_exists()) ? static_cast<void>(0)
                     : qt_assert("item_exists()",
                                 "/usr/local/include/QtCore/qlist.h", 1154));
    return *n;
  }
  inline const T &value() const {
    ((item_exists()) ? static_cast<void>(0)
                     : qt_assert("item_exists()",
                                 "/usr/local/include/QtCore/qlist.h", 1154));
    return *n;
  }
  inline void insert(const T &t) {
    n = i = c->insert(i, t);
    ++i;
  }
  inline bool findNext(const T &t) {
    while (c->constEnd() != const_iterator(n = i))
      if (*i++ == t)
        return true;
    return false;
  }
  inline bool findPrevious(const T &t) {
    while (c->constBegin() != const_iterator(i))
      if (*(n = --i) == t)
        return true;
    n = c->end();
    return false;
  }
};

template <typename T>
uint qHash(const QList<T> &key,
           uint seed = 0) noexcept(noexcept(qHashRange(key.cbegin(), key.cend(),
                                                       seed))) {
  return qHashRange(key.cbegin(), key.cend(), seed);
}

template <typename T>
bool operator<(const QList<T> &lhs, const QList<T> &rhs) noexcept(
    noexcept(std::lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(),
                                          rhs.end()))) {
  return std::lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(),
                                      rhs.end());
}

template <typename T>
inline bool operator>(const QList<T> &lhs,
                      const QList<T> &rhs) noexcept(noexcept(lhs < rhs)) {
  return rhs < lhs;
}

template <typename T>
inline bool operator<=(const QList<T> &lhs,
                       const QList<T> &rhs) noexcept(noexcept(lhs < rhs)) {
  return !(lhs > rhs);
}

template <typename T>
inline bool operator>=(const QList<T> &lhs,
                       const QList<T> &rhs) noexcept(noexcept(lhs < rhs)) {
  return !(lhs < rhs);
}

# 1 "/usr/local/include/QtCore/qbytearraylist.h" 1
# 42 "/usr/local/include/QtCore/qbytearraylist.h"
# 1 "/usr/local/include/QtCore/qlist.h" 1
# 43 "/usr/local/include/QtCore/qbytearraylist.h" 2
# 52 "/usr/local/include/QtCore/qbytearraylist.h"
typedef QListIterator<QByteArray> QByteArrayListIterator;
typedef QMutableListIterator<QByteArray> QMutableByteArrayListIterator;

typedef QList<QByteArray> QByteArrayList;

namespace QtPrivate {
QByteArray __attribute__((visibility("default")))
QByteArrayList_join(const QByteArrayList *that, const char *separator,
                    int separatorLength);
int __attribute__((visibility("default")))
QByteArrayList_indexOf(const QByteArrayList *that, const char *needle,
                       int from);
} // namespace QtPrivate

template <>
struct QListSpecialMethods<QByteArray>

{

protected:
  ~QListSpecialMethods() = default;

public:
  inline QByteArray join() const {
    return QtPrivate::QByteArrayList_join(self(), nullptr, 0);
  }
  inline QByteArray join(const QByteArray &sep) const {
    return QtPrivate::QByteArrayList_join(self(), sep.constData(), sep.size());
  }
  inline QByteArray join(char sep) const {
    return QtPrivate::QByteArrayList_join(self(), &sep, 1);
  }

  inline int indexOf(const char *needle, int from = 0) const {
    return QtPrivate::QByteArrayList_indexOf(self(), needle, from);
  }

private:
  typedef QList<QByteArray> Self;
  Self *self() { return static_cast<Self *>(this); }
  const Self *self() const { return static_cast<const Self *>(this); }
};
# 1196 "/usr/local/include/QtCore/qlist.h" 2
# 1 "/usr/local/include/QtCore/qstringlist.h" 1
# 41 "/usr/local/include/QtCore/qstringlist.h"
# 1 "/usr/local/include/QtCore/qlist.h" 1
# 42 "/usr/local/include/QtCore/qstringlist.h" 2

# 1 "/usr/local/include/QtCore/qcontainertools_impl.h" 1
# 48 "/usr/local/include/QtCore/qstringlist.h" 2
# 1 "/usr/local/include/QtCore/qregexp.h" 1
# 52 "/usr/local/include/QtCore/qregexp.h"
struct QRegExpPrivate;
class QStringList;
class QRegExp;

__attribute__((visibility("default"))) uint qHash(const QRegExp &key,
                                                  uint seed = 0) noexcept;

class __attribute__((visibility("default"))) QRegExp {
public:
  enum PatternSyntax {
    RegExp,
    Wildcard,
    FixedString,
    RegExp2,
    WildcardUnix,
    W3CXmlSchema11
  };
  enum CaretMode { CaretAtZero, CaretAtOffset, CaretWontMatch };

  QRegExp();
  explicit QRegExp(const QString &pattern,
                   Qt::CaseSensitivity cs = Qt::CaseSensitive,
                   PatternSyntax syntax = RegExp);
  QRegExp(const QRegExp &rx);
  ~QRegExp();
  QRegExp &operator=(const QRegExp &rx);
  QRegExp &operator=(QRegExp &&other) noexcept {
    swap(other);
    return *this;
  }
  void swap(QRegExp &other) noexcept { qSwap(priv, other.priv); }

  bool operator==(const QRegExp &rx) const;
  inline bool operator!=(const QRegExp &rx) const { return !operator==(rx); }

  bool isEmpty() const;
  bool isValid() const;
  QString pattern() const;
  void setPattern(const QString &pattern);
  Qt::CaseSensitivity caseSensitivity() const;
  void setCaseSensitivity(Qt::CaseSensitivity cs);
  PatternSyntax patternSyntax() const;
  void setPatternSyntax(PatternSyntax syntax);

  bool isMinimal() const;
  void setMinimal(bool minimal);

  bool exactMatch(const QString &str) const;

  int indexIn(const QString &str, int offset = 0,
              CaretMode caretMode = CaretAtZero) const;
  int lastIndexIn(const QString &str, int offset = -1,
                  CaretMode caretMode = CaretAtZero) const;
  int matchedLength() const;

  int captureCount() const;
  QStringList capturedTexts() const;
  QStringList capturedTexts();
  QString cap(int nth = 0) const;
  QString cap(int nth = 0);
  int pos(int nth = 0) const;
  int pos(int nth = 0);
  QString errorString() const;
  QString errorString();

  static QString escape(const QString &str);

  friend __attribute__((visibility("default"))) uint qHash(const QRegExp &key,
                                                           uint seed) noexcept;

private:
  QRegExpPrivate *priv;
};

template <> class QTypeInfo<QRegExp> {
public:
  enum {
    isSpecialized = true,
    isComplex =
        (((Q_MOVABLE_TYPE)&Q_PRIMITIVE_TYPE) == 0) && !qIsTrivial<QRegExp>(),
    isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0),
    isRelocatable = !isStatic || ((Q_MOVABLE_TYPE)&Q_RELOCATABLE_TYPE) ||
                    qIsRelocatable<QRegExp>(),
    isLarge = (sizeof(QRegExp) > sizeof(void *)),
    isPointer = false,
    isIntegral = std::is_integral<QRegExp>::value,
    isDummy = (((Q_MOVABLE_TYPE)&Q_DUMMY_TYPE) != 0),
    sizeOf = sizeof(QRegExp)
  };
  static inline const char *name() { return "QRegExp"; }
};

__attribute__((visibility("default"))) QDataStream &
operator<<(QDataStream &out, const QRegExp &regExp);
__attribute__((visibility("default"))) QDataStream &operator>>(QDataStream &in,
                                                               QRegExp &regExp);

__attribute__((visibility("default"))) QDebug operator<<(QDebug,
                                                         const QRegExp &);
# 49 "/usr/local/include/QtCore/qstringlist.h" 2

# 1 "/usr/local/include/QtCore/qstringmatcher.h" 1
# 50 "/usr/local/include/QtCore/qstringmatcher.h"
class QStringMatcherPrivate;

class __attribute__((visibility("default"))) QStringMatcher {
public:
  QStringMatcher();
  explicit QStringMatcher(const QString &pattern,
                          Qt::CaseSensitivity cs = Qt::CaseSensitive);
  QStringMatcher(const QChar *uc, int len,
                 Qt::CaseSensitivity cs = Qt::CaseSensitive);
  QStringMatcher(QStringView pattern,
                 Qt::CaseSensitivity cs = Qt::CaseSensitive);
  QStringMatcher(const QStringMatcher &other);
  ~QStringMatcher();

  QStringMatcher &operator=(const QStringMatcher &other);

  void setPattern(const QString &pattern);
  void setCaseSensitivity(Qt::CaseSensitivity cs);

  int indexIn(const QString &str, int from = 0) const;
  int indexIn(const QChar *str, int length, int from = 0) const;
  qsizetype indexIn(QStringView str, qsizetype from = 0) const;
  QString pattern() const;
  inline Qt::CaseSensitivity caseSensitivity() const { return q_cs; }

private:
  QStringMatcherPrivate *d_ptr;
  QString q_pattern;
  Qt::CaseSensitivity q_cs;
  struct Data {
    uchar q_skiptable[256];
    const QChar *uc;
    int len;
  };
  union {
    uint q_data[256];
    Data p;
  };
};
# 51 "/usr/local/include/QtCore/qstringlist.h" 2

class QRegExp;
class QRegularExpression;

typedef QListIterator<QString> QStringListIterator;
typedef QMutableListIterator<QString> QMutableStringListIterator;

class QStringList;

template <>
struct QListSpecialMethods<QString>

{

protected:
  ~QListSpecialMethods() = default;

public:
  inline void sort(Qt::CaseSensitivity cs = Qt::CaseSensitive);
  inline int removeDuplicates();

  inline QString join(const QString &sep) const;

  inline QString join(QStringView sep) const;
  inline QString join(QLatin1String sep) const;
  inline QString join(QChar sep) const;

  inline QStringList filter(QStringView str,
                            Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
  inline QStringList &
  replaceInStrings(QStringView before, QStringView after,
                   Qt::CaseSensitivity cs = Qt::CaseSensitive);

  inline QStringList filter(const QString &str,
                            Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
  inline QStringList &
  replaceInStrings(const QString &before, const QString &after,
                   Qt::CaseSensitivity cs = Qt::CaseSensitive);
  inline QStringList &
  replaceInStrings(const QString &before, QStringView after,
                   Qt::CaseSensitivity cs = Qt::CaseSensitive);
  inline QStringList &
  replaceInStrings(QStringView before, const QString &after,
                   Qt::CaseSensitivity cs = Qt::CaseSensitive);

  inline QStringList filter(const QRegExp &rx) const;
  inline QStringList &replaceInStrings(const QRegExp &rx, const QString &after);

  inline QStringList filter(const QRegularExpression &re) const;
  inline QStringList &replaceInStrings(const QRegularExpression &re,
                                       const QString &after);

private:
  inline QStringList *self();
  inline const QStringList *self() const;
};

class QStringList : public QList<QString> {

public:
  inline QStringList() noexcept {}
  inline explicit QStringList(const QString &i) { append(i); }
  inline QStringList(const QList<QString> &l) : QList<QString>(l) {}
  inline QStringList(QList<QString> &&l) noexcept
      : QList<QString>(std::move(l)) {}
  inline QStringList(std::initializer_list<QString> args)
      : QList<QString>(args) {}
  template <typename InputIterator,
            QtPrivate::IfIsInputIterator<InputIterator> = true>
  inline QStringList(InputIterator first, InputIterator last)
      : QList<QString>(first, last) {}

  QStringList &operator=(const QList<QString> &other) {
    QList<QString>::operator=(other);
    return *this;
  }
  QStringList &operator=(QList<QString> &&other) noexcept {
    QList<QString>::operator=(std::move(other));
    return *this;
  }

  inline bool contains(const QString &str,
                       Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

  inline bool contains(QLatin1String str,
                       Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
  inline bool contains(QStringView str,
                       Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

  inline QStringList operator+(const QStringList &other) const {
    QStringList n = *this;
    n += other;
    return n;
  }
  inline QStringList &operator<<(const QString &str) {
    append(str);
    return *this;
  }
  inline QStringList &operator<<(const QStringList &l) {
    *this += l;
    return *this;
  }
  inline QStringList &operator<<(const QList<QString> &l) {
    *this += l;
    return *this;
  }

  inline int indexOf(QStringView str, int from = 0) const;
  inline int indexOf(QLatin1String str, int from = 0) const;

  inline int lastIndexOf(QStringView str, int from = -1) const;
  inline int lastIndexOf(QLatin1String str, int from = -1) const;

  inline int indexOf(const QRegExp &rx, int from = 0) const;
  inline int lastIndexOf(const QRegExp &rx, int from = -1) const;
  inline int indexOf(QRegExp &rx, int from = 0) const;
  inline int lastIndexOf(QRegExp &rx, int from = -1) const;

  inline int indexOf(const QRegularExpression &re, int from = 0) const;
  inline int lastIndexOf(const QRegularExpression &re, int from = -1) const;

  using QList<QString>::indexOf;
  using QList<QString>::lastIndexOf;
};

template <> class QTypeInfo<QStringList> {
public:
  enum {
    isSpecialized = true,
    isComplex = (((Q_MOVABLE_TYPE)&Q_PRIMITIVE_TYPE) == 0) &&
                !qIsTrivial<QStringList>(),
    isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0),
    isRelocatable = !isStatic || ((Q_MOVABLE_TYPE)&Q_RELOCATABLE_TYPE) ||
                    qIsRelocatable<QStringList>(),
    isLarge = (sizeof(QStringList) > sizeof(void *)),
    isPointer = false,
    isIntegral = std::is_integral<QStringList>::value,
    isDummy = (((Q_MOVABLE_TYPE)&Q_DUMMY_TYPE) != 0),
    sizeOf = sizeof(QStringList)
  };
  static inline const char *name() { return "QStringList"; }
};

inline QStringList *QListSpecialMethods<QString>::self() {
  return static_cast<QStringList *>(this);
}
inline const QStringList *QListSpecialMethods<QString>::self() const {
  return static_cast<const QStringList *>(this);
}

namespace QtPrivate {
void __attribute__((visibility("default")))
QStringList_sort(QStringList *that, Qt::CaseSensitivity cs);
int __attribute__((visibility("default")))
QStringList_removeDuplicates(QStringList *that);
QString __attribute__((visibility("default")))
QStringList_join(const QStringList *that, QStringView sep);
QString __attribute__((visibility("default")))
QStringList_join(const QStringList *that, const QChar *sep, int seplen);
__attribute__((visibility("default"))) QString
QStringList_join(const QStringList &list, QLatin1String sep);
QStringList __attribute__((visibility("default")))
QStringList_filter(const QStringList *that, QStringView str,
                   Qt::CaseSensitivity cs);

QStringList __attribute__((visibility("default")))
QStringList_filter(const QStringList *that, const QString &str,
                   Qt::CaseSensitivity cs);

bool __attribute__((visibility("default")))
QStringList_contains(const QStringList *that, const QString &str,
                     Qt::CaseSensitivity cs);

bool __attribute__((visibility("default")))
QStringList_contains(const QStringList *that, QStringView str,
                     Qt::CaseSensitivity cs);
bool __attribute__((visibility("default")))
QStringList_contains(const QStringList *that, QLatin1String str,
                     Qt::CaseSensitivity cs);
void __attribute__((visibility("default")))
QStringList_replaceInStrings(QStringList *that, QStringView before,
                             QStringView after, Qt::CaseSensitivity cs);

void __attribute__((visibility("default")))
QStringList_replaceInStrings(QStringList *that, const QString &before,
                             const QString &after, Qt::CaseSensitivity cs);

void __attribute__((visibility("default")))
QStringList_replaceInStrings(QStringList *that, const QRegExp &rx,
                             const QString &after);
QStringList __attribute__((visibility("default")))
QStringList_filter(const QStringList *that, const QRegExp &re);
int __attribute__((visibility("default")))
QStringList_indexOf(const QStringList *that, const QRegExp &rx, int from);
int __attribute__((visibility("default")))
QStringList_lastIndexOf(const QStringList *that, const QRegExp &rx, int from);
int __attribute__((visibility("default")))
QStringList_indexOf(const QStringList *that, QRegExp &rx, int from);
int __attribute__((visibility("default")))
QStringList_lastIndexOf(const QStringList *that, QRegExp &rx, int from);

void __attribute__((visibility("default")))
QStringList_replaceInStrings(QStringList *that, const QRegularExpression &rx,
                             const QString &after);
QStringList __attribute__((visibility("default")))
QStringList_filter(const QStringList *that, const QRegularExpression &re);
int __attribute__((visibility("default")))
QStringList_indexOf(const QStringList *that, const QRegularExpression &re,
                    int from);
int __attribute__((visibility("default")))
QStringList_lastIndexOf(const QStringList *that, const QRegularExpression &re,
                        int from);

} // namespace QtPrivate

inline void QListSpecialMethods<QString>::sort(Qt::CaseSensitivity cs) {
  QtPrivate::QStringList_sort(self(), cs);
}

inline int QListSpecialMethods<QString>::removeDuplicates() {
  return QtPrivate::QStringList_removeDuplicates(self());
}

inline QString QListSpecialMethods<QString>::join(const QString &sep) const {
  return QtPrivate::QStringList_join(self(), sep.constData(), sep.length());
}

inline QString QListSpecialMethods<QString>::join(QStringView sep) const {
  return QtPrivate::QStringList_join(self(), sep);
}

QString QListSpecialMethods<QString>::join(QLatin1String sep) const {
  return QtPrivate::QStringList_join(*self(), sep);
}

inline QString QListSpecialMethods<QString>::join(QChar sep) const {
  return QtPrivate::QStringList_join(self(), &sep, 1);
}

inline QStringList
QListSpecialMethods<QString>::filter(QStringView str,
                                     Qt::CaseSensitivity cs) const {
  return QtPrivate::QStringList_filter(self(), str, cs);
}

inline QStringList
QListSpecialMethods<QString>::filter(const QString &str,
                                     Qt::CaseSensitivity cs) const {
  return QtPrivate::QStringList_filter(self(), str, cs);
}

inline bool QStringList::contains(const QString &str,
                                  Qt::CaseSensitivity cs) const {
  return QtPrivate::QStringList_contains(this, str, cs);
}

inline bool QStringList::contains(QLatin1String str,
                                  Qt::CaseSensitivity cs) const {
  return QtPrivate::QStringList_contains(this, str, cs);
}

inline bool QStringList::contains(QStringView str,
                                  Qt::CaseSensitivity cs) const {
  return QtPrivate::QStringList_contains(this, str, cs);
}

inline QStringList &QListSpecialMethods<QString>::replaceInStrings(
    QStringView before, QStringView after, Qt::CaseSensitivity cs) {
  QtPrivate::QStringList_replaceInStrings(self(), before, after, cs);
  return *self();
}

inline QStringList &QListSpecialMethods<QString>::replaceInStrings(
    const QString &before, const QString &after, Qt::CaseSensitivity cs) {
  QtPrivate::QStringList_replaceInStrings(self(), before, after, cs);
  return *self();
}

inline QStringList &QListSpecialMethods<QString>::replaceInStrings(
    QStringView before, const QString &after, Qt::CaseSensitivity cs) {
  QtPrivate::QStringList_replaceInStrings(self(), before,
                                          qToStringViewIgnoringNull(after), cs);
  return *self();
}

inline QStringList &QListSpecialMethods<QString>::replaceInStrings(
    const QString &before, QStringView after, Qt::CaseSensitivity cs) {
  QtPrivate::QStringList_replaceInStrings(self(), QStringView(before), after,
                                          cs);
  return *self();
}

inline QStringList operator+(const QList<QString> &one,
                             const QStringList &other) {
  QStringList n = one;
  n += other;
  return n;
}

inline int QStringList::indexOf(QStringView string, int from) const {
  return QtPrivate::indexOf<QString, QStringView>(*this, string, from);
}

inline int QStringList::indexOf(QLatin1String string, int from) const {
  return QtPrivate::indexOf<QString, QLatin1String>(*this, string, from);
}

inline int QStringList::lastIndexOf(QStringView string, int from) const {
  return QtPrivate::lastIndexOf<QString, QStringView>(*this, string, from);
}

inline int QStringList::lastIndexOf(QLatin1String string, int from) const {
  return QtPrivate::lastIndexOf<QString, QLatin1String>(*this, string, from);
}

inline QStringList &
QListSpecialMethods<QString>::replaceInStrings(const QRegExp &rx,
                                               const QString &after) {
  QtPrivate::QStringList_replaceInStrings(self(), rx, after);
  return *self();
}

inline QStringList
QListSpecialMethods<QString>::filter(const QRegExp &rx) const {
  return QtPrivate::QStringList_filter(self(), rx);
}

inline int QStringList::indexOf(const QRegExp &rx, int from) const {
  return QtPrivate::QStringList_indexOf(this, rx, from);
}

inline int QStringList::lastIndexOf(const QRegExp &rx, int from) const {
  return QtPrivate::QStringList_lastIndexOf(this, rx, from);
}

inline int QStringList::indexOf(QRegExp &rx, int from) const {
  return QtPrivate::QStringList_indexOf(this, rx, from);
}

inline int QStringList::lastIndexOf(QRegExp &rx, int from) const {
  return QtPrivate::QStringList_lastIndexOf(this, rx, from);
}

inline QStringList &
QListSpecialMethods<QString>::replaceInStrings(const QRegularExpression &rx,
                                               const QString &after) {
  QtPrivate::QStringList_replaceInStrings(self(), rx, after);
  return *self();
}

inline QStringList
QListSpecialMethods<QString>::filter(const QRegularExpression &rx) const {
  return QtPrivate::QStringList_filter(self(), rx);
}

inline int QStringList::indexOf(const QRegularExpression &rx, int from) const {
  return QtPrivate::QStringList_indexOf(this, rx, from);
}

inline int QStringList::lastIndexOf(const QRegularExpression &rx,
                                    int from) const {
  return QtPrivate::QStringList_lastIndexOf(this, rx, from);
}
# 1197 "/usr/local/include/QtCore/qlist.h" 2
# 50 "/usr/local//include/QtCore/qobject.h" 2

# 1 "/usr/local/include/QtCore/qscopedpointer.h" 1
# 45 "/usr/local/include/QtCore/qscopedpointer.h"
# 1 "/Applications/apps/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/stdlib.h" 1 3
# 46 "/usr/local/include/QtCore/qscopedpointer.h" 2

template <typename T> struct QScopedPointerDeleter {
  static inline void cleanup(T *pointer) {

    typedef char IsIncompleteType[sizeof(T) ? 1 : -1];
    (void)sizeof(IsIncompleteType);

    delete pointer;
  }
};

template <typename T> struct QScopedPointerArrayDeleter {
  static inline void cleanup(T *pointer) {

    typedef char IsIncompleteType[sizeof(T) ? 1 : -1];
    (void)sizeof(IsIncompleteType);

    delete[] pointer;
  }
};

struct QScopedPointerPodDeleter {
  static inline void cleanup(void *pointer) {
    if (pointer)
      free(pointer);
  }
};

template <typename T> struct QScopedPointerObjectDeleteLater {
  static inline void cleanup(T *pointer) {
    if (pointer)
      pointer->deleteLater();
  }
};

class QObject;
typedef QScopedPointerObjectDeleteLater<QObject> QScopedPointerDeleteLater;

template <typename T, typename Cleanup = QScopedPointerDeleter<T>>
class QScopedPointer {
  typedef T *QScopedPointer::*RestrictedBool;

public:
  explicit QScopedPointer(T *p = nullptr) noexcept : d(p) {}

  inline ~QScopedPointer() {
    T *oldD = this->d;
    Cleanup::cleanup(oldD);
  }

  inline T &operator*() const {
    ((d) ? static_cast<void>(0)
         : qt_assert("d", "/usr/local/include/QtCore/qscopedpointer.h", 112));
    return *d;
  }

  T *operator->() const noexcept { return d; }

  bool operator!() const noexcept { return !d; }

  operator RestrictedBool() const noexcept {
    return isNull() ? nullptr : &QScopedPointer::d;
  }

  T *data() const noexcept { return d; }

  T *get() const noexcept { return d; }

  bool isNull() const noexcept { return !d; }

  void reset(T *other = nullptr) noexcept(
      noexcept(Cleanup::cleanup(std::declval<T *>()))) {
    if (d == other)
      return;
    T *oldD = d;
    d = other;
    Cleanup::cleanup(oldD);
  }

  T *take() noexcept {
    T *oldD = d;
    d = nullptr;
    return oldD;
  }

  void swap(QScopedPointer<T, Cleanup> &other) noexcept { qSwap(d, other.d); }

  typedef T *pointer;

protected:
  T *d;

private:
  QScopedPointer(const QScopedPointer &) = delete;
  QScopedPointer &operator=(const QScopedPointer &) = delete;
};

template <class T, class Cleanup>
inline bool operator==(const QScopedPointer<T, Cleanup> &lhs,
                       const QScopedPointer<T, Cleanup> &rhs) noexcept {
  return lhs.data() == rhs.data();
}

template <class T, class Cleanup>
inline bool operator!=(const QScopedPointer<T, Cleanup> &lhs,
                       const QScopedPointer<T, Cleanup> &rhs) noexcept {
  return lhs.data() != rhs.data();
}

template <class T, class Cleanup>
inline bool operator==(const QScopedPointer<T, Cleanup> &lhs,
                       std::nullptr_t) noexcept {
  return lhs.isNull();
}

template <class T, class Cleanup>
inline bool operator==(std::nullptr_t,
                       const QScopedPointer<T, Cleanup> &rhs) noexcept {
  return rhs.isNull();
}

template <class T, class Cleanup>
inline bool operator!=(const QScopedPointer<T, Cleanup> &lhs,
                       std::nullptr_t) noexcept {
  return !lhs.isNull();
}

template <class T, class Cleanup>
inline bool operator!=(std::nullptr_t,
                       const QScopedPointer<T, Cleanup> &rhs) noexcept {
  return !rhs.isNull();
}

template <class T, class Cleanup>
inline void swap(QScopedPointer<T, Cleanup> &p1,
                 QScopedPointer<T, Cleanup> &p2) noexcept {
  p1.swap(p2);
}

template <typename T, typename Cleanup = QScopedPointerArrayDeleter<T>>
class QScopedArrayPointer : public QScopedPointer<T, Cleanup> {
  template <typename Ptr>
  using if_same_type = typename std::enable_if<
      std::is_same<typename std::remove_cv<T>::type, Ptr>::value, bool>::type;

public:
  inline QScopedArrayPointer() : QScopedPointer<T, Cleanup>(nullptr) {}

  template <typename D, if_same_type<D> = true>
  explicit QScopedArrayPointer(D *p) : QScopedPointer<T, Cleanup>(p) {}

  inline T &operator[](int i) { return this->d[i]; }

  inline const T &operator[](int i) const { return this->d[i]; }

  void swap(QScopedArrayPointer &other) noexcept {
    QScopedPointer<T, Cleanup>::swap(other);
  }

private:
  explicit inline QScopedArrayPointer(void *){
# 260 "/usr/local/include/QtCore/qscopedpointer.h"
  }

  QScopedArrayPointer(const QScopedArrayPointer &) = delete;
  QScopedArrayPointer &operator=(const QScopedArrayPointer &) = delete;
};

template <typename T, typename Cleanup>
inline void swap(QScopedArrayPointer<T, Cleanup> &lhs,
                 QScopedArrayPointer<T, Cleanup> &rhs) noexcept {
  lhs.swap(rhs);
}
# 54 "/usr/local//include/QtCore/qobject.h" 2

# 1 "/usr/local/include/QtCore/qobject_impl.h" 1
# 54 "/usr/local/include/QtCore/qobject_impl.h"
namespace QtPrivate {
# 65 "/usr/local/include/QtCore/qobject_impl.h"
template <typename ArgList> struct TypesAreDeclaredMetaType {
  enum { Value = false };
};
template <> struct TypesAreDeclaredMetaType<List<>> {
  enum { Value = true };
};
template <typename Arg, typename... Tail>
struct TypesAreDeclaredMetaType<List<Arg, Tail...>> {
  enum {
    Value = QMetaTypeId2<Arg>::Defined &&
            TypesAreDeclaredMetaType<List<Tail...>>::Value
  };
};

template <typename ArgList,
          bool Declared = TypesAreDeclaredMetaType<ArgList>::Value>
struct ConnectionTypes {
  static const int *types() { return nullptr; }
};
template <> struct ConnectionTypes<List<>, true> {
  static const int *types() { return nullptr; }
};
template <typename... Args> struct ConnectionTypes<List<Args...>, true> {
  static const int *types() {
    static const int t[sizeof...(Args) + 1] = {
        (QtPrivate::QMetaTypeIdHelper<Args>::qt_metatype_id())..., 0};
    return t;
  }
};

template <typename Func, typename Args, typename R>
class QStaticSlotObject : public QSlotObjectBase {
  typedef QtPrivate::FunctionPointer<Func> FuncType;
  Func function;
  static void impl(int which, QSlotObjectBase *this_, QObject *r, void **a,
                   bool *ret) {
    switch (which) {
    case Destroy:
      delete static_cast<QStaticSlotObject *>(this_);
      break;
    case Call:
      FuncType::template call<Args, R>(
          static_cast<QStaticSlotObject *>(this_)->function, r, a);
      break;
    case Compare:
    case NumOperations:
      (void)ret;
      ;
    }
  }

public:
  explicit QStaticSlotObject(Func f) : QSlotObjectBase(&impl), function(f) {}
};
} // namespace QtPrivate
# 57 "/usr/local//include/QtCore/qobject.h" 2

class QEvent;
class QTimerEvent;
class QChildEvent;
struct QMetaObject;
class QVariant;
class QObjectPrivate;
class QObject;
class QThread;
class QWidget;
class QAccessibleWidget;

class QRegExp;

class QRegularExpression;

class QObjectUserData;

struct QDynamicMetaObjectData;

typedef QList<QObject *> QObjectList;

__attribute__((visibility("default"))) void
qt_qFindChildren_helper(const QObject *parent, const QString &name,
                        const QMetaObject &mo, QList<void *> *list,
                        Qt::FindChildOptions options);
__attribute__((visibility("default"))) void
qt_qFindChildren_helper(const QObject *parent, const QRegExp &re,
                        const QMetaObject &mo, QList<void *> *list,
                        Qt::FindChildOptions options);
__attribute__((visibility("default"))) void
qt_qFindChildren_helper(const QObject *parent, const QRegularExpression &re,
                        const QMetaObject &mo, QList<void *> *list,
                        Qt::FindChildOptions options);
__attribute__((visibility("default"))) QObject *
qt_qFindChild_helper(const QObject *parent, const QString &name,
                     const QMetaObject &mo, Qt::FindChildOptions options);

class __attribute__((visibility("default"))) QObjectData {
  QObjectData(const QObjectData &) = delete;
  QObjectData &operator=(const QObjectData &) = delete;

public:
  QObjectData() = default;
  virtual ~QObjectData() = 0;
  QObject *q_ptr;
  QObject *parent;
  QObjectList children;

  uint isWidget : 1;
  uint blockSig : 1;
  uint wasDeleted : 1;
  uint isDeletingChildren : 1;
  uint sendChildEvents : 1;
  uint receiveChildEvents : 1;
  uint isWindow : 1;
  uint deleteLaterCalled : 1;
  uint unused : 24;
  int postedEvents;
  QDynamicMetaObjectData *metaObject;
  QMetaObject *dynamicMetaObject() const;

  enum { CheckForParentChildLoopsWarnDepth = 4096 };
};

class __attribute__((visibility("default"))) QObject {
public:
# 129 "/usr/local//include/QtCore/qobject.h"
#pragma clang diagnostic push
# 129 "/usr/local//include/QtCore/qobject.h"
#pragma clang diagnostic ignored "-Winconsistent-missing-override"
# 129 "/usr/local//include/QtCore/qobject.h"
  static const QMetaObject staticMetaObject;
  virtual const QMetaObject *metaObject() const;
  virtual void *qt_metacast(const char *);
  virtual int qt_metacall(QMetaObject::Call, int, void **);
  static inline QString tr(const char *s, const char *c = nullptr, int n = -1) {
    return staticMetaObject.tr(s, c, n);
  }
  __attribute__((__deprecated__)) static inline QString
  trUtf8(const char *s, const char *c = nullptr, int n = -1) {
    return staticMetaObject.tr(s, c, n);
  }
private:
  __attribute__((visibility("hidden"))) static void
  qt_static_metacall(QObject *, QMetaObject::Call, int, void **);
# 129 "/usr/local//include/QtCore/qobject.h"
#pragma clang diagnostic pop
# 129 "/usr/local//include/QtCore/qobject.h"
  struct QPrivateSignal {};

  inline QObjectPrivate *d_func() {
# 132 "/usr/local//include/QtCore/qobject.h"
#pragma clang diagnostic push
# 132 "/usr/local//include/QtCore/qobject.h"
    return reinterpret_cast<QObjectPrivate *>(qGetPtrHelper(d_ptr));
# 132 "/usr/local//include/QtCore/qobject.h"
#pragma clang diagnostic pop
# 132 "/usr/local//include/QtCore/qobject.h"
  }
  inline const QObjectPrivate *d_func() const {
# 132 "/usr/local//include/QtCore/qobject.h"
#pragma clang diagnostic push
# 132 "/usr/local//include/QtCore/qobject.h"
    return reinterpret_cast<const QObjectPrivate *>(qGetPtrHelper(d_ptr));
# 132 "/usr/local//include/QtCore/qobject.h"
#pragma clang diagnostic pop
# 132 "/usr/local//include/QtCore/qobject.h"
  }
  friend class QObjectPrivate;

public:
  explicit QObject(QObject *parent = nullptr);
  virtual ~QObject();

  virtual bool event(QEvent *event);
  virtual bool eventFilter(QObject *watched, QEvent *event);
# 150 "/usr/local//include/QtCore/qobject.h"
  QString objectName() const;
  void setObjectName(const QString &name);

  inline bool isWidgetType() const { return d_ptr->isWidget; }
  inline bool isWindowType() const { return d_ptr->isWindow; }

  inline bool signalsBlocked() const noexcept { return d_ptr->blockSig; }
  bool blockSignals(bool b) noexcept;

  QThread *thread() const;
  void moveToThread(QThread *thread);

  int startTimer(int interval, Qt::TimerType timerType = Qt::CoarseTimer);

  inline __attribute__((always_inline)) int
  startTimer(std::chrono::milliseconds time,
             Qt::TimerType timerType = Qt::CoarseTimer) {
    return startTimer(int(time.count()), timerType);
  }

  void killTimer(int id);

  template <typename T>
  inline T
  findChild(const QString &aName = QString(),
            Qt::FindChildOptions options = Qt::FindChildrenRecursively) const {
    typedef typename std::remove_cv<typename std::remove_pointer<T>::type>::type
        ObjType;
    return static_cast<T>(
        qt_qFindChild_helper(this, aName, ObjType::staticMetaObject, options));
  }

  template <typename T>
  inline QList<T> findChildren(
      const QString &aName = QString(),
      Qt::FindChildOptions options = Qt::FindChildrenRecursively) const {
    typedef typename std::remove_cv<typename std::remove_pointer<T>::type>::type
        ObjType;
    QList<T> list;
    qt_qFindChildren_helper(this, aName, ObjType::staticMetaObject,
                            reinterpret_cast<QList<void *> *>(&list), options);
    return list;
  }

  template <typename T>
  __attribute__((__deprecated__("Use findChildren(const QRegularExpression &, "
                                "...) instead."))) inline QList<T>
  findChildren(const QRegExp &re, Qt::FindChildOptions options =
                                      Qt::FindChildrenRecursively) const {
    typedef typename std::remove_cv<typename std::remove_pointer<T>::type>::type
        ObjType;
    QList<T> list;
    qt_qFindChildren_helper(this, re, ObjType::staticMetaObject,
                            reinterpret_cast<QList<void *> *>(&list), options);
    return list;
  }

  template <typename T>
  inline QList<T> findChildren(
      const QRegularExpression &re,
      Qt::FindChildOptions options = Qt::FindChildrenRecursively) const {
    typedef typename std::remove_cv<typename std::remove_pointer<T>::type>::type
        ObjType;
    QList<T> list;
    qt_qFindChildren_helper(this, re, ObjType::staticMetaObject,
                            reinterpret_cast<QList<void *> *>(&list), options);
    return list;
  }

  inline const QObjectList &children() const { return d_ptr->children; }

  void setParent(QObject *parent);
  void installEventFilter(QObject *filterObj);
  void removeEventFilter(QObject *obj);

  static QMetaObject::Connection
  connect(const QObject *sender, const char *signal, const QObject *receiver,
          const char *member, Qt::ConnectionType = Qt::AutoConnection);

  static QMetaObject::Connection
  connect(const QObject *sender, const QMetaMethod &signal,
          const QObject *receiver, const QMetaMethod &method,
          Qt::ConnectionType type = Qt::AutoConnection);

  inline QMetaObject::Connection
  connect(const QObject *sender, const char *signal, const char *member,
          Qt::ConnectionType type = Qt::AutoConnection) const;
# 241 "/usr/local//include/QtCore/qobject.h"
  template <typename Func1, typename Func2>
  static inline QMetaObject::Connection
  connect(const typename QtPrivate::FunctionPointer<Func1>::Object *sender,
          Func1 signal,
          const typename QtPrivate::FunctionPointer<Func2>::Object *receiver,
          Func2 slot, Qt::ConnectionType type = Qt::AutoConnection) {
    typedef QtPrivate::FunctionPointer<Func1> SignalType;
    typedef QtPrivate::FunctionPointer<Func2> SlotType;

    static_assert(
        bool(QtPrivate::HasQ_OBJECT_Macro<typename SignalType::Object>::Value),
        "No Q_OBJECT in the class with the signal");

    static_assert(
        bool(int(SignalType::ArgumentCount) >= int(SlotType::ArgumentCount)),
        "The slot requires more arguments than the signal provides.");

    static_assert(bool((QtPrivate::CheckCompatibleArguments<
                        typename SignalType::Arguments,
                        typename SlotType::Arguments>::value)),
                  "Signal and slot arguments are not compatible.");

    static_assert(bool((QtPrivate::AreArgumentsCompatible<
                        typename SlotType::ReturnType,
                        typename SignalType::ReturnType>::value)),
                  "Return type of the slot is not compatible with the return "
                  "type of the signal.");

    const int *types = nullptr;
    if (type == Qt::QueuedConnection || type == Qt::BlockingQueuedConnection)
      types =
          QtPrivate::ConnectionTypes<typename SignalType::Arguments>::types();

    return connectImpl(
        sender, reinterpret_cast<void **>(&signal), receiver,
        reinterpret_cast<void **>(&slot),
        new QtPrivate::QSlotObject<
            Func2,
            typename QtPrivate::List_Left<typename SignalType::Arguments,
                                          SlotType::ArgumentCount>::Value,
            typename SignalType::ReturnType>(slot),
        type, types, &SignalType::Object::staticMetaObject);
  }

  template <typename Func1, typename Func2>
  static inline typename std::enable_if<
      int(QtPrivate::FunctionPointer<Func2>::ArgumentCount) >= 0,
      QMetaObject::Connection>::type
  connect(const typename QtPrivate::FunctionPointer<Func1>::Object *sender,
          Func1 signal, Func2 slot) {
    return connect(sender, signal, sender, slot, Qt::DirectConnection);
  }

  template <typename Func1, typename Func2>
  static inline typename std::enable_if<
      int(QtPrivate::FunctionPointer<Func2>::ArgumentCount) >= 0 &&
          !QtPrivate::FunctionPointer<Func2>::IsPointerToMemberFunction,
      QMetaObject::Connection>::type
  connect(const typename QtPrivate::FunctionPointer<Func1>::Object *sender,
          Func1 signal, const QObject *context, Func2 slot,
          Qt::ConnectionType type = Qt::AutoConnection) {
    typedef QtPrivate::FunctionPointer<Func1> SignalType;
    typedef QtPrivate::FunctionPointer<Func2> SlotType;

    static_assert(
        bool(QtPrivate::HasQ_OBJECT_Macro<typename SignalType::Object>::Value),
        "No Q_OBJECT in the class with the signal");

    static_assert(
        bool(int(SignalType::ArgumentCount) >= int(SlotType::ArgumentCount)),
        "The slot requires more arguments than the signal provides.");

    static_assert(bool((QtPrivate::CheckCompatibleArguments<
                        typename SignalType::Arguments,
                        typename SlotType::Arguments>::value)),
                  "Signal and slot arguments are not compatible.");

    static_assert(bool((QtPrivate::AreArgumentsCompatible<
                        typename SlotType::ReturnType,
                        typename SignalType::ReturnType>::value)),
                  "Return type of the slot is not compatible with the return "
                  "type of the signal.");

    const int *types = nullptr;
    if (type == Qt::QueuedConnection || type == Qt::BlockingQueuedConnection)
      types =
          QtPrivate::ConnectionTypes<typename SignalType::Arguments>::types();

    return connectImpl(
        sender, reinterpret_cast<void **>(&signal), context, nullptr,
        new QtPrivate::QStaticSlotObject<
            Func2,
            typename QtPrivate::List_Left<typename SignalType::Arguments,
                                          SlotType::ArgumentCount>::Value,
            typename SignalType::ReturnType>(slot),
        type, types, &SignalType::Object::staticMetaObject);
  }

  template <typename Func1, typename Func2>
  static inline typename std::enable_if<
      QtPrivate::FunctionPointer<Func2>::ArgumentCount == -1,
      QMetaObject::Connection>::type
  connect(const typename QtPrivate::FunctionPointer<Func1>::Object *sender,
          Func1 signal, Func2 slot) {
    return connect(sender, signal, sender, std::move(slot),
                   Qt::DirectConnection);
  }

  template <typename Func1, typename Func2>
  static inline typename std::enable_if<
      QtPrivate::FunctionPointer<Func2>::ArgumentCount == -1,
      QMetaObject::Connection>::type
  connect(const typename QtPrivate::FunctionPointer<Func1>::Object *sender,
          Func1 signal, const QObject *context, Func2 slot,
          Qt::ConnectionType type = Qt::AutoConnection) {
    typedef QtPrivate::FunctionPointer<Func1> SignalType;
    const int FunctorArgumentCount = QtPrivate::ComputeFunctorArgumentCount<
        Func2, typename SignalType::Arguments>::Value;

    static_assert(bool((FunctorArgumentCount >= 0)),
                  "Signal and slot arguments are not compatible.");

    const int SlotArgumentCount =
        (FunctorArgumentCount >= 0) ? FunctorArgumentCount : 0;
    typedef typename QtPrivate::FunctorReturnType<
        Func2, typename QtPrivate::List_Left<typename SignalType::Arguments,
                                             SlotArgumentCount>::Value>::Value
        SlotReturnType;

    static_assert(
        bool((QtPrivate::AreArgumentsCompatible<
              SlotReturnType, typename SignalType::ReturnType>::value)),
        "Return type of the slot is not compatible with the return type of the "
        "signal.");

    static_assert(
        bool(QtPrivate::HasQ_OBJECT_Macro<typename SignalType::Object>::Value),
        "No Q_OBJECT in the class with the signal");

    const int *types = nullptr;
    if (type == Qt::QueuedConnection || type == Qt::BlockingQueuedConnection)
      types =
          QtPrivate::ConnectionTypes<typename SignalType::Arguments>::types();

    return connectImpl(
        sender, reinterpret_cast<void **>(&signal), context, nullptr,
        new QtPrivate::QFunctorSlotObject<
            Func2, SlotArgumentCount,
            typename QtPrivate::List_Left<typename SignalType::Arguments,
                                          SlotArgumentCount>::Value,
            typename SignalType::ReturnType>(std::move(slot)),
        type, types, &SignalType::Object::staticMetaObject);
  }

  static bool disconnect(const QObject *sender, const char *signal,
                         const QObject *receiver, const char *member);
  static bool disconnect(const QObject *sender, const QMetaMethod &signal,
                         const QObject *receiver, const QMetaMethod &member);
  inline bool disconnect(const char *signal = nullptr,
                         const QObject *receiver = nullptr,
                         const char *member = nullptr) const {
    return disconnect(this, signal, receiver, member);
  }
  inline bool disconnect(const QObject *receiver,
                         const char *member = nullptr) const {
    return disconnect(this, nullptr, receiver, member);
  }
  static bool disconnect(const QMetaObject::Connection &);

  template <typename Func1, typename Func2>
  static inline bool
  disconnect(const typename QtPrivate::FunctionPointer<Func1>::Object *sender,
             Func1 signal,
             const typename QtPrivate::FunctionPointer<Func2>::Object *receiver,
             Func2 slot) {
    typedef QtPrivate::FunctionPointer<Func1> SignalType;
    typedef QtPrivate::FunctionPointer<Func2> SlotType;

    static_assert(
        bool(QtPrivate::HasQ_OBJECT_Macro<typename SignalType::Object>::Value),
        "No Q_OBJECT in the class with the signal");

    static_assert(bool((QtPrivate::CheckCompatibleArguments<
                        typename SignalType::Arguments,
                        typename SlotType::Arguments>::value)),
                  "Signal and slot arguments are not compatible.");

    return disconnectImpl(sender, reinterpret_cast<void **>(&signal), receiver,
                          reinterpret_cast<void **>(&slot),
                          &SignalType::Object::staticMetaObject);
  }
  template <typename Func1>
  static inline bool
  disconnect(const typename QtPrivate::FunctionPointer<Func1>::Object *sender,
             Func1 signal, const QObject *receiver, void **zero) {

    ((!zero) ? static_cast<void>(0)
             : qt_assert("!zero", "/usr/local//include/QtCore/qobject.h", 390));
    typedef QtPrivate::FunctionPointer<Func1> SignalType;
    return disconnectImpl(sender, reinterpret_cast<void **>(&signal), receiver,
                          zero, &SignalType::Object::staticMetaObject);
  }

  void dumpObjectTree();
  void dumpObjectInfo();

  void dumpObjectTree() const;
  void dumpObjectInfo() const;

  bool setProperty(const char *name, const QVariant &value);
  QVariant property(const char *name) const;
  QList<QByteArray> dynamicPropertyNames() const;

  __attribute__((__deprecated__)) static uint registerUserData();
  __attribute__((__deprecated__("Use setProperty()"))) void
  setUserData(uint id, QObjectUserData *data);
  __attribute__((__deprecated__("Use property()"))) QObjectUserData *
  userData(uint id) const;

public:
  void destroyed(QObject * = nullptr);
  void objectNameChanged(const QString &objectName, QPrivateSignal);

public:
  inline QObject *parent() const { return d_ptr->parent; }

  inline bool inherits(const char *classname) const {
    return const_cast<QObject *>(this)->qt_metacast(classname) != nullptr;
  }

public:
  void deleteLater();

protected:
  QObject *sender() const;
  int senderSignalIndex() const;
  int receivers(const char *signal) const;
  bool isSignalConnected(const QMetaMethod &signal) const;

  virtual void timerEvent(QTimerEvent *event);
  virtual void childEvent(QChildEvent *event);
  virtual void customEvent(QEvent *event);

  virtual void connectNotify(const QMetaMethod &signal);
  virtual void disconnectNotify(const QMetaMethod &signal);

protected:
  QObject(QObjectPrivate &dd, QObject *parent = nullptr);

protected:
  QScopedPointer<QObjectData> d_ptr;

  static const QMetaObject staticQtMetaObject;
  friend inline const QMetaObject *qt_getQtMetaObject() noexcept;

  friend struct QMetaObject;
  friend struct QMetaObjectPrivate;
  friend class QMetaCallEvent;
  friend class QApplication;
  friend class QApplicationPrivate;
  friend class QCoreApplication;
  friend class QCoreApplicationPrivate;
  friend class QWidget;
  friend class QAccessibleWidget;
  friend class QThreadData;

private:
  QObject(const QObject &) = delete;
  QObject &operator=(const QObject &) = delete;

private:
  static QMetaObject::Connection
  connectImpl(const QObject *sender, void **signal, const QObject *receiver,
              void **slotPtr, QtPrivate::QSlotObjectBase *slot,
              Qt::ConnectionType type, const int *types,
              const QMetaObject *senderMetaObject);

  static bool disconnectImpl(const QObject *sender, void **signal,
                             const QObject *receiver, void **slot,
                             const QMetaObject *senderMetaObject);
};

inline QMetaObject::Connection
QObject::connect(const QObject *asender, const char *asignal,
                 const char *amember, Qt::ConnectionType atype) const {
  return connect(asender, asignal, this, amember, atype);
}

inline const QMetaObject *qt_getQtMetaObject() noexcept {
  return &QObject::staticQtMetaObject;
}

class __attribute__((visibility("default"))) QObjectUserData {
  QObjectUserData(const QObjectUserData &) = delete;
  QObjectUserData &operator=(const QObjectUserData &) = delete;

public:
  QObjectUserData() = default;
  virtual ~QObjectUserData();
};
# 518 "/usr/local//include/QtCore/qobject.h"
template <class T> inline T qobject_cast(QObject *object) {
  typedef typename std::remove_cv<typename std::remove_pointer<T>::type>::type
      ObjType;
  static_assert(bool(QtPrivate::HasQ_OBJECT_Macro<ObjType>::Value),
                "qobject_cast requires the type to have a Q_OBJECT macro");

  return static_cast<T>(ObjType::staticMetaObject.cast(object));
}

template <class T> inline T qobject_cast(const QObject *object) {
  typedef typename std::remove_cv<typename std::remove_pointer<T>::type>::type
      ObjType;
  static_assert(bool(QtPrivate::HasQ_OBJECT_Macro<ObjType>::Value),
                "qobject_cast requires the type to have a Q_OBJECT macro");

  return static_cast<T>(ObjType::staticMetaObject.cast(object));
}

template <class T> inline const char *qobject_interface_iid() {
  return nullptr;
}
# 554 "/usr/local//include/QtCore/qobject.h"
__attribute__((visibility("default"))) QDebug operator<<(QDebug,
                                                         const QObject *);

class QSignalBlocker {
public:
  inline explicit QSignalBlocker(QObject *o) noexcept;
  inline explicit QSignalBlocker(QObject &o) noexcept;
  inline ~QSignalBlocker();

  inline QSignalBlocker(QSignalBlocker &&other) noexcept;
  inline QSignalBlocker &operator=(QSignalBlocker &&other) noexcept;

  inline void reblock() noexcept;
  inline void unblock() noexcept;

private:
  QSignalBlocker(const QSignalBlocker &) = delete;
  QSignalBlocker &operator=(const QSignalBlocker &) = delete;
  QObject *m_o;
  bool m_blocked;
  bool m_inhibited;
};

QSignalBlocker::QSignalBlocker(QObject *o) noexcept
    : m_o(o), m_blocked(o && o->blockSignals(true)), m_inhibited(false) {}

QSignalBlocker::QSignalBlocker(QObject &o) noexcept
    : m_o(&o), m_blocked(o.blockSignals(true)), m_inhibited(false) {}

QSignalBlocker::QSignalBlocker(QSignalBlocker &&other) noexcept
    : m_o(other.m_o), m_blocked(other.m_blocked),
      m_inhibited(other.m_inhibited) {
  other.m_o = nullptr;
}

QSignalBlocker &QSignalBlocker::operator=(QSignalBlocker &&other) noexcept {
  if (this != &other) {

    if (m_o != other.m_o || (!m_inhibited && other.m_inhibited))
      unblock();
    m_o = other.m_o;
    m_blocked = other.m_blocked;
    m_inhibited = other.m_inhibited;

    other.m_o = nullptr;
  }
  return *this;
}

QSignalBlocker::~QSignalBlocker() {
  if (m_o && !m_inhibited)
    m_o->blockSignals(m_blocked);
}

void QSignalBlocker::reblock() noexcept {
  if (m_o)
    m_o->blockSignals(true);
  m_inhibited = false;
}

void QSignalBlocker::unblock() noexcept {
  if (m_o)
    m_o->blockSignals(m_blocked);
  m_inhibited = true;
}

namespace QtPrivate {
inline QObject &deref_for_methodcall(QObject &o) { return o; }
inline QObject &deref_for_methodcall(QObject *o) { return *o; }
} // namespace QtPrivate
# 2 "/usr/local//include/QtCore/QObject" 2
# 28 "./example.h" 2

class MyObject : public QObject {

  using W_ThisType = MyObject;
  static constexpr auto W_UnscopedName = w_internal::viewLiteral("MyObject");
  friend struct w_internal::FriendHelper;
  template <typename W_Flag> static inline constexpr int w_flagAlias(W_Flag) {
    return 0;
  }
public:
  struct W_MetaObjectCreatorHelper;
public:
  using W_BaseType = std::remove_reference_t<decltype(
      w_internal::getParentObjectHelper(&W_ThisType::qt_metacast))>;
public:
# 35 "./example.h"
#pragma clang diagnostic push
# 35 "./example.h"
#pragma clang diagnostic ignored "-Winconsistent-missing-override"
# 35 "./example.h"
  static const QMetaObject staticMetaObject;
  virtual const QMetaObject *metaObject() const;
  virtual void *qt_metacast(const char *);
  virtual int qt_metacall(QMetaObject::Call, int, void **);
  static inline QString tr(const char *s, const char *c = nullptr, int n = -1) {
    return staticMetaObject.tr(s, c, n);
  }
  __attribute__((__deprecated__)) static inline QString
  trUtf8(const char *s, const char *c = nullptr, int n = -1) {
    return staticMetaObject.tr(s, c, n);
  }
private:
  __attribute__((visibility("hidden"))) static void
  qt_static_metacall(QObject *, QMetaObject::Call, int, void **);
# 35 "./example.h"
#pragma clang diagnostic pop
# 35 "./example.h"
  struct QPrivateSignal {};

public:
  void mySlot(const QString &name) {
    QMessageLogger(static_cast<const char *>("./example.h"), 40,
                   static_cast<const char *>(__PRETTY_FUNCTION__))
        .debug("hello %s", QtPrivate::asString(name).toLocal8Bit().constData());
  }

  friend constexpr auto w_state(
      w_internal::Index<
          w_internal::stateCount<0, w_internal::SlotStateTag, W_ThisType **>>,
      w_internal::SlotStateTag, W_ThisType **)
      -> decltype((w_internal::makeMetaSlotInfo(
          (&W_ThisType::mySlot), w_internal::viewLiteral("mySlot"),
          std::integral_constant<decltype((&W_ThisType::mySlot)),
                                 &W_ThisType::mySlot>(),
          w_internal::viewParsedLiterals<w_internal::countParsedLiterals(""
                                                                         "")>(
              ""
              ""),
          w_internal::W_EmptyFlag))) {
    return (w_internal::makeMetaSlotInfo(
        (&W_ThisType::mySlot), w_internal::viewLiteral("mySlot"),
        std::integral_constant<decltype((&W_ThisType::mySlot)),
                               &W_ThisType::mySlot>(),
        w_internal::viewParsedLiterals<w_internal::countParsedLiterals(""
                                                                       "")>(""
                                                                            ""),
        w_internal::W_EmptyFlag));
  }
  static inline void w_GetAccessSpecifierHelper(
      std::integral_constant<decltype((&W_ThisType::mySlot)),
                             &W_ThisType::mySlot>) {}

public:
  void mySignal(const QString &name) {
    using w_SignalType = decltype((&W_ThisType::mySignal));
    return w_internal::SignalImplementation<w_SignalType,
                                            w_signalIndex_mySignal_53>{this}(
        name, 0);
  }
  static constexpr int w_signalIndex_mySignal_53 =
      w_internal::stateCount<1, w_internal::SignalStateTag, W_ThisType **>;
  friend constexpr auto w_state(w_internal::Index<w_signalIndex_mySignal_53>,
                                w_internal::SignalStateTag, W_ThisType **)
      -> decltype(w_internal::makeMetaSignalInfo(
          (&W_ThisType::mySignal), w_internal::viewLiteral("mySignal"),
          std::integral_constant<decltype((&W_ThisType::mySignal)),
                                 &W_ThisType::mySignal>(),
          w_internal::viewParsedLiterals<w_internal::countParsedLiterals(""
                                                                         "")>(
              ""
              ""),
          w_internal::viewParsedLiterals<
              w_internal::countParsedLiterals(""
                                              "name , 0")>(""
                                                           "name , 0"))) {
    return w_internal::makeMetaSignalInfo(
        (&W_ThisType::mySignal), w_internal::viewLiteral("mySignal"),
        std::integral_constant<decltype((&W_ThisType::mySignal)),
                               &W_ThisType::mySignal>(),
        w_internal::viewParsedLiterals<w_internal::countParsedLiterals(""
                                                                       "")>(""
                                                                            ""),
        w_internal::viewParsedLiterals<w_internal::countParsedLiterals(
            ""
            "name , 0")>(""
                         "name , 0"));
  }
  static inline void w_GetAccessSpecifierHelper(
      std::integral_constant<decltype((&W_ThisType::mySignal)),
                             &W_ThisType::mySignal>) {}
};
# 3 "example.cpp" 2

# 1 "./verdigris/wobjectimpl.h" 1
# 27 "./verdigris/wobjectimpl.h"
namespace w_internal {

enum : uint {
  IsUnresolvedType = 0x80000000,
  IsUnresolvedNotifySignal = 0x70000000
};

template <class T, class Name, size_t L = 1024 * 1024 * 1024>
struct ObjectInfo {
  using Type = T;
  static constexpr auto counter = L;
  static constexpr auto name = StringView{Name::value};

  static constexpr int signalCount = stateCount<L, SignalStateTag, T **>;
  static constexpr int slotCount = stateCount<L, SlotStateTag, T **>;
  static constexpr int methodCount =
      signalCount + slotCount + stateCount<L, MethodStateTag, T **>;
  static constexpr int constructorCount =
      stateCount<L, ConstructorStateTag, T **>;
  static constexpr int propertyCount = stateCount<L, PropertyStateTag, T **>;
  static constexpr int enumCount = stateCount<L, EnumStateTag, T **>;
  static constexpr int classInfoCount = stateCount<L, ClassInfoStateTag, T **>;
  static constexpr int interfaceCount = stateCount<L, InterfaceStateTag, T **>;

  static constexpr auto methodSequence = make_index_sequence<methodCount>{};
  static constexpr auto constructorSequence =
      make_index_sequence<constructorCount>{};
  static constexpr auto propertySequence = make_index_sequence<propertyCount>{};
  static constexpr auto interfaceSequence =
      make_index_sequence<interfaceCount>{};
# 62 "./verdigris/wobjectimpl.h"
  template <size_t Idx>
  static constexpr auto method(Index<Idx>,
                               std::enable_if_t<(Idx < signalCount)> * = {}) {
    using TPP = T **;
    return w_state(index<Idx>, SignalStateTag{}, TPP{});
  }
  template <size_t Idx>
  static constexpr auto
  method(Index<Idx>,
         std::enable_if_t<(Idx >= signalCount && Idx - signalCount < slotCount)>
             * = {}) {
    using TPP = T **;
    return w_state(index<Idx - signalCount>, SlotStateTag{}, TPP{});
  }
  template <size_t Idx>
  static constexpr auto
  method(Index<Idx>,
         std::enable_if_t<(Idx >= signalCount + slotCount)> * = {}) {
    using TPP = T **;
    return w_state(index<Idx - signalCount - slotCount>, MethodStateTag{},
                   TPP{});
  }
};

template <class F, size_t... Is>
constexpr void fold(index_sequence<Is...>, F &&f) {
  (void)f;

  ordered((f(index<Is>), 0)...);
}

template <class F, class State, class TPP> struct FoldState {
  F &&f;
  template <class I> constexpr void operator()(I i) {
    f(w_state(i, State{}, TPP{}), i);
  }
};
template <size_t L, class State, class TPP, class F>
constexpr void foldState(F &&f) {
  auto fs = FoldState<F, State, TPP>{std::forward<F>(f)};
  fold(make_index_sequence<stateCount<L, State, TPP>>{}, fs);
}

template <size_t L, class T, class F> constexpr void foldMethods(F &&f) {
  foldState<L, SignalStateTag, T>(f);
  foldState<L, SlotStateTag, T>(f);
  foldState<L, MethodStateTag, T>(f);
}

template <class T>
constexpr auto fetchExplicitName(const StringView &defaultName, ...) {
  return defaultName;
}

template <class T>
constexpr auto fetchExplicitName(const StringView &, int)
    -> decltype(w_explicitObjectName(static_cast<T *>(nullptr))) {
  return w_explicitObjectName(static_cast<T *>(nullptr));
}

template <size_t L, size_t PropIdx, typename T, typename O>
struct ResolveNotifySignal {
private:
  using TP = T **;
  using OP = O **;
  static constexpr auto prop =
      w_state(index<PropIdx>, PropertyStateTag{}, TP{});

  template <size_t SigIdx,
            bool Eq = w_state(index<SigIdx>, SignalStateTag{}, OP{}).func ==
                      prop.notify>
  static constexpr auto match(int) {
    return Eq;
  }
  template <size_t SigIdx> static constexpr auto match(float) { return false; }

  template <size_t... Is>
  static constexpr int indexFold(index_sequence<Is...>) {
    int r = -1;

    ordered2<int>({(match<Is>(0) ? r = (int)Is : 0)...});

    return r;
  }

public:
  static constexpr int signalIndex() {
    return indexFold(
        make_index_sequence<stateCount<L, SignalStateTag, O **>>{});
  }
};
# 166 "./verdigris/wobjectimpl.h"
struct HasNotifySignal {
  bool r{};
  template <class P, class I> constexpr void operator()(P p, I) {
    r = r || !std::is_same<decltype(p.notify), std::nullptr_t>::value;
  }
};
template <size_t L, typename TPP> constexpr bool hasNotifySignal() {
  auto hns = HasNotifySignal{};
  foldState<L, PropertyStateTag, TPP>(hns);
  return hns.r;
}

template <class State> struct ClassInfoGenerator {
  State &s;
  constexpr ClassInfoGenerator(State &s) : s(s) {}

  template <class ClassInfo, class Index>
  constexpr void operator()(const ClassInfo &ci, Index) {
    s.addString(ci.first);
    s.addString(ci.second);
  }
};

template <class T, class M>
auto test_public(int) -> std::enable_if_t<
    std::is_same<void, decltype(T::w_GetAccessSpecifierHelper(M{}))>::value,
    std::true_type>;
template <class T, class M> auto test_public(float) -> std::false_type;
template <class T, class M> using isPublic = decltype(test_public<T, M>(0));

template <typename T, typename M, typename = void>
struct isProtected : std::false_type {};
template <typename T, typename = std::enable_if_t<!std::is_final<T>::value>>
struct Derived : T {
  template <typename M, typename X = T>
  static decltype(X::w_GetAccessSpecifierHelper(std::declval<M>())) test(M);
};
template <typename T, typename M>
struct isProtected<T, M, decltype(Derived<T>::test(std::declval<M>()))>
    : std::true_type {};

template <class State, class T> struct MethodGenerator {
  State &s;
  int parameterIndex;
  MethodGenerator(const MethodGenerator &) = delete;
  constexpr MethodGenerator(State &s, int pi) : s(s), parameterIndex(pi) {}

  template <class Method, class Index>
  constexpr void operator()(const Method &method, Index) {
    s.addString(method.name);
    s.addInts((uint)Method::argCount, parameterIndex, 1,
              adjustFlags(Method::flags, typename Method::IntegralConstant()));
    parameterIndex += 1 + Method::argCount * 2;
  }

private:
  template <typename M> static constexpr uint adjustFlags(uint f, M) {
    if (!(f & (W_Access::Protected.value | W_Access::Private.value |
               W_Access::Public.value))) {

      f |= isPublic<T, M>::value      ? W_Access::Public.value
           : isProtected<T, M>::value ? W_Access::Protected.value
                                      : W_Access::Private.value;
    }
    return f & static_cast<uint>(~W_Access::Private.value);
  }
};

template <typename T, typename = void>
struct MetaTypeIdIsBuiltIn : std::false_type {};
template <typename T>
struct MetaTypeIdIsBuiltIn<
    T, typename std::enable_if<QMetaTypeId2<T>::IsBuiltIn>::type>
    : std::true_type {};
# 258 "./verdigris/wobjectimpl.h"
template <typename T, typename State, typename TypeStr = int>
constexpr void
handleType(State &s, TypeStr = {},
           std::enable_if_t<MetaTypeIdIsBuiltIn<T>::value> * = {}) {
  s.addInts(QMetaTypeId2<T>::MetaType);
}
template <typename T, typename State, typename TypeStr = int>
constexpr void
handleType(State &s, TypeStr = {},
           std::enable_if_t<!MetaTypeIdIsBuiltIn<T>::value> * = {}) {
  s.addTypeString(W_TypeRegistery<T>::name);
  static_assert(W_TypeRegistery<T>::registered,
                "Please Register T with W_REGISTER_ARGTYPE");
}
template <typename T, typename State>
constexpr void
handleType(State &s, StringView v,
           std::enable_if_t<!MetaTypeIdIsBuiltIn<T>::value> * = {}) {
  s.addTypeString(v);
}

template <class State, class T> struct PropertyGenerator {
  State &s;
  constexpr PropertyGenerator(State &s) : s(s) {}

  template <class Prop, class Index>
  constexpr void operator()(const Prop &prop, Index) {
    s.addString(prop.name);
    handleType<typename Prop::PropertyType>(s, prop.typeStr);
    constexpr uint moreFlags =
        (QtPrivate::IsQEnumHelper<typename Prop::PropertyType>::Value
             ? uint(PropertyFlags::EnumOrFlag)
             : 0);
    constexpr uint finalFlag =
        std::is_final<T>::value ? 0 | PropertyFlags::Final : 0;
    constexpr uint defaultFlags = 0 | PropertyFlags::Stored |
                                  PropertyFlags::Scriptable |
                                  PropertyFlags::Designable;
    s.addInts(Prop::flags | moreFlags | finalFlag | defaultFlags);
  }
};

template <class State, size_t L, class T, bool hasNotify>
struct NotifySignalGenerator;
template <class State, size_t L, class T>
struct NotifySignalGenerator<State, L, T, false> {
  constexpr NotifySignalGenerator(State &) {}
  template <class Prop, size_t Idx>
  constexpr void operator()(const Prop &, Index<Idx>) {}
};
template <class State, size_t L, class T>
struct NotifySignalGenerator<State, L, T, true> {

  using TP = T **;
  State &s;
  constexpr NotifySignalGenerator(State &s) : s(s) {}
# 318 "./verdigris/wobjectimpl.h"
  template <class Prop, size_t Idx>
  constexpr void operator()(const Prop &prop, Index<Idx>) {
    process(prop.notify, index<Idx>);
  }

private:
  template <size_t Idx> constexpr void process(Empty, Index<Idx>) {
    s.addInts(0);
  }

  template <size_t Idx, typename Func>
  constexpr void
  process(Func, Index<Idx>,
          std::enable_if_t<std::is_same<T, typename QtPrivate::FunctionPointer<
                                               Func>::Object>::value,
                           int> = 0) {
    constexpr int signalIndex =
        ResolveNotifySignal<L, Idx, T, T>::signalIndex();
    static_assert(signalIndex >= 0,
                  "NOTIFY signal in parent class not registered as a W_SIGNAL");
    s.addInts(signalIndex);
  }

  template <size_t Idx, typename Func>
  constexpr void
  process(Func, Index<Idx>,
          std::enable_if_t<!std::is_same<T, typename QtPrivate::FunctionPointer<
                                                Func>::Object>::value,
                           int> = 0) {
    using O = typename QtPrivate::FunctionPointer<Func>::Object;
    using OP = O **;
    constexpr int signalIndex =
        ResolveNotifySignal<L, Idx, T, O>::signalIndex();
    static_assert(signalIndex >= 0,
                  "NOTIFY signal in parent class not registered as a W_SIGNAL");
    static_assert(signalIndex < 0 || ((5 << 16) | (15 << 8) | (0)) >=
                                         ((5 << 16) | (10 << 8) | (0)),
                  "NOTIFY signal in parent class requires Qt 5.10");
    constexpr auto sig = w_state(index<signalIndex>, SignalStateTag{}, OP{});
    s.template addTypeString<IsUnresolvedNotifySignal>(sig.name);
  }
};

template <class State> struct EnumGenerator {
  State &s;
  int dataIndex{};
  EnumGenerator(const EnumGenerator &) = delete;
  constexpr EnumGenerator(State &s, int di) : s(s), dataIndex(di) {}

  template <class Enum, class Index>
  constexpr void operator()(const Enum &e, Index) {
    auto nameIndex = s.stringCount;
    (void)nameIndex;
    s.addString(e.name);

    if (Enum::hasAlias)
      s.addString(e.alias);

    else
      s.addInts(nameIndex);

    s.addInts(Enum::flags, (uint)Enum::count, dataIndex);
    dataIndex += Enum::count * 2;
  }
};

template <class State> struct EnumValuesGenerator {
  State &s;
  constexpr EnumValuesGenerator(State &s) : s(s) {}

  template <class Enum, class Index>
  constexpr void operator()(const Enum &e, Index) {
    generateAll(typename Enum::Values{}, e.names, Enum::sequence);
  }

private:
  template <size_t... Values, typename Names, size_t... Is>
  constexpr void generateAll(index_sequence<Values...>, const Names &names,
                             index_sequence<Is...>) {

    ordered((s.addString(names[Is]), s.addInts((uint)Values), 0)...);
  }
};
# 411 "./verdigris/wobjectimpl.h"
template <size_t I, size_t N>
constexpr auto stringFetch(const StringViewArray<N> &s,
                           std::enable_if_t<(I < N)> * = {}) {
  return s[I];
}
template <size_t I, size_t N>
constexpr auto stringFetch(const StringViewArray<N> &s,
                           std::enable_if_t<!(I < N)> * = {}) {
  (void)s;
  struct _ {};
  return _{};
}

template <class Arg, class State, class TypeName>
constexpr void handleArgType(State &ss, const TypeName &typeName) {
  using Type = typename QtPrivate::RemoveConstRef<Arg>::Type;

  auto typeName2 = std::conditional_t<std::is_same<Arg, Type>::value, TypeName,
                                      std::tuple<TypeName>>{typeName};
  handleType<Type>(ss, typeName2);
}
template <class... Args, class State, class TypeNames, size_t... Is>
constexpr void handleArgTypes(State &ss, const TypeNames &typeNames,
                              index_sequence<Is...>) {

  ordered((handleArgType<Args>(ss, stringFetch<Is>(typeNames)), 0)...);
}

template <size_t ArgCount, class State, size_t NameCount>
constexpr void handleArgNames(State &ss,
                              const StringViewArray<NameCount> &paramNames) {
  auto i = size_t{};
  for (; i < ArgCount && i < NameCount; ++i)
    ss.addString(paramNames[i]);
  for (; i < ArgCount; ++i)
    ss.addInts(1);
}

template <class State> struct MethodParametersGenerator {
  State &s;
  constexpr MethodParametersGenerator(State &s) : s(s) {}
  template <class Method, class Index>
  constexpr void operator()(const Method &method, Index) {
    generateSingleMethodParameter(method.func, method);
  }

private:
  template <typename Method, typename Obj, typename Ret, typename... Args>
  constexpr void generateSingleMethodParameter(Ret (Obj::*)(Args...),
                                               const Method &method) {
    handleType<Ret>(s);
    handleArgTypes<Args...>(s, method.paramTypes, Method::argSequence);
    handleArgNames<Method::argCount>(s, method.paramNames);
  }
# 470 "./verdigris/wobjectimpl.h"
  template <typename Method, typename Obj, typename Ret, typename... Args>

  constexpr void generateSingleMethodParameter(Ret (Obj::*)(Args...) const,
                                               const Method &method) {
    handleType<Ret>(s);
    handleArgTypes<Args...>(s, method.paramTypes, Method::argSequence);
    handleArgNames<Method::argCount>(s, method.paramNames);
  }
# 486 "./verdigris/wobjectimpl.h"
  template <typename Method, typename Ret, typename... Args>
  constexpr void generateSingleMethodParameter(Ret (*)(Args...),
                                               const Method &method) {
    handleType<Ret>(s);
    handleArgTypes<Args...>(s, method.paramTypes, Method::argSequence);
    handleArgNames<Method::argCount>(s, method.paramNames);
  }
# 500 "./verdigris/wobjectimpl.h"
};

template <class State> struct ConstructorParametersGenerator {
  State &s;
  constexpr ConstructorParametersGenerator(State &s) : s(s) {}

  template <typename... Args, class Index>
  constexpr void operator()(const MetaConstructorInfo<Args...> &info, Index) {
    s.addInts(IsUnresolvedType | 1);
    handleArgTypes<Args...>(s, StringViewArray<>{}, info.argSequence);
    s.addInts(((void)sizeof(Args), 1)...);
  }
};
# 525 "./verdigris/wobjectimpl.h"
struct MethodParamOffset {
  int sum{};
  template <class M, class I> constexpr void operator()(M m, I) {
    sum += int(1 + m.argCount * 2);
  }
};
template <size_t L, class T> constexpr int methodsParamOffset() {
  auto mpo = MethodParamOffset{};
  foldMethods<L, T>(mpo);
  return mpo.sum;
}
# 545 "./verdigris/wobjectimpl.h"
struct ConstructorParamOffset {
  int sum{};
  template <class M, class I> constexpr void operator()(M m, I) {
    sum += int(1 + m.argCount * 2);
  }
};
template <size_t L, class T> constexpr int constructorParamOffset() {
  auto cpo = ConstructorParamOffset{};
  foldState<L, ConstructorStateTag, T>(cpo);
  return cpo.sum;
}

template <class T, size_t N> using RawArray = T[N];
template <class T, size_t N> struct OwnArray {
  RawArray<T, N> data{};
  constexpr OwnArray(const T (&s)[N]) {
    auto p = data;
    for (auto c : s)
      *p++ = c;
  }
};

struct LayoutBuilder {
  size_t stringSize{};
  uint stringCount{};
  uint intCount{};

  constexpr void addString(const StringView &s) {
    stringSize += s.size() + 1;
    stringCount += 1;
    intCount += 1;
  }
  constexpr void addStringUntracked(const StringView &s) {
    stringSize += s.size() + 1;
    stringCount += 1;
  }
  template <uint Flag = IsUnresolvedType>
  constexpr void addTypeString(const StringView &s) {
    stringSize += s.size() + 1;
    stringCount += 1;
    intCount += 1;
  }
  template <class... Ts> constexpr void addInts(Ts...) {
    intCount += sizeof...(Ts);
  }
};
struct DataBuilder {
  char *stringCharP{};
  qptrdiff *stringOffestP{};
  int *stringLengthP{};
  uint *intP{};
  uint stringCount{};
  uint intCount{};
  qptrdiff stringOffset{};

  constexpr DataBuilder() = default;
  DataBuilder(const DataBuilder &) = delete;
  template <class Holder>
  constexpr DataBuilder(Holder &r)
      : stringCharP(r.stringChars), stringOffestP(r.stringOffsets),
        stringLengthP(r.stringLengths), intP(r.ints),
        stringOffset(r.stringOffset) {}

  constexpr void addString(const StringView &s) {
    for (auto c : s)
      *stringCharP++ = c;
    *stringCharP++ = '\0';
    *stringOffestP++ = stringOffset;
    *stringLengthP++ = s.size();
    *intP++ = stringCount;
    stringOffset += 1 + s.size() - qptrdiff(sizeof(QByteArrayData));
    stringCount += 1;
    intCount += 1;
  }
  constexpr void addStringUntracked(const StringView &s) {
    for (auto c : s)
      *stringCharP++ = c;
    *stringCharP++ = '\0';
    *stringOffestP++ = stringOffset;
    *stringLengthP++ = s.size();
    stringOffset += 1 + s.size() - qptrdiff(sizeof(QByteArrayData));
    stringCount += 1;
  }

  template <uint Flag = IsUnresolvedType>
  constexpr void addTypeString(const StringView &s) {
    for (auto c : s)
      *stringCharP++ = c;
    *stringCharP++ = '\0';
    *stringOffestP++ = stringOffset;
    *stringLengthP++ = s.size();
    *intP++ = Flag | stringCount;
    stringOffset += 1 + s.size() - qptrdiff(sizeof(QByteArrayData));
    stringCount += 1;
    intCount += 1;
  }
  template <class... Ts> constexpr void addInts(Ts... vs) {

    ordered2<uint>({(*intP++ = vs)...});

    intCount += sizeof...(Ts);
  }
};

template <typename T, typename State>
constexpr void generateDataPass(State &state) {
  using ObjI = typename T::W_MetaObjectCreatorHelper::ObjectInfo;
  constexpr size_t L = ObjI::counter;
  constexpr bool hasNotify = hasNotifySignal<L, T **>();
  constexpr int classInfoOffset = 14;
  constexpr int methodOffset = classInfoOffset + ObjI::classInfoCount * 2;
  constexpr int propertyOffset = methodOffset + ObjI::methodCount * 5;
  constexpr int enumOffset =
      propertyOffset + ObjI::propertyCount * (hasNotify ? 4 : 3);
  constexpr int constructorOffset =
      enumOffset +
      ObjI::enumCount *
          (((5 << 16) | (15 << 8) | (0)) >= ((5 << 16) | (12 << 8) | (0)) ? 5
                                                                          : 4);
  constexpr int paramIndex = constructorOffset + ObjI::constructorCount * 5;
  constexpr int constructorParamIndex =
      paramIndex + methodsParamOffset<L, T **>();
  constexpr int enumValueOffset =
      constructorParamIndex + constructorParamOffset<L, T **>();

  state.addInts(
      ((5 << 16) | (15 << 8) | (0)) >= ((5 << 16) | (12 << 8) | (0)) ? 8 : 7);
  state.addString(ObjI::name);
  state.addStringUntracked(viewLiteral(""));
  state.addInts(ObjI::classInfoCount, classInfoOffset, ObjI::methodCount,
                methodOffset, ObjI::propertyCount, propertyOffset,
                ObjI::enumCount, enumOffset, ObjI::constructorCount,
                constructorOffset, 0x4, ObjI::signalCount);

  foldState<L, ClassInfoStateTag, T **>(ClassInfoGenerator<State>{state});

  foldMethods<L, T **>(MethodGenerator<State, T>{state, paramIndex});

  foldState<L, PropertyStateTag, T **>(PropertyGenerator<State, T>{state});
  foldState<L, PropertyStateTag, T **>(
      NotifySignalGenerator<State, L, T, hasNotify>{state});

  foldState<L, EnumStateTag, T **>(
      EnumGenerator<State>{state, enumValueOffset});

  foldState<L, ConstructorStateTag, T **>(
      MethodGenerator<State, T>{state, constructorParamIndex});

  foldMethods<L, T **>(MethodParametersGenerator<State>{state});

  foldState<L, ConstructorStateTag, T **>(
      ConstructorParametersGenerator<State>{state});

  foldState<L, EnumStateTag, T **>(EnumValuesGenerator<State>{state});
}
# 715 "./verdigris/wobjectimpl.h"
template <class T> constexpr auto createLayout() {
  auto r = LayoutBuilder{};
  generateDataPass<T>(r);
  return r;
}
template <class T> constexpr LayoutBuilder dataLayout = createLayout<T>();

template <std::size_t StringSize, std::size_t StringCount, std::size_t IntCount>
struct MetaDataHolder {
  RawArray<QByteArrayData, StringCount> byteArrays;
  OwnArray<char, StringSize> stringChars;

  OwnArray<uint, IntCount> ints;
};
template <class T> struct MetaDataProvider {
  static constexpr auto stringSize = dataLayout<T>.stringSize;
  static constexpr auto stringCount = dataLayout<T>.stringCount;
  static constexpr auto intCount = dataLayout<T>.intCount;
  using MetaDataType = const MetaDataHolder<stringSize, stringCount, intCount>;

  struct Arrays {

    constexpr static qptrdiff stringOffset =
        __builtin_offsetof(MetaDataType, stringChars);

    RawArray<qptrdiff, stringCount> stringOffsets{};
    RawArray<int, stringCount> stringLengths{};
    RawArray<char, stringSize> stringChars{};
    RawArray<uint, intCount> ints{};
  };
# 762 "./verdigris/wobjectimpl.h"
  constexpr static auto buildArrays() {
    auto r = Arrays{};
    DataBuilder b{r};
    generateDataPass<T>(b);
    return r;
  }
  constexpr static Arrays arrays = buildArrays();
};

template <class T, class IS> struct MetaDataBuilder;
template <class T, std::size_t... Is>
struct MetaDataBuilder<T, index_sequence<Is...>> {
  using P = MetaDataProvider<T>;
  using MetaDataType = typename P::MetaDataType;

  static MetaDataType meta_data;
};

template <class T, std::size_t... Is>
typename MetaDataBuilder<T, index_sequence<Is...>>::MetaDataType
    MetaDataBuilder<T, index_sequence<Is...>>::meta_data = {
        {{{{-1}},
          P::arrays.stringLengths[Is],
          0,
          0,
          P::arrays.stringOffsets[Is]}...},
        {P::arrays.stringChars},
        {P::arrays.ints}};

template <typename T>
static constexpr auto parentMetaObject(int)
    -> decltype(&T::W_BaseType::staticMetaObject) {
  return &T::W_BaseType::staticMetaObject;
}
template <typename T>
static constexpr const QMetaObject *parentMetaObject(...) {
  return nullptr;
}

template <typename F, typename O, typename T>
inline auto propSet(F f, O *o, const T &t) -> decltype(((o->*f)(t), 0)) {
  return ((o->*f)(t), 0);
}
template <typename F, typename O, typename T>
inline auto propSet(F f, O *o, const T &t) -> decltype(o->*f = t) {
  return o->*f = t;
}
template <typename O, typename T> inline void propSet(Empty, O *, const T &) {}

template <typename F, typename O, typename T>
inline auto propGet(F f, O *o, T &t) -> decltype(t = (o->*f)()) {
  return t = (o->*f)();
}
template <typename F, typename O, typename T>
inline auto propGet(F f, O *o, T &t) -> decltype(t = o->*f) {
  return t = o->*f;
}
template <typename O, typename T> inline void propGet(Empty, O *, T &) {}

template <typename F, typename M, typename O>
inline auto propNotify(F f, M m, O *o) -> decltype(((o->*f)(o->*m), 0)) {
  return ((o->*f)(o->*m), 0);
}
template <typename F, typename M, typename O>
inline auto propNotify(F f, M, O *o) -> decltype(((o->*f)(), 0)) {
  return ((o->*f)(), 0);
}
template <typename... T> inline void propNotify(T...) {}

template <typename F, typename O>
inline auto propReset(F f, O *o) -> decltype(((o->*f)(), 0)) {
  return ((o->*f)(), 0);
}
template <typename... T> inline void propReset(T...) {}

struct FriendHelper {

  template <typename T> static constexpr QMetaObject createMetaObject() {
    using MetaData =
        MetaDataBuilder<T, make_index_sequence<dataLayout<T>.stringCount>>;

    return {{parentMetaObject<T>(0),
             MetaData::meta_data.byteArrays,
             MetaData::meta_data.ints.data,
             T::qt_static_metacall,
             {},
             {}}};
  }

  template <typename T>
  static int qt_metacall_impl(T *_o, QMetaObject::Call _c, int _id, void **_a) {
    using ObjI = typename T::W_MetaObjectCreatorHelper::ObjectInfo;
    _id = _o->T::W_BaseType::qt_metacall(_c, _id, _a);
    if (_id < 0)
      return _id;
    if (_c == QMetaObject::InvokeMetaMethod ||
        _c == QMetaObject::RegisterMethodArgumentMetaType) {
      constexpr int methodCount = ObjI::methodCount;
      if (_id < methodCount)
        T::qt_static_metacall(_o, _c, _id, _a);
      _id -= methodCount;
    } else if ((_c >= QMetaObject::ReadProperty &&
                _c <= QMetaObject::QueryPropertyUser) ||
               _c == QMetaObject::RegisterPropertyMetaType) {
      constexpr int propertyCount = ObjI::propertyCount;
      if (_id < propertyCount)
        T::qt_static_metacall(_o, _c, _id, _a);
      _id -= propertyCount;
    }
    return _id;
  }

#pragma clang diagnostic push

  template <typename T, int I> static int indexOfMethod(void **func) {
    using ObjI = typename T::W_MetaObjectCreatorHelper::ObjectInfo;
    constexpr auto m = ObjI::method(index<I>);
    if ((m.flags & 0xc) == W_MethodType::Signal.value &&
        m.func == *reinterpret_cast<decltype(m.func) *>(func))
      return I;
    return -1;
  }
#pragma clang diagnostic pop

  template <typename T, int I>
  static void invokeMethod(T *_o, int _id, void **_a) {
    if (_id == I) {
      using ObjI = typename T::W_MetaObjectCreatorHelper::ObjectInfo;
      constexpr auto f = ObjI::method(index<I>).func;
      using P = QtPrivate::FunctionPointer<std::remove_const_t<decltype(f)>>;
      P::template call<typename P::Arguments, typename P::ReturnType>(f, _o,
                                                                      _a);
    }
  }

  template <typename T, int I>
  static void registerMethodArgumentType(int _id, void **_a) {
    if (_id == I) {
      using ObjI = typename T::W_MetaObjectCreatorHelper::ObjectInfo;
      constexpr auto f = ObjI::method(index<I>).func;
      using P = QtPrivate::FunctionPointer<std::remove_const_t<decltype(f)>>;
      auto _t = QtPrivate::ConnectionTypes<typename P::Arguments>::types();
      uint arg = *reinterpret_cast<uint *>(_a[1]);
      *reinterpret_cast<int *>(_a[0]) =
          _t && arg < P::ArgumentCount ? _t[arg] : -1;
    }
  }

  template <typename T, int I>
  static void propertyOperation(T *_o, QMetaObject::Call _c, int _id,
                                void **_a) {
    if (_id != I)
      return;
    using TPP = T **;
    constexpr auto p = w_state(index<I>, PropertyStateTag{}, TPP{});
    using Type = typename decltype(p)::PropertyType;
    switch (+_c) {
    case QMetaObject::ReadProperty:
      if (p.getter) {
        propGet(p.getter, _o, *reinterpret_cast<Type *>(_a[0]));
      } else if (p.member) {
        propGet(p.member, _o, *reinterpret_cast<Type *>(_a[0]));
      }
      break;
    case QMetaObject::WriteProperty:
      if (p.setter) {
        propSet(p.setter, _o, *reinterpret_cast<Type *>(_a[0]));
      } else if (p.member) {
        propSet(p.member, _o, *reinterpret_cast<Type *>(_a[0]));
        propNotify(p.notify, p.member, _o);
      }
      break;
    case QMetaObject::ResetProperty:
      if (p.reset) {
        propReset(p.reset, _o);
      }
      break;
    case QMetaObject::RegisterPropertyMetaType:
      *reinterpret_cast<int *>(_a[0]) =
          QtPrivate::QMetaTypeIdHelper<Type>::qt_metatype_id();
    }
  }

  template <typename T, class... Args, std::size_t... I>
  static void createInstanceImpl(void **_a,
                                 const MetaConstructorInfo<Args...> &,
                                 index_sequence<I...>) {
    *reinterpret_cast<T **>(_a[0]) =
        new T(*reinterpret_cast<std::remove_reference_t<Args> *>(_a[I + 1])...);
  }
  template <typename T, int I> static void createInstance(int _id, void **_a) {
    if (_id == I) {
      using TPP = T **;
      constexpr auto m = w_state(index<I>, ConstructorStateTag{}, TPP{});
      createInstanceImpl<T>(_a, m, m.argSequence);
    }
  }

  template <typename T, size_t... MethI, size_t... ConsI, size_t... PropI>
  static void qt_static_metacall_impl2(QObject *_o, QMetaObject::Call _c,
                                       int _id, void **_a,
                                       std::index_sequence<MethI...>,
                                       std::index_sequence<ConsI...>,
                                       std::index_sequence<PropI...>) {
    (void)_id;
    (void)_o;
    (void)_a;
    if (_c == QMetaObject::InvokeMetaMethod) {
      ((T::staticMetaObject.cast(_o))
           ? static_cast<void>(0)
           : qt_assert("T::staticMetaObject.cast(_o)",
                       "./verdigris/wobjectimpl.h", 964));

      ordered(
          (invokeMethod<T, MethI>(reinterpret_cast<T *>(_o), _id, _a), 0)...);

    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {

      ordered((registerMethodArgumentType<T, MethI>(_id, _a), 0)...);

    } else if (_c == QMetaObject::IndexOfMethod) {

      auto r = int{-1};
      ordered2<int>({(r += (1 + indexOfMethod<T, MethI>( reinterpret_cast<void **>(_a[1]))
                                    ))...});
      *reinterpret_cast<int *>(_a[0]) = r;

    } else if (_c == QMetaObject::CreateInstance) {

      ordered((createInstance<T, ConsI>(_id, _a), 0)...);

    } else if ((_c >= QMetaObject::ReadProperty &&
                _c <= QMetaObject::QueryPropertyUser) ||
               _c == QMetaObject::RegisterPropertyMetaType) {

      ordered((propertyOperation<T, PropI>(static_cast<T *>(_o), _c, _id, _a),
               0)...);
    }
  }

  template <typename T, size_t... MethI, size_t... ConsI, size_t... PropI>
  static void qt_static_metacall_impl2(T *_o, QMetaObject::Call _c, int _id,
                                       void **_a, std::index_sequence<MethI...>,
                                       std::index_sequence<ConsI...>,
                                       std::index_sequence<PropI...>) {
    (void)_id;
    (void)_o;
    (void)_a;
    if (_c == QMetaObject::InvokeMetaMethod) {

      ordered((invokeMethod<T, MethI>(_o, _id, _a), 0)...);

    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {

      ordered((registerMethodArgumentType<T, MethI>(_id, _a), 0)...);

    } else if (_c == QMetaObject::IndexOfMethod) {
      ((false) ? static_cast<void>(0)
               : qt_assert_x("qt_static_metacall",
                             "IndexOfMethod called on a Q_GADGET",
                             "./verdigris/wobjectimpl.h", 1018));
    } else if (_c == QMetaObject::CreateInstance) {

      ordered((createInstance<T, ConsI>(_id, _a), 0)...);

    } else if ((_c >= QMetaObject::ReadProperty &&
                _c <= QMetaObject::QueryPropertyUser) ||
               _c == QMetaObject::RegisterPropertyMetaType) {

      ordered((propertyOperation<T, PropI>(_o, _c, _id, _a), 0)...);
    }
  }

  template <typename T, typename... Ts>
  static void qt_static_metacall_impl(Ts &&...args) {
    using ObjI = typename T::W_MetaObjectCreatorHelper::ObjectInfo;
    return qt_static_metacall_impl2<T>(
        std::forward<Ts>(args)..., ObjI::methodSequence,
        ObjI::constructorSequence, ObjI::propertySequence);
  }

  template <typename T>
  static void *qt_metacast_impl(T *o, const char *_clname) {
    if (!_clname)
      return nullptr;
    const QByteArrayDataPtr sd = {
        const_cast<QByteArrayData *>(T::staticMetaObject.d.stringdata)};
    if (_clname == QByteArray(sd))
      return o;
    using ObjI = typename T::W_MetaObjectCreatorHelper::ObjectInfo;
    void *result = {};
    auto l = [&](auto i) {
      using TPP = T **;
      using Interface = decltype(w_state(i, InterfaceStateTag{}, TPP{}));
      const char *iid = qobject_interface_iid<Interface>();
      if (iid && !strcmp(_clname, iid))
        result = static_cast<Interface>(o);
    };
    fold(ObjI::interfaceSequence, l);
    if (!result)
      return o->T::W_BaseType::qt_metacast(_clname);
    return result;
  }
};

} // namespace w_internal
# 6 "example.cpp" 2

struct MyObject::W_MetaObjectCreatorHelper {
  struct Name {
    static constexpr auto defaultName = w_internal::viewLiteral("MyObject");
    static constexpr auto value =
        w_internal::fetchExplicitName<typename MyObject::W_ThisType>(
            defaultName, 0);
  };
  using ObjectInfo =
      w_internal::ObjectInfo<typename MyObject::W_ThisType, Name>;
};
const QMetaObject MyObject::staticMetaObject =
    w_internal::FriendHelper::createMetaObject<typename MyObject::W_ThisType>();
void MyObject::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id,
                                  void **_a) {
  w_internal::FriendHelper::qt_static_metacall_impl<MyObject>(_o, _c, _id, _a);
}
const QMetaObject *MyObject::metaObject() const { return &staticMetaObject; }
void *MyObject::qt_metacast(const char *_clname) {
  return w_internal::FriendHelper::qt_metacast_impl<MyObject>(this, _clname);
}
int MyObject::qt_metacall(QMetaObject::Call _c, int _id, void **_a) {
  return w_internal::FriendHelper::qt_metacall_impl<MyObject>(this, _c, _id,
                                                              _a);
}

void aaa(MyObject *obj1) {
  bool ok = true;

  ok = ok && QObject::connect(obj1,
                              qFlagLocation("2"
                                            "mySignal(QString)"
                                            "\0"
                                            "example.cpp"
                                            ":"
                                            "18"),
                              obj1,
                              qFlagLocation("1"
                                            "mySlot(QString)"
                                            "\0"
                                            "example.cpp"
                                            ":"
                                            "18"));
  ((ok) ? static_cast<void>(0) : qt_assert("ok", "example.cpp", 19));
}

int main() {
  MyObject o;
  aaa(&o);
  o.mySlot("world");
}
